// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.UI.Xaml.Controls.h"

namespace py::cpp::Windows::UI::Xaml::Controls
{
    // ----- AppBarButton class --------------------

    static PyObject* _new_AppBarButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::AppBarButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppBarButton(py::wrapper::Windows::UI::Xaml::Controls::AppBarButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBarButton_get_Label(py::wrapper::Windows::UI::Xaml::Controls::AppBarButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarButton_put_Label(py::wrapper::Windows::UI::Xaml::Controls::AppBarButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarButton_get_Icon(py::wrapper::Windows::UI::Xaml::Controls::AppBarButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"Icon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Icon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarButton_put_Icon(py::wrapper::Windows::UI::Xaml::Controls::AppBarButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"Icon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::IconElement>(arg);

            self->obj.Icon(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarButton_get_LabelPosition(py::wrapper::Windows::UI::Xaml::Controls::AppBarButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"LabelPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LabelPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarButton_put_LabelPosition(py::wrapper::Windows::UI::Xaml::Controls::AppBarButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"LabelPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::CommandBarLabelPosition>(arg);

            self->obj.LabelPosition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarButton_get_KeyboardAcceleratorTextOverride(py::wrapper::Windows::UI::Xaml::Controls::AppBarButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"KeyboardAcceleratorTextOverride");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyboardAcceleratorTextOverride());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarButton_put_KeyboardAcceleratorTextOverride(py::wrapper::Windows::UI::Xaml::Controls::AppBarButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"KeyboardAcceleratorTextOverride");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.KeyboardAcceleratorTextOverride(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarButton_get_TemplateSettings(py::wrapper::Windows::UI::Xaml::Controls::AppBarButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"TemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TemplateSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarButton_get_IsCompact(py::wrapper::Windows::UI::Xaml::Controls::AppBarButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"IsCompact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCompact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarButton_put_IsCompact(py::wrapper::Windows::UI::Xaml::Controls::AppBarButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"IsCompact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCompact(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarButton_get_DynamicOverflowOrder(py::wrapper::Windows::UI::Xaml::Controls::AppBarButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"DynamicOverflowOrder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DynamicOverflowOrder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarButton_put_DynamicOverflowOrder(py::wrapper::Windows::UI::Xaml::Controls::AppBarButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"DynamicOverflowOrder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.DynamicOverflowOrder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarButton_get_IsInOverflow(py::wrapper::Windows::UI::Xaml::Controls::AppBarButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"IsInOverflow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsInOverflow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarButton_get_IconProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"IconProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarButton::IconProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarButton_get_IsCompactProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"IsCompactProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarButton::IsCompactProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarButton_get_LabelProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"LabelProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarButton::LabelProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarButton_get_DynamicOverflowOrderProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"DynamicOverflowOrderProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarButton::DynamicOverflowOrderProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarButton_get_IsInOverflowProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"IsInOverflowProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarButton::IsInOverflowProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarButton_get_LabelPositionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"LabelPositionProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarButton::LabelPositionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarButton_get_KeyboardAcceleratorTextOverrideProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"KeyboardAcceleratorTextOverrideProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarButton::KeyboardAcceleratorTextOverrideProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBarButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::AppBarButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBarButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::AppBarButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBarButton[] = {
        { "_assign_array_", _assign_array_AppBarButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBarButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBarButton[] = {
        { "label", reinterpret_cast<getter>(AppBarButton_get_Label), reinterpret_cast<setter>(AppBarButton_put_Label), nullptr, nullptr },
        { "icon", reinterpret_cast<getter>(AppBarButton_get_Icon), reinterpret_cast<setter>(AppBarButton_put_Icon), nullptr, nullptr },
        { "label_position", reinterpret_cast<getter>(AppBarButton_get_LabelPosition), reinterpret_cast<setter>(AppBarButton_put_LabelPosition), nullptr, nullptr },
        { "keyboard_accelerator_text_override", reinterpret_cast<getter>(AppBarButton_get_KeyboardAcceleratorTextOverride), reinterpret_cast<setter>(AppBarButton_put_KeyboardAcceleratorTextOverride), nullptr, nullptr },
        { "template_settings", reinterpret_cast<getter>(AppBarButton_get_TemplateSettings), nullptr, nullptr, nullptr },
        { "is_compact", reinterpret_cast<getter>(AppBarButton_get_IsCompact), reinterpret_cast<setter>(AppBarButton_put_IsCompact), nullptr, nullptr },
        { "dynamic_overflow_order", reinterpret_cast<getter>(AppBarButton_get_DynamicOverflowOrder), reinterpret_cast<setter>(AppBarButton_put_DynamicOverflowOrder), nullptr, nullptr },
        { "is_in_overflow", reinterpret_cast<getter>(AppBarButton_get_IsInOverflow), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBarButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBarButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBarButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBarButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBarButton) },
        { }
    };

    static PyType_Spec type_spec_AppBarButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.AppBarButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::AppBarButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBarButton};

    static PyGetSetDef getset_AppBarButton_Static[] = {
        { "icon_property", reinterpret_cast<getter>(AppBarButton_get_IconProperty), nullptr, nullptr, nullptr },
        { "is_compact_property", reinterpret_cast<getter>(AppBarButton_get_IsCompactProperty), nullptr, nullptr, nullptr },
        { "label_property", reinterpret_cast<getter>(AppBarButton_get_LabelProperty), nullptr, nullptr, nullptr },
        { "dynamic_overflow_order_property", reinterpret_cast<getter>(AppBarButton_get_DynamicOverflowOrderProperty), nullptr, nullptr, nullptr },
        { "is_in_overflow_property", reinterpret_cast<getter>(AppBarButton_get_IsInOverflowProperty), nullptr, nullptr, nullptr },
        { "label_position_property", reinterpret_cast<getter>(AppBarButton_get_LabelPositionProperty), nullptr, nullptr, nullptr },
        { "keyboard_accelerator_text_override_property", reinterpret_cast<getter>(AppBarButton_get_KeyboardAcceleratorTextOverrideProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_AppBarButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_AppBarButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppBarButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppBarButton_Static) },
        { }
    };

    static PyType_Spec type_spec_AppBarButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.AppBarButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AppBarButton_Static
    };

    // ----- AppBarToggleButton class --------------------

    static PyObject* _new_AppBarToggleButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::AppBarToggleButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppBarToggleButton(py::wrapper::Windows::UI::Xaml::Controls::AppBarToggleButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBarToggleButton_get_Label(py::wrapper::Windows::UI::Xaml::Controls::AppBarToggleButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarToggleButton_put_Label(py::wrapper::Windows::UI::Xaml::Controls::AppBarToggleButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarToggleButton_get_Icon(py::wrapper::Windows::UI::Xaml::Controls::AppBarToggleButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"Icon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Icon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarToggleButton_put_Icon(py::wrapper::Windows::UI::Xaml::Controls::AppBarToggleButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"Icon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::IconElement>(arg);

            self->obj.Icon(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarToggleButton_get_LabelPosition(py::wrapper::Windows::UI::Xaml::Controls::AppBarToggleButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"LabelPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LabelPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarToggleButton_put_LabelPosition(py::wrapper::Windows::UI::Xaml::Controls::AppBarToggleButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"LabelPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::CommandBarLabelPosition>(arg);

            self->obj.LabelPosition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarToggleButton_get_KeyboardAcceleratorTextOverride(py::wrapper::Windows::UI::Xaml::Controls::AppBarToggleButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"KeyboardAcceleratorTextOverride");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyboardAcceleratorTextOverride());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarToggleButton_put_KeyboardAcceleratorTextOverride(py::wrapper::Windows::UI::Xaml::Controls::AppBarToggleButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"KeyboardAcceleratorTextOverride");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.KeyboardAcceleratorTextOverride(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarToggleButton_get_TemplateSettings(py::wrapper::Windows::UI::Xaml::Controls::AppBarToggleButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"TemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TemplateSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarToggleButton_get_IsCompact(py::wrapper::Windows::UI::Xaml::Controls::AppBarToggleButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"IsCompact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCompact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarToggleButton_put_IsCompact(py::wrapper::Windows::UI::Xaml::Controls::AppBarToggleButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"IsCompact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCompact(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarToggleButton_get_DynamicOverflowOrder(py::wrapper::Windows::UI::Xaml::Controls::AppBarToggleButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"DynamicOverflowOrder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DynamicOverflowOrder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarToggleButton_put_DynamicOverflowOrder(py::wrapper::Windows::UI::Xaml::Controls::AppBarToggleButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"DynamicOverflowOrder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.DynamicOverflowOrder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarToggleButton_get_IsInOverflow(py::wrapper::Windows::UI::Xaml::Controls::AppBarToggleButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"IsInOverflow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsInOverflow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarToggleButton_get_IconProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"IconProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarToggleButton::IconProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarToggleButton_get_IsCompactProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"IsCompactProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarToggleButton::IsCompactProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarToggleButton_get_LabelProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"LabelProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarToggleButton::LabelProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarToggleButton_get_DynamicOverflowOrderProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"DynamicOverflowOrderProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarToggleButton::DynamicOverflowOrderProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarToggleButton_get_IsInOverflowProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"IsInOverflowProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarToggleButton::IsInOverflowProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarToggleButton_get_LabelPositionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"LabelPositionProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarToggleButton::LabelPositionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarToggleButton_get_KeyboardAcceleratorTextOverrideProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"KeyboardAcceleratorTextOverrideProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarToggleButton::KeyboardAcceleratorTextOverrideProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBarToggleButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::AppBarToggleButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBarToggleButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::AppBarToggleButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBarToggleButton[] = {
        { "_assign_array_", _assign_array_AppBarToggleButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBarToggleButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBarToggleButton[] = {
        { "label", reinterpret_cast<getter>(AppBarToggleButton_get_Label), reinterpret_cast<setter>(AppBarToggleButton_put_Label), nullptr, nullptr },
        { "icon", reinterpret_cast<getter>(AppBarToggleButton_get_Icon), reinterpret_cast<setter>(AppBarToggleButton_put_Icon), nullptr, nullptr },
        { "label_position", reinterpret_cast<getter>(AppBarToggleButton_get_LabelPosition), reinterpret_cast<setter>(AppBarToggleButton_put_LabelPosition), nullptr, nullptr },
        { "keyboard_accelerator_text_override", reinterpret_cast<getter>(AppBarToggleButton_get_KeyboardAcceleratorTextOverride), reinterpret_cast<setter>(AppBarToggleButton_put_KeyboardAcceleratorTextOverride), nullptr, nullptr },
        { "template_settings", reinterpret_cast<getter>(AppBarToggleButton_get_TemplateSettings), nullptr, nullptr, nullptr },
        { "is_compact", reinterpret_cast<getter>(AppBarToggleButton_get_IsCompact), reinterpret_cast<setter>(AppBarToggleButton_put_IsCompact), nullptr, nullptr },
        { "dynamic_overflow_order", reinterpret_cast<getter>(AppBarToggleButton_get_DynamicOverflowOrder), reinterpret_cast<setter>(AppBarToggleButton_put_DynamicOverflowOrder), nullptr, nullptr },
        { "is_in_overflow", reinterpret_cast<getter>(AppBarToggleButton_get_IsInOverflow), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBarToggleButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBarToggleButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBarToggleButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBarToggleButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBarToggleButton) },
        { }
    };

    static PyType_Spec type_spec_AppBarToggleButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.AppBarToggleButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::AppBarToggleButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBarToggleButton};

    static PyGetSetDef getset_AppBarToggleButton_Static[] = {
        { "icon_property", reinterpret_cast<getter>(AppBarToggleButton_get_IconProperty), nullptr, nullptr, nullptr },
        { "is_compact_property", reinterpret_cast<getter>(AppBarToggleButton_get_IsCompactProperty), nullptr, nullptr, nullptr },
        { "label_property", reinterpret_cast<getter>(AppBarToggleButton_get_LabelProperty), nullptr, nullptr, nullptr },
        { "dynamic_overflow_order_property", reinterpret_cast<getter>(AppBarToggleButton_get_DynamicOverflowOrderProperty), nullptr, nullptr, nullptr },
        { "is_in_overflow_property", reinterpret_cast<getter>(AppBarToggleButton_get_IsInOverflowProperty), nullptr, nullptr, nullptr },
        { "label_position_property", reinterpret_cast<getter>(AppBarToggleButton_get_LabelPositionProperty), nullptr, nullptr, nullptr },
        { "keyboard_accelerator_text_override_property", reinterpret_cast<getter>(AppBarToggleButton_get_KeyboardAcceleratorTextOverrideProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_AppBarToggleButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_AppBarToggleButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppBarToggleButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppBarToggleButton_Static) },
        { }
    };

    static PyType_Spec type_spec_AppBarToggleButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.AppBarToggleButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AppBarToggleButton_Static
    };

    // ----- Button class --------------------

    static PyObject* _new_Button(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Button instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Button(py::wrapper::Windows::UI::Xaml::Controls::Button* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Button_get_Flyout(py::wrapper::Windows::UI::Xaml::Controls::Button* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Button", L"Flyout");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Flyout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Button_put_Flyout(py::wrapper::Windows::UI::Xaml::Controls::Button* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Button", L"Flyout");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>(arg);

            self->obj.Flyout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Button_get_FlyoutProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Button", L"FlyoutProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Button::FlyoutProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Button(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Button>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Button(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Button>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Button[] = {
        { "_assign_array_", _assign_array_Button, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Button), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Button[] = {
        { "flyout", reinterpret_cast<getter>(Button_get_Flyout), reinterpret_cast<setter>(Button_put_Flyout), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Button[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Button) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Button) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Button) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Button) },
        { }
    };

    static PyType_Spec type_spec_Button = {
        "winrt._winrt_windows_ui_xaml_controls_2.Button",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Button),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Button};

    static PyGetSetDef getset_Button_Static[] = {
        { "flyout_property", reinterpret_cast<getter>(Button_get_FlyoutProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Button_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Button_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Button_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Button_Static) },
        { }
    };

    static PyType_Spec type_spec_Button_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.Button_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Button_Static
    };

    // ----- CheckBox class --------------------

    static PyObject* _new_CheckBox(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::CheckBox instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CheckBox(py::wrapper::Windows::UI::Xaml::Controls::CheckBox* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CheckBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::CheckBox>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CheckBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::CheckBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CheckBox[] = {
        { "_assign_array_", _assign_array_CheckBox, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CheckBox), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CheckBox[] = {
        { }
    };

    static PyType_Slot _type_slots_CheckBox[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CheckBox) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CheckBox) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CheckBox) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CheckBox) },
        { }
    };

    static PyType_Spec type_spec_CheckBox = {
        "winrt._winrt_windows_ui_xaml_controls_2.CheckBox",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::CheckBox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CheckBox};

    static PyGetSetDef getset_CheckBox_Static[] = {
        { }
    };

    static PyMethodDef methods_CheckBox_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CheckBox_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CheckBox_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CheckBox_Static) },
        { }
    };

    static PyType_Spec type_spec_CheckBox_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.CheckBox_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CheckBox_Static
    };

    // ----- ComboBox class --------------------

    static PyObject* _new_ComboBox(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::ComboBox instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ComboBox(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ComboBox_get_MaxDropDownHeight(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"MaxDropDownHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxDropDownHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_MaxDropDownHeight(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"MaxDropDownHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.MaxDropDownHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_IsEditable(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"IsEditable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsEditable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_IsEditable(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"IsEditable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEditable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_IsDropDownOpen(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"IsDropDownOpen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDropDownOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_IsDropDownOpen(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"IsDropDownOpen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDropDownOpen(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_IsSelectionBoxHighlighted(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"IsSelectionBoxHighlighted");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSelectionBoxHighlighted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_SelectionBoxItem(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"SelectionBoxItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectionBoxItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_SelectionBoxItemTemplate(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"SelectionBoxItemTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectionBoxItemTemplate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_TemplateSettings(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"TemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TemplateSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_PlaceholderText(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"PlaceholderText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PlaceholderText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_PlaceholderText(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"PlaceholderText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PlaceholderText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_HeaderTemplate(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"HeaderTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HeaderTemplate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_HeaderTemplate(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"HeaderTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DataTemplate>(arg);

            self->obj.HeaderTemplate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_Header(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"Header");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Header());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_Header(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"Header");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.Header(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_LightDismissOverlayMode(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"LightDismissOverlayMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LightDismissOverlayMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_LightDismissOverlayMode(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"LightDismissOverlayMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::LightDismissOverlayMode>(arg);

            self->obj.LightDismissOverlayMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_IsTextSearchEnabled(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"IsTextSearchEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsTextSearchEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_IsTextSearchEnabled(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"IsTextSearchEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsTextSearchEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_SelectionChangedTrigger(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"SelectionChangedTrigger");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectionChangedTrigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_SelectionChangedTrigger(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"SelectionChangedTrigger");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ComboBoxSelectionChangedTrigger>(arg);

            self->obj.SelectionChangedTrigger(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_PlaceholderForeground(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"PlaceholderForeground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PlaceholderForeground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_PlaceholderForeground(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"PlaceholderForeground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.PlaceholderForeground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_TextBoxStyle(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"TextBoxStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TextBoxStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_TextBoxStyle(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"TextBoxStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Style>(arg);

            self->obj.TextBoxStyle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_Text(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_Text(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_Description(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"Description");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_Description(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"Description");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_IsDropDownOpenProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"IsDropDownOpenProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::IsDropDownOpenProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_MaxDropDownHeightProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"MaxDropDownHeightProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::MaxDropDownHeightProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_HeaderProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"HeaderProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::HeaderProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_HeaderTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"HeaderTemplateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::HeaderTemplateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_PlaceholderTextProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"PlaceholderTextProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::PlaceholderTextProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_IsTextSearchEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"IsTextSearchEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::IsTextSearchEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_LightDismissOverlayModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"LightDismissOverlayModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::LightDismissOverlayModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_SelectionChangedTriggerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"SelectionChangedTriggerProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::SelectionChangedTriggerProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_PlaceholderForegroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"PlaceholderForegroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::PlaceholderForegroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_DescriptionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"DescriptionProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::DescriptionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_IsEditableProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"IsEditableProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::IsEditableProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_TextBoxStyleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"TextBoxStyleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::TextBoxStyleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_TextProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"TextProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::TextProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_add_DropDownClosed(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"DropDownClosed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.DropDownClosed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_remove_DropDownClosed(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"DropDownClosed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DropDownClosed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_add_DropDownOpened(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"DropDownOpened");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.DropDownOpened(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_remove_DropDownOpened(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"DropDownOpened");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DropDownOpened(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_add_TextSubmitted(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"TextSubmitted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::ComboBox, winrt::Windows::UI::Xaml::Controls::ComboBoxTextSubmittedEventArgs>>(arg);

            return py::convert(self->obj.TextSubmitted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_remove_TextSubmitted(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"TextSubmitted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TextSubmitted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ComboBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::ComboBox>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ComboBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::ComboBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ComboBox[] = {
        { "add_drop_down_closed", reinterpret_cast<PyCFunction>(ComboBox_add_DropDownClosed), METH_O, nullptr },
        { "remove_drop_down_closed", reinterpret_cast<PyCFunction>(ComboBox_remove_DropDownClosed), METH_O, nullptr },
        { "add_drop_down_opened", reinterpret_cast<PyCFunction>(ComboBox_add_DropDownOpened), METH_O, nullptr },
        { "remove_drop_down_opened", reinterpret_cast<PyCFunction>(ComboBox_remove_DropDownOpened), METH_O, nullptr },
        { "add_text_submitted", reinterpret_cast<PyCFunction>(ComboBox_add_TextSubmitted), METH_O, nullptr },
        { "remove_text_submitted", reinterpret_cast<PyCFunction>(ComboBox_remove_TextSubmitted), METH_O, nullptr },
        { "_assign_array_", _assign_array_ComboBox, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ComboBox), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ComboBox[] = {
        { "max_drop_down_height", reinterpret_cast<getter>(ComboBox_get_MaxDropDownHeight), reinterpret_cast<setter>(ComboBox_put_MaxDropDownHeight), nullptr, nullptr },
        { "is_editable", reinterpret_cast<getter>(ComboBox_get_IsEditable), reinterpret_cast<setter>(ComboBox_put_IsEditable), nullptr, nullptr },
        { "is_drop_down_open", reinterpret_cast<getter>(ComboBox_get_IsDropDownOpen), reinterpret_cast<setter>(ComboBox_put_IsDropDownOpen), nullptr, nullptr },
        { "is_selection_box_highlighted", reinterpret_cast<getter>(ComboBox_get_IsSelectionBoxHighlighted), nullptr, nullptr, nullptr },
        { "selection_box_item", reinterpret_cast<getter>(ComboBox_get_SelectionBoxItem), nullptr, nullptr, nullptr },
        { "selection_box_item_template", reinterpret_cast<getter>(ComboBox_get_SelectionBoxItemTemplate), nullptr, nullptr, nullptr },
        { "template_settings", reinterpret_cast<getter>(ComboBox_get_TemplateSettings), nullptr, nullptr, nullptr },
        { "placeholder_text", reinterpret_cast<getter>(ComboBox_get_PlaceholderText), reinterpret_cast<setter>(ComboBox_put_PlaceholderText), nullptr, nullptr },
        { "header_template", reinterpret_cast<getter>(ComboBox_get_HeaderTemplate), reinterpret_cast<setter>(ComboBox_put_HeaderTemplate), nullptr, nullptr },
        { "header", reinterpret_cast<getter>(ComboBox_get_Header), reinterpret_cast<setter>(ComboBox_put_Header), nullptr, nullptr },
        { "light_dismiss_overlay_mode", reinterpret_cast<getter>(ComboBox_get_LightDismissOverlayMode), reinterpret_cast<setter>(ComboBox_put_LightDismissOverlayMode), nullptr, nullptr },
        { "is_text_search_enabled", reinterpret_cast<getter>(ComboBox_get_IsTextSearchEnabled), reinterpret_cast<setter>(ComboBox_put_IsTextSearchEnabled), nullptr, nullptr },
        { "selection_changed_trigger", reinterpret_cast<getter>(ComboBox_get_SelectionChangedTrigger), reinterpret_cast<setter>(ComboBox_put_SelectionChangedTrigger), nullptr, nullptr },
        { "placeholder_foreground", reinterpret_cast<getter>(ComboBox_get_PlaceholderForeground), reinterpret_cast<setter>(ComboBox_put_PlaceholderForeground), nullptr, nullptr },
        { "text_box_style", reinterpret_cast<getter>(ComboBox_get_TextBoxStyle), reinterpret_cast<setter>(ComboBox_put_TextBoxStyle), nullptr, nullptr },
        { "text", reinterpret_cast<getter>(ComboBox_get_Text), reinterpret_cast<setter>(ComboBox_put_Text), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(ComboBox_get_Description), reinterpret_cast<setter>(ComboBox_put_Description), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ComboBox[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ComboBox) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ComboBox) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ComboBox) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ComboBox) },
        { }
    };

    static PyType_Spec type_spec_ComboBox = {
        "winrt._winrt_windows_ui_xaml_controls_2.ComboBox",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::ComboBox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ComboBox};

    static PyGetSetDef getset_ComboBox_Static[] = {
        { "is_drop_down_open_property", reinterpret_cast<getter>(ComboBox_get_IsDropDownOpenProperty), nullptr, nullptr, nullptr },
        { "max_drop_down_height_property", reinterpret_cast<getter>(ComboBox_get_MaxDropDownHeightProperty), nullptr, nullptr, nullptr },
        { "header_property", reinterpret_cast<getter>(ComboBox_get_HeaderProperty), nullptr, nullptr, nullptr },
        { "header_template_property", reinterpret_cast<getter>(ComboBox_get_HeaderTemplateProperty), nullptr, nullptr, nullptr },
        { "placeholder_text_property", reinterpret_cast<getter>(ComboBox_get_PlaceholderTextProperty), nullptr, nullptr, nullptr },
        { "is_text_search_enabled_property", reinterpret_cast<getter>(ComboBox_get_IsTextSearchEnabledProperty), nullptr, nullptr, nullptr },
        { "light_dismiss_overlay_mode_property", reinterpret_cast<getter>(ComboBox_get_LightDismissOverlayModeProperty), nullptr, nullptr, nullptr },
        { "selection_changed_trigger_property", reinterpret_cast<getter>(ComboBox_get_SelectionChangedTriggerProperty), nullptr, nullptr, nullptr },
        { "placeholder_foreground_property", reinterpret_cast<getter>(ComboBox_get_PlaceholderForegroundProperty), nullptr, nullptr, nullptr },
        { "description_property", reinterpret_cast<getter>(ComboBox_get_DescriptionProperty), nullptr, nullptr, nullptr },
        { "is_editable_property", reinterpret_cast<getter>(ComboBox_get_IsEditableProperty), nullptr, nullptr, nullptr },
        { "text_box_style_property", reinterpret_cast<getter>(ComboBox_get_TextBoxStyleProperty), nullptr, nullptr, nullptr },
        { "text_property", reinterpret_cast<getter>(ComboBox_get_TextProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ComboBox_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ComboBox_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ComboBox_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ComboBox_Static) },
        { }
    };

    static PyType_Spec type_spec_ComboBox_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.ComboBox_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ComboBox_Static
    };

    // ----- ComboBoxItem class --------------------

    static PyObject* _new_ComboBoxItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::ComboBoxItem instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ComboBoxItem(py::wrapper::Windows::UI::Xaml::Controls::ComboBoxItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ComboBoxItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::ComboBoxItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ComboBoxItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::ComboBoxItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ComboBoxItem[] = {
        { "_assign_array_", _assign_array_ComboBoxItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ComboBoxItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ComboBoxItem[] = {
        { }
    };

    static PyType_Slot _type_slots_ComboBoxItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ComboBoxItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ComboBoxItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ComboBoxItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ComboBoxItem) },
        { }
    };

    static PyType_Spec type_spec_ComboBoxItem = {
        "winrt._winrt_windows_ui_xaml_controls_2.ComboBoxItem",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::ComboBoxItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ComboBoxItem};

    static PyGetSetDef getset_ComboBoxItem_Static[] = {
        { }
    };

    static PyMethodDef methods_ComboBoxItem_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ComboBoxItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ComboBoxItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ComboBoxItem_Static) },
        { }
    };

    static PyType_Spec type_spec_ComboBoxItem_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.ComboBoxItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ComboBoxItem_Static
    };

    // ----- DropDownButton class --------------------

    static PyObject* _new_DropDownButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::DropDownButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DropDownButton(py::wrapper::Windows::UI::Xaml::Controls::DropDownButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_DropDownButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::DropDownButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DropDownButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::DropDownButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DropDownButton[] = {
        { "_assign_array_", _assign_array_DropDownButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DropDownButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DropDownButton[] = {
        { }
    };

    static PyType_Slot _type_slots_DropDownButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DropDownButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DropDownButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DropDownButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DropDownButton) },
        { }
    };

    static PyType_Spec type_spec_DropDownButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.DropDownButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::DropDownButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DropDownButton};

    static PyGetSetDef getset_DropDownButton_Static[] = {
        { }
    };

    static PyMethodDef methods_DropDownButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_DropDownButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DropDownButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DropDownButton_Static) },
        { }
    };

    static PyType_Spec type_spec_DropDownButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.DropDownButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DropDownButton_Static
    };

    // ----- FlipView class --------------------

    static PyObject* _new_FlipView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::FlipView instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FlipView(py::wrapper::Windows::UI::Xaml::Controls::FlipView* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FlipView_get_UseTouchAnimationsForAllNavigation(py::wrapper::Windows::UI::Xaml::Controls::FlipView* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.FlipView", L"UseTouchAnimationsForAllNavigation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UseTouchAnimationsForAllNavigation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlipView_put_UseTouchAnimationsForAllNavigation(py::wrapper::Windows::UI::Xaml::Controls::FlipView* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.FlipView", L"UseTouchAnimationsForAllNavigation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.UseTouchAnimationsForAllNavigation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlipView_get_UseTouchAnimationsForAllNavigationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.FlipView", L"UseTouchAnimationsForAllNavigationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::FlipView::UseTouchAnimationsForAllNavigationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FlipView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::FlipView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlipView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::FlipView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlipView[] = {
        { "_assign_array_", _assign_array_FlipView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlipView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlipView[] = {
        { "use_touch_animations_for_all_navigation", reinterpret_cast<getter>(FlipView_get_UseTouchAnimationsForAllNavigation), reinterpret_cast<setter>(FlipView_put_UseTouchAnimationsForAllNavigation), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FlipView[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlipView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlipView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlipView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlipView) },
        { }
    };

    static PyType_Spec type_spec_FlipView = {
        "winrt._winrt_windows_ui_xaml_controls_2.FlipView",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::FlipView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlipView};

    static PyGetSetDef getset_FlipView_Static[] = {
        { "use_touch_animations_for_all_navigation_property", reinterpret_cast<getter>(FlipView_get_UseTouchAnimationsForAllNavigationProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_FlipView_Static[] = {
        { }
    };

    static PyType_Slot type_slots_FlipView_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FlipView_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FlipView_Static) },
        { }
    };

    static PyType_Spec type_spec_FlipView_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.FlipView_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_FlipView_Static
    };

    // ----- FlipViewItem class --------------------

    static PyObject* _new_FlipViewItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::FlipViewItem instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FlipViewItem(py::wrapper::Windows::UI::Xaml::Controls::FlipViewItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_FlipViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::FlipViewItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlipViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::FlipViewItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlipViewItem[] = {
        { "_assign_array_", _assign_array_FlipViewItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlipViewItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlipViewItem[] = {
        { }
    };

    static PyType_Slot _type_slots_FlipViewItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlipViewItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlipViewItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlipViewItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlipViewItem) },
        { }
    };

    static PyType_Spec type_spec_FlipViewItem = {
        "winrt._winrt_windows_ui_xaml_controls_2.FlipViewItem",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::FlipViewItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlipViewItem};

    static PyGetSetDef getset_FlipViewItem_Static[] = {
        { }
    };

    static PyMethodDef methods_FlipViewItem_Static[] = {
        { }
    };

    static PyType_Slot type_slots_FlipViewItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FlipViewItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FlipViewItem_Static) },
        { }
    };

    static PyType_Spec type_spec_FlipViewItem_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.FlipViewItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_FlipViewItem_Static
    };

    // ----- GridView class --------------------

    static PyObject* _new_GridView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::GridView instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GridView(py::wrapper::Windows::UI::Xaml::Controls::GridView* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_GridView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::GridView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GridView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::GridView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GridView[] = {
        { "_assign_array_", _assign_array_GridView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GridView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GridView[] = {
        { }
    };

    static PyType_Slot _type_slots_GridView[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GridView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridView) },
        { }
    };

    static PyType_Spec type_spec_GridView = {
        "winrt._winrt_windows_ui_xaml_controls_2.GridView",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::GridView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GridView};

    static PyGetSetDef getset_GridView_Static[] = {
        { }
    };

    static PyMethodDef methods_GridView_Static[] = {
        { }
    };

    static PyType_Slot type_slots_GridView_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GridView_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GridView_Static) },
        { }
    };

    static PyType_Spec type_spec_GridView_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.GridView_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GridView_Static
    };

    // ----- GridViewItem class --------------------

    static PyObject* _new_GridViewItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::GridViewItem instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GridViewItem(py::wrapper::Windows::UI::Xaml::Controls::GridViewItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GridViewItem_get_TemplateSettings(py::wrapper::Windows::UI::Xaml::Controls::GridViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.GridViewItem", L"TemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TemplateSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GridViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::GridViewItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GridViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::GridViewItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GridViewItem[] = {
        { "_assign_array_", _assign_array_GridViewItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GridViewItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GridViewItem[] = {
        { "template_settings", reinterpret_cast<getter>(GridViewItem_get_TemplateSettings), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GridViewItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridViewItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridViewItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GridViewItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridViewItem) },
        { }
    };

    static PyType_Spec type_spec_GridViewItem = {
        "winrt._winrt_windows_ui_xaml_controls_2.GridViewItem",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::GridViewItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GridViewItem};

    static PyGetSetDef getset_GridViewItem_Static[] = {
        { }
    };

    static PyMethodDef methods_GridViewItem_Static[] = {
        { }
    };

    static PyType_Slot type_slots_GridViewItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GridViewItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GridViewItem_Static) },
        { }
    };

    static PyType_Spec type_spec_GridViewItem_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.GridViewItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GridViewItem_Static
    };

    // ----- HyperlinkButton class --------------------

    static PyObject* _new_HyperlinkButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::HyperlinkButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HyperlinkButton(py::wrapper::Windows::UI::Xaml::Controls::HyperlinkButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HyperlinkButton_get_NavigateUri(py::wrapper::Windows::UI::Xaml::Controls::HyperlinkButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.HyperlinkButton", L"NavigateUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NavigateUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HyperlinkButton_put_NavigateUri(py::wrapper::Windows::UI::Xaml::Controls::HyperlinkButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.HyperlinkButton", L"NavigateUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.NavigateUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HyperlinkButton_get_NavigateUriProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.HyperlinkButton", L"NavigateUriProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::HyperlinkButton::NavigateUriProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HyperlinkButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::HyperlinkButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HyperlinkButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::HyperlinkButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HyperlinkButton[] = {
        { "_assign_array_", _assign_array_HyperlinkButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HyperlinkButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HyperlinkButton[] = {
        { "navigate_uri", reinterpret_cast<getter>(HyperlinkButton_get_NavigateUri), reinterpret_cast<setter>(HyperlinkButton_put_NavigateUri), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HyperlinkButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HyperlinkButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HyperlinkButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HyperlinkButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HyperlinkButton) },
        { }
    };

    static PyType_Spec type_spec_HyperlinkButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.HyperlinkButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::HyperlinkButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HyperlinkButton};

    static PyGetSetDef getset_HyperlinkButton_Static[] = {
        { "navigate_uri_property", reinterpret_cast<getter>(HyperlinkButton_get_NavigateUriProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_HyperlinkButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_HyperlinkButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HyperlinkButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HyperlinkButton_Static) },
        { }
    };

    static PyType_Spec type_spec_HyperlinkButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.HyperlinkButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HyperlinkButton_Static
    };

    // ----- InkToolbarBallpointPenButton class --------------------

    static PyObject* _new_InkToolbarBallpointPenButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::InkToolbarBallpointPenButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkToolbarBallpointPenButton(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarBallpointPenButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_InkToolbarBallpointPenButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarBallpointPenButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarBallpointPenButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarBallpointPenButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarBallpointPenButton[] = {
        { "_assign_array_", _assign_array_InkToolbarBallpointPenButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarBallpointPenButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarBallpointPenButton[] = {
        { }
    };

    static PyType_Slot _type_slots_InkToolbarBallpointPenButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarBallpointPenButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarBallpointPenButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarBallpointPenButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarBallpointPenButton) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarBallpointPenButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarBallpointPenButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarBallpointPenButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkToolbarBallpointPenButton};

    static PyGetSetDef getset_InkToolbarBallpointPenButton_Static[] = {
        { }
    };

    static PyMethodDef methods_InkToolbarBallpointPenButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarBallpointPenButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarBallpointPenButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarBallpointPenButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarBallpointPenButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarBallpointPenButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InkToolbarBallpointPenButton_Static
    };

    // ----- InkToolbarCustomPenButton class --------------------

    static PyObject* _new_InkToolbarCustomPenButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::InkToolbarCustomPenButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkToolbarCustomPenButton(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarCustomPenButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkToolbarCustomPenButton_get_CustomPen(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarCustomPenButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarCustomPenButton", L"CustomPen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CustomPen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarCustomPenButton_put_CustomPen(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarCustomPenButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarCustomPenButton", L"CustomPen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::InkToolbarCustomPen>(arg);

            self->obj.CustomPen(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarCustomPenButton_get_ConfigurationContent(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarCustomPenButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarCustomPenButton", L"ConfigurationContent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ConfigurationContent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarCustomPenButton_put_ConfigurationContent(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarCustomPenButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarCustomPenButton", L"ConfigurationContent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(arg);

            self->obj.ConfigurationContent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarCustomPenButton_get_ConfigurationContentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarCustomPenButton", L"ConfigurationContentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarCustomPenButton::ConfigurationContentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarCustomPenButton_get_CustomPenProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarCustomPenButton", L"CustomPenProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarCustomPenButton::CustomPenProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkToolbarCustomPenButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarCustomPenButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarCustomPenButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarCustomPenButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarCustomPenButton[] = {
        { "_assign_array_", _assign_array_InkToolbarCustomPenButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarCustomPenButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarCustomPenButton[] = {
        { "custom_pen", reinterpret_cast<getter>(InkToolbarCustomPenButton_get_CustomPen), reinterpret_cast<setter>(InkToolbarCustomPenButton_put_CustomPen), nullptr, nullptr },
        { "configuration_content", reinterpret_cast<getter>(InkToolbarCustomPenButton_get_ConfigurationContent), reinterpret_cast<setter>(InkToolbarCustomPenButton_put_ConfigurationContent), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkToolbarCustomPenButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarCustomPenButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarCustomPenButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarCustomPenButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarCustomPenButton) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarCustomPenButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarCustomPenButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarCustomPenButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkToolbarCustomPenButton};

    static PyGetSetDef getset_InkToolbarCustomPenButton_Static[] = {
        { "configuration_content_property", reinterpret_cast<getter>(InkToolbarCustomPenButton_get_ConfigurationContentProperty), nullptr, nullptr, nullptr },
        { "custom_pen_property", reinterpret_cast<getter>(InkToolbarCustomPenButton_get_CustomPenProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_InkToolbarCustomPenButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarCustomPenButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarCustomPenButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarCustomPenButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarCustomPenButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarCustomPenButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InkToolbarCustomPenButton_Static
    };

    // ----- InkToolbarCustomToggleButton class --------------------

    static PyObject* _new_InkToolbarCustomToggleButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::InkToolbarCustomToggleButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkToolbarCustomToggleButton(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarCustomToggleButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_InkToolbarCustomToggleButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarCustomToggleButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarCustomToggleButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarCustomToggleButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarCustomToggleButton[] = {
        { "_assign_array_", _assign_array_InkToolbarCustomToggleButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarCustomToggleButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarCustomToggleButton[] = {
        { }
    };

    static PyType_Slot _type_slots_InkToolbarCustomToggleButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarCustomToggleButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarCustomToggleButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarCustomToggleButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarCustomToggleButton) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarCustomToggleButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarCustomToggleButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarCustomToggleButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkToolbarCustomToggleButton};

    static PyGetSetDef getset_InkToolbarCustomToggleButton_Static[] = {
        { }
    };

    static PyMethodDef methods_InkToolbarCustomToggleButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarCustomToggleButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarCustomToggleButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarCustomToggleButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarCustomToggleButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarCustomToggleButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InkToolbarCustomToggleButton_Static
    };

    // ----- InkToolbarCustomToolButton class --------------------

    static PyObject* _new_InkToolbarCustomToolButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::InkToolbarCustomToolButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkToolbarCustomToolButton(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarCustomToolButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkToolbarCustomToolButton_get_ConfigurationContent(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarCustomToolButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarCustomToolButton", L"ConfigurationContent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ConfigurationContent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarCustomToolButton_put_ConfigurationContent(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarCustomToolButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarCustomToolButton", L"ConfigurationContent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(arg);

            self->obj.ConfigurationContent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarCustomToolButton_get_ConfigurationContentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarCustomToolButton", L"ConfigurationContentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarCustomToolButton::ConfigurationContentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkToolbarCustomToolButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarCustomToolButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarCustomToolButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarCustomToolButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarCustomToolButton[] = {
        { "_assign_array_", _assign_array_InkToolbarCustomToolButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarCustomToolButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarCustomToolButton[] = {
        { "configuration_content", reinterpret_cast<getter>(InkToolbarCustomToolButton_get_ConfigurationContent), reinterpret_cast<setter>(InkToolbarCustomToolButton_put_ConfigurationContent), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkToolbarCustomToolButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarCustomToolButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarCustomToolButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarCustomToolButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarCustomToolButton) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarCustomToolButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarCustomToolButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarCustomToolButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkToolbarCustomToolButton};

    static PyGetSetDef getset_InkToolbarCustomToolButton_Static[] = {
        { "configuration_content_property", reinterpret_cast<getter>(InkToolbarCustomToolButton_get_ConfigurationContentProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_InkToolbarCustomToolButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarCustomToolButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarCustomToolButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarCustomToolButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarCustomToolButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarCustomToolButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InkToolbarCustomToolButton_Static
    };

    // ----- InkToolbarEraserButton class --------------------

    static PyObject* _new_InkToolbarEraserButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::InkToolbarEraserButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkToolbarEraserButton(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarEraserButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkToolbarEraserButton_get_IsClearAllVisible(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarEraserButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarEraserButton", L"IsClearAllVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsClearAllVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarEraserButton_put_IsClearAllVisible(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarEraserButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarEraserButton", L"IsClearAllVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsClearAllVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarEraserButton_get_IsClearAllVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarEraserButton", L"IsClearAllVisibleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarEraserButton::IsClearAllVisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkToolbarEraserButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarEraserButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarEraserButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarEraserButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarEraserButton[] = {
        { "_assign_array_", _assign_array_InkToolbarEraserButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarEraserButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarEraserButton[] = {
        { "is_clear_all_visible", reinterpret_cast<getter>(InkToolbarEraserButton_get_IsClearAllVisible), reinterpret_cast<setter>(InkToolbarEraserButton_put_IsClearAllVisible), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkToolbarEraserButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarEraserButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarEraserButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarEraserButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarEraserButton) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarEraserButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarEraserButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarEraserButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkToolbarEraserButton};

    static PyGetSetDef getset_InkToolbarEraserButton_Static[] = {
        { "is_clear_all_visible_property", reinterpret_cast<getter>(InkToolbarEraserButton_get_IsClearAllVisibleProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_InkToolbarEraserButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarEraserButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarEraserButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarEraserButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarEraserButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarEraserButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InkToolbarEraserButton_Static
    };

    // ----- InkToolbarFlyoutItem class --------------------

    static PyObject* _new_InkToolbarFlyoutItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkToolbarFlyoutItem(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkToolbarFlyoutItem_get_Kind(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarFlyoutItem", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarFlyoutItem_put_Kind(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarFlyoutItem", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItemKind>(arg);

            self->obj.Kind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarFlyoutItem_get_IsChecked(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarFlyoutItem", L"IsChecked");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsChecked());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarFlyoutItem_put_IsChecked(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarFlyoutItem", L"IsChecked");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsChecked(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarFlyoutItem_get_IsCheckedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarFlyoutItem", L"IsCheckedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem::IsCheckedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarFlyoutItem_get_KindProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarFlyoutItem", L"KindProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem::KindProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarFlyoutItem_add_Checked(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.InkToolbarFlyoutItem", L"Checked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Checked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarFlyoutItem_remove_Checked(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.InkToolbarFlyoutItem", L"Checked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Checked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarFlyoutItem_add_Unchecked(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.InkToolbarFlyoutItem", L"Unchecked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Unchecked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarFlyoutItem_remove_Unchecked(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.InkToolbarFlyoutItem", L"Unchecked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Unchecked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkToolbarFlyoutItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarFlyoutItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarFlyoutItem[] = {
        { "add_checked", reinterpret_cast<PyCFunction>(InkToolbarFlyoutItem_add_Checked), METH_O, nullptr },
        { "remove_checked", reinterpret_cast<PyCFunction>(InkToolbarFlyoutItem_remove_Checked), METH_O, nullptr },
        { "add_unchecked", reinterpret_cast<PyCFunction>(InkToolbarFlyoutItem_add_Unchecked), METH_O, nullptr },
        { "remove_unchecked", reinterpret_cast<PyCFunction>(InkToolbarFlyoutItem_remove_Unchecked), METH_O, nullptr },
        { "_assign_array_", _assign_array_InkToolbarFlyoutItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarFlyoutItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarFlyoutItem[] = {
        { "kind", reinterpret_cast<getter>(InkToolbarFlyoutItem_get_Kind), reinterpret_cast<setter>(InkToolbarFlyoutItem_put_Kind), nullptr, nullptr },
        { "is_checked", reinterpret_cast<getter>(InkToolbarFlyoutItem_get_IsChecked), reinterpret_cast<setter>(InkToolbarFlyoutItem_put_IsChecked), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkToolbarFlyoutItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarFlyoutItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarFlyoutItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarFlyoutItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarFlyoutItem) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarFlyoutItem = {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarFlyoutItem",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkToolbarFlyoutItem};

    static PyGetSetDef getset_InkToolbarFlyoutItem_Static[] = {
        { "is_checked_property", reinterpret_cast<getter>(InkToolbarFlyoutItem_get_IsCheckedProperty), nullptr, nullptr, nullptr },
        { "kind_property", reinterpret_cast<getter>(InkToolbarFlyoutItem_get_KindProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_InkToolbarFlyoutItem_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarFlyoutItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarFlyoutItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarFlyoutItem_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarFlyoutItem_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarFlyoutItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InkToolbarFlyoutItem_Static
    };

    // ----- InkToolbarHighlighterButton class --------------------

    static PyObject* _new_InkToolbarHighlighterButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::InkToolbarHighlighterButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkToolbarHighlighterButton(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarHighlighterButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_InkToolbarHighlighterButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarHighlighterButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarHighlighterButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarHighlighterButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarHighlighterButton[] = {
        { "_assign_array_", _assign_array_InkToolbarHighlighterButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarHighlighterButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarHighlighterButton[] = {
        { }
    };

    static PyType_Slot _type_slots_InkToolbarHighlighterButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarHighlighterButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarHighlighterButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarHighlighterButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarHighlighterButton) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarHighlighterButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarHighlighterButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarHighlighterButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkToolbarHighlighterButton};

    static PyGetSetDef getset_InkToolbarHighlighterButton_Static[] = {
        { }
    };

    static PyMethodDef methods_InkToolbarHighlighterButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarHighlighterButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarHighlighterButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarHighlighterButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarHighlighterButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarHighlighterButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InkToolbarHighlighterButton_Static
    };

    // ----- InkToolbarMenuButton class --------------------

    static PyObject* _new_InkToolbarMenuButton(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::InkToolbarMenuButton>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::InkToolbarMenuButton>::type_name);
        return nullptr;
    }

    static void _dealloc_InkToolbarMenuButton(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarMenuButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkToolbarMenuButton_get_IsExtensionGlyphShown(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarMenuButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarMenuButton", L"IsExtensionGlyphShown");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsExtensionGlyphShown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarMenuButton_put_IsExtensionGlyphShown(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarMenuButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarMenuButton", L"IsExtensionGlyphShown");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsExtensionGlyphShown(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarMenuButton_get_MenuKind(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarMenuButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarMenuButton", L"MenuKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MenuKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarMenuButton_get_IsExtensionGlyphShownProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarMenuButton", L"IsExtensionGlyphShownProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarMenuButton::IsExtensionGlyphShownProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkToolbarMenuButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarMenuButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarMenuButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarMenuButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarMenuButton[] = {
        { "_assign_array_", _assign_array_InkToolbarMenuButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarMenuButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarMenuButton[] = {
        { "is_extension_glyph_shown", reinterpret_cast<getter>(InkToolbarMenuButton_get_IsExtensionGlyphShown), reinterpret_cast<setter>(InkToolbarMenuButton_put_IsExtensionGlyphShown), nullptr, nullptr },
        { "menu_kind", reinterpret_cast<getter>(InkToolbarMenuButton_get_MenuKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkToolbarMenuButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarMenuButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarMenuButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarMenuButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarMenuButton) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarMenuButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarMenuButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarMenuButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkToolbarMenuButton};

    static PyGetSetDef getset_InkToolbarMenuButton_Static[] = {
        { "is_extension_glyph_shown_property", reinterpret_cast<getter>(InkToolbarMenuButton_get_IsExtensionGlyphShownProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_InkToolbarMenuButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarMenuButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarMenuButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarMenuButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarMenuButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarMenuButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InkToolbarMenuButton_Static
    };

    // ----- InkToolbarPenButton class --------------------

    static PyObject* _new_InkToolbarPenButton(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton>::type_name);
        return nullptr;
    }

    static void _dealloc_InkToolbarPenButton(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarPenButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkToolbarPenButton_get_SelectedStrokeWidth(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarPenButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"SelectedStrokeWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedStrokeWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarPenButton_put_SelectedStrokeWidth(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarPenButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"SelectedStrokeWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.SelectedStrokeWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarPenButton_get_SelectedBrushIndex(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarPenButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"SelectedBrushIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedBrushIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarPenButton_put_SelectedBrushIndex(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarPenButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"SelectedBrushIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.SelectedBrushIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarPenButton_get_Palette(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarPenButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"Palette");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Palette());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarPenButton_put_Palette(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarPenButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"Palette");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::UI::Xaml::Media::Brush>>(arg);

            self->obj.Palette(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarPenButton_get_MinStrokeWidth(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarPenButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"MinStrokeWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinStrokeWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarPenButton_put_MinStrokeWidth(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarPenButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"MinStrokeWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.MinStrokeWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarPenButton_get_MaxStrokeWidth(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarPenButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"MaxStrokeWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxStrokeWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarPenButton_put_MaxStrokeWidth(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarPenButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"MaxStrokeWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.MaxStrokeWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarPenButton_get_SelectedBrush(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarPenButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"SelectedBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarPenButton_get_MaxStrokeWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"MaxStrokeWidthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton::MaxStrokeWidthProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarPenButton_get_MinStrokeWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"MinStrokeWidthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton::MinStrokeWidthProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarPenButton_get_PaletteProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"PaletteProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton::PaletteProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarPenButton_get_SelectedBrushIndexProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"SelectedBrushIndexProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton::SelectedBrushIndexProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarPenButton_get_SelectedBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"SelectedBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton::SelectedBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarPenButton_get_SelectedStrokeWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"SelectedStrokeWidthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton::SelectedStrokeWidthProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkToolbarPenButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarPenButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarPenButton[] = {
        { "_assign_array_", _assign_array_InkToolbarPenButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarPenButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarPenButton[] = {
        { "selected_stroke_width", reinterpret_cast<getter>(InkToolbarPenButton_get_SelectedStrokeWidth), reinterpret_cast<setter>(InkToolbarPenButton_put_SelectedStrokeWidth), nullptr, nullptr },
        { "selected_brush_index", reinterpret_cast<getter>(InkToolbarPenButton_get_SelectedBrushIndex), reinterpret_cast<setter>(InkToolbarPenButton_put_SelectedBrushIndex), nullptr, nullptr },
        { "palette", reinterpret_cast<getter>(InkToolbarPenButton_get_Palette), reinterpret_cast<setter>(InkToolbarPenButton_put_Palette), nullptr, nullptr },
        { "min_stroke_width", reinterpret_cast<getter>(InkToolbarPenButton_get_MinStrokeWidth), reinterpret_cast<setter>(InkToolbarPenButton_put_MinStrokeWidth), nullptr, nullptr },
        { "max_stroke_width", reinterpret_cast<getter>(InkToolbarPenButton_get_MaxStrokeWidth), reinterpret_cast<setter>(InkToolbarPenButton_put_MaxStrokeWidth), nullptr, nullptr },
        { "selected_brush", reinterpret_cast<getter>(InkToolbarPenButton_get_SelectedBrush), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkToolbarPenButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarPenButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarPenButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarPenButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarPenButton) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarPenButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarPenButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarPenButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkToolbarPenButton};

    static PyGetSetDef getset_InkToolbarPenButton_Static[] = {
        { "max_stroke_width_property", reinterpret_cast<getter>(InkToolbarPenButton_get_MaxStrokeWidthProperty), nullptr, nullptr, nullptr },
        { "min_stroke_width_property", reinterpret_cast<getter>(InkToolbarPenButton_get_MinStrokeWidthProperty), nullptr, nullptr, nullptr },
        { "palette_property", reinterpret_cast<getter>(InkToolbarPenButton_get_PaletteProperty), nullptr, nullptr, nullptr },
        { "selected_brush_index_property", reinterpret_cast<getter>(InkToolbarPenButton_get_SelectedBrushIndexProperty), nullptr, nullptr, nullptr },
        { "selected_brush_property", reinterpret_cast<getter>(InkToolbarPenButton_get_SelectedBrushProperty), nullptr, nullptr, nullptr },
        { "selected_stroke_width_property", reinterpret_cast<getter>(InkToolbarPenButton_get_SelectedStrokeWidthProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_InkToolbarPenButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarPenButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarPenButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarPenButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarPenButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarPenButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InkToolbarPenButton_Static
    };

    // ----- InkToolbarPencilButton class --------------------

    static PyObject* _new_InkToolbarPencilButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::InkToolbarPencilButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkToolbarPencilButton(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarPencilButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_InkToolbarPencilButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarPencilButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarPencilButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarPencilButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarPencilButton[] = {
        { "_assign_array_", _assign_array_InkToolbarPencilButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarPencilButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarPencilButton[] = {
        { }
    };

    static PyType_Slot _type_slots_InkToolbarPencilButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarPencilButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarPencilButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarPencilButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarPencilButton) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarPencilButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarPencilButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarPencilButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkToolbarPencilButton};

    static PyGetSetDef getset_InkToolbarPencilButton_Static[] = {
        { }
    };

    static PyMethodDef methods_InkToolbarPencilButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarPencilButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarPencilButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarPencilButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarPencilButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarPencilButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InkToolbarPencilButton_Static
    };

    // ----- InkToolbarRulerButton class --------------------

    static PyObject* _new_InkToolbarRulerButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::InkToolbarRulerButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkToolbarRulerButton(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarRulerButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkToolbarRulerButton_get_Ruler(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarRulerButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarRulerButton", L"Ruler");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Ruler());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarRulerButton_get_RulerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarRulerButton", L"RulerProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarRulerButton::RulerProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkToolbarRulerButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarRulerButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarRulerButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarRulerButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarRulerButton[] = {
        { "_assign_array_", _assign_array_InkToolbarRulerButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarRulerButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarRulerButton[] = {
        { "ruler", reinterpret_cast<getter>(InkToolbarRulerButton_get_Ruler), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkToolbarRulerButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarRulerButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarRulerButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarRulerButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarRulerButton) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarRulerButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarRulerButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarRulerButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkToolbarRulerButton};

    static PyGetSetDef getset_InkToolbarRulerButton_Static[] = {
        { "ruler_property", reinterpret_cast<getter>(InkToolbarRulerButton_get_RulerProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_InkToolbarRulerButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarRulerButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarRulerButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarRulerButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarRulerButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarRulerButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InkToolbarRulerButton_Static
    };

    // ----- InkToolbarStencilButton class --------------------

    static PyObject* _new_InkToolbarStencilButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkToolbarStencilButton(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarStencilButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkToolbarStencilButton_get_SelectedStencil(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarStencilButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"SelectedStencil");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedStencil());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarStencilButton_put_SelectedStencil(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarStencilButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"SelectedStencil");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::InkToolbarStencilKind>(arg);

            self->obj.SelectedStencil(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarStencilButton_get_IsRulerItemVisible(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarStencilButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"IsRulerItemVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsRulerItemVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarStencilButton_put_IsRulerItemVisible(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarStencilButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"IsRulerItemVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsRulerItemVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarStencilButton_get_IsProtractorItemVisible(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarStencilButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"IsProtractorItemVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsProtractorItemVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarStencilButton_put_IsProtractorItemVisible(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarStencilButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"IsProtractorItemVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsProtractorItemVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarStencilButton_get_Protractor(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarStencilButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"Protractor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Protractor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarStencilButton_get_Ruler(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarStencilButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"Ruler");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Ruler());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarStencilButton_get_IsProtractorItemVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"IsProtractorItemVisibleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButton::IsProtractorItemVisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarStencilButton_get_IsRulerItemVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"IsRulerItemVisibleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButton::IsRulerItemVisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarStencilButton_get_ProtractorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"ProtractorProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButton::ProtractorProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarStencilButton_get_RulerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"RulerProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButton::RulerProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarStencilButton_get_SelectedStencilProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"SelectedStencilProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButton::SelectedStencilProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkToolbarStencilButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarStencilButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarStencilButton[] = {
        { "_assign_array_", _assign_array_InkToolbarStencilButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarStencilButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarStencilButton[] = {
        { "selected_stencil", reinterpret_cast<getter>(InkToolbarStencilButton_get_SelectedStencil), reinterpret_cast<setter>(InkToolbarStencilButton_put_SelectedStencil), nullptr, nullptr },
        { "is_ruler_item_visible", reinterpret_cast<getter>(InkToolbarStencilButton_get_IsRulerItemVisible), reinterpret_cast<setter>(InkToolbarStencilButton_put_IsRulerItemVisible), nullptr, nullptr },
        { "is_protractor_item_visible", reinterpret_cast<getter>(InkToolbarStencilButton_get_IsProtractorItemVisible), reinterpret_cast<setter>(InkToolbarStencilButton_put_IsProtractorItemVisible), nullptr, nullptr },
        { "protractor", reinterpret_cast<getter>(InkToolbarStencilButton_get_Protractor), nullptr, nullptr, nullptr },
        { "ruler", reinterpret_cast<getter>(InkToolbarStencilButton_get_Ruler), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkToolbarStencilButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarStencilButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarStencilButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarStencilButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarStencilButton) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarStencilButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarStencilButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarStencilButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkToolbarStencilButton};

    static PyGetSetDef getset_InkToolbarStencilButton_Static[] = {
        { "is_protractor_item_visible_property", reinterpret_cast<getter>(InkToolbarStencilButton_get_IsProtractorItemVisibleProperty), nullptr, nullptr, nullptr },
        { "is_ruler_item_visible_property", reinterpret_cast<getter>(InkToolbarStencilButton_get_IsRulerItemVisibleProperty), nullptr, nullptr, nullptr },
        { "protractor_property", reinterpret_cast<getter>(InkToolbarStencilButton_get_ProtractorProperty), nullptr, nullptr, nullptr },
        { "ruler_property", reinterpret_cast<getter>(InkToolbarStencilButton_get_RulerProperty), nullptr, nullptr, nullptr },
        { "selected_stencil_property", reinterpret_cast<getter>(InkToolbarStencilButton_get_SelectedStencilProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_InkToolbarStencilButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarStencilButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarStencilButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarStencilButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarStencilButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarStencilButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InkToolbarStencilButton_Static
    };

    // ----- InkToolbarToggleButton class --------------------

    static PyObject* _new_InkToolbarToggleButton(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::InkToolbarToggleButton>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::InkToolbarToggleButton>::type_name);
        return nullptr;
    }

    static void _dealloc_InkToolbarToggleButton(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarToggleButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkToolbarToggleButton_get_ToggleKind(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarToggleButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarToggleButton", L"ToggleKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ToggleKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkToolbarToggleButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarToggleButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarToggleButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarToggleButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarToggleButton[] = {
        { "_assign_array_", _assign_array_InkToolbarToggleButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarToggleButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarToggleButton[] = {
        { "toggle_kind", reinterpret_cast<getter>(InkToolbarToggleButton_get_ToggleKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkToolbarToggleButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarToggleButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarToggleButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarToggleButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarToggleButton) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarToggleButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarToggleButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarToggleButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkToolbarToggleButton};

    static PyGetSetDef getset_InkToolbarToggleButton_Static[] = {
        { }
    };

    static PyMethodDef methods_InkToolbarToggleButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarToggleButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarToggleButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarToggleButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarToggleButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarToggleButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InkToolbarToggleButton_Static
    };

    // ----- InkToolbarToolButton class --------------------

    static PyObject* _new_InkToolbarToolButton(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::InkToolbarToolButton>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::InkToolbarToolButton>::type_name);
        return nullptr;
    }

    static void _dealloc_InkToolbarToolButton(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarToolButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkToolbarToolButton_get_IsExtensionGlyphShown(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarToolButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarToolButton", L"IsExtensionGlyphShown");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsExtensionGlyphShown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarToolButton_put_IsExtensionGlyphShown(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarToolButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarToolButton", L"IsExtensionGlyphShown");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsExtensionGlyphShown(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarToolButton_get_ToolKind(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarToolButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarToolButton", L"ToolKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ToolKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarToolButton_get_IsExtensionGlyphShownProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarToolButton", L"IsExtensionGlyphShownProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarToolButton::IsExtensionGlyphShownProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkToolbarToolButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarToolButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarToolButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarToolButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarToolButton[] = {
        { "_assign_array_", _assign_array_InkToolbarToolButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarToolButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarToolButton[] = {
        { "is_extension_glyph_shown", reinterpret_cast<getter>(InkToolbarToolButton_get_IsExtensionGlyphShown), reinterpret_cast<setter>(InkToolbarToolButton_put_IsExtensionGlyphShown), nullptr, nullptr },
        { "tool_kind", reinterpret_cast<getter>(InkToolbarToolButton_get_ToolKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkToolbarToolButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarToolButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarToolButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarToolButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarToolButton) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarToolButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarToolButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarToolButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkToolbarToolButton};

    static PyGetSetDef getset_InkToolbarToolButton_Static[] = {
        { "is_extension_glyph_shown_property", reinterpret_cast<getter>(InkToolbarToolButton_get_IsExtensionGlyphShownProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_InkToolbarToolButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarToolButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarToolButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarToolButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarToolButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarToolButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InkToolbarToolButton_Static
    };

    // ----- ListBox class --------------------

    static PyObject* _new_ListBox(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::ListBox instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListBox(py::wrapper::Windows::UI::Xaml::Controls::ListBox* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ListBox_ScrollIntoView(py::wrapper::Windows::UI::Xaml::Controls::ListBox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListBox", L"ScrollIntoView", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                self->obj.ScrollIntoView(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListBox_SelectAll(py::wrapper::Windows::UI::Xaml::Controls::ListBox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListBox", L"SelectAll", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.SelectAll();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListBox_get_SelectionMode(py::wrapper::Windows::UI::Xaml::Controls::ListBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListBox", L"SelectionMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListBox_put_SelectionMode(py::wrapper::Windows::UI::Xaml::Controls::ListBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListBox", L"SelectionMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SelectionMode>(arg);

            self->obj.SelectionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListBox_get_SelectedItems(py::wrapper::Windows::UI::Xaml::Controls::ListBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListBox", L"SelectedItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListBox_get_SingleSelectionFollowsFocus(py::wrapper::Windows::UI::Xaml::Controls::ListBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListBox", L"SingleSelectionFollowsFocus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SingleSelectionFollowsFocus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListBox_put_SingleSelectionFollowsFocus(py::wrapper::Windows::UI::Xaml::Controls::ListBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListBox", L"SingleSelectionFollowsFocus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.SingleSelectionFollowsFocus(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListBox_get_SelectionModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListBox", L"SelectionModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListBox::SelectionModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListBox_get_SingleSelectionFollowsFocusProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListBox", L"SingleSelectionFollowsFocusProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListBox::SingleSelectionFollowsFocusProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ListBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::ListBox>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::ListBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListBox[] = {
        { "scroll_into_view", reinterpret_cast<PyCFunction>(ListBox_ScrollIntoView), METH_VARARGS, nullptr },
        { "select_all", reinterpret_cast<PyCFunction>(ListBox_SelectAll), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ListBox, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListBox), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListBox[] = {
        { "selection_mode", reinterpret_cast<getter>(ListBox_get_SelectionMode), reinterpret_cast<setter>(ListBox_put_SelectionMode), nullptr, nullptr },
        { "selected_items", reinterpret_cast<getter>(ListBox_get_SelectedItems), nullptr, nullptr, nullptr },
        { "single_selection_follows_focus", reinterpret_cast<getter>(ListBox_get_SingleSelectionFollowsFocus), reinterpret_cast<setter>(ListBox_put_SingleSelectionFollowsFocus), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ListBox[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListBox) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListBox) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListBox) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListBox) },
        { }
    };

    static PyType_Spec type_spec_ListBox = {
        "winrt._winrt_windows_ui_xaml_controls_2.ListBox",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::ListBox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListBox};

    static PyGetSetDef getset_ListBox_Static[] = {
        { "selection_mode_property", reinterpret_cast<getter>(ListBox_get_SelectionModeProperty), nullptr, nullptr, nullptr },
        { "single_selection_follows_focus_property", reinterpret_cast<getter>(ListBox_get_SingleSelectionFollowsFocusProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ListBox_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListBox_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListBox_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListBox_Static) },
        { }
    };

    static PyType_Spec type_spec_ListBox_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.ListBox_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ListBox_Static
    };

    // ----- ListBoxItem class --------------------

    static PyObject* _new_ListBoxItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::ListBoxItem instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListBoxItem(py::wrapper::Windows::UI::Xaml::Controls::ListBoxItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListBoxItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::ListBoxItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListBoxItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::ListBoxItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListBoxItem[] = {
        { "_assign_array_", _assign_array_ListBoxItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListBoxItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListBoxItem[] = {
        { }
    };

    static PyType_Slot _type_slots_ListBoxItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListBoxItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListBoxItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListBoxItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListBoxItem) },
        { }
    };

    static PyType_Spec type_spec_ListBoxItem = {
        "winrt._winrt_windows_ui_xaml_controls_2.ListBoxItem",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::ListBoxItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListBoxItem};

    static PyGetSetDef getset_ListBoxItem_Static[] = {
        { }
    };

    static PyMethodDef methods_ListBoxItem_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListBoxItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListBoxItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListBoxItem_Static) },
        { }
    };

    static PyType_Spec type_spec_ListBoxItem_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.ListBoxItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ListBoxItem_Static
    };

    // ----- ListView class --------------------

    static PyObject* _new_ListView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::ListView instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListView(py::wrapper::Windows::UI::Xaml::Controls::ListView* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::ListView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::ListView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListView[] = {
        { "_assign_array_", _assign_array_ListView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListView[] = {
        { }
    };

    static PyType_Slot _type_slots_ListView[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListView) },
        { }
    };

    static PyType_Spec type_spec_ListView = {
        "winrt._winrt_windows_ui_xaml_controls_2.ListView",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::ListView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListView};

    static PyGetSetDef getset_ListView_Static[] = {
        { }
    };

    static PyMethodDef methods_ListView_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListView_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListView_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListView_Static) },
        { }
    };

    static PyType_Spec type_spec_ListView_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.ListView_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ListView_Static
    };

    // ----- ListViewBase class --------------------

    static PyObject* _new_ListViewBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::ListViewBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::ListViewBase>::type_name);
        return nullptr;
    }

    static void _dealloc_ListViewBase(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ListViewBase_CompleteViewChange(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"CompleteViewChange", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.CompleteViewChange();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_CompleteViewChangeFrom(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"CompleteViewChangeFrom", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SemanticZoomLocation>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SemanticZoomLocation>(args, 1);

                self->obj.CompleteViewChangeFrom(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_CompleteViewChangeTo(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"CompleteViewChangeTo", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SemanticZoomLocation>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SemanticZoomLocation>(args, 1);

                self->obj.CompleteViewChangeTo(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_DeselectRange(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"DeselectRange", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Data::ItemIndexRange>(args, 0);

                self->obj.DeselectRange(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_InitializeViewChange(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"InitializeViewChange", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.InitializeViewChange();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_IsDragSource(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsDragSource", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.IsDragSource());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_LoadMoreItemsAsync(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"LoadMoreItemsAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.LoadMoreItemsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_MakeVisible(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"MakeVisible", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SemanticZoomLocation>(args, 0);

                self->obj.MakeVisible(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_PrepareConnectedAnimation(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"PrepareConnectedAnimation", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.PrepareConnectedAnimation(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_ScrollIntoView(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ScrollIntoView", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                self->obj.ScrollIntoView(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_ScrollIntoViewWithAlignment(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ScrollIntoView", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ScrollIntoViewAlignment>(args, 1);

                self->obj.ScrollIntoView(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_SelectAll(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SelectAll", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.SelectAll();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_SelectRange(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SelectRange", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Data::ItemIndexRange>(args, 0);

                self->obj.SelectRange(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_SetDesiredContainerUpdateDuration(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SetDesiredContainerUpdateDuration", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                self->obj.SetDesiredContainerUpdateDuration(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_StartViewChangeFrom(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"StartViewChangeFrom", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SemanticZoomLocation>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SemanticZoomLocation>(args, 1);

                self->obj.StartViewChangeFrom(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_StartViewChangeTo(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"StartViewChangeTo", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SemanticZoomLocation>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SemanticZoomLocation>(args, 1);

                self->obj.StartViewChangeTo(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_TryStartConnectedAnimationAsync(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"TryStartConnectedAnimationAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::ConnectedAnimation>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.TryStartConnectedAnimationAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_SelectionMode(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SelectionMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_SelectionMode(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SelectionMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ListViewSelectionMode>(arg);

            self->obj.SelectionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_IsSwipeEnabled(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsSwipeEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSwipeEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_IsSwipeEnabled(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsSwipeEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSwipeEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_IsItemClickEnabled(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsItemClickEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsItemClickEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_IsItemClickEnabled(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsItemClickEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsItemClickEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_IncrementalLoadingTrigger(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IncrementalLoadingTrigger");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IncrementalLoadingTrigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_IncrementalLoadingTrigger(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IncrementalLoadingTrigger");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::IncrementalLoadingTrigger>(arg);

            self->obj.IncrementalLoadingTrigger(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_IncrementalLoadingThreshold(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IncrementalLoadingThreshold");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IncrementalLoadingThreshold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_IncrementalLoadingThreshold(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IncrementalLoadingThreshold");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.IncrementalLoadingThreshold(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_HeaderTransitions(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"HeaderTransitions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HeaderTransitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_HeaderTransitions(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"HeaderTransitions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::TransitionCollection>(arg);

            self->obj.HeaderTransitions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_HeaderTemplate(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"HeaderTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HeaderTemplate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_HeaderTemplate(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"HeaderTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DataTemplate>(arg);

            self->obj.HeaderTemplate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_Header(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"Header");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Header());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_Header(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"Header");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.Header(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_DataFetchSize(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"DataFetchSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DataFetchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_DataFetchSize(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"DataFetchSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.DataFetchSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_CanReorderItems(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"CanReorderItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanReorderItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_CanReorderItems(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"CanReorderItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanReorderItems(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_CanDragItems(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"CanDragItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanDragItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_CanDragItems(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"CanDragItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanDragItems(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_SelectedItems(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SelectedItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_ShowsScrollingPlaceholders(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ShowsScrollingPlaceholders");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ShowsScrollingPlaceholders());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_ShowsScrollingPlaceholders(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ShowsScrollingPlaceholders");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShowsScrollingPlaceholders(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_FooterTransitions(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"FooterTransitions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FooterTransitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_FooterTransitions(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"FooterTransitions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::TransitionCollection>(arg);

            self->obj.FooterTransitions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_FooterTemplate(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"FooterTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FooterTemplate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_FooterTemplate(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"FooterTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DataTemplate>(arg);

            self->obj.FooterTemplate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_Footer(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"Footer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Footer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_Footer(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"Footer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.Footer(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_ReorderMode(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ReorderMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReorderMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_ReorderMode(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ReorderMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ListViewReorderMode>(arg);

            self->obj.ReorderMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_IsMultiSelectCheckBoxEnabled(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsMultiSelectCheckBoxEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsMultiSelectCheckBoxEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_IsMultiSelectCheckBoxEnabled(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsMultiSelectCheckBoxEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsMultiSelectCheckBoxEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_SelectedRanges(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SelectedRanges");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedRanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_SingleSelectionFollowsFocus(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SingleSelectionFollowsFocus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SingleSelectionFollowsFocus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_SingleSelectionFollowsFocus(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SingleSelectionFollowsFocus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.SingleSelectionFollowsFocus(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_SemanticZoomOwner(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SemanticZoomOwner");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SemanticZoomOwner());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_SemanticZoomOwner(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SemanticZoomOwner");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SemanticZoom>(arg);

            self->obj.SemanticZoomOwner(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_IsZoomedInView(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsZoomedInView");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsZoomedInView());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_IsZoomedInView(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsZoomedInView");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsZoomedInView(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_IsActiveView(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsActiveView");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsActiveView());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_IsActiveView(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsActiveView");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsActiveView(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_CanDragItemsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"CanDragItemsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::CanDragItemsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_CanReorderItemsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"CanReorderItemsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::CanReorderItemsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_DataFetchSizeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"DataFetchSizeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::DataFetchSizeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_HeaderProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"HeaderProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::HeaderProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_HeaderTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"HeaderTemplateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::HeaderTemplateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_HeaderTransitionsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"HeaderTransitionsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::HeaderTransitionsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_IncrementalLoadingThresholdProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IncrementalLoadingThresholdProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::IncrementalLoadingThresholdProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_IncrementalLoadingTriggerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IncrementalLoadingTriggerProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::IncrementalLoadingTriggerProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_IsActiveViewProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsActiveViewProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::IsActiveViewProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_IsItemClickEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsItemClickEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::IsItemClickEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_IsSwipeEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsSwipeEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::IsSwipeEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_IsZoomedInViewProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsZoomedInViewProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::IsZoomedInViewProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_SelectionModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SelectionModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::SelectionModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_SemanticZoomOwnerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SemanticZoomOwnerProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::SemanticZoomOwnerProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_FooterProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"FooterProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::FooterProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_FooterTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"FooterTemplateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::FooterTemplateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_FooterTransitionsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"FooterTransitionsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::FooterTransitionsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_ShowsScrollingPlaceholdersProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ShowsScrollingPlaceholdersProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::ShowsScrollingPlaceholdersProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_ReorderModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ReorderModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::ReorderModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_IsMultiSelectCheckBoxEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsMultiSelectCheckBoxEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::IsMultiSelectCheckBoxEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_SingleSelectionFollowsFocusProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SingleSelectionFollowsFocusProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::SingleSelectionFollowsFocusProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_add_DragItemsStarting(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"DragItemsStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::DragItemsStartingEventHandler>(arg);

            return py::convert(self->obj.DragItemsStarting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_remove_DragItemsStarting(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"DragItemsStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DragItemsStarting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_add_ItemClick(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ItemClick");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ItemClickEventHandler>(arg);

            return py::convert(self->obj.ItemClick(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_remove_ItemClick(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ItemClick");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ItemClick(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_add_ContainerContentChanging(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ContainerContentChanging");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::ListViewBase, winrt::Windows::UI::Xaml::Controls::ContainerContentChangingEventArgs>>(arg);

            return py::convert(self->obj.ContainerContentChanging(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_remove_ContainerContentChanging(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ContainerContentChanging");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ContainerContentChanging(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_add_ChoosingGroupHeaderContainer(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ChoosingGroupHeaderContainer");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::ListViewBase, winrt::Windows::UI::Xaml::Controls::ChoosingGroupHeaderContainerEventArgs>>(arg);

            return py::convert(self->obj.ChoosingGroupHeaderContainer(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_remove_ChoosingGroupHeaderContainer(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ChoosingGroupHeaderContainer");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ChoosingGroupHeaderContainer(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_add_ChoosingItemContainer(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ChoosingItemContainer");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::ListViewBase, winrt::Windows::UI::Xaml::Controls::ChoosingItemContainerEventArgs>>(arg);

            return py::convert(self->obj.ChoosingItemContainer(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_remove_ChoosingItemContainer(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ChoosingItemContainer");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ChoosingItemContainer(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_add_DragItemsCompleted(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"DragItemsCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::ListViewBase, winrt::Windows::UI::Xaml::Controls::DragItemsCompletedEventArgs>>(arg);

            return py::convert(self->obj.DragItemsCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_remove_DragItemsCompleted(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"DragItemsCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DragItemsCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ListViewBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::ListViewBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::ListViewBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewBase[] = {
        { "complete_view_change", reinterpret_cast<PyCFunction>(ListViewBase_CompleteViewChange), METH_VARARGS, nullptr },
        { "complete_view_change_from", reinterpret_cast<PyCFunction>(ListViewBase_CompleteViewChangeFrom), METH_VARARGS, nullptr },
        { "complete_view_change_to", reinterpret_cast<PyCFunction>(ListViewBase_CompleteViewChangeTo), METH_VARARGS, nullptr },
        { "deselect_range", reinterpret_cast<PyCFunction>(ListViewBase_DeselectRange), METH_VARARGS, nullptr },
        { "initialize_view_change", reinterpret_cast<PyCFunction>(ListViewBase_InitializeViewChange), METH_VARARGS, nullptr },
        { "is_drag_source", reinterpret_cast<PyCFunction>(ListViewBase_IsDragSource), METH_VARARGS, nullptr },
        { "load_more_items_async", reinterpret_cast<PyCFunction>(ListViewBase_LoadMoreItemsAsync), METH_VARARGS, nullptr },
        { "make_visible", reinterpret_cast<PyCFunction>(ListViewBase_MakeVisible), METH_VARARGS, nullptr },
        { "prepare_connected_animation", reinterpret_cast<PyCFunction>(ListViewBase_PrepareConnectedAnimation), METH_VARARGS, nullptr },
        { "scroll_into_view", reinterpret_cast<PyCFunction>(ListViewBase_ScrollIntoView), METH_VARARGS, nullptr },
        { "scroll_into_view_with_alignment", reinterpret_cast<PyCFunction>(ListViewBase_ScrollIntoViewWithAlignment), METH_VARARGS, nullptr },
        { "select_all", reinterpret_cast<PyCFunction>(ListViewBase_SelectAll), METH_VARARGS, nullptr },
        { "select_range", reinterpret_cast<PyCFunction>(ListViewBase_SelectRange), METH_VARARGS, nullptr },
        { "set_desired_container_update_duration", reinterpret_cast<PyCFunction>(ListViewBase_SetDesiredContainerUpdateDuration), METH_VARARGS, nullptr },
        { "start_view_change_from", reinterpret_cast<PyCFunction>(ListViewBase_StartViewChangeFrom), METH_VARARGS, nullptr },
        { "start_view_change_to", reinterpret_cast<PyCFunction>(ListViewBase_StartViewChangeTo), METH_VARARGS, nullptr },
        { "try_start_connected_animation_async", reinterpret_cast<PyCFunction>(ListViewBase_TryStartConnectedAnimationAsync), METH_VARARGS, nullptr },
        { "add_drag_items_starting", reinterpret_cast<PyCFunction>(ListViewBase_add_DragItemsStarting), METH_O, nullptr },
        { "remove_drag_items_starting", reinterpret_cast<PyCFunction>(ListViewBase_remove_DragItemsStarting), METH_O, nullptr },
        { "add_item_click", reinterpret_cast<PyCFunction>(ListViewBase_add_ItemClick), METH_O, nullptr },
        { "remove_item_click", reinterpret_cast<PyCFunction>(ListViewBase_remove_ItemClick), METH_O, nullptr },
        { "add_container_content_changing", reinterpret_cast<PyCFunction>(ListViewBase_add_ContainerContentChanging), METH_O, nullptr },
        { "remove_container_content_changing", reinterpret_cast<PyCFunction>(ListViewBase_remove_ContainerContentChanging), METH_O, nullptr },
        { "add_choosing_group_header_container", reinterpret_cast<PyCFunction>(ListViewBase_add_ChoosingGroupHeaderContainer), METH_O, nullptr },
        { "remove_choosing_group_header_container", reinterpret_cast<PyCFunction>(ListViewBase_remove_ChoosingGroupHeaderContainer), METH_O, nullptr },
        { "add_choosing_item_container", reinterpret_cast<PyCFunction>(ListViewBase_add_ChoosingItemContainer), METH_O, nullptr },
        { "remove_choosing_item_container", reinterpret_cast<PyCFunction>(ListViewBase_remove_ChoosingItemContainer), METH_O, nullptr },
        { "add_drag_items_completed", reinterpret_cast<PyCFunction>(ListViewBase_add_DragItemsCompleted), METH_O, nullptr },
        { "remove_drag_items_completed", reinterpret_cast<PyCFunction>(ListViewBase_remove_DragItemsCompleted), METH_O, nullptr },
        { "_assign_array_", _assign_array_ListViewBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewBase[] = {
        { "selection_mode", reinterpret_cast<getter>(ListViewBase_get_SelectionMode), reinterpret_cast<setter>(ListViewBase_put_SelectionMode), nullptr, nullptr },
        { "is_swipe_enabled", reinterpret_cast<getter>(ListViewBase_get_IsSwipeEnabled), reinterpret_cast<setter>(ListViewBase_put_IsSwipeEnabled), nullptr, nullptr },
        { "is_item_click_enabled", reinterpret_cast<getter>(ListViewBase_get_IsItemClickEnabled), reinterpret_cast<setter>(ListViewBase_put_IsItemClickEnabled), nullptr, nullptr },
        { "incremental_loading_trigger", reinterpret_cast<getter>(ListViewBase_get_IncrementalLoadingTrigger), reinterpret_cast<setter>(ListViewBase_put_IncrementalLoadingTrigger), nullptr, nullptr },
        { "incremental_loading_threshold", reinterpret_cast<getter>(ListViewBase_get_IncrementalLoadingThreshold), reinterpret_cast<setter>(ListViewBase_put_IncrementalLoadingThreshold), nullptr, nullptr },
        { "header_transitions", reinterpret_cast<getter>(ListViewBase_get_HeaderTransitions), reinterpret_cast<setter>(ListViewBase_put_HeaderTransitions), nullptr, nullptr },
        { "header_template", reinterpret_cast<getter>(ListViewBase_get_HeaderTemplate), reinterpret_cast<setter>(ListViewBase_put_HeaderTemplate), nullptr, nullptr },
        { "header", reinterpret_cast<getter>(ListViewBase_get_Header), reinterpret_cast<setter>(ListViewBase_put_Header), nullptr, nullptr },
        { "data_fetch_size", reinterpret_cast<getter>(ListViewBase_get_DataFetchSize), reinterpret_cast<setter>(ListViewBase_put_DataFetchSize), nullptr, nullptr },
        { "can_reorder_items", reinterpret_cast<getter>(ListViewBase_get_CanReorderItems), reinterpret_cast<setter>(ListViewBase_put_CanReorderItems), nullptr, nullptr },
        { "can_drag_items", reinterpret_cast<getter>(ListViewBase_get_CanDragItems), reinterpret_cast<setter>(ListViewBase_put_CanDragItems), nullptr, nullptr },
        { "selected_items", reinterpret_cast<getter>(ListViewBase_get_SelectedItems), nullptr, nullptr, nullptr },
        { "shows_scrolling_placeholders", reinterpret_cast<getter>(ListViewBase_get_ShowsScrollingPlaceholders), reinterpret_cast<setter>(ListViewBase_put_ShowsScrollingPlaceholders), nullptr, nullptr },
        { "footer_transitions", reinterpret_cast<getter>(ListViewBase_get_FooterTransitions), reinterpret_cast<setter>(ListViewBase_put_FooterTransitions), nullptr, nullptr },
        { "footer_template", reinterpret_cast<getter>(ListViewBase_get_FooterTemplate), reinterpret_cast<setter>(ListViewBase_put_FooterTemplate), nullptr, nullptr },
        { "footer", reinterpret_cast<getter>(ListViewBase_get_Footer), reinterpret_cast<setter>(ListViewBase_put_Footer), nullptr, nullptr },
        { "reorder_mode", reinterpret_cast<getter>(ListViewBase_get_ReorderMode), reinterpret_cast<setter>(ListViewBase_put_ReorderMode), nullptr, nullptr },
        { "is_multi_select_check_box_enabled", reinterpret_cast<getter>(ListViewBase_get_IsMultiSelectCheckBoxEnabled), reinterpret_cast<setter>(ListViewBase_put_IsMultiSelectCheckBoxEnabled), nullptr, nullptr },
        { "selected_ranges", reinterpret_cast<getter>(ListViewBase_get_SelectedRanges), nullptr, nullptr, nullptr },
        { "single_selection_follows_focus", reinterpret_cast<getter>(ListViewBase_get_SingleSelectionFollowsFocus), reinterpret_cast<setter>(ListViewBase_put_SingleSelectionFollowsFocus), nullptr, nullptr },
        { "semantic_zoom_owner", reinterpret_cast<getter>(ListViewBase_get_SemanticZoomOwner), reinterpret_cast<setter>(ListViewBase_put_SemanticZoomOwner), nullptr, nullptr },
        { "is_zoomed_in_view", reinterpret_cast<getter>(ListViewBase_get_IsZoomedInView), reinterpret_cast<setter>(ListViewBase_put_IsZoomedInView), nullptr, nullptr },
        { "is_active_view", reinterpret_cast<getter>(ListViewBase_get_IsActiveView), reinterpret_cast<setter>(ListViewBase_put_IsActiveView), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ListViewBase[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewBase) },
        { }
    };

    static PyType_Spec type_spec_ListViewBase = {
        "winrt._winrt_windows_ui_xaml_controls_2.ListViewBase",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListViewBase};

    static PyGetSetDef getset_ListViewBase_Static[] = {
        { "can_drag_items_property", reinterpret_cast<getter>(ListViewBase_get_CanDragItemsProperty), nullptr, nullptr, nullptr },
        { "can_reorder_items_property", reinterpret_cast<getter>(ListViewBase_get_CanReorderItemsProperty), nullptr, nullptr, nullptr },
        { "data_fetch_size_property", reinterpret_cast<getter>(ListViewBase_get_DataFetchSizeProperty), nullptr, nullptr, nullptr },
        { "header_property", reinterpret_cast<getter>(ListViewBase_get_HeaderProperty), nullptr, nullptr, nullptr },
        { "header_template_property", reinterpret_cast<getter>(ListViewBase_get_HeaderTemplateProperty), nullptr, nullptr, nullptr },
        { "header_transitions_property", reinterpret_cast<getter>(ListViewBase_get_HeaderTransitionsProperty), nullptr, nullptr, nullptr },
        { "incremental_loading_threshold_property", reinterpret_cast<getter>(ListViewBase_get_IncrementalLoadingThresholdProperty), nullptr, nullptr, nullptr },
        { "incremental_loading_trigger_property", reinterpret_cast<getter>(ListViewBase_get_IncrementalLoadingTriggerProperty), nullptr, nullptr, nullptr },
        { "is_active_view_property", reinterpret_cast<getter>(ListViewBase_get_IsActiveViewProperty), nullptr, nullptr, nullptr },
        { "is_item_click_enabled_property", reinterpret_cast<getter>(ListViewBase_get_IsItemClickEnabledProperty), nullptr, nullptr, nullptr },
        { "is_swipe_enabled_property", reinterpret_cast<getter>(ListViewBase_get_IsSwipeEnabledProperty), nullptr, nullptr, nullptr },
        { "is_zoomed_in_view_property", reinterpret_cast<getter>(ListViewBase_get_IsZoomedInViewProperty), nullptr, nullptr, nullptr },
        { "selection_mode_property", reinterpret_cast<getter>(ListViewBase_get_SelectionModeProperty), nullptr, nullptr, nullptr },
        { "semantic_zoom_owner_property", reinterpret_cast<getter>(ListViewBase_get_SemanticZoomOwnerProperty), nullptr, nullptr, nullptr },
        { "footer_property", reinterpret_cast<getter>(ListViewBase_get_FooterProperty), nullptr, nullptr, nullptr },
        { "footer_template_property", reinterpret_cast<getter>(ListViewBase_get_FooterTemplateProperty), nullptr, nullptr, nullptr },
        { "footer_transitions_property", reinterpret_cast<getter>(ListViewBase_get_FooterTransitionsProperty), nullptr, nullptr, nullptr },
        { "shows_scrolling_placeholders_property", reinterpret_cast<getter>(ListViewBase_get_ShowsScrollingPlaceholdersProperty), nullptr, nullptr, nullptr },
        { "reorder_mode_property", reinterpret_cast<getter>(ListViewBase_get_ReorderModeProperty), nullptr, nullptr, nullptr },
        { "is_multi_select_check_box_enabled_property", reinterpret_cast<getter>(ListViewBase_get_IsMultiSelectCheckBoxEnabledProperty), nullptr, nullptr, nullptr },
        { "single_selection_follows_focus_property", reinterpret_cast<getter>(ListViewBase_get_SingleSelectionFollowsFocusProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ListViewBase_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListViewBase_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListViewBase_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListViewBase_Static) },
        { }
    };

    static PyType_Spec type_spec_ListViewBase_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.ListViewBase_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ListViewBase_Static
    };

    // ----- ListViewItem class --------------------

    static PyObject* _new_ListViewItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::ListViewItem instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListViewItem(py::wrapper::Windows::UI::Xaml::Controls::ListViewItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ListViewItem_get_TemplateSettings(py::wrapper::Windows::UI::Xaml::Controls::ListViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewItem", L"TemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TemplateSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ListViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::ListViewItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::ListViewItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewItem[] = {
        { "_assign_array_", _assign_array_ListViewItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewItem[] = {
        { "template_settings", reinterpret_cast<getter>(ListViewItem_get_TemplateSettings), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ListViewItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewItem) },
        { }
    };

    static PyType_Spec type_spec_ListViewItem = {
        "winrt._winrt_windows_ui_xaml_controls_2.ListViewItem",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::ListViewItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListViewItem};

    static PyGetSetDef getset_ListViewItem_Static[] = {
        { }
    };

    static PyMethodDef methods_ListViewItem_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListViewItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListViewItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListViewItem_Static) },
        { }
    };

    static PyType_Spec type_spec_ListViewItem_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.ListViewItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ListViewItem_Static
    };

    // ----- NavigationViewItem class --------------------

    static PyObject* _new_NavigationViewItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::NavigationViewItem instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NavigationViewItem(py::wrapper::Windows::UI::Xaml::Controls::NavigationViewItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NavigationViewItem_get_Icon(py::wrapper::Windows::UI::Xaml::Controls::NavigationViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.NavigationViewItem", L"Icon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Icon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationViewItem_put_Icon(py::wrapper::Windows::UI::Xaml::Controls::NavigationViewItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.NavigationViewItem", L"Icon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::IconElement>(arg);

            self->obj.Icon(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationViewItem_get_CompactPaneLength(py::wrapper::Windows::UI::Xaml::Controls::NavigationViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.NavigationViewItem", L"CompactPaneLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CompactPaneLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItem_get_SelectsOnInvoked(py::wrapper::Windows::UI::Xaml::Controls::NavigationViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.NavigationViewItem", L"SelectsOnInvoked");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectsOnInvoked());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationViewItem_put_SelectsOnInvoked(py::wrapper::Windows::UI::Xaml::Controls::NavigationViewItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.NavigationViewItem", L"SelectsOnInvoked");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.SelectsOnInvoked(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationViewItem_get_CompactPaneLengthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.NavigationViewItem", L"CompactPaneLengthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::NavigationViewItem::CompactPaneLengthProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItem_get_IconProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.NavigationViewItem", L"IconProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::NavigationViewItem::IconProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItem_get_SelectsOnInvokedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.NavigationViewItem", L"SelectsOnInvokedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::NavigationViewItem::SelectsOnInvokedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NavigationViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::NavigationViewItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::NavigationViewItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewItem[] = {
        { "_assign_array_", _assign_array_NavigationViewItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NavigationViewItem[] = {
        { "icon", reinterpret_cast<getter>(NavigationViewItem_get_Icon), reinterpret_cast<setter>(NavigationViewItem_put_Icon), nullptr, nullptr },
        { "compact_pane_length", reinterpret_cast<getter>(NavigationViewItem_get_CompactPaneLength), nullptr, nullptr, nullptr },
        { "selects_on_invoked", reinterpret_cast<getter>(NavigationViewItem_get_SelectsOnInvoked), reinterpret_cast<setter>(NavigationViewItem_put_SelectsOnInvoked), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NavigationViewItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewItem) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItem = {
        "winrt._winrt_windows_ui_xaml_controls_2.NavigationViewItem",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::NavigationViewItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NavigationViewItem};

    static PyGetSetDef getset_NavigationViewItem_Static[] = {
        { "compact_pane_length_property", reinterpret_cast<getter>(NavigationViewItem_get_CompactPaneLengthProperty), nullptr, nullptr, nullptr },
        { "icon_property", reinterpret_cast<getter>(NavigationViewItem_get_IconProperty), nullptr, nullptr, nullptr },
        { "selects_on_invoked_property", reinterpret_cast<getter>(NavigationViewItem_get_SelectsOnInvokedProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_NavigationViewItem_Static[] = {
        { }
    };

    static PyType_Slot type_slots_NavigationViewItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NavigationViewItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NavigationViewItem_Static) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItem_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.NavigationViewItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_NavigationViewItem_Static
    };

    // ----- NavigationViewItemBase class --------------------

    static PyObject* _new_NavigationViewItemBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::NavigationViewItemBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::NavigationViewItemBase>::type_name);
        return nullptr;
    }

    static void _dealloc_NavigationViewItemBase(py::wrapper::Windows::UI::Xaml::Controls::NavigationViewItemBase* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_NavigationViewItemBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::NavigationViewItemBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewItemBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::NavigationViewItemBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewItemBase[] = {
        { "_assign_array_", _assign_array_NavigationViewItemBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewItemBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NavigationViewItemBase[] = {
        { }
    };

    static PyType_Slot _type_slots_NavigationViewItemBase[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewItemBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewItemBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewItemBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewItemBase) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItemBase = {
        "winrt._winrt_windows_ui_xaml_controls_2.NavigationViewItemBase",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::NavigationViewItemBase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NavigationViewItemBase};

    static PyGetSetDef getset_NavigationViewItemBase_Static[] = {
        { }
    };

    static PyMethodDef methods_NavigationViewItemBase_Static[] = {
        { }
    };

    static PyType_Slot type_slots_NavigationViewItemBase_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NavigationViewItemBase_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NavigationViewItemBase_Static) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItemBase_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.NavigationViewItemBase_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_NavigationViewItemBase_Static
    };

    // ----- NavigationViewItemHeader class --------------------

    static PyObject* _new_NavigationViewItemHeader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::NavigationViewItemHeader instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NavigationViewItemHeader(py::wrapper::Windows::UI::Xaml::Controls::NavigationViewItemHeader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_NavigationViewItemHeader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::NavigationViewItemHeader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewItemHeader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::NavigationViewItemHeader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewItemHeader[] = {
        { "_assign_array_", _assign_array_NavigationViewItemHeader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewItemHeader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NavigationViewItemHeader[] = {
        { }
    };

    static PyType_Slot _type_slots_NavigationViewItemHeader[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewItemHeader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewItemHeader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewItemHeader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewItemHeader) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItemHeader = {
        "winrt._winrt_windows_ui_xaml_controls_2.NavigationViewItemHeader",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::NavigationViewItemHeader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NavigationViewItemHeader};

    static PyGetSetDef getset_NavigationViewItemHeader_Static[] = {
        { }
    };

    static PyMethodDef methods_NavigationViewItemHeader_Static[] = {
        { }
    };

    static PyType_Slot type_slots_NavigationViewItemHeader_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NavigationViewItemHeader_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NavigationViewItemHeader_Static) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItemHeader_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.NavigationViewItemHeader_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_NavigationViewItemHeader_Static
    };

    // ----- NavigationViewItemSeparator class --------------------

    static PyObject* _new_NavigationViewItemSeparator(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::NavigationViewItemSeparator instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NavigationViewItemSeparator(py::wrapper::Windows::UI::Xaml::Controls::NavigationViewItemSeparator* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_NavigationViewItemSeparator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::NavigationViewItemSeparator>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewItemSeparator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::NavigationViewItemSeparator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewItemSeparator[] = {
        { "_assign_array_", _assign_array_NavigationViewItemSeparator, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewItemSeparator), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NavigationViewItemSeparator[] = {
        { }
    };

    static PyType_Slot _type_slots_NavigationViewItemSeparator[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewItemSeparator) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewItemSeparator) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewItemSeparator) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewItemSeparator) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItemSeparator = {
        "winrt._winrt_windows_ui_xaml_controls_2.NavigationViewItemSeparator",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::NavigationViewItemSeparator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NavigationViewItemSeparator};

    static PyGetSetDef getset_NavigationViewItemSeparator_Static[] = {
        { }
    };

    static PyMethodDef methods_NavigationViewItemSeparator_Static[] = {
        { }
    };

    static PyType_Slot type_slots_NavigationViewItemSeparator_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NavigationViewItemSeparator_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NavigationViewItemSeparator_Static) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItemSeparator_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.NavigationViewItemSeparator_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_NavigationViewItemSeparator_Static
    };

    // ----- NavigationViewList class --------------------

    static PyObject* _new_NavigationViewList(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::NavigationViewList instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NavigationViewList(py::wrapper::Windows::UI::Xaml::Controls::NavigationViewList* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_NavigationViewList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::NavigationViewList>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::NavigationViewList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewList[] = {
        { "_assign_array_", _assign_array_NavigationViewList, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewList), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NavigationViewList[] = {
        { }
    };

    static PyType_Slot _type_slots_NavigationViewList[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewList) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewList) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewList) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewList) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewList = {
        "winrt._winrt_windows_ui_xaml_controls_2.NavigationViewList",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::NavigationViewList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NavigationViewList};

    static PyGetSetDef getset_NavigationViewList_Static[] = {
        { }
    };

    static PyMethodDef methods_NavigationViewList_Static[] = {
        { }
    };

    static PyType_Slot type_slots_NavigationViewList_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NavigationViewList_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NavigationViewList_Static) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewList_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.NavigationViewList_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_NavigationViewList_Static
    };

    // ----- ProgressBar class --------------------

    static PyObject* _new_ProgressBar(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::ProgressBar instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ProgressBar(py::wrapper::Windows::UI::Xaml::Controls::ProgressBar* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProgressBar_get_ShowPaused(py::wrapper::Windows::UI::Xaml::Controls::ProgressBar* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ProgressBar", L"ShowPaused");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ShowPaused());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProgressBar_put_ShowPaused(py::wrapper::Windows::UI::Xaml::Controls::ProgressBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ProgressBar", L"ShowPaused");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShowPaused(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProgressBar_get_ShowError(py::wrapper::Windows::UI::Xaml::Controls::ProgressBar* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ProgressBar", L"ShowError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ShowError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProgressBar_put_ShowError(py::wrapper::Windows::UI::Xaml::Controls::ProgressBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ProgressBar", L"ShowError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShowError(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProgressBar_get_IsIndeterminate(py::wrapper::Windows::UI::Xaml::Controls::ProgressBar* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ProgressBar", L"IsIndeterminate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsIndeterminate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProgressBar_put_IsIndeterminate(py::wrapper::Windows::UI::Xaml::Controls::ProgressBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ProgressBar", L"IsIndeterminate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsIndeterminate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProgressBar_get_TemplateSettings(py::wrapper::Windows::UI::Xaml::Controls::ProgressBar* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ProgressBar", L"TemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TemplateSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressBar_get_IsIndeterminateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ProgressBar", L"IsIndeterminateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ProgressBar::IsIndeterminateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressBar_get_ShowErrorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ProgressBar", L"ShowErrorProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ProgressBar::ShowErrorProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressBar_get_ShowPausedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ProgressBar", L"ShowPausedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ProgressBar::ShowPausedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProgressBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::ProgressBar>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProgressBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::ProgressBar>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProgressBar[] = {
        { "_assign_array_", _assign_array_ProgressBar, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProgressBar), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProgressBar[] = {
        { "show_paused", reinterpret_cast<getter>(ProgressBar_get_ShowPaused), reinterpret_cast<setter>(ProgressBar_put_ShowPaused), nullptr, nullptr },
        { "show_error", reinterpret_cast<getter>(ProgressBar_get_ShowError), reinterpret_cast<setter>(ProgressBar_put_ShowError), nullptr, nullptr },
        { "is_indeterminate", reinterpret_cast<getter>(ProgressBar_get_IsIndeterminate), reinterpret_cast<setter>(ProgressBar_put_IsIndeterminate), nullptr, nullptr },
        { "template_settings", reinterpret_cast<getter>(ProgressBar_get_TemplateSettings), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProgressBar[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProgressBar) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProgressBar) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProgressBar) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProgressBar) },
        { }
    };

    static PyType_Spec type_spec_ProgressBar = {
        "winrt._winrt_windows_ui_xaml_controls_2.ProgressBar",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::ProgressBar),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProgressBar};

    static PyGetSetDef getset_ProgressBar_Static[] = {
        { "is_indeterminate_property", reinterpret_cast<getter>(ProgressBar_get_IsIndeterminateProperty), nullptr, nullptr, nullptr },
        { "show_error_property", reinterpret_cast<getter>(ProgressBar_get_ShowErrorProperty), nullptr, nullptr, nullptr },
        { "show_paused_property", reinterpret_cast<getter>(ProgressBar_get_ShowPausedProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ProgressBar_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ProgressBar_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ProgressBar_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ProgressBar_Static) },
        { }
    };

    static PyType_Spec type_spec_ProgressBar_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.ProgressBar_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ProgressBar_Static
    };

    // ----- RadioButton class --------------------

    static PyObject* _new_RadioButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::RadioButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RadioButton(py::wrapper::Windows::UI::Xaml::Controls::RadioButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RadioButton_get_GroupName(py::wrapper::Windows::UI::Xaml::Controls::RadioButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.RadioButton", L"GroupName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.GroupName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadioButton_put_GroupName(py::wrapper::Windows::UI::Xaml::Controls::RadioButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.RadioButton", L"GroupName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.GroupName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RadioButton_get_GroupNameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.RadioButton", L"GroupNameProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::RadioButton::GroupNameProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RadioButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::RadioButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RadioButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::RadioButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadioButton[] = {
        { "_assign_array_", _assign_array_RadioButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RadioButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RadioButton[] = {
        { "group_name", reinterpret_cast<getter>(RadioButton_get_GroupName), reinterpret_cast<setter>(RadioButton_put_GroupName), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RadioButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RadioButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RadioButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RadioButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RadioButton) },
        { }
    };

    static PyType_Spec type_spec_RadioButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.RadioButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::RadioButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadioButton};

    static PyGetSetDef getset_RadioButton_Static[] = {
        { "group_name_property", reinterpret_cast<getter>(RadioButton_get_GroupNameProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_RadioButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RadioButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RadioButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RadioButton_Static) },
        { }
    };

    static PyType_Spec type_spec_RadioButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.RadioButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RadioButton_Static
    };

    // ----- Slider class --------------------

    static PyObject* _new_Slider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Slider instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Slider(py::wrapper::Windows::UI::Xaml::Controls::Slider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Slider_get_TickPlacement(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"TickPlacement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TickPlacement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_TickPlacement(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"TickPlacement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::TickPlacement>(arg);

            self->obj.TickPlacement(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_TickFrequency(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"TickFrequency");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TickFrequency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_TickFrequency(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"TickFrequency");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.TickFrequency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_ThumbToolTipValueConverter(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"ThumbToolTipValueConverter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ThumbToolTipValueConverter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_ThumbToolTipValueConverter(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"ThumbToolTipValueConverter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Data::IValueConverter>(arg);

            self->obj.ThumbToolTipValueConverter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_StepFrequency(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"StepFrequency");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StepFrequency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_StepFrequency(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"StepFrequency");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.StepFrequency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_SnapsTo(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"SnapsTo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SnapsTo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_SnapsTo(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"SnapsTo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::SliderSnapsTo>(arg);

            self->obj.SnapsTo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_Orientation(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_Orientation(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Orientation>(arg);

            self->obj.Orientation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_IsThumbToolTipEnabled(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"IsThumbToolTipEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsThumbToolTipEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_IsThumbToolTipEnabled(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"IsThumbToolTipEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsThumbToolTipEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_IsDirectionReversed(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"IsDirectionReversed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDirectionReversed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_IsDirectionReversed(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"IsDirectionReversed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDirectionReversed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_IntermediateValue(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"IntermediateValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IntermediateValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_IntermediateValue(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"IntermediateValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.IntermediateValue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_HeaderTemplate(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"HeaderTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HeaderTemplate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_HeaderTemplate(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"HeaderTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DataTemplate>(arg);

            self->obj.HeaderTemplate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_Header(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"Header");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Header());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_Header(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"Header");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.Header(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_IntermediateValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"IntermediateValueProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Slider::IntermediateValueProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_IsDirectionReversedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"IsDirectionReversedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Slider::IsDirectionReversedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_IsThumbToolTipEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"IsThumbToolTipEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Slider::IsThumbToolTipEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_OrientationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"OrientationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Slider::OrientationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_SnapsToProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"SnapsToProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Slider::SnapsToProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_StepFrequencyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"StepFrequencyProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Slider::StepFrequencyProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_ThumbToolTipValueConverterProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"ThumbToolTipValueConverterProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Slider::ThumbToolTipValueConverterProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_TickFrequencyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"TickFrequencyProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Slider::TickFrequencyProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_TickPlacementProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"TickPlacementProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Slider::TickPlacementProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_HeaderProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"HeaderProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Slider::HeaderProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_HeaderTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"HeaderTemplateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Slider::HeaderTemplateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Slider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Slider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Slider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Slider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Slider[] = {
        { "_assign_array_", _assign_array_Slider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Slider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Slider[] = {
        { "tick_placement", reinterpret_cast<getter>(Slider_get_TickPlacement), reinterpret_cast<setter>(Slider_put_TickPlacement), nullptr, nullptr },
        { "tick_frequency", reinterpret_cast<getter>(Slider_get_TickFrequency), reinterpret_cast<setter>(Slider_put_TickFrequency), nullptr, nullptr },
        { "thumb_tool_tip_value_converter", reinterpret_cast<getter>(Slider_get_ThumbToolTipValueConverter), reinterpret_cast<setter>(Slider_put_ThumbToolTipValueConverter), nullptr, nullptr },
        { "step_frequency", reinterpret_cast<getter>(Slider_get_StepFrequency), reinterpret_cast<setter>(Slider_put_StepFrequency), nullptr, nullptr },
        { "snaps_to", reinterpret_cast<getter>(Slider_get_SnapsTo), reinterpret_cast<setter>(Slider_put_SnapsTo), nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(Slider_get_Orientation), reinterpret_cast<setter>(Slider_put_Orientation), nullptr, nullptr },
        { "is_thumb_tool_tip_enabled", reinterpret_cast<getter>(Slider_get_IsThumbToolTipEnabled), reinterpret_cast<setter>(Slider_put_IsThumbToolTipEnabled), nullptr, nullptr },
        { "is_direction_reversed", reinterpret_cast<getter>(Slider_get_IsDirectionReversed), reinterpret_cast<setter>(Slider_put_IsDirectionReversed), nullptr, nullptr },
        { "intermediate_value", reinterpret_cast<getter>(Slider_get_IntermediateValue), reinterpret_cast<setter>(Slider_put_IntermediateValue), nullptr, nullptr },
        { "header_template", reinterpret_cast<getter>(Slider_get_HeaderTemplate), reinterpret_cast<setter>(Slider_put_HeaderTemplate), nullptr, nullptr },
        { "header", reinterpret_cast<getter>(Slider_get_Header), reinterpret_cast<setter>(Slider_put_Header), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Slider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Slider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Slider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Slider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Slider) },
        { }
    };

    static PyType_Spec type_spec_Slider = {
        "winrt._winrt_windows_ui_xaml_controls_2.Slider",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Slider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Slider};

    static PyGetSetDef getset_Slider_Static[] = {
        { "intermediate_value_property", reinterpret_cast<getter>(Slider_get_IntermediateValueProperty), nullptr, nullptr, nullptr },
        { "is_direction_reversed_property", reinterpret_cast<getter>(Slider_get_IsDirectionReversedProperty), nullptr, nullptr, nullptr },
        { "is_thumb_tool_tip_enabled_property", reinterpret_cast<getter>(Slider_get_IsThumbToolTipEnabledProperty), nullptr, nullptr, nullptr },
        { "orientation_property", reinterpret_cast<getter>(Slider_get_OrientationProperty), nullptr, nullptr, nullptr },
        { "snaps_to_property", reinterpret_cast<getter>(Slider_get_SnapsToProperty), nullptr, nullptr, nullptr },
        { "step_frequency_property", reinterpret_cast<getter>(Slider_get_StepFrequencyProperty), nullptr, nullptr, nullptr },
        { "thumb_tool_tip_value_converter_property", reinterpret_cast<getter>(Slider_get_ThumbToolTipValueConverterProperty), nullptr, nullptr, nullptr },
        { "tick_frequency_property", reinterpret_cast<getter>(Slider_get_TickFrequencyProperty), nullptr, nullptr, nullptr },
        { "tick_placement_property", reinterpret_cast<getter>(Slider_get_TickPlacementProperty), nullptr, nullptr, nullptr },
        { "header_property", reinterpret_cast<getter>(Slider_get_HeaderProperty), nullptr, nullptr, nullptr },
        { "header_template_property", reinterpret_cast<getter>(Slider_get_HeaderTemplateProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Slider_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Slider_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Slider_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Slider_Static) },
        { }
    };

    static PyType_Spec type_spec_Slider_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.Slider_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Slider_Static
    };

    // ----- TreeViewItem class --------------------

    static PyObject* _new_TreeViewItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::TreeViewItem instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TreeViewItem(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TreeViewItem_get_IsExpanded(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"IsExpanded");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsExpanded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_IsExpanded(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"IsExpanded");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsExpanded(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_GlyphSize(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"GlyphSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.GlyphSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_GlyphSize(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"GlyphSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.GlyphSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_GlyphOpacity(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"GlyphOpacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.GlyphOpacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_GlyphOpacity(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"GlyphOpacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.GlyphOpacity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_GlyphBrush(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"GlyphBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.GlyphBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_GlyphBrush(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"GlyphBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.GlyphBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_ExpandedGlyph(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"ExpandedGlyph");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpandedGlyph());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_ExpandedGlyph(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"ExpandedGlyph");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ExpandedGlyph(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_CollapsedGlyph(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"CollapsedGlyph");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CollapsedGlyph());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_CollapsedGlyph(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"CollapsedGlyph");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CollapsedGlyph(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_TreeViewItemTemplateSettings(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"TreeViewItemTemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TreeViewItemTemplateSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_ItemsSource(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"ItemsSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ItemsSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_ItemsSource(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"ItemsSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.ItemsSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_HasUnrealizedChildren(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"HasUnrealizedChildren");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HasUnrealizedChildren());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_HasUnrealizedChildren(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"HasUnrealizedChildren");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.HasUnrealizedChildren(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_CollapsedGlyphProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"CollapsedGlyphProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::TreeViewItem::CollapsedGlyphProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_ExpandedGlyphProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"ExpandedGlyphProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::TreeViewItem::ExpandedGlyphProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_GlyphBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"GlyphBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::TreeViewItem::GlyphBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_GlyphOpacityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"GlyphOpacityProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::TreeViewItem::GlyphOpacityProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_GlyphSizeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"GlyphSizeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::TreeViewItem::GlyphSizeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_IsExpandedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"IsExpandedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::TreeViewItem::IsExpandedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_TreeViewItemTemplateSettingsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"TreeViewItemTemplateSettingsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::TreeViewItem::TreeViewItemTemplateSettingsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_HasUnrealizedChildrenProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"HasUnrealizedChildrenProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::TreeViewItem::HasUnrealizedChildrenProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_ItemsSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"ItemsSourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::TreeViewItem::ItemsSourceProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TreeViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::TreeViewItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TreeViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::TreeViewItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TreeViewItem[] = {
        { "_assign_array_", _assign_array_TreeViewItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TreeViewItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TreeViewItem[] = {
        { "is_expanded", reinterpret_cast<getter>(TreeViewItem_get_IsExpanded), reinterpret_cast<setter>(TreeViewItem_put_IsExpanded), nullptr, nullptr },
        { "glyph_size", reinterpret_cast<getter>(TreeViewItem_get_GlyphSize), reinterpret_cast<setter>(TreeViewItem_put_GlyphSize), nullptr, nullptr },
        { "glyph_opacity", reinterpret_cast<getter>(TreeViewItem_get_GlyphOpacity), reinterpret_cast<setter>(TreeViewItem_put_GlyphOpacity), nullptr, nullptr },
        { "glyph_brush", reinterpret_cast<getter>(TreeViewItem_get_GlyphBrush), reinterpret_cast<setter>(TreeViewItem_put_GlyphBrush), nullptr, nullptr },
        { "expanded_glyph", reinterpret_cast<getter>(TreeViewItem_get_ExpandedGlyph), reinterpret_cast<setter>(TreeViewItem_put_ExpandedGlyph), nullptr, nullptr },
        { "collapsed_glyph", reinterpret_cast<getter>(TreeViewItem_get_CollapsedGlyph), reinterpret_cast<setter>(TreeViewItem_put_CollapsedGlyph), nullptr, nullptr },
        { "tree_view_item_template_settings", reinterpret_cast<getter>(TreeViewItem_get_TreeViewItemTemplateSettings), nullptr, nullptr, nullptr },
        { "items_source", reinterpret_cast<getter>(TreeViewItem_get_ItemsSource), reinterpret_cast<setter>(TreeViewItem_put_ItemsSource), nullptr, nullptr },
        { "has_unrealized_children", reinterpret_cast<getter>(TreeViewItem_get_HasUnrealizedChildren), reinterpret_cast<setter>(TreeViewItem_put_HasUnrealizedChildren), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TreeViewItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TreeViewItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TreeViewItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TreeViewItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TreeViewItem) },
        { }
    };

    static PyType_Spec type_spec_TreeViewItem = {
        "winrt._winrt_windows_ui_xaml_controls_2.TreeViewItem",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TreeViewItem};

    static PyGetSetDef getset_TreeViewItem_Static[] = {
        { "collapsed_glyph_property", reinterpret_cast<getter>(TreeViewItem_get_CollapsedGlyphProperty), nullptr, nullptr, nullptr },
        { "expanded_glyph_property", reinterpret_cast<getter>(TreeViewItem_get_ExpandedGlyphProperty), nullptr, nullptr, nullptr },
        { "glyph_brush_property", reinterpret_cast<getter>(TreeViewItem_get_GlyphBrushProperty), nullptr, nullptr, nullptr },
        { "glyph_opacity_property", reinterpret_cast<getter>(TreeViewItem_get_GlyphOpacityProperty), nullptr, nullptr, nullptr },
        { "glyph_size_property", reinterpret_cast<getter>(TreeViewItem_get_GlyphSizeProperty), nullptr, nullptr, nullptr },
        { "is_expanded_property", reinterpret_cast<getter>(TreeViewItem_get_IsExpandedProperty), nullptr, nullptr, nullptr },
        { "tree_view_item_template_settings_property", reinterpret_cast<getter>(TreeViewItem_get_TreeViewItemTemplateSettingsProperty), nullptr, nullptr, nullptr },
        { "has_unrealized_children_property", reinterpret_cast<getter>(TreeViewItem_get_HasUnrealizedChildrenProperty), nullptr, nullptr, nullptr },
        { "items_source_property", reinterpret_cast<getter>(TreeViewItem_get_ItemsSourceProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_TreeViewItem_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TreeViewItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TreeViewItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TreeViewItem_Static) },
        { }
    };

    static PyType_Spec type_spec_TreeViewItem_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.TreeViewItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TreeViewItem_Static
    };

    // ----- TreeViewList class --------------------

    static PyObject* _new_TreeViewList(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::TreeViewList instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TreeViewList(py::wrapper::Windows::UI::Xaml::Controls::TreeViewList* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TreeViewList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::TreeViewList>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TreeViewList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::TreeViewList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TreeViewList[] = {
        { "_assign_array_", _assign_array_TreeViewList, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TreeViewList), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TreeViewList[] = {
        { }
    };

    static PyType_Slot _type_slots_TreeViewList[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TreeViewList) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TreeViewList) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TreeViewList) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TreeViewList) },
        { }
    };

    static PyType_Spec type_spec_TreeViewList = {
        "winrt._winrt_windows_ui_xaml_controls_2.TreeViewList",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::TreeViewList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TreeViewList};

    static PyGetSetDef getset_TreeViewList_Static[] = {
        { }
    };

    static PyMethodDef methods_TreeViewList_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TreeViewList_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TreeViewList_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TreeViewList_Static) },
        { }
    };

    static PyType_Spec type_spec_TreeViewList_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.TreeViewList_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TreeViewList_Static
    };

    // ----- VirtualizingStackPanel class --------------------

    static PyObject* _new_VirtualizingStackPanel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::VirtualizingStackPanel instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VirtualizingStackPanel(py::wrapper::Windows::UI::Xaml::Controls::VirtualizingStackPanel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VirtualizingStackPanel_GetIsVirtualizing(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"GetIsVirtualizing", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::VirtualizingStackPanel::GetIsVirtualizing(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VirtualizingStackPanel_GetVirtualizationMode(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"GetVirtualizationMode", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::VirtualizingStackPanel::GetVirtualizationMode(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VirtualizingStackPanel_SetVirtualizationMode(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"SetVirtualizationMode", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::VirtualizationMode>(args, 1);

                winrt::Windows::UI::Xaml::Controls::VirtualizingStackPanel::SetVirtualizationMode(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VirtualizingStackPanel_get_Orientation(py::wrapper::Windows::UI::Xaml::Controls::VirtualizingStackPanel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VirtualizingStackPanel_put_Orientation(py::wrapper::Windows::UI::Xaml::Controls::VirtualizingStackPanel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Orientation>(arg);

            self->obj.Orientation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VirtualizingStackPanel_get_AreScrollSnapPointsRegular(py::wrapper::Windows::UI::Xaml::Controls::VirtualizingStackPanel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"AreScrollSnapPointsRegular");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AreScrollSnapPointsRegular());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VirtualizingStackPanel_put_AreScrollSnapPointsRegular(py::wrapper::Windows::UI::Xaml::Controls::VirtualizingStackPanel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"AreScrollSnapPointsRegular");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AreScrollSnapPointsRegular(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VirtualizingStackPanel_get_AreScrollSnapPointsRegularProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"AreScrollSnapPointsRegularProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::VirtualizingStackPanel::AreScrollSnapPointsRegularProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VirtualizingStackPanel_get_IsVirtualizingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"IsVirtualizingProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::VirtualizingStackPanel::IsVirtualizingProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VirtualizingStackPanel_get_OrientationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"OrientationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::VirtualizingStackPanel::OrientationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VirtualizingStackPanel_get_VirtualizationModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"VirtualizationModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::VirtualizingStackPanel::VirtualizationModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VirtualizingStackPanel_add_CleanUpVirtualizedItemEvent(py::wrapper::Windows::UI::Xaml::Controls::VirtualizingStackPanel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"CleanUpVirtualizedItemEvent");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::CleanUpVirtualizedItemEventHandler>(arg);

            return py::convert(self->obj.CleanUpVirtualizedItemEvent(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VirtualizingStackPanel_remove_CleanUpVirtualizedItemEvent(py::wrapper::Windows::UI::Xaml::Controls::VirtualizingStackPanel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"CleanUpVirtualizedItemEvent");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CleanUpVirtualizedItemEvent(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VirtualizingStackPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::VirtualizingStackPanel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VirtualizingStackPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::VirtualizingStackPanel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VirtualizingStackPanel[] = {
        { "add_clean_up_virtualized_item_event", reinterpret_cast<PyCFunction>(VirtualizingStackPanel_add_CleanUpVirtualizedItemEvent), METH_O, nullptr },
        { "remove_clean_up_virtualized_item_event", reinterpret_cast<PyCFunction>(VirtualizingStackPanel_remove_CleanUpVirtualizedItemEvent), METH_O, nullptr },
        { "_assign_array_", _assign_array_VirtualizingStackPanel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VirtualizingStackPanel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VirtualizingStackPanel[] = {
        { "orientation", reinterpret_cast<getter>(VirtualizingStackPanel_get_Orientation), reinterpret_cast<setter>(VirtualizingStackPanel_put_Orientation), nullptr, nullptr },
        { "are_scroll_snap_points_regular", reinterpret_cast<getter>(VirtualizingStackPanel_get_AreScrollSnapPointsRegular), reinterpret_cast<setter>(VirtualizingStackPanel_put_AreScrollSnapPointsRegular), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VirtualizingStackPanel[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VirtualizingStackPanel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VirtualizingStackPanel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VirtualizingStackPanel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VirtualizingStackPanel) },
        { }
    };

    static PyType_Spec type_spec_VirtualizingStackPanel = {
        "winrt._winrt_windows_ui_xaml_controls_2.VirtualizingStackPanel",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::VirtualizingStackPanel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VirtualizingStackPanel};

    static PyGetSetDef getset_VirtualizingStackPanel_Static[] = {
        { "are_scroll_snap_points_regular_property", reinterpret_cast<getter>(VirtualizingStackPanel_get_AreScrollSnapPointsRegularProperty), nullptr, nullptr, nullptr },
        { "is_virtualizing_property", reinterpret_cast<getter>(VirtualizingStackPanel_get_IsVirtualizingProperty), nullptr, nullptr, nullptr },
        { "orientation_property", reinterpret_cast<getter>(VirtualizingStackPanel_get_OrientationProperty), nullptr, nullptr, nullptr },
        { "virtualization_mode_property", reinterpret_cast<getter>(VirtualizingStackPanel_get_VirtualizationModeProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_VirtualizingStackPanel_Static[] = {
        { "get_is_virtualizing", reinterpret_cast<PyCFunction>(VirtualizingStackPanel_GetIsVirtualizing), METH_VARARGS, nullptr },
        { "get_virtualization_mode", reinterpret_cast<PyCFunction>(VirtualizingStackPanel_GetVirtualizationMode), METH_VARARGS, nullptr },
        { "set_virtualization_mode", reinterpret_cast<PyCFunction>(VirtualizingStackPanel_SetVirtualizationMode), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_VirtualizingStackPanel_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_VirtualizingStackPanel_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_VirtualizingStackPanel_Static) },
        { }
    };

    static PyType_Spec type_spec_VirtualizingStackPanel_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.VirtualizingStackPanel_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_VirtualizingStackPanel_Static
    };

    // ----- WrapGrid class --------------------

    static PyObject* _new_WrapGrid(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::WrapGrid instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WrapGrid(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WrapGrid_get_VerticalChildrenAlignment(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"VerticalChildrenAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticalChildrenAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WrapGrid_put_VerticalChildrenAlignment(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"VerticalChildrenAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::VerticalAlignment>(arg);

            self->obj.VerticalChildrenAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WrapGrid_get_Orientation(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WrapGrid_put_Orientation(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Orientation>(arg);

            self->obj.Orientation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WrapGrid_get_MaximumRowsOrColumns(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"MaximumRowsOrColumns");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaximumRowsOrColumns());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WrapGrid_put_MaximumRowsOrColumns(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"MaximumRowsOrColumns");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.MaximumRowsOrColumns(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WrapGrid_get_ItemWidth(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"ItemWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ItemWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WrapGrid_put_ItemWidth(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"ItemWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.ItemWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WrapGrid_get_ItemHeight(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"ItemHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ItemHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WrapGrid_put_ItemHeight(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"ItemHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.ItemHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WrapGrid_get_HorizontalChildrenAlignment(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"HorizontalChildrenAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontalChildrenAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WrapGrid_put_HorizontalChildrenAlignment(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"HorizontalChildrenAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::HorizontalAlignment>(arg);

            self->obj.HorizontalChildrenAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WrapGrid_get_HorizontalChildrenAlignmentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"HorizontalChildrenAlignmentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::WrapGrid::HorizontalChildrenAlignmentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WrapGrid_get_ItemHeightProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"ItemHeightProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::WrapGrid::ItemHeightProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WrapGrid_get_ItemWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"ItemWidthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::WrapGrid::ItemWidthProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WrapGrid_get_MaximumRowsOrColumnsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"MaximumRowsOrColumnsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::WrapGrid::MaximumRowsOrColumnsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WrapGrid_get_OrientationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"OrientationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::WrapGrid::OrientationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WrapGrid_get_VerticalChildrenAlignmentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"VerticalChildrenAlignmentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::WrapGrid::VerticalChildrenAlignmentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WrapGrid(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::WrapGrid>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WrapGrid(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::WrapGrid>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WrapGrid[] = {
        { "_assign_array_", _assign_array_WrapGrid, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WrapGrid), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WrapGrid[] = {
        { "vertical_children_alignment", reinterpret_cast<getter>(WrapGrid_get_VerticalChildrenAlignment), reinterpret_cast<setter>(WrapGrid_put_VerticalChildrenAlignment), nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(WrapGrid_get_Orientation), reinterpret_cast<setter>(WrapGrid_put_Orientation), nullptr, nullptr },
        { "maximum_rows_or_columns", reinterpret_cast<getter>(WrapGrid_get_MaximumRowsOrColumns), reinterpret_cast<setter>(WrapGrid_put_MaximumRowsOrColumns), nullptr, nullptr },
        { "item_width", reinterpret_cast<getter>(WrapGrid_get_ItemWidth), reinterpret_cast<setter>(WrapGrid_put_ItemWidth), nullptr, nullptr },
        { "item_height", reinterpret_cast<getter>(WrapGrid_get_ItemHeight), reinterpret_cast<setter>(WrapGrid_put_ItemHeight), nullptr, nullptr },
        { "horizontal_children_alignment", reinterpret_cast<getter>(WrapGrid_get_HorizontalChildrenAlignment), reinterpret_cast<setter>(WrapGrid_put_HorizontalChildrenAlignment), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WrapGrid[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WrapGrid) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WrapGrid) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WrapGrid) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WrapGrid) },
        { }
    };

    static PyType_Spec type_spec_WrapGrid = {
        "winrt._winrt_windows_ui_xaml_controls_2.WrapGrid",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WrapGrid};

    static PyGetSetDef getset_WrapGrid_Static[] = {
        { "horizontal_children_alignment_property", reinterpret_cast<getter>(WrapGrid_get_HorizontalChildrenAlignmentProperty), nullptr, nullptr, nullptr },
        { "item_height_property", reinterpret_cast<getter>(WrapGrid_get_ItemHeightProperty), nullptr, nullptr, nullptr },
        { "item_width_property", reinterpret_cast<getter>(WrapGrid_get_ItemWidthProperty), nullptr, nullptr, nullptr },
        { "maximum_rows_or_columns_property", reinterpret_cast<getter>(WrapGrid_get_MaximumRowsOrColumnsProperty), nullptr, nullptr, nullptr },
        { "orientation_property", reinterpret_cast<getter>(WrapGrid_get_OrientationProperty), nullptr, nullptr, nullptr },
        { "vertical_children_alignment_property", reinterpret_cast<getter>(WrapGrid_get_VerticalChildrenAlignmentProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_WrapGrid_Static[] = {
        { }
    };

    static PyType_Slot type_slots_WrapGrid_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_WrapGrid_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_WrapGrid_Static) },
        { }
    };

    static PyType_Spec type_spec_WrapGrid_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.WrapGrid_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_WrapGrid_Static
    };

    // ----- Windows.UI.Xaml.Controls Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.UI.Xaml.Controls");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_ui_xaml_controls_2",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::UI::Xaml::Controls

PyMODINIT_FUNC PyInit__winrt_windows_ui_xaml_controls_2(void) noexcept
{
    using namespace py::cpp::Windows::UI::Xaml::Controls;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppBarButton_Static{PyType_FromSpec(&type_spec_AppBarButton_Static)};
    if (!type_AppBarButton_Static)
    {
        return nullptr;
    }

    py::pytype_handle AppBarButton_type{py::register_python_type(module.get(), &type_spec_AppBarButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppBarButton_Static.get()))};
    if (!AppBarButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppBarToggleButton_Static{PyType_FromSpec(&type_spec_AppBarToggleButton_Static)};
    if (!type_AppBarToggleButton_Static)
    {
        return nullptr;
    }

    py::pytype_handle AppBarToggleButton_type{py::register_python_type(module.get(), &type_spec_AppBarToggleButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppBarToggleButton_Static.get()))};
    if (!AppBarToggleButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_Button_Static{PyType_FromSpec(&type_spec_Button_Static)};
    if (!type_Button_Static)
    {
        return nullptr;
    }

    py::pytype_handle Button_type{py::register_python_type(module.get(), &type_spec_Button, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Button_Static.get()))};
    if (!Button_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_CheckBox_Static{PyType_FromSpec(&type_spec_CheckBox_Static)};
    if (!type_CheckBox_Static)
    {
        return nullptr;
    }

    py::pytype_handle CheckBox_type{py::register_python_type(module.get(), &type_spec_CheckBox, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CheckBox_Static.get()))};
    if (!CheckBox_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ComboBox_Static{PyType_FromSpec(&type_spec_ComboBox_Static)};
    if (!type_ComboBox_Static)
    {
        return nullptr;
    }

    py::pytype_handle ComboBox_type{py::register_python_type(module.get(), &type_spec_ComboBox, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ComboBox_Static.get()))};
    if (!ComboBox_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ComboBoxItem_Static{PyType_FromSpec(&type_spec_ComboBoxItem_Static)};
    if (!type_ComboBoxItem_Static)
    {
        return nullptr;
    }

    py::pytype_handle ComboBoxItem_type{py::register_python_type(module.get(), &type_spec_ComboBoxItem, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ComboBoxItem_Static.get()))};
    if (!ComboBoxItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_DropDownButton_Static{PyType_FromSpec(&type_spec_DropDownButton_Static)};
    if (!type_DropDownButton_Static)
    {
        return nullptr;
    }

    py::pytype_handle DropDownButton_type{py::register_python_type(module.get(), &type_spec_DropDownButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DropDownButton_Static.get()))};
    if (!DropDownButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_FlipView_Static{PyType_FromSpec(&type_spec_FlipView_Static)};
    if (!type_FlipView_Static)
    {
        return nullptr;
    }

    py::pytype_handle FlipView_type{py::register_python_type(module.get(), &type_spec_FlipView, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FlipView_Static.get()))};
    if (!FlipView_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_FlipViewItem_Static{PyType_FromSpec(&type_spec_FlipViewItem_Static)};
    if (!type_FlipViewItem_Static)
    {
        return nullptr;
    }

    py::pytype_handle FlipViewItem_type{py::register_python_type(module.get(), &type_spec_FlipViewItem, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FlipViewItem_Static.get()))};
    if (!FlipViewItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_GridView_Static{PyType_FromSpec(&type_spec_GridView_Static)};
    if (!type_GridView_Static)
    {
        return nullptr;
    }

    py::pytype_handle GridView_type{py::register_python_type(module.get(), &type_spec_GridView, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GridView_Static.get()))};
    if (!GridView_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_GridViewItem_Static{PyType_FromSpec(&type_spec_GridViewItem_Static)};
    if (!type_GridViewItem_Static)
    {
        return nullptr;
    }

    py::pytype_handle GridViewItem_type{py::register_python_type(module.get(), &type_spec_GridViewItem, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GridViewItem_Static.get()))};
    if (!GridViewItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_HyperlinkButton_Static{PyType_FromSpec(&type_spec_HyperlinkButton_Static)};
    if (!type_HyperlinkButton_Static)
    {
        return nullptr;
    }

    py::pytype_handle HyperlinkButton_type{py::register_python_type(module.get(), &type_spec_HyperlinkButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HyperlinkButton_Static.get()))};
    if (!HyperlinkButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarBallpointPenButton_Static{PyType_FromSpec(&type_spec_InkToolbarBallpointPenButton_Static)};
    if (!type_InkToolbarBallpointPenButton_Static)
    {
        return nullptr;
    }

    py::pytype_handle InkToolbarBallpointPenButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarBallpointPenButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarBallpointPenButton_Static.get()))};
    if (!InkToolbarBallpointPenButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarCustomPenButton_Static{PyType_FromSpec(&type_spec_InkToolbarCustomPenButton_Static)};
    if (!type_InkToolbarCustomPenButton_Static)
    {
        return nullptr;
    }

    py::pytype_handle InkToolbarCustomPenButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarCustomPenButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarCustomPenButton_Static.get()))};
    if (!InkToolbarCustomPenButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarCustomToggleButton_Static{PyType_FromSpec(&type_spec_InkToolbarCustomToggleButton_Static)};
    if (!type_InkToolbarCustomToggleButton_Static)
    {
        return nullptr;
    }

    py::pytype_handle InkToolbarCustomToggleButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarCustomToggleButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarCustomToggleButton_Static.get()))};
    if (!InkToolbarCustomToggleButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarCustomToolButton_Static{PyType_FromSpec(&type_spec_InkToolbarCustomToolButton_Static)};
    if (!type_InkToolbarCustomToolButton_Static)
    {
        return nullptr;
    }

    py::pytype_handle InkToolbarCustomToolButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarCustomToolButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarCustomToolButton_Static.get()))};
    if (!InkToolbarCustomToolButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarEraserButton_Static{PyType_FromSpec(&type_spec_InkToolbarEraserButton_Static)};
    if (!type_InkToolbarEraserButton_Static)
    {
        return nullptr;
    }

    py::pytype_handle InkToolbarEraserButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarEraserButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarEraserButton_Static.get()))};
    if (!InkToolbarEraserButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarFlyoutItem_Static{PyType_FromSpec(&type_spec_InkToolbarFlyoutItem_Static)};
    if (!type_InkToolbarFlyoutItem_Static)
    {
        return nullptr;
    }

    py::pytype_handle InkToolbarFlyoutItem_type{py::register_python_type(module.get(), &type_spec_InkToolbarFlyoutItem, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarFlyoutItem_Static.get()))};
    if (!InkToolbarFlyoutItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarHighlighterButton_Static{PyType_FromSpec(&type_spec_InkToolbarHighlighterButton_Static)};
    if (!type_InkToolbarHighlighterButton_Static)
    {
        return nullptr;
    }

    py::pytype_handle InkToolbarHighlighterButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarHighlighterButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarHighlighterButton_Static.get()))};
    if (!InkToolbarHighlighterButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarMenuButton_Static{PyType_FromSpec(&type_spec_InkToolbarMenuButton_Static)};
    if (!type_InkToolbarMenuButton_Static)
    {
        return nullptr;
    }

    py::pytype_handle InkToolbarMenuButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarMenuButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarMenuButton_Static.get()))};
    if (!InkToolbarMenuButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarPenButton_Static{PyType_FromSpec(&type_spec_InkToolbarPenButton_Static)};
    if (!type_InkToolbarPenButton_Static)
    {
        return nullptr;
    }

    py::pytype_handle InkToolbarPenButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarPenButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarPenButton_Static.get()))};
    if (!InkToolbarPenButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarPencilButton_Static{PyType_FromSpec(&type_spec_InkToolbarPencilButton_Static)};
    if (!type_InkToolbarPencilButton_Static)
    {
        return nullptr;
    }

    py::pytype_handle InkToolbarPencilButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarPencilButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarPencilButton_Static.get()))};
    if (!InkToolbarPencilButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarRulerButton_Static{PyType_FromSpec(&type_spec_InkToolbarRulerButton_Static)};
    if (!type_InkToolbarRulerButton_Static)
    {
        return nullptr;
    }

    py::pytype_handle InkToolbarRulerButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarRulerButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarRulerButton_Static.get()))};
    if (!InkToolbarRulerButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarStencilButton_Static{PyType_FromSpec(&type_spec_InkToolbarStencilButton_Static)};
    if (!type_InkToolbarStencilButton_Static)
    {
        return nullptr;
    }

    py::pytype_handle InkToolbarStencilButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarStencilButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarStencilButton_Static.get()))};
    if (!InkToolbarStencilButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarToggleButton_Static{PyType_FromSpec(&type_spec_InkToolbarToggleButton_Static)};
    if (!type_InkToolbarToggleButton_Static)
    {
        return nullptr;
    }

    py::pytype_handle InkToolbarToggleButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarToggleButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarToggleButton_Static.get()))};
    if (!InkToolbarToggleButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarToolButton_Static{PyType_FromSpec(&type_spec_InkToolbarToolButton_Static)};
    if (!type_InkToolbarToolButton_Static)
    {
        return nullptr;
    }

    py::pytype_handle InkToolbarToolButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarToolButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarToolButton_Static.get()))};
    if (!InkToolbarToolButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListBox_Static{PyType_FromSpec(&type_spec_ListBox_Static)};
    if (!type_ListBox_Static)
    {
        return nullptr;
    }

    py::pytype_handle ListBox_type{py::register_python_type(module.get(), &type_spec_ListBox, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListBox_Static.get()))};
    if (!ListBox_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListBoxItem_Static{PyType_FromSpec(&type_spec_ListBoxItem_Static)};
    if (!type_ListBoxItem_Static)
    {
        return nullptr;
    }

    py::pytype_handle ListBoxItem_type{py::register_python_type(module.get(), &type_spec_ListBoxItem, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListBoxItem_Static.get()))};
    if (!ListBoxItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListView_Static{PyType_FromSpec(&type_spec_ListView_Static)};
    if (!type_ListView_Static)
    {
        return nullptr;
    }

    py::pytype_handle ListView_type{py::register_python_type(module.get(), &type_spec_ListView, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListView_Static.get()))};
    if (!ListView_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListViewBase_Static{PyType_FromSpec(&type_spec_ListViewBase_Static)};
    if (!type_ListViewBase_Static)
    {
        return nullptr;
    }

    py::pytype_handle ListViewBase_type{py::register_python_type(module.get(), &type_spec_ListViewBase, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListViewBase_Static.get()))};
    if (!ListViewBase_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListViewItem_Static{PyType_FromSpec(&type_spec_ListViewItem_Static)};
    if (!type_ListViewItem_Static)
    {
        return nullptr;
    }

    py::pytype_handle ListViewItem_type{py::register_python_type(module.get(), &type_spec_ListViewItem, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListViewItem_Static.get()))};
    if (!ListViewItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_NavigationViewItem_Static{PyType_FromSpec(&type_spec_NavigationViewItem_Static)};
    if (!type_NavigationViewItem_Static)
    {
        return nullptr;
    }

    py::pytype_handle NavigationViewItem_type{py::register_python_type(module.get(), &type_spec_NavigationViewItem, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_NavigationViewItem_Static.get()))};
    if (!NavigationViewItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_NavigationViewItemBase_Static{PyType_FromSpec(&type_spec_NavigationViewItemBase_Static)};
    if (!type_NavigationViewItemBase_Static)
    {
        return nullptr;
    }

    py::pytype_handle NavigationViewItemBase_type{py::register_python_type(module.get(), &type_spec_NavigationViewItemBase, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_NavigationViewItemBase_Static.get()))};
    if (!NavigationViewItemBase_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_NavigationViewItemHeader_Static{PyType_FromSpec(&type_spec_NavigationViewItemHeader_Static)};
    if (!type_NavigationViewItemHeader_Static)
    {
        return nullptr;
    }

    py::pytype_handle NavigationViewItemHeader_type{py::register_python_type(module.get(), &type_spec_NavigationViewItemHeader, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_NavigationViewItemHeader_Static.get()))};
    if (!NavigationViewItemHeader_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_NavigationViewItemSeparator_Static{PyType_FromSpec(&type_spec_NavigationViewItemSeparator_Static)};
    if (!type_NavigationViewItemSeparator_Static)
    {
        return nullptr;
    }

    py::pytype_handle NavigationViewItemSeparator_type{py::register_python_type(module.get(), &type_spec_NavigationViewItemSeparator, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_NavigationViewItemSeparator_Static.get()))};
    if (!NavigationViewItemSeparator_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_NavigationViewList_Static{PyType_FromSpec(&type_spec_NavigationViewList_Static)};
    if (!type_NavigationViewList_Static)
    {
        return nullptr;
    }

    py::pytype_handle NavigationViewList_type{py::register_python_type(module.get(), &type_spec_NavigationViewList, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_NavigationViewList_Static.get()))};
    if (!NavigationViewList_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ProgressBar_Static{PyType_FromSpec(&type_spec_ProgressBar_Static)};
    if (!type_ProgressBar_Static)
    {
        return nullptr;
    }

    py::pytype_handle ProgressBar_type{py::register_python_type(module.get(), &type_spec_ProgressBar, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ProgressBar_Static.get()))};
    if (!ProgressBar_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_RadioButton_Static{PyType_FromSpec(&type_spec_RadioButton_Static)};
    if (!type_RadioButton_Static)
    {
        return nullptr;
    }

    py::pytype_handle RadioButton_type{py::register_python_type(module.get(), &type_spec_RadioButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RadioButton_Static.get()))};
    if (!RadioButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_Slider_Static{PyType_FromSpec(&type_spec_Slider_Static)};
    if (!type_Slider_Static)
    {
        return nullptr;
    }

    py::pytype_handle Slider_type{py::register_python_type(module.get(), &type_spec_Slider, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Slider_Static.get()))};
    if (!Slider_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_TreeViewItem_Static{PyType_FromSpec(&type_spec_TreeViewItem_Static)};
    if (!type_TreeViewItem_Static)
    {
        return nullptr;
    }

    py::pytype_handle TreeViewItem_type{py::register_python_type(module.get(), &type_spec_TreeViewItem, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TreeViewItem_Static.get()))};
    if (!TreeViewItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_TreeViewList_Static{PyType_FromSpec(&type_spec_TreeViewList_Static)};
    if (!type_TreeViewList_Static)
    {
        return nullptr;
    }

    py::pytype_handle TreeViewList_type{py::register_python_type(module.get(), &type_spec_TreeViewList, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TreeViewList_Static.get()))};
    if (!TreeViewList_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_VirtualizingStackPanel_Static{PyType_FromSpec(&type_spec_VirtualizingStackPanel_Static)};
    if (!type_VirtualizingStackPanel_Static)
    {
        return nullptr;
    }

    py::pytype_handle VirtualizingStackPanel_type{py::register_python_type(module.get(), &type_spec_VirtualizingStackPanel, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_VirtualizingStackPanel_Static.get()))};
    if (!VirtualizingStackPanel_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_WrapGrid_Static{PyType_FromSpec(&type_spec_WrapGrid_Static)};
    if (!type_WrapGrid_Static)
    {
        return nullptr;
    }

    py::pytype_handle WrapGrid_type{py::register_python_type(module.get(), &type_spec_WrapGrid, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_WrapGrid_Static.get()))};
    if (!WrapGrid_type)
    {
        return nullptr;
    }


    return module.detach();
}
