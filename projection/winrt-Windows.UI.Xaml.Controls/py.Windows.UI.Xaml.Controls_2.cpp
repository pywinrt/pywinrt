// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.UI.Xaml.Controls.h"

namespace py::cpp::Windows::UI::Xaml::Controls
{
    // ----- AppBarButton class --------------------

    struct PyWinrtAppBarButton;
    using BasePyWinrtAppBarButton = winrt::Windows::UI::Xaml::Controls::AppBarButtonT<PyWinrtAppBarButton, py::IPywinrtObject>;

    struct PyWinrtAppBarButton : py::py_obj_ref, BasePyWinrtAppBarButton
    {
        PyWinrtAppBarButton(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtAppBarButton() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtAppBarButton* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_AppBarButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::AppBarButton>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtAppBarButton>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::AppBarButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppBarButton(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBarButton_get_Label(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::AppBarButton>().Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarButton_put_Label(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::AppBarButton>().Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarButton_get_Icon(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"Icon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::AppBarButton>().Icon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarButton_put_Icon(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"Icon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::IconElement>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::AppBarButton>().Icon(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarButton_get_LabelPosition(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"LabelPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::AppBarButton>().LabelPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarButton_put_LabelPosition(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"LabelPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::CommandBarLabelPosition>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::AppBarButton>().LabelPosition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarButton_get_KeyboardAcceleratorTextOverride(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"KeyboardAcceleratorTextOverride");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::AppBarButton>().KeyboardAcceleratorTextOverride());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarButton_put_KeyboardAcceleratorTextOverride(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"KeyboardAcceleratorTextOverride");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::AppBarButton>().KeyboardAcceleratorTextOverride(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarButton_get_TemplateSettings(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"TemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::AppBarButton>().TemplateSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarButton_get_IsCompact(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"IsCompact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::AppBarButton>().IsCompact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarButton_put_IsCompact(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"IsCompact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::AppBarButton>().IsCompact(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarButton_get_DynamicOverflowOrder(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"DynamicOverflowOrder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::AppBarButton>().DynamicOverflowOrder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarButton_put_DynamicOverflowOrder(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"DynamicOverflowOrder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::AppBarButton>().DynamicOverflowOrder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarButton_get_IsInOverflow(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"IsInOverflow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::AppBarButton>().IsInOverflow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarButton_get_IconProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"IconProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarButton::IconProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarButton_get_IsCompactProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"IsCompactProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarButton::IsCompactProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarButton_get_LabelProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"LabelProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarButton::LabelProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarButton_get_DynamicOverflowOrderProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"DynamicOverflowOrderProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarButton::DynamicOverflowOrderProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarButton_get_IsInOverflowProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"IsInOverflowProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarButton::IsInOverflowProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarButton_get_LabelPositionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"LabelPositionProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarButton::LabelPositionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarButton_get_KeyboardAcceleratorTextOverrideProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"KeyboardAcceleratorTextOverrideProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarButton::KeyboardAcceleratorTextOverrideProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBarButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::AppBarButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBarButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::AppBarButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBarButton[] = {
        { "_assign_array_", _assign_array_AppBarButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBarButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBarButton[] = {
        { "label", reinterpret_cast<getter>(AppBarButton_get_Label), reinterpret_cast<setter>(AppBarButton_put_Label), nullptr, nullptr },
        { "icon", reinterpret_cast<getter>(AppBarButton_get_Icon), reinterpret_cast<setter>(AppBarButton_put_Icon), nullptr, nullptr },
        { "label_position", reinterpret_cast<getter>(AppBarButton_get_LabelPosition), reinterpret_cast<setter>(AppBarButton_put_LabelPosition), nullptr, nullptr },
        { "keyboard_accelerator_text_override", reinterpret_cast<getter>(AppBarButton_get_KeyboardAcceleratorTextOverride), reinterpret_cast<setter>(AppBarButton_put_KeyboardAcceleratorTextOverride), nullptr, nullptr },
        { "template_settings", reinterpret_cast<getter>(AppBarButton_get_TemplateSettings), nullptr, nullptr, nullptr },
        { "is_compact", reinterpret_cast<getter>(AppBarButton_get_IsCompact), reinterpret_cast<setter>(AppBarButton_put_IsCompact), nullptr, nullptr },
        { "dynamic_overflow_order", reinterpret_cast<getter>(AppBarButton_get_DynamicOverflowOrder), reinterpret_cast<setter>(AppBarButton_put_DynamicOverflowOrder), nullptr, nullptr },
        { "is_in_overflow", reinterpret_cast<getter>(AppBarButton_get_IsInOverflow), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBarButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBarButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBarButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBarButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBarButton) },
        { }
    };

    static PyType_Spec type_spec_AppBarButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.AppBarButton",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_AppBarButton};

    static PyGetSetDef getset_AppBarButton_Static[] = {
        { "icon_property", reinterpret_cast<getter>(AppBarButton_get_IconProperty), nullptr, nullptr, nullptr },
        { "is_compact_property", reinterpret_cast<getter>(AppBarButton_get_IsCompactProperty), nullptr, nullptr, nullptr },
        { "label_property", reinterpret_cast<getter>(AppBarButton_get_LabelProperty), nullptr, nullptr, nullptr },
        { "dynamic_overflow_order_property", reinterpret_cast<getter>(AppBarButton_get_DynamicOverflowOrderProperty), nullptr, nullptr, nullptr },
        { "is_in_overflow_property", reinterpret_cast<getter>(AppBarButton_get_IsInOverflowProperty), nullptr, nullptr, nullptr },
        { "label_position_property", reinterpret_cast<getter>(AppBarButton_get_LabelPositionProperty), nullptr, nullptr, nullptr },
        { "keyboard_accelerator_text_override_property", reinterpret_cast<getter>(AppBarButton_get_KeyboardAcceleratorTextOverrideProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_AppBarButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_AppBarButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppBarButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppBarButton_Static) },
        { }
    };

    static PyType_Spec type_spec_AppBarButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.AppBarButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_AppBarButton_Static
    };

    // ----- AppBarToggleButton class --------------------

    struct PyWinrtAppBarToggleButton;
    using BasePyWinrtAppBarToggleButton = winrt::Windows::UI::Xaml::Controls::AppBarToggleButtonT<PyWinrtAppBarToggleButton, py::IPywinrtObject>;

    struct PyWinrtAppBarToggleButton : py::py_obj_ref, BasePyWinrtAppBarToggleButton
    {
        PyWinrtAppBarToggleButton(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtAppBarToggleButton() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtAppBarToggleButton* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_AppBarToggleButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::AppBarToggleButton>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtAppBarToggleButton>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::AppBarToggleButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppBarToggleButton(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBarToggleButton_get_Label(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::AppBarToggleButton>().Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarToggleButton_put_Label(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::AppBarToggleButton>().Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarToggleButton_get_Icon(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"Icon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::AppBarToggleButton>().Icon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarToggleButton_put_Icon(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"Icon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::IconElement>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::AppBarToggleButton>().Icon(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarToggleButton_get_LabelPosition(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"LabelPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::AppBarToggleButton>().LabelPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarToggleButton_put_LabelPosition(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"LabelPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::CommandBarLabelPosition>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::AppBarToggleButton>().LabelPosition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarToggleButton_get_KeyboardAcceleratorTextOverride(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"KeyboardAcceleratorTextOverride");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::AppBarToggleButton>().KeyboardAcceleratorTextOverride());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarToggleButton_put_KeyboardAcceleratorTextOverride(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"KeyboardAcceleratorTextOverride");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::AppBarToggleButton>().KeyboardAcceleratorTextOverride(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarToggleButton_get_TemplateSettings(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"TemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::AppBarToggleButton>().TemplateSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarToggleButton_get_IsCompact(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"IsCompact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::AppBarToggleButton>().IsCompact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarToggleButton_put_IsCompact(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"IsCompact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::AppBarToggleButton>().IsCompact(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarToggleButton_get_DynamicOverflowOrder(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"DynamicOverflowOrder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::AppBarToggleButton>().DynamicOverflowOrder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarToggleButton_put_DynamicOverflowOrder(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"DynamicOverflowOrder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::AppBarToggleButton>().DynamicOverflowOrder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarToggleButton_get_IsInOverflow(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"IsInOverflow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::AppBarToggleButton>().IsInOverflow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarToggleButton_get_IconProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"IconProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarToggleButton::IconProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarToggleButton_get_IsCompactProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"IsCompactProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarToggleButton::IsCompactProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarToggleButton_get_LabelProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"LabelProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarToggleButton::LabelProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarToggleButton_get_DynamicOverflowOrderProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"DynamicOverflowOrderProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarToggleButton::DynamicOverflowOrderProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarToggleButton_get_IsInOverflowProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"IsInOverflowProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarToggleButton::IsInOverflowProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarToggleButton_get_LabelPositionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"LabelPositionProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarToggleButton::LabelPositionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarToggleButton_get_KeyboardAcceleratorTextOverrideProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"KeyboardAcceleratorTextOverrideProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarToggleButton::KeyboardAcceleratorTextOverrideProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBarToggleButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::AppBarToggleButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBarToggleButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::AppBarToggleButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBarToggleButton[] = {
        { "_assign_array_", _assign_array_AppBarToggleButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBarToggleButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBarToggleButton[] = {
        { "label", reinterpret_cast<getter>(AppBarToggleButton_get_Label), reinterpret_cast<setter>(AppBarToggleButton_put_Label), nullptr, nullptr },
        { "icon", reinterpret_cast<getter>(AppBarToggleButton_get_Icon), reinterpret_cast<setter>(AppBarToggleButton_put_Icon), nullptr, nullptr },
        { "label_position", reinterpret_cast<getter>(AppBarToggleButton_get_LabelPosition), reinterpret_cast<setter>(AppBarToggleButton_put_LabelPosition), nullptr, nullptr },
        { "keyboard_accelerator_text_override", reinterpret_cast<getter>(AppBarToggleButton_get_KeyboardAcceleratorTextOverride), reinterpret_cast<setter>(AppBarToggleButton_put_KeyboardAcceleratorTextOverride), nullptr, nullptr },
        { "template_settings", reinterpret_cast<getter>(AppBarToggleButton_get_TemplateSettings), nullptr, nullptr, nullptr },
        { "is_compact", reinterpret_cast<getter>(AppBarToggleButton_get_IsCompact), reinterpret_cast<setter>(AppBarToggleButton_put_IsCompact), nullptr, nullptr },
        { "dynamic_overflow_order", reinterpret_cast<getter>(AppBarToggleButton_get_DynamicOverflowOrder), reinterpret_cast<setter>(AppBarToggleButton_put_DynamicOverflowOrder), nullptr, nullptr },
        { "is_in_overflow", reinterpret_cast<getter>(AppBarToggleButton_get_IsInOverflow), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBarToggleButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBarToggleButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBarToggleButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBarToggleButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBarToggleButton) },
        { }
    };

    static PyType_Spec type_spec_AppBarToggleButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.AppBarToggleButton",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_AppBarToggleButton};

    static PyGetSetDef getset_AppBarToggleButton_Static[] = {
        { "icon_property", reinterpret_cast<getter>(AppBarToggleButton_get_IconProperty), nullptr, nullptr, nullptr },
        { "is_compact_property", reinterpret_cast<getter>(AppBarToggleButton_get_IsCompactProperty), nullptr, nullptr, nullptr },
        { "label_property", reinterpret_cast<getter>(AppBarToggleButton_get_LabelProperty), nullptr, nullptr, nullptr },
        { "dynamic_overflow_order_property", reinterpret_cast<getter>(AppBarToggleButton_get_DynamicOverflowOrderProperty), nullptr, nullptr, nullptr },
        { "is_in_overflow_property", reinterpret_cast<getter>(AppBarToggleButton_get_IsInOverflowProperty), nullptr, nullptr, nullptr },
        { "label_position_property", reinterpret_cast<getter>(AppBarToggleButton_get_LabelPositionProperty), nullptr, nullptr, nullptr },
        { "keyboard_accelerator_text_override_property", reinterpret_cast<getter>(AppBarToggleButton_get_KeyboardAcceleratorTextOverrideProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_AppBarToggleButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_AppBarToggleButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppBarToggleButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppBarToggleButton_Static) },
        { }
    };

    static PyType_Spec type_spec_AppBarToggleButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.AppBarToggleButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_AppBarToggleButton_Static
    };

    // ----- Button class --------------------

    struct PyWinrtButton;
    using BasePyWinrtButton = winrt::Windows::UI::Xaml::Controls::ButtonT<PyWinrtButton, py::IPywinrtObject>;

    struct PyWinrtButton : py::py_obj_ref, BasePyWinrtButton
    {
        PyWinrtButton(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtButton() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtButton* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_Button(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::Button>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtButton>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::Button instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Button(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Button_get_Flyout(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Button", L"Flyout");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Button>().Flyout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Button_put_Flyout(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Button", L"Flyout");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Button>().Flyout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Button_get_FlyoutProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Button", L"FlyoutProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Button::FlyoutProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Button(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Button>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Button(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Button>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Button[] = {
        { "_assign_array_", _assign_array_Button, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Button), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Button[] = {
        { "flyout", reinterpret_cast<getter>(Button_get_Flyout), reinterpret_cast<setter>(Button_put_Flyout), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Button[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Button) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Button) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Button) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Button) },
        { }
    };

    static PyType_Spec type_spec_Button = {
        "winrt._winrt_windows_ui_xaml_controls_2.Button",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_Button};

    static PyGetSetDef getset_Button_Static[] = {
        { "flyout_property", reinterpret_cast<getter>(Button_get_FlyoutProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Button_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Button_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Button_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Button_Static) },
        { }
    };

    static PyType_Spec type_spec_Button_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.Button_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_Button_Static
    };

    // ----- CheckBox class --------------------

    struct PyWinrtCheckBox;
    using BasePyWinrtCheckBox = winrt::Windows::UI::Xaml::Controls::CheckBoxT<PyWinrtCheckBox, py::IPywinrtObject>;

    struct PyWinrtCheckBox : py::py_obj_ref, BasePyWinrtCheckBox
    {
        PyWinrtCheckBox(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtCheckBox() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtCheckBox* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_CheckBox(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::CheckBox>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtCheckBox>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::CheckBox instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CheckBox(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CheckBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::CheckBox>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CheckBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::CheckBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CheckBox[] = {
        { "_assign_array_", _assign_array_CheckBox, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CheckBox), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CheckBox[] = {
        { }
    };

    static PyType_Slot _type_slots_CheckBox[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CheckBox) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CheckBox) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CheckBox) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CheckBox) },
        { }
    };

    static PyType_Spec type_spec_CheckBox = {
        "winrt._winrt_windows_ui_xaml_controls_2.CheckBox",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_CheckBox};

    static PyGetSetDef getset_CheckBox_Static[] = {
        { }
    };

    static PyMethodDef methods_CheckBox_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CheckBox_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CheckBox_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CheckBox_Static) },
        { }
    };

    static PyType_Spec type_spec_CheckBox_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.CheckBox_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_CheckBox_Static
    };

    // ----- ComboBox class --------------------

    struct PyWinrtComboBox;
    using BasePyWinrtComboBox = winrt::Windows::UI::Xaml::Controls::ComboBoxT<PyWinrtComboBox, py::IPywinrtObject>;

    struct PyWinrtComboBox : py::py_obj_ref, BasePyWinrtComboBox
    {
        PyWinrtComboBox(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtComboBox() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtComboBox* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        void OnDropDownClosed(winrt::Windows::Foundation::IInspectable const& param0)
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_on_drop_down_closed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void OnDropDownOpened(winrt::Windows::Foundation::IInspectable const& param0)
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_on_drop_down_opened")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _new_ComboBox(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::ComboBox>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtComboBox>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::ComboBox instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ComboBox(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ComboBox_OnDropDownClosed(PyObject* /*unused*/, PyObject* /* unused */) noexcept
    {
        PyErr_SetString(PyExc_RuntimeError, "cannot call protected method");
        return nullptr;
    }

    static PyObject* ComboBox_OnDropDownOpened(PyObject* /*unused*/, PyObject* /* unused */) noexcept
    {
        PyErr_SetString(PyExc_RuntimeError, "cannot call protected method");
        return nullptr;
    }

    static PyObject* ComboBox_get_MaxDropDownHeight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"MaxDropDownHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().MaxDropDownHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_MaxDropDownHeight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"MaxDropDownHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().MaxDropDownHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_IsEditable(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"IsEditable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().IsEditable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_IsEditable(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"IsEditable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().IsEditable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_IsDropDownOpen(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"IsDropDownOpen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().IsDropDownOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_IsDropDownOpen(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"IsDropDownOpen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().IsDropDownOpen(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_IsSelectionBoxHighlighted(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"IsSelectionBoxHighlighted");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().IsSelectionBoxHighlighted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_SelectionBoxItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"SelectionBoxItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().SelectionBoxItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_SelectionBoxItemTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"SelectionBoxItemTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().SelectionBoxItemTemplate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_TemplateSettings(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"TemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().TemplateSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_PlaceholderText(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"PlaceholderText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().PlaceholderText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_PlaceholderText(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"PlaceholderText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().PlaceholderText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_HeaderTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"HeaderTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().HeaderTemplate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_HeaderTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"HeaderTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DataTemplate>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().HeaderTemplate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_Header(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"Header");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().Header());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_Header(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"Header");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().Header(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_LightDismissOverlayMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"LightDismissOverlayMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().LightDismissOverlayMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_LightDismissOverlayMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"LightDismissOverlayMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::LightDismissOverlayMode>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().LightDismissOverlayMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_IsTextSearchEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"IsTextSearchEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().IsTextSearchEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_IsTextSearchEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"IsTextSearchEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().IsTextSearchEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_SelectionChangedTrigger(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"SelectionChangedTrigger");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().SelectionChangedTrigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_SelectionChangedTrigger(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"SelectionChangedTrigger");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ComboBoxSelectionChangedTrigger>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().SelectionChangedTrigger(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_PlaceholderForeground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"PlaceholderForeground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().PlaceholderForeground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_PlaceholderForeground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"PlaceholderForeground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().PlaceholderForeground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_TextBoxStyle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"TextBoxStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().TextBoxStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_TextBoxStyle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"TextBoxStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Style>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().TextBoxStyle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_Text(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_Text(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_Description(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"Description");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_Description(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"Description");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_IsDropDownOpenProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"IsDropDownOpenProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::IsDropDownOpenProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_MaxDropDownHeightProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"MaxDropDownHeightProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::MaxDropDownHeightProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_HeaderProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"HeaderProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::HeaderProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_HeaderTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"HeaderTemplateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::HeaderTemplateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_PlaceholderTextProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"PlaceholderTextProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::PlaceholderTextProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_IsTextSearchEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"IsTextSearchEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::IsTextSearchEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_LightDismissOverlayModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"LightDismissOverlayModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::LightDismissOverlayModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_SelectionChangedTriggerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"SelectionChangedTriggerProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::SelectionChangedTriggerProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_PlaceholderForegroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"PlaceholderForegroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::PlaceholderForegroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_DescriptionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"DescriptionProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::DescriptionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_IsEditableProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"IsEditableProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::IsEditableProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_TextBoxStyleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"TextBoxStyleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::TextBoxStyleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_TextProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"TextProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::TextProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_add_DropDownClosed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"DropDownClosed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().DropDownClosed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_remove_DropDownClosed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"DropDownClosed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().DropDownClosed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_add_DropDownOpened(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"DropDownOpened");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().DropDownOpened(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_remove_DropDownOpened(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"DropDownOpened");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().DropDownOpened(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_add_TextSubmitted(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"TextSubmitted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::ComboBox, winrt::Windows::UI::Xaml::Controls::ComboBoxTextSubmittedEventArgs>>(arg);

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().TextSubmitted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_remove_TextSubmitted(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"TextSubmitted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ComboBox>().TextSubmitted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ComboBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::ComboBox>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ComboBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::ComboBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ComboBox[] = {
        { "_on_drop_down_closed", reinterpret_cast<PyCFunction>(ComboBox_OnDropDownClosed), METH_VARARGS, nullptr },
        { "_on_drop_down_opened", reinterpret_cast<PyCFunction>(ComboBox_OnDropDownOpened), METH_VARARGS, nullptr },
        { "add_drop_down_closed", reinterpret_cast<PyCFunction>(ComboBox_add_DropDownClosed), METH_O, nullptr },
        { "remove_drop_down_closed", reinterpret_cast<PyCFunction>(ComboBox_remove_DropDownClosed), METH_O, nullptr },
        { "add_drop_down_opened", reinterpret_cast<PyCFunction>(ComboBox_add_DropDownOpened), METH_O, nullptr },
        { "remove_drop_down_opened", reinterpret_cast<PyCFunction>(ComboBox_remove_DropDownOpened), METH_O, nullptr },
        { "add_text_submitted", reinterpret_cast<PyCFunction>(ComboBox_add_TextSubmitted), METH_O, nullptr },
        { "remove_text_submitted", reinterpret_cast<PyCFunction>(ComboBox_remove_TextSubmitted), METH_O, nullptr },
        { "_assign_array_", _assign_array_ComboBox, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ComboBox), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ComboBox[] = {
        { "max_drop_down_height", reinterpret_cast<getter>(ComboBox_get_MaxDropDownHeight), reinterpret_cast<setter>(ComboBox_put_MaxDropDownHeight), nullptr, nullptr },
        { "is_editable", reinterpret_cast<getter>(ComboBox_get_IsEditable), reinterpret_cast<setter>(ComboBox_put_IsEditable), nullptr, nullptr },
        { "is_drop_down_open", reinterpret_cast<getter>(ComboBox_get_IsDropDownOpen), reinterpret_cast<setter>(ComboBox_put_IsDropDownOpen), nullptr, nullptr },
        { "is_selection_box_highlighted", reinterpret_cast<getter>(ComboBox_get_IsSelectionBoxHighlighted), nullptr, nullptr, nullptr },
        { "selection_box_item", reinterpret_cast<getter>(ComboBox_get_SelectionBoxItem), nullptr, nullptr, nullptr },
        { "selection_box_item_template", reinterpret_cast<getter>(ComboBox_get_SelectionBoxItemTemplate), nullptr, nullptr, nullptr },
        { "template_settings", reinterpret_cast<getter>(ComboBox_get_TemplateSettings), nullptr, nullptr, nullptr },
        { "placeholder_text", reinterpret_cast<getter>(ComboBox_get_PlaceholderText), reinterpret_cast<setter>(ComboBox_put_PlaceholderText), nullptr, nullptr },
        { "header_template", reinterpret_cast<getter>(ComboBox_get_HeaderTemplate), reinterpret_cast<setter>(ComboBox_put_HeaderTemplate), nullptr, nullptr },
        { "header", reinterpret_cast<getter>(ComboBox_get_Header), reinterpret_cast<setter>(ComboBox_put_Header), nullptr, nullptr },
        { "light_dismiss_overlay_mode", reinterpret_cast<getter>(ComboBox_get_LightDismissOverlayMode), reinterpret_cast<setter>(ComboBox_put_LightDismissOverlayMode), nullptr, nullptr },
        { "is_text_search_enabled", reinterpret_cast<getter>(ComboBox_get_IsTextSearchEnabled), reinterpret_cast<setter>(ComboBox_put_IsTextSearchEnabled), nullptr, nullptr },
        { "selection_changed_trigger", reinterpret_cast<getter>(ComboBox_get_SelectionChangedTrigger), reinterpret_cast<setter>(ComboBox_put_SelectionChangedTrigger), nullptr, nullptr },
        { "placeholder_foreground", reinterpret_cast<getter>(ComboBox_get_PlaceholderForeground), reinterpret_cast<setter>(ComboBox_put_PlaceholderForeground), nullptr, nullptr },
        { "text_box_style", reinterpret_cast<getter>(ComboBox_get_TextBoxStyle), reinterpret_cast<setter>(ComboBox_put_TextBoxStyle), nullptr, nullptr },
        { "text", reinterpret_cast<getter>(ComboBox_get_Text), reinterpret_cast<setter>(ComboBox_put_Text), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(ComboBox_get_Description), reinterpret_cast<setter>(ComboBox_put_Description), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ComboBox[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ComboBox) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ComboBox) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ComboBox) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ComboBox) },
        { }
    };

    static PyType_Spec type_spec_ComboBox = {
        "winrt._winrt_windows_ui_xaml_controls_2.ComboBox",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ComboBox};

    static PyGetSetDef getset_ComboBox_Static[] = {
        { "is_drop_down_open_property", reinterpret_cast<getter>(ComboBox_get_IsDropDownOpenProperty), nullptr, nullptr, nullptr },
        { "max_drop_down_height_property", reinterpret_cast<getter>(ComboBox_get_MaxDropDownHeightProperty), nullptr, nullptr, nullptr },
        { "header_property", reinterpret_cast<getter>(ComboBox_get_HeaderProperty), nullptr, nullptr, nullptr },
        { "header_template_property", reinterpret_cast<getter>(ComboBox_get_HeaderTemplateProperty), nullptr, nullptr, nullptr },
        { "placeholder_text_property", reinterpret_cast<getter>(ComboBox_get_PlaceholderTextProperty), nullptr, nullptr, nullptr },
        { "is_text_search_enabled_property", reinterpret_cast<getter>(ComboBox_get_IsTextSearchEnabledProperty), nullptr, nullptr, nullptr },
        { "light_dismiss_overlay_mode_property", reinterpret_cast<getter>(ComboBox_get_LightDismissOverlayModeProperty), nullptr, nullptr, nullptr },
        { "selection_changed_trigger_property", reinterpret_cast<getter>(ComboBox_get_SelectionChangedTriggerProperty), nullptr, nullptr, nullptr },
        { "placeholder_foreground_property", reinterpret_cast<getter>(ComboBox_get_PlaceholderForegroundProperty), nullptr, nullptr, nullptr },
        { "description_property", reinterpret_cast<getter>(ComboBox_get_DescriptionProperty), nullptr, nullptr, nullptr },
        { "is_editable_property", reinterpret_cast<getter>(ComboBox_get_IsEditableProperty), nullptr, nullptr, nullptr },
        { "text_box_style_property", reinterpret_cast<getter>(ComboBox_get_TextBoxStyleProperty), nullptr, nullptr, nullptr },
        { "text_property", reinterpret_cast<getter>(ComboBox_get_TextProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ComboBox_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ComboBox_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ComboBox_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ComboBox_Static) },
        { }
    };

    static PyType_Spec type_spec_ComboBox_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.ComboBox_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ComboBox_Static
    };

    // ----- ComboBoxItem class --------------------

    struct PyWinrtComboBoxItem;
    using BasePyWinrtComboBoxItem = winrt::Windows::UI::Xaml::Controls::ComboBoxItemT<PyWinrtComboBoxItem, py::IPywinrtObject>;

    struct PyWinrtComboBoxItem : py::py_obj_ref, BasePyWinrtComboBoxItem
    {
        PyWinrtComboBoxItem(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtComboBoxItem() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtComboBoxItem* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ComboBoxItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::ComboBoxItem>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtComboBoxItem>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::ComboBoxItem instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ComboBoxItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ComboBoxItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::ComboBoxItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ComboBoxItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::ComboBoxItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ComboBoxItem[] = {
        { "_assign_array_", _assign_array_ComboBoxItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ComboBoxItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ComboBoxItem[] = {
        { }
    };

    static PyType_Slot _type_slots_ComboBoxItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ComboBoxItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ComboBoxItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ComboBoxItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ComboBoxItem) },
        { }
    };

    static PyType_Spec type_spec_ComboBoxItem = {
        "winrt._winrt_windows_ui_xaml_controls_2.ComboBoxItem",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ComboBoxItem};

    static PyGetSetDef getset_ComboBoxItem_Static[] = {
        { }
    };

    static PyMethodDef methods_ComboBoxItem_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ComboBoxItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ComboBoxItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ComboBoxItem_Static) },
        { }
    };

    static PyType_Spec type_spec_ComboBoxItem_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.ComboBoxItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ComboBoxItem_Static
    };

    // ----- CommandBarFlyout class --------------------

    struct PyWinrtCommandBarFlyout;
    using BasePyWinrtCommandBarFlyout = winrt::Windows::UI::Xaml::Controls::CommandBarFlyoutT<PyWinrtCommandBarFlyout, py::IPywinrtObject>;

    struct PyWinrtCommandBarFlyout : py::py_obj_ref, BasePyWinrtCommandBarFlyout
    {
        PyWinrtCommandBarFlyout(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtCommandBarFlyout() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtCommandBarFlyout* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_CommandBarFlyout(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::CommandBarFlyout>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtCommandBarFlyout>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::CommandBarFlyout instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CommandBarFlyout(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CommandBarFlyout_get_PrimaryCommands(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.CommandBarFlyout", L"PrimaryCommands");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::CommandBarFlyout>().PrimaryCommands());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyout_get_SecondaryCommands(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.CommandBarFlyout", L"SecondaryCommands");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::CommandBarFlyout>().SecondaryCommands());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CommandBarFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::CommandBarFlyout>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CommandBarFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::CommandBarFlyout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CommandBarFlyout[] = {
        { "_assign_array_", _assign_array_CommandBarFlyout, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CommandBarFlyout), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CommandBarFlyout[] = {
        { "primary_commands", reinterpret_cast<getter>(CommandBarFlyout_get_PrimaryCommands), nullptr, nullptr, nullptr },
        { "secondary_commands", reinterpret_cast<getter>(CommandBarFlyout_get_SecondaryCommands), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CommandBarFlyout[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CommandBarFlyout) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CommandBarFlyout) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CommandBarFlyout) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CommandBarFlyout) },
        { }
    };

    static PyType_Spec type_spec_CommandBarFlyout = {
        "winrt._winrt_windows_ui_xaml_controls_2.CommandBarFlyout",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_CommandBarFlyout};

    static PyGetSetDef getset_CommandBarFlyout_Static[] = {
        { }
    };

    static PyMethodDef methods_CommandBarFlyout_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CommandBarFlyout_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CommandBarFlyout_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CommandBarFlyout_Static) },
        { }
    };

    static PyType_Spec type_spec_CommandBarFlyout_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.CommandBarFlyout_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_CommandBarFlyout_Static
    };

    // ----- DatePickerFlyout class --------------------

    static PyObject* _new_DatePickerFlyout(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::DatePickerFlyout instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DatePickerFlyout(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DatePickerFlyout_ShowAtAsync(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"ShowAtAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::FrameworkElement>(args, 0);

                return py::convert(self->obj.ShowAtAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatePickerFlyout_get_YearVisible(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"YearVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.YearVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatePickerFlyout_put_YearVisible(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"YearVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.YearVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatePickerFlyout_get_MonthVisible(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"MonthVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MonthVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatePickerFlyout_put_MonthVisible(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"MonthVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.MonthVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatePickerFlyout_get_MinYear(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"MinYear");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinYear());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatePickerFlyout_put_MinYear(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"MinYear");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.MinYear(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatePickerFlyout_get_MaxYear(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"MaxYear");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxYear());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatePickerFlyout_put_MaxYear(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"MaxYear");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.MaxYear(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatePickerFlyout_get_DayVisible(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"DayVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DayVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatePickerFlyout_put_DayVisible(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"DayVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.DayVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatePickerFlyout_get_Date(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"Date");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Date());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatePickerFlyout_put_Date(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"Date");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.Date(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatePickerFlyout_get_CalendarIdentifier(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"CalendarIdentifier");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CalendarIdentifier());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatePickerFlyout_put_CalendarIdentifier(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"CalendarIdentifier");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CalendarIdentifier(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatePickerFlyout_get_YearFormat(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"YearFormat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.YearFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatePickerFlyout_put_YearFormat(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"YearFormat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.YearFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatePickerFlyout_get_MonthFormat(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"MonthFormat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MonthFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatePickerFlyout_put_MonthFormat(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"MonthFormat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MonthFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatePickerFlyout_get_DayFormat(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"DayFormat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DayFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatePickerFlyout_put_DayFormat(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"DayFormat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DayFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatePickerFlyout_get_CalendarIdentifierProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"CalendarIdentifierProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::DatePickerFlyout::CalendarIdentifierProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatePickerFlyout_get_DateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"DateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::DatePickerFlyout::DateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatePickerFlyout_get_DayVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"DayVisibleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::DatePickerFlyout::DayVisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatePickerFlyout_get_MaxYearProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"MaxYearProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::DatePickerFlyout::MaxYearProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatePickerFlyout_get_MinYearProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"MinYearProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::DatePickerFlyout::MinYearProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatePickerFlyout_get_MonthVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"MonthVisibleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::DatePickerFlyout::MonthVisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatePickerFlyout_get_YearVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"YearVisibleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::DatePickerFlyout::YearVisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatePickerFlyout_get_DayFormatProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"DayFormatProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::DatePickerFlyout::DayFormatProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatePickerFlyout_get_MonthFormatProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"MonthFormatProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::DatePickerFlyout::MonthFormatProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatePickerFlyout_get_YearFormatProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"YearFormatProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::DatePickerFlyout::YearFormatProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatePickerFlyout_add_DatePicked(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"DatePicked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::DatePickerFlyout, winrt::Windows::UI::Xaml::Controls::DatePickedEventArgs>>(arg);

            return py::convert(self->obj.DatePicked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatePickerFlyout_remove_DatePicked(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"DatePicked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DatePicked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DatePickerFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::DatePickerFlyout>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DatePickerFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::DatePickerFlyout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DatePickerFlyout[] = {
        { "show_at_async", reinterpret_cast<PyCFunction>(DatePickerFlyout_ShowAtAsync), METH_VARARGS, nullptr },
        { "add_date_picked", reinterpret_cast<PyCFunction>(DatePickerFlyout_add_DatePicked), METH_O, nullptr },
        { "remove_date_picked", reinterpret_cast<PyCFunction>(DatePickerFlyout_remove_DatePicked), METH_O, nullptr },
        { "_assign_array_", _assign_array_DatePickerFlyout, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DatePickerFlyout), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DatePickerFlyout[] = {
        { "year_visible", reinterpret_cast<getter>(DatePickerFlyout_get_YearVisible), reinterpret_cast<setter>(DatePickerFlyout_put_YearVisible), nullptr, nullptr },
        { "month_visible", reinterpret_cast<getter>(DatePickerFlyout_get_MonthVisible), reinterpret_cast<setter>(DatePickerFlyout_put_MonthVisible), nullptr, nullptr },
        { "min_year", reinterpret_cast<getter>(DatePickerFlyout_get_MinYear), reinterpret_cast<setter>(DatePickerFlyout_put_MinYear), nullptr, nullptr },
        { "max_year", reinterpret_cast<getter>(DatePickerFlyout_get_MaxYear), reinterpret_cast<setter>(DatePickerFlyout_put_MaxYear), nullptr, nullptr },
        { "day_visible", reinterpret_cast<getter>(DatePickerFlyout_get_DayVisible), reinterpret_cast<setter>(DatePickerFlyout_put_DayVisible), nullptr, nullptr },
        { "date", reinterpret_cast<getter>(DatePickerFlyout_get_Date), reinterpret_cast<setter>(DatePickerFlyout_put_Date), nullptr, nullptr },
        { "calendar_identifier", reinterpret_cast<getter>(DatePickerFlyout_get_CalendarIdentifier), reinterpret_cast<setter>(DatePickerFlyout_put_CalendarIdentifier), nullptr, nullptr },
        { "year_format", reinterpret_cast<getter>(DatePickerFlyout_get_YearFormat), reinterpret_cast<setter>(DatePickerFlyout_put_YearFormat), nullptr, nullptr },
        { "month_format", reinterpret_cast<getter>(DatePickerFlyout_get_MonthFormat), reinterpret_cast<setter>(DatePickerFlyout_put_MonthFormat), nullptr, nullptr },
        { "day_format", reinterpret_cast<getter>(DatePickerFlyout_get_DayFormat), reinterpret_cast<setter>(DatePickerFlyout_put_DayFormat), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DatePickerFlyout[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DatePickerFlyout) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DatePickerFlyout) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DatePickerFlyout) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DatePickerFlyout) },
        { }
    };

    static PyType_Spec type_spec_DatePickerFlyout = {
        "winrt._winrt_windows_ui_xaml_controls_2.DatePickerFlyout",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DatePickerFlyout};

    static PyGetSetDef getset_DatePickerFlyout_Static[] = {
        { "calendar_identifier_property", reinterpret_cast<getter>(DatePickerFlyout_get_CalendarIdentifierProperty), nullptr, nullptr, nullptr },
        { "date_property", reinterpret_cast<getter>(DatePickerFlyout_get_DateProperty), nullptr, nullptr, nullptr },
        { "day_visible_property", reinterpret_cast<getter>(DatePickerFlyout_get_DayVisibleProperty), nullptr, nullptr, nullptr },
        { "max_year_property", reinterpret_cast<getter>(DatePickerFlyout_get_MaxYearProperty), nullptr, nullptr, nullptr },
        { "min_year_property", reinterpret_cast<getter>(DatePickerFlyout_get_MinYearProperty), nullptr, nullptr, nullptr },
        { "month_visible_property", reinterpret_cast<getter>(DatePickerFlyout_get_MonthVisibleProperty), nullptr, nullptr, nullptr },
        { "year_visible_property", reinterpret_cast<getter>(DatePickerFlyout_get_YearVisibleProperty), nullptr, nullptr, nullptr },
        { "day_format_property", reinterpret_cast<getter>(DatePickerFlyout_get_DayFormatProperty), nullptr, nullptr, nullptr },
        { "month_format_property", reinterpret_cast<getter>(DatePickerFlyout_get_MonthFormatProperty), nullptr, nullptr, nullptr },
        { "year_format_property", reinterpret_cast<getter>(DatePickerFlyout_get_YearFormatProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_DatePickerFlyout_Static[] = {
        { }
    };

    static PyType_Slot type_slots_DatePickerFlyout_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DatePickerFlyout_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DatePickerFlyout_Static) },
        { }
    };

    static PyType_Spec type_spec_DatePickerFlyout_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.DatePickerFlyout_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DatePickerFlyout_Static
    };

    // ----- DropDownButton class --------------------

    struct PyWinrtDropDownButton;
    using BasePyWinrtDropDownButton = winrt::Windows::UI::Xaml::Controls::DropDownButtonT<PyWinrtDropDownButton, py::IPywinrtObject>;

    struct PyWinrtDropDownButton : py::py_obj_ref, BasePyWinrtDropDownButton
    {
        PyWinrtDropDownButton(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtDropDownButton() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtDropDownButton* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_DropDownButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::DropDownButton>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtDropDownButton>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::DropDownButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DropDownButton(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_DropDownButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::DropDownButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DropDownButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::DropDownButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DropDownButton[] = {
        { "_assign_array_", _assign_array_DropDownButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DropDownButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DropDownButton[] = {
        { }
    };

    static PyType_Slot _type_slots_DropDownButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DropDownButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DropDownButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DropDownButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DropDownButton) },
        { }
    };

    static PyType_Spec type_spec_DropDownButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.DropDownButton",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_DropDownButton};

    static PyGetSetDef getset_DropDownButton_Static[] = {
        { }
    };

    static PyMethodDef methods_DropDownButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_DropDownButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DropDownButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DropDownButton_Static) },
        { }
    };

    static PyType_Spec type_spec_DropDownButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.DropDownButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_DropDownButton_Static
    };

    // ----- FlipView class --------------------

    struct PyWinrtFlipView;
    using BasePyWinrtFlipView = winrt::Windows::UI::Xaml::Controls::FlipViewT<PyWinrtFlipView, py::IPywinrtObject>;

    struct PyWinrtFlipView : py::py_obj_ref, BasePyWinrtFlipView
    {
        PyWinrtFlipView(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtFlipView() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtFlipView* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_FlipView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::FlipView>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtFlipView>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::FlipView instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FlipView(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FlipView_get_UseTouchAnimationsForAllNavigation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.FlipView", L"UseTouchAnimationsForAllNavigation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::FlipView>().UseTouchAnimationsForAllNavigation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlipView_put_UseTouchAnimationsForAllNavigation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.FlipView", L"UseTouchAnimationsForAllNavigation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::FlipView>().UseTouchAnimationsForAllNavigation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlipView_get_UseTouchAnimationsForAllNavigationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.FlipView", L"UseTouchAnimationsForAllNavigationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::FlipView::UseTouchAnimationsForAllNavigationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FlipView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::FlipView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlipView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::FlipView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlipView[] = {
        { "_assign_array_", _assign_array_FlipView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlipView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlipView[] = {
        { "use_touch_animations_for_all_navigation", reinterpret_cast<getter>(FlipView_get_UseTouchAnimationsForAllNavigation), reinterpret_cast<setter>(FlipView_put_UseTouchAnimationsForAllNavigation), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FlipView[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlipView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlipView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlipView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlipView) },
        { }
    };

    static PyType_Spec type_spec_FlipView = {
        "winrt._winrt_windows_ui_xaml_controls_2.FlipView",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_FlipView};

    static PyGetSetDef getset_FlipView_Static[] = {
        { "use_touch_animations_for_all_navigation_property", reinterpret_cast<getter>(FlipView_get_UseTouchAnimationsForAllNavigationProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_FlipView_Static[] = {
        { }
    };

    static PyType_Slot type_slots_FlipView_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FlipView_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FlipView_Static) },
        { }
    };

    static PyType_Spec type_spec_FlipView_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.FlipView_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_FlipView_Static
    };

    // ----- FlipViewItem class --------------------

    struct PyWinrtFlipViewItem;
    using BasePyWinrtFlipViewItem = winrt::Windows::UI::Xaml::Controls::FlipViewItemT<PyWinrtFlipViewItem, py::IPywinrtObject>;

    struct PyWinrtFlipViewItem : py::py_obj_ref, BasePyWinrtFlipViewItem
    {
        PyWinrtFlipViewItem(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtFlipViewItem() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtFlipViewItem* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_FlipViewItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::FlipViewItem>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtFlipViewItem>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::FlipViewItem instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FlipViewItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_FlipViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::FlipViewItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlipViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::FlipViewItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlipViewItem[] = {
        { "_assign_array_", _assign_array_FlipViewItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlipViewItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlipViewItem[] = {
        { }
    };

    static PyType_Slot _type_slots_FlipViewItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlipViewItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlipViewItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlipViewItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlipViewItem) },
        { }
    };

    static PyType_Spec type_spec_FlipViewItem = {
        "winrt._winrt_windows_ui_xaml_controls_2.FlipViewItem",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_FlipViewItem};

    static PyGetSetDef getset_FlipViewItem_Static[] = {
        { }
    };

    static PyMethodDef methods_FlipViewItem_Static[] = {
        { }
    };

    static PyType_Slot type_slots_FlipViewItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FlipViewItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FlipViewItem_Static) },
        { }
    };

    static PyType_Spec type_spec_FlipViewItem_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.FlipViewItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_FlipViewItem_Static
    };

    // ----- Flyout class --------------------

    struct PyWinrtFlyout;
    using BasePyWinrtFlyout = winrt::Windows::UI::Xaml::Controls::FlyoutT<PyWinrtFlyout, py::IPywinrtObject>;

    struct PyWinrtFlyout : py::py_obj_ref, BasePyWinrtFlyout
    {
        PyWinrtFlyout(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtFlyout() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtFlyout* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_Flyout(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::Flyout>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtFlyout>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::Flyout instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Flyout(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Flyout_get_FlyoutPresenterStyle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Flyout", L"FlyoutPresenterStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Flyout>().FlyoutPresenterStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Flyout_put_FlyoutPresenterStyle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Flyout", L"FlyoutPresenterStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Style>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Flyout>().FlyoutPresenterStyle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Flyout_get_Content(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Flyout", L"Content");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Flyout>().Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Flyout_put_Content(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Flyout", L"Content");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Flyout>().Content(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Flyout_get_ContentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Flyout", L"ContentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Flyout::ContentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Flyout_get_FlyoutPresenterStyleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Flyout", L"FlyoutPresenterStyleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Flyout::FlyoutPresenterStyleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Flyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Flyout>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Flyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Flyout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Flyout[] = {
        { "_assign_array_", _assign_array_Flyout, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Flyout), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Flyout[] = {
        { "flyout_presenter_style", reinterpret_cast<getter>(Flyout_get_FlyoutPresenterStyle), reinterpret_cast<setter>(Flyout_put_FlyoutPresenterStyle), nullptr, nullptr },
        { "content", reinterpret_cast<getter>(Flyout_get_Content), reinterpret_cast<setter>(Flyout_put_Content), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Flyout[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Flyout) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Flyout) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Flyout) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Flyout) },
        { }
    };

    static PyType_Spec type_spec_Flyout = {
        "winrt._winrt_windows_ui_xaml_controls_2.Flyout",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_Flyout};

    static PyGetSetDef getset_Flyout_Static[] = {
        { "content_property", reinterpret_cast<getter>(Flyout_get_ContentProperty), nullptr, nullptr, nullptr },
        { "flyout_presenter_style_property", reinterpret_cast<getter>(Flyout_get_FlyoutPresenterStyleProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Flyout_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Flyout_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Flyout_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Flyout_Static) },
        { }
    };

    static PyType_Spec type_spec_Flyout_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.Flyout_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_Flyout_Static
    };

    // ----- GridView class --------------------

    struct PyWinrtGridView;
    using BasePyWinrtGridView = winrt::Windows::UI::Xaml::Controls::GridViewT<PyWinrtGridView, py::IPywinrtObject>;

    struct PyWinrtGridView : py::py_obj_ref, BasePyWinrtGridView
    {
        PyWinrtGridView(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtGridView() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtGridView* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_GridView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::GridView>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtGridView>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::GridView instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GridView(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_GridView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::GridView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GridView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::GridView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GridView[] = {
        { "_assign_array_", _assign_array_GridView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GridView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GridView[] = {
        { }
    };

    static PyType_Slot _type_slots_GridView[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GridView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridView) },
        { }
    };

    static PyType_Spec type_spec_GridView = {
        "winrt._winrt_windows_ui_xaml_controls_2.GridView",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_GridView};

    static PyGetSetDef getset_GridView_Static[] = {
        { }
    };

    static PyMethodDef methods_GridView_Static[] = {
        { }
    };

    static PyType_Slot type_slots_GridView_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GridView_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GridView_Static) },
        { }
    };

    static PyType_Spec type_spec_GridView_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.GridView_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_GridView_Static
    };

    // ----- GridViewItem class --------------------

    struct PyWinrtGridViewItem;
    using BasePyWinrtGridViewItem = winrt::Windows::UI::Xaml::Controls::GridViewItemT<PyWinrtGridViewItem, py::IPywinrtObject>;

    struct PyWinrtGridViewItem : py::py_obj_ref, BasePyWinrtGridViewItem
    {
        PyWinrtGridViewItem(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtGridViewItem() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtGridViewItem* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_GridViewItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::GridViewItem>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtGridViewItem>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::GridViewItem instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GridViewItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GridViewItem_get_TemplateSettings(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.GridViewItem", L"TemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::GridViewItem>().TemplateSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GridViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::GridViewItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GridViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::GridViewItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GridViewItem[] = {
        { "_assign_array_", _assign_array_GridViewItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GridViewItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GridViewItem[] = {
        { "template_settings", reinterpret_cast<getter>(GridViewItem_get_TemplateSettings), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GridViewItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridViewItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridViewItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GridViewItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridViewItem) },
        { }
    };

    static PyType_Spec type_spec_GridViewItem = {
        "winrt._winrt_windows_ui_xaml_controls_2.GridViewItem",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_GridViewItem};

    static PyGetSetDef getset_GridViewItem_Static[] = {
        { }
    };

    static PyMethodDef methods_GridViewItem_Static[] = {
        { }
    };

    static PyType_Slot type_slots_GridViewItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GridViewItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GridViewItem_Static) },
        { }
    };

    static PyType_Spec type_spec_GridViewItem_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.GridViewItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_GridViewItem_Static
    };

    // ----- HyperlinkButton class --------------------

    struct PyWinrtHyperlinkButton;
    using BasePyWinrtHyperlinkButton = winrt::Windows::UI::Xaml::Controls::HyperlinkButtonT<PyWinrtHyperlinkButton, py::IPywinrtObject>;

    struct PyWinrtHyperlinkButton : py::py_obj_ref, BasePyWinrtHyperlinkButton
    {
        PyWinrtHyperlinkButton(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtHyperlinkButton() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtHyperlinkButton* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_HyperlinkButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::HyperlinkButton>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtHyperlinkButton>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::HyperlinkButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HyperlinkButton(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HyperlinkButton_get_NavigateUri(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.HyperlinkButton", L"NavigateUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::HyperlinkButton>().NavigateUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HyperlinkButton_put_NavigateUri(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.HyperlinkButton", L"NavigateUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::HyperlinkButton>().NavigateUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HyperlinkButton_get_NavigateUriProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.HyperlinkButton", L"NavigateUriProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::HyperlinkButton::NavigateUriProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HyperlinkButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::HyperlinkButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HyperlinkButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::HyperlinkButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HyperlinkButton[] = {
        { "_assign_array_", _assign_array_HyperlinkButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HyperlinkButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HyperlinkButton[] = {
        { "navigate_uri", reinterpret_cast<getter>(HyperlinkButton_get_NavigateUri), reinterpret_cast<setter>(HyperlinkButton_put_NavigateUri), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HyperlinkButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HyperlinkButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HyperlinkButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HyperlinkButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HyperlinkButton) },
        { }
    };

    static PyType_Spec type_spec_HyperlinkButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.HyperlinkButton",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_HyperlinkButton};

    static PyGetSetDef getset_HyperlinkButton_Static[] = {
        { "navigate_uri_property", reinterpret_cast<getter>(HyperlinkButton_get_NavigateUriProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_HyperlinkButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_HyperlinkButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HyperlinkButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HyperlinkButton_Static) },
        { }
    };

    static PyType_Spec type_spec_HyperlinkButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.HyperlinkButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_HyperlinkButton_Static
    };

    // ----- InkToolbarBallpointPenButton class --------------------

    struct PyWinrtInkToolbarBallpointPenButton;
    using BasePyWinrtInkToolbarBallpointPenButton = winrt::Windows::UI::Xaml::Controls::InkToolbarBallpointPenButtonT<PyWinrtInkToolbarBallpointPenButton, py::IPywinrtObject>;

    struct PyWinrtInkToolbarBallpointPenButton : py::py_obj_ref, BasePyWinrtInkToolbarBallpointPenButton
    {
        PyWinrtInkToolbarBallpointPenButton(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtInkToolbarBallpointPenButton() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtInkToolbarBallpointPenButton* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_InkToolbarBallpointPenButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::InkToolbarBallpointPenButton>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtInkToolbarBallpointPenButton>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::InkToolbarBallpointPenButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkToolbarBallpointPenButton(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_InkToolbarBallpointPenButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarBallpointPenButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarBallpointPenButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarBallpointPenButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarBallpointPenButton[] = {
        { "_assign_array_", _assign_array_InkToolbarBallpointPenButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarBallpointPenButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarBallpointPenButton[] = {
        { }
    };

    static PyType_Slot _type_slots_InkToolbarBallpointPenButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarBallpointPenButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarBallpointPenButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarBallpointPenButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarBallpointPenButton) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarBallpointPenButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarBallpointPenButton",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_InkToolbarBallpointPenButton};

    static PyGetSetDef getset_InkToolbarBallpointPenButton_Static[] = {
        { }
    };

    static PyMethodDef methods_InkToolbarBallpointPenButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarBallpointPenButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarBallpointPenButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarBallpointPenButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarBallpointPenButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarBallpointPenButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_InkToolbarBallpointPenButton_Static
    };

    // ----- InkToolbarCustomPenButton class --------------------

    struct PyWinrtInkToolbarCustomPenButton;
    using BasePyWinrtInkToolbarCustomPenButton = winrt::Windows::UI::Xaml::Controls::InkToolbarCustomPenButtonT<PyWinrtInkToolbarCustomPenButton, py::IPywinrtObject>;

    struct PyWinrtInkToolbarCustomPenButton : py::py_obj_ref, BasePyWinrtInkToolbarCustomPenButton
    {
        PyWinrtInkToolbarCustomPenButton(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtInkToolbarCustomPenButton() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtInkToolbarCustomPenButton* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_InkToolbarCustomPenButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::InkToolbarCustomPenButton>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtInkToolbarCustomPenButton>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::InkToolbarCustomPenButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkToolbarCustomPenButton(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkToolbarCustomPenButton_get_CustomPen(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarCustomPenButton", L"CustomPen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarCustomPenButton>().CustomPen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarCustomPenButton_put_CustomPen(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarCustomPenButton", L"CustomPen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::InkToolbarCustomPen>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarCustomPenButton>().CustomPen(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarCustomPenButton_get_ConfigurationContent(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarCustomPenButton", L"ConfigurationContent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarCustomPenButton>().ConfigurationContent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarCustomPenButton_put_ConfigurationContent(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarCustomPenButton", L"ConfigurationContent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarCustomPenButton>().ConfigurationContent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarCustomPenButton_get_ConfigurationContentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarCustomPenButton", L"ConfigurationContentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarCustomPenButton::ConfigurationContentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarCustomPenButton_get_CustomPenProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarCustomPenButton", L"CustomPenProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarCustomPenButton::CustomPenProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkToolbarCustomPenButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarCustomPenButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarCustomPenButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarCustomPenButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarCustomPenButton[] = {
        { "_assign_array_", _assign_array_InkToolbarCustomPenButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarCustomPenButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarCustomPenButton[] = {
        { "custom_pen", reinterpret_cast<getter>(InkToolbarCustomPenButton_get_CustomPen), reinterpret_cast<setter>(InkToolbarCustomPenButton_put_CustomPen), nullptr, nullptr },
        { "configuration_content", reinterpret_cast<getter>(InkToolbarCustomPenButton_get_ConfigurationContent), reinterpret_cast<setter>(InkToolbarCustomPenButton_put_ConfigurationContent), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkToolbarCustomPenButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarCustomPenButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarCustomPenButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarCustomPenButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarCustomPenButton) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarCustomPenButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarCustomPenButton",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_InkToolbarCustomPenButton};

    static PyGetSetDef getset_InkToolbarCustomPenButton_Static[] = {
        { "configuration_content_property", reinterpret_cast<getter>(InkToolbarCustomPenButton_get_ConfigurationContentProperty), nullptr, nullptr, nullptr },
        { "custom_pen_property", reinterpret_cast<getter>(InkToolbarCustomPenButton_get_CustomPenProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_InkToolbarCustomPenButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarCustomPenButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarCustomPenButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarCustomPenButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarCustomPenButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarCustomPenButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_InkToolbarCustomPenButton_Static
    };

    // ----- InkToolbarCustomToggleButton class --------------------

    struct PyWinrtInkToolbarCustomToggleButton;
    using BasePyWinrtInkToolbarCustomToggleButton = winrt::Windows::UI::Xaml::Controls::InkToolbarCustomToggleButtonT<PyWinrtInkToolbarCustomToggleButton, py::IPywinrtObject>;

    struct PyWinrtInkToolbarCustomToggleButton : py::py_obj_ref, BasePyWinrtInkToolbarCustomToggleButton
    {
        PyWinrtInkToolbarCustomToggleButton(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtInkToolbarCustomToggleButton() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtInkToolbarCustomToggleButton* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_InkToolbarCustomToggleButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::InkToolbarCustomToggleButton>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtInkToolbarCustomToggleButton>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::InkToolbarCustomToggleButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkToolbarCustomToggleButton(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_InkToolbarCustomToggleButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarCustomToggleButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarCustomToggleButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarCustomToggleButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarCustomToggleButton[] = {
        { "_assign_array_", _assign_array_InkToolbarCustomToggleButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarCustomToggleButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarCustomToggleButton[] = {
        { }
    };

    static PyType_Slot _type_slots_InkToolbarCustomToggleButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarCustomToggleButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarCustomToggleButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarCustomToggleButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarCustomToggleButton) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarCustomToggleButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarCustomToggleButton",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_InkToolbarCustomToggleButton};

    static PyGetSetDef getset_InkToolbarCustomToggleButton_Static[] = {
        { }
    };

    static PyMethodDef methods_InkToolbarCustomToggleButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarCustomToggleButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarCustomToggleButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarCustomToggleButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarCustomToggleButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarCustomToggleButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_InkToolbarCustomToggleButton_Static
    };

    // ----- InkToolbarCustomToolButton class --------------------

    struct PyWinrtInkToolbarCustomToolButton;
    using BasePyWinrtInkToolbarCustomToolButton = winrt::Windows::UI::Xaml::Controls::InkToolbarCustomToolButtonT<PyWinrtInkToolbarCustomToolButton, py::IPywinrtObject>;

    struct PyWinrtInkToolbarCustomToolButton : py::py_obj_ref, BasePyWinrtInkToolbarCustomToolButton
    {
        PyWinrtInkToolbarCustomToolButton(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtInkToolbarCustomToolButton() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtInkToolbarCustomToolButton* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_InkToolbarCustomToolButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::InkToolbarCustomToolButton>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtInkToolbarCustomToolButton>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::InkToolbarCustomToolButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkToolbarCustomToolButton(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkToolbarCustomToolButton_get_ConfigurationContent(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarCustomToolButton", L"ConfigurationContent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarCustomToolButton>().ConfigurationContent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarCustomToolButton_put_ConfigurationContent(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarCustomToolButton", L"ConfigurationContent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarCustomToolButton>().ConfigurationContent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarCustomToolButton_get_ConfigurationContentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarCustomToolButton", L"ConfigurationContentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarCustomToolButton::ConfigurationContentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkToolbarCustomToolButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarCustomToolButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarCustomToolButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarCustomToolButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarCustomToolButton[] = {
        { "_assign_array_", _assign_array_InkToolbarCustomToolButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarCustomToolButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarCustomToolButton[] = {
        { "configuration_content", reinterpret_cast<getter>(InkToolbarCustomToolButton_get_ConfigurationContent), reinterpret_cast<setter>(InkToolbarCustomToolButton_put_ConfigurationContent), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkToolbarCustomToolButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarCustomToolButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarCustomToolButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarCustomToolButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarCustomToolButton) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarCustomToolButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarCustomToolButton",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_InkToolbarCustomToolButton};

    static PyGetSetDef getset_InkToolbarCustomToolButton_Static[] = {
        { "configuration_content_property", reinterpret_cast<getter>(InkToolbarCustomToolButton_get_ConfigurationContentProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_InkToolbarCustomToolButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarCustomToolButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarCustomToolButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarCustomToolButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarCustomToolButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarCustomToolButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_InkToolbarCustomToolButton_Static
    };

    // ----- InkToolbarEraserButton class --------------------

    struct PyWinrtInkToolbarEraserButton;
    using BasePyWinrtInkToolbarEraserButton = winrt::Windows::UI::Xaml::Controls::InkToolbarEraserButtonT<PyWinrtInkToolbarEraserButton, py::IPywinrtObject>;

    struct PyWinrtInkToolbarEraserButton : py::py_obj_ref, BasePyWinrtInkToolbarEraserButton
    {
        PyWinrtInkToolbarEraserButton(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtInkToolbarEraserButton() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtInkToolbarEraserButton* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_InkToolbarEraserButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::InkToolbarEraserButton>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtInkToolbarEraserButton>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::InkToolbarEraserButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkToolbarEraserButton(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkToolbarEraserButton_get_IsClearAllVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarEraserButton", L"IsClearAllVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarEraserButton>().IsClearAllVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarEraserButton_put_IsClearAllVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarEraserButton", L"IsClearAllVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarEraserButton>().IsClearAllVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarEraserButton_get_IsClearAllVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarEraserButton", L"IsClearAllVisibleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarEraserButton::IsClearAllVisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkToolbarEraserButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarEraserButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarEraserButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarEraserButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarEraserButton[] = {
        { "_assign_array_", _assign_array_InkToolbarEraserButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarEraserButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarEraserButton[] = {
        { "is_clear_all_visible", reinterpret_cast<getter>(InkToolbarEraserButton_get_IsClearAllVisible), reinterpret_cast<setter>(InkToolbarEraserButton_put_IsClearAllVisible), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkToolbarEraserButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarEraserButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarEraserButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarEraserButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarEraserButton) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarEraserButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarEraserButton",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_InkToolbarEraserButton};

    static PyGetSetDef getset_InkToolbarEraserButton_Static[] = {
        { "is_clear_all_visible_property", reinterpret_cast<getter>(InkToolbarEraserButton_get_IsClearAllVisibleProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_InkToolbarEraserButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarEraserButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarEraserButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarEraserButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarEraserButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarEraserButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_InkToolbarEraserButton_Static
    };

    // ----- InkToolbarFlyoutItem class --------------------

    struct PyWinrtInkToolbarFlyoutItem;
    using BasePyWinrtInkToolbarFlyoutItem = winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItemT<PyWinrtInkToolbarFlyoutItem, py::IPywinrtObject>;

    struct PyWinrtInkToolbarFlyoutItem : py::py_obj_ref, BasePyWinrtInkToolbarFlyoutItem
    {
        PyWinrtInkToolbarFlyoutItem(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtInkToolbarFlyoutItem() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtInkToolbarFlyoutItem* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_InkToolbarFlyoutItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtInkToolbarFlyoutItem>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkToolbarFlyoutItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkToolbarFlyoutItem_get_Kind(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarFlyoutItem", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem>().Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarFlyoutItem_put_Kind(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarFlyoutItem", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItemKind>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem>().Kind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarFlyoutItem_get_IsChecked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarFlyoutItem", L"IsChecked");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem>().IsChecked());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarFlyoutItem_put_IsChecked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarFlyoutItem", L"IsChecked");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem>().IsChecked(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarFlyoutItem_get_IsCheckedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarFlyoutItem", L"IsCheckedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem::IsCheckedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarFlyoutItem_get_KindProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarFlyoutItem", L"KindProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem::KindProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarFlyoutItem_add_Checked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.InkToolbarFlyoutItem", L"Checked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem>().Checked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarFlyoutItem_remove_Checked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.InkToolbarFlyoutItem", L"Checked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem>().Checked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarFlyoutItem_add_Unchecked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.InkToolbarFlyoutItem", L"Unchecked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem>().Unchecked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarFlyoutItem_remove_Unchecked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.InkToolbarFlyoutItem", L"Unchecked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem>().Unchecked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkToolbarFlyoutItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarFlyoutItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarFlyoutItem[] = {
        { "add_checked", reinterpret_cast<PyCFunction>(InkToolbarFlyoutItem_add_Checked), METH_O, nullptr },
        { "remove_checked", reinterpret_cast<PyCFunction>(InkToolbarFlyoutItem_remove_Checked), METH_O, nullptr },
        { "add_unchecked", reinterpret_cast<PyCFunction>(InkToolbarFlyoutItem_add_Unchecked), METH_O, nullptr },
        { "remove_unchecked", reinterpret_cast<PyCFunction>(InkToolbarFlyoutItem_remove_Unchecked), METH_O, nullptr },
        { "_assign_array_", _assign_array_InkToolbarFlyoutItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarFlyoutItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarFlyoutItem[] = {
        { "kind", reinterpret_cast<getter>(InkToolbarFlyoutItem_get_Kind), reinterpret_cast<setter>(InkToolbarFlyoutItem_put_Kind), nullptr, nullptr },
        { "is_checked", reinterpret_cast<getter>(InkToolbarFlyoutItem_get_IsChecked), reinterpret_cast<setter>(InkToolbarFlyoutItem_put_IsChecked), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkToolbarFlyoutItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarFlyoutItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarFlyoutItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarFlyoutItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarFlyoutItem) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarFlyoutItem = {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarFlyoutItem",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_InkToolbarFlyoutItem};

    static PyGetSetDef getset_InkToolbarFlyoutItem_Static[] = {
        { "is_checked_property", reinterpret_cast<getter>(InkToolbarFlyoutItem_get_IsCheckedProperty), nullptr, nullptr, nullptr },
        { "kind_property", reinterpret_cast<getter>(InkToolbarFlyoutItem_get_KindProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_InkToolbarFlyoutItem_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarFlyoutItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarFlyoutItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarFlyoutItem_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarFlyoutItem_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarFlyoutItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_InkToolbarFlyoutItem_Static
    };

    // ----- InkToolbarHighlighterButton class --------------------

    struct PyWinrtInkToolbarHighlighterButton;
    using BasePyWinrtInkToolbarHighlighterButton = winrt::Windows::UI::Xaml::Controls::InkToolbarHighlighterButtonT<PyWinrtInkToolbarHighlighterButton, py::IPywinrtObject>;

    struct PyWinrtInkToolbarHighlighterButton : py::py_obj_ref, BasePyWinrtInkToolbarHighlighterButton
    {
        PyWinrtInkToolbarHighlighterButton(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtInkToolbarHighlighterButton() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtInkToolbarHighlighterButton* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_InkToolbarHighlighterButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::InkToolbarHighlighterButton>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtInkToolbarHighlighterButton>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::InkToolbarHighlighterButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkToolbarHighlighterButton(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_InkToolbarHighlighterButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarHighlighterButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarHighlighterButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarHighlighterButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarHighlighterButton[] = {
        { "_assign_array_", _assign_array_InkToolbarHighlighterButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarHighlighterButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarHighlighterButton[] = {
        { }
    };

    static PyType_Slot _type_slots_InkToolbarHighlighterButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarHighlighterButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarHighlighterButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarHighlighterButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarHighlighterButton) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarHighlighterButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarHighlighterButton",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_InkToolbarHighlighterButton};

    static PyGetSetDef getset_InkToolbarHighlighterButton_Static[] = {
        { }
    };

    static PyMethodDef methods_InkToolbarHighlighterButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarHighlighterButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarHighlighterButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarHighlighterButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarHighlighterButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarHighlighterButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_InkToolbarHighlighterButton_Static
    };

    // ----- InkToolbarMenuButton class --------------------

    static PyObject* _new_InkToolbarMenuButton(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::InkToolbarMenuButton>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::InkToolbarMenuButton>::type_name);
        return nullptr;
    }

    static void _dealloc_InkToolbarMenuButton(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkToolbarMenuButton_get_IsExtensionGlyphShown(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarMenuButton", L"IsExtensionGlyphShown");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarMenuButton>().IsExtensionGlyphShown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarMenuButton_put_IsExtensionGlyphShown(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarMenuButton", L"IsExtensionGlyphShown");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarMenuButton>().IsExtensionGlyphShown(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarMenuButton_get_MenuKind(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarMenuButton", L"MenuKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarMenuButton>().MenuKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarMenuButton_get_IsExtensionGlyphShownProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarMenuButton", L"IsExtensionGlyphShownProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarMenuButton::IsExtensionGlyphShownProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkToolbarMenuButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarMenuButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarMenuButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarMenuButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarMenuButton[] = {
        { "_assign_array_", _assign_array_InkToolbarMenuButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarMenuButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarMenuButton[] = {
        { "is_extension_glyph_shown", reinterpret_cast<getter>(InkToolbarMenuButton_get_IsExtensionGlyphShown), reinterpret_cast<setter>(InkToolbarMenuButton_put_IsExtensionGlyphShown), nullptr, nullptr },
        { "menu_kind", reinterpret_cast<getter>(InkToolbarMenuButton_get_MenuKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkToolbarMenuButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarMenuButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarMenuButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarMenuButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarMenuButton) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarMenuButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarMenuButton",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_InkToolbarMenuButton};

    static PyGetSetDef getset_InkToolbarMenuButton_Static[] = {
        { "is_extension_glyph_shown_property", reinterpret_cast<getter>(InkToolbarMenuButton_get_IsExtensionGlyphShownProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_InkToolbarMenuButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarMenuButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarMenuButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarMenuButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarMenuButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarMenuButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_InkToolbarMenuButton_Static
    };

    // ----- InkToolbarPenButton class --------------------

    static PyObject* _new_InkToolbarPenButton(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton>::type_name);
        return nullptr;
    }

    static void _dealloc_InkToolbarPenButton(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkToolbarPenButton_get_SelectedStrokeWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"SelectedStrokeWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton>().SelectedStrokeWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarPenButton_put_SelectedStrokeWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"SelectedStrokeWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton>().SelectedStrokeWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarPenButton_get_SelectedBrushIndex(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"SelectedBrushIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton>().SelectedBrushIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarPenButton_put_SelectedBrushIndex(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"SelectedBrushIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton>().SelectedBrushIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarPenButton_get_Palette(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"Palette");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton>().Palette());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarPenButton_put_Palette(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"Palette");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::UI::Xaml::Media::Brush>>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton>().Palette(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarPenButton_get_MinStrokeWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"MinStrokeWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton>().MinStrokeWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarPenButton_put_MinStrokeWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"MinStrokeWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton>().MinStrokeWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarPenButton_get_MaxStrokeWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"MaxStrokeWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton>().MaxStrokeWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarPenButton_put_MaxStrokeWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"MaxStrokeWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton>().MaxStrokeWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarPenButton_get_SelectedBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"SelectedBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton>().SelectedBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarPenButton_get_MaxStrokeWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"MaxStrokeWidthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton::MaxStrokeWidthProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarPenButton_get_MinStrokeWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"MinStrokeWidthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton::MinStrokeWidthProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarPenButton_get_PaletteProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"PaletteProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton::PaletteProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarPenButton_get_SelectedBrushIndexProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"SelectedBrushIndexProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton::SelectedBrushIndexProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarPenButton_get_SelectedBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"SelectedBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton::SelectedBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarPenButton_get_SelectedStrokeWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"SelectedStrokeWidthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton::SelectedStrokeWidthProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkToolbarPenButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarPenButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarPenButton[] = {
        { "_assign_array_", _assign_array_InkToolbarPenButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarPenButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarPenButton[] = {
        { "selected_stroke_width", reinterpret_cast<getter>(InkToolbarPenButton_get_SelectedStrokeWidth), reinterpret_cast<setter>(InkToolbarPenButton_put_SelectedStrokeWidth), nullptr, nullptr },
        { "selected_brush_index", reinterpret_cast<getter>(InkToolbarPenButton_get_SelectedBrushIndex), reinterpret_cast<setter>(InkToolbarPenButton_put_SelectedBrushIndex), nullptr, nullptr },
        { "palette", reinterpret_cast<getter>(InkToolbarPenButton_get_Palette), reinterpret_cast<setter>(InkToolbarPenButton_put_Palette), nullptr, nullptr },
        { "min_stroke_width", reinterpret_cast<getter>(InkToolbarPenButton_get_MinStrokeWidth), reinterpret_cast<setter>(InkToolbarPenButton_put_MinStrokeWidth), nullptr, nullptr },
        { "max_stroke_width", reinterpret_cast<getter>(InkToolbarPenButton_get_MaxStrokeWidth), reinterpret_cast<setter>(InkToolbarPenButton_put_MaxStrokeWidth), nullptr, nullptr },
        { "selected_brush", reinterpret_cast<getter>(InkToolbarPenButton_get_SelectedBrush), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkToolbarPenButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarPenButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarPenButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarPenButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarPenButton) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarPenButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarPenButton",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_InkToolbarPenButton};

    static PyGetSetDef getset_InkToolbarPenButton_Static[] = {
        { "max_stroke_width_property", reinterpret_cast<getter>(InkToolbarPenButton_get_MaxStrokeWidthProperty), nullptr, nullptr, nullptr },
        { "min_stroke_width_property", reinterpret_cast<getter>(InkToolbarPenButton_get_MinStrokeWidthProperty), nullptr, nullptr, nullptr },
        { "palette_property", reinterpret_cast<getter>(InkToolbarPenButton_get_PaletteProperty), nullptr, nullptr, nullptr },
        { "selected_brush_index_property", reinterpret_cast<getter>(InkToolbarPenButton_get_SelectedBrushIndexProperty), nullptr, nullptr, nullptr },
        { "selected_brush_property", reinterpret_cast<getter>(InkToolbarPenButton_get_SelectedBrushProperty), nullptr, nullptr, nullptr },
        { "selected_stroke_width_property", reinterpret_cast<getter>(InkToolbarPenButton_get_SelectedStrokeWidthProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_InkToolbarPenButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarPenButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarPenButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarPenButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarPenButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarPenButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_InkToolbarPenButton_Static
    };

    // ----- InkToolbarPencilButton class --------------------

    struct PyWinrtInkToolbarPencilButton;
    using BasePyWinrtInkToolbarPencilButton = winrt::Windows::UI::Xaml::Controls::InkToolbarPencilButtonT<PyWinrtInkToolbarPencilButton, py::IPywinrtObject>;

    struct PyWinrtInkToolbarPencilButton : py::py_obj_ref, BasePyWinrtInkToolbarPencilButton
    {
        PyWinrtInkToolbarPencilButton(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtInkToolbarPencilButton() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtInkToolbarPencilButton* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_InkToolbarPencilButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::InkToolbarPencilButton>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtInkToolbarPencilButton>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::InkToolbarPencilButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkToolbarPencilButton(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_InkToolbarPencilButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarPencilButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarPencilButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarPencilButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarPencilButton[] = {
        { "_assign_array_", _assign_array_InkToolbarPencilButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarPencilButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarPencilButton[] = {
        { }
    };

    static PyType_Slot _type_slots_InkToolbarPencilButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarPencilButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarPencilButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarPencilButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarPencilButton) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarPencilButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarPencilButton",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_InkToolbarPencilButton};

    static PyGetSetDef getset_InkToolbarPencilButton_Static[] = {
        { }
    };

    static PyMethodDef methods_InkToolbarPencilButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarPencilButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarPencilButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarPencilButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarPencilButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarPencilButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_InkToolbarPencilButton_Static
    };

    // ----- InkToolbarRulerButton class --------------------

    struct PyWinrtInkToolbarRulerButton;
    using BasePyWinrtInkToolbarRulerButton = winrt::Windows::UI::Xaml::Controls::InkToolbarRulerButtonT<PyWinrtInkToolbarRulerButton, py::IPywinrtObject>;

    struct PyWinrtInkToolbarRulerButton : py::py_obj_ref, BasePyWinrtInkToolbarRulerButton
    {
        PyWinrtInkToolbarRulerButton(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtInkToolbarRulerButton() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtInkToolbarRulerButton* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_InkToolbarRulerButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::InkToolbarRulerButton>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtInkToolbarRulerButton>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::InkToolbarRulerButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkToolbarRulerButton(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkToolbarRulerButton_get_Ruler(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarRulerButton", L"Ruler");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarRulerButton>().Ruler());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarRulerButton_get_RulerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarRulerButton", L"RulerProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarRulerButton::RulerProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkToolbarRulerButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarRulerButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarRulerButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarRulerButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarRulerButton[] = {
        { "_assign_array_", _assign_array_InkToolbarRulerButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarRulerButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarRulerButton[] = {
        { "ruler", reinterpret_cast<getter>(InkToolbarRulerButton_get_Ruler), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkToolbarRulerButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarRulerButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarRulerButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarRulerButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarRulerButton) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarRulerButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarRulerButton",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_InkToolbarRulerButton};

    static PyGetSetDef getset_InkToolbarRulerButton_Static[] = {
        { "ruler_property", reinterpret_cast<getter>(InkToolbarRulerButton_get_RulerProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_InkToolbarRulerButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarRulerButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarRulerButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarRulerButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarRulerButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarRulerButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_InkToolbarRulerButton_Static
    };

    // ----- InkToolbarStencilButton class --------------------

    struct PyWinrtInkToolbarStencilButton;
    using BasePyWinrtInkToolbarStencilButton = winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButtonT<PyWinrtInkToolbarStencilButton, py::IPywinrtObject>;

    struct PyWinrtInkToolbarStencilButton : py::py_obj_ref, BasePyWinrtInkToolbarStencilButton
    {
        PyWinrtInkToolbarStencilButton(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtInkToolbarStencilButton() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtInkToolbarStencilButton* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_InkToolbarStencilButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButton>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtInkToolbarStencilButton>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkToolbarStencilButton(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkToolbarStencilButton_get_SelectedStencil(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"SelectedStencil");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButton>().SelectedStencil());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarStencilButton_put_SelectedStencil(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"SelectedStencil");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::InkToolbarStencilKind>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButton>().SelectedStencil(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarStencilButton_get_IsRulerItemVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"IsRulerItemVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButton>().IsRulerItemVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarStencilButton_put_IsRulerItemVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"IsRulerItemVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButton>().IsRulerItemVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarStencilButton_get_IsProtractorItemVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"IsProtractorItemVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButton>().IsProtractorItemVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarStencilButton_put_IsProtractorItemVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"IsProtractorItemVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButton>().IsProtractorItemVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarStencilButton_get_Protractor(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"Protractor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButton>().Protractor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarStencilButton_get_Ruler(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"Ruler");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButton>().Ruler());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarStencilButton_get_IsProtractorItemVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"IsProtractorItemVisibleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButton::IsProtractorItemVisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarStencilButton_get_IsRulerItemVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"IsRulerItemVisibleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButton::IsRulerItemVisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarStencilButton_get_ProtractorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"ProtractorProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButton::ProtractorProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarStencilButton_get_RulerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"RulerProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButton::RulerProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarStencilButton_get_SelectedStencilProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"SelectedStencilProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButton::SelectedStencilProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkToolbarStencilButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarStencilButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarStencilButton[] = {
        { "_assign_array_", _assign_array_InkToolbarStencilButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarStencilButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarStencilButton[] = {
        { "selected_stencil", reinterpret_cast<getter>(InkToolbarStencilButton_get_SelectedStencil), reinterpret_cast<setter>(InkToolbarStencilButton_put_SelectedStencil), nullptr, nullptr },
        { "is_ruler_item_visible", reinterpret_cast<getter>(InkToolbarStencilButton_get_IsRulerItemVisible), reinterpret_cast<setter>(InkToolbarStencilButton_put_IsRulerItemVisible), nullptr, nullptr },
        { "is_protractor_item_visible", reinterpret_cast<getter>(InkToolbarStencilButton_get_IsProtractorItemVisible), reinterpret_cast<setter>(InkToolbarStencilButton_put_IsProtractorItemVisible), nullptr, nullptr },
        { "protractor", reinterpret_cast<getter>(InkToolbarStencilButton_get_Protractor), nullptr, nullptr, nullptr },
        { "ruler", reinterpret_cast<getter>(InkToolbarStencilButton_get_Ruler), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkToolbarStencilButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarStencilButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarStencilButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarStencilButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarStencilButton) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarStencilButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarStencilButton",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_InkToolbarStencilButton};

    static PyGetSetDef getset_InkToolbarStencilButton_Static[] = {
        { "is_protractor_item_visible_property", reinterpret_cast<getter>(InkToolbarStencilButton_get_IsProtractorItemVisibleProperty), nullptr, nullptr, nullptr },
        { "is_ruler_item_visible_property", reinterpret_cast<getter>(InkToolbarStencilButton_get_IsRulerItemVisibleProperty), nullptr, nullptr, nullptr },
        { "protractor_property", reinterpret_cast<getter>(InkToolbarStencilButton_get_ProtractorProperty), nullptr, nullptr, nullptr },
        { "ruler_property", reinterpret_cast<getter>(InkToolbarStencilButton_get_RulerProperty), nullptr, nullptr, nullptr },
        { "selected_stencil_property", reinterpret_cast<getter>(InkToolbarStencilButton_get_SelectedStencilProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_InkToolbarStencilButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarStencilButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarStencilButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarStencilButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarStencilButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarStencilButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_InkToolbarStencilButton_Static
    };

    // ----- InkToolbarToggleButton class --------------------

    static PyObject* _new_InkToolbarToggleButton(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::InkToolbarToggleButton>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::InkToolbarToggleButton>::type_name);
        return nullptr;
    }

    static void _dealloc_InkToolbarToggleButton(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkToolbarToggleButton_get_ToggleKind(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarToggleButton", L"ToggleKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarToggleButton>().ToggleKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkToolbarToggleButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarToggleButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarToggleButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarToggleButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarToggleButton[] = {
        { "_assign_array_", _assign_array_InkToolbarToggleButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarToggleButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarToggleButton[] = {
        { "toggle_kind", reinterpret_cast<getter>(InkToolbarToggleButton_get_ToggleKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkToolbarToggleButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarToggleButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarToggleButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarToggleButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarToggleButton) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarToggleButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarToggleButton",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_InkToolbarToggleButton};

    static PyGetSetDef getset_InkToolbarToggleButton_Static[] = {
        { }
    };

    static PyMethodDef methods_InkToolbarToggleButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarToggleButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarToggleButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarToggleButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarToggleButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarToggleButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_InkToolbarToggleButton_Static
    };

    // ----- InkToolbarToolButton class --------------------

    static PyObject* _new_InkToolbarToolButton(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::InkToolbarToolButton>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::InkToolbarToolButton>::type_name);
        return nullptr;
    }

    static void _dealloc_InkToolbarToolButton(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkToolbarToolButton_get_IsExtensionGlyphShown(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarToolButton", L"IsExtensionGlyphShown");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarToolButton>().IsExtensionGlyphShown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarToolButton_put_IsExtensionGlyphShown(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarToolButton", L"IsExtensionGlyphShown");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarToolButton>().IsExtensionGlyphShown(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarToolButton_get_ToolKind(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarToolButton", L"ToolKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::InkToolbarToolButton>().ToolKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarToolButton_get_IsExtensionGlyphShownProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarToolButton", L"IsExtensionGlyphShownProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarToolButton::IsExtensionGlyphShownProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkToolbarToolButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarToolButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarToolButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarToolButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarToolButton[] = {
        { "_assign_array_", _assign_array_InkToolbarToolButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarToolButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarToolButton[] = {
        { "is_extension_glyph_shown", reinterpret_cast<getter>(InkToolbarToolButton_get_IsExtensionGlyphShown), reinterpret_cast<setter>(InkToolbarToolButton_put_IsExtensionGlyphShown), nullptr, nullptr },
        { "tool_kind", reinterpret_cast<getter>(InkToolbarToolButton_get_ToolKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkToolbarToolButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarToolButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarToolButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarToolButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarToolButton) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarToolButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarToolButton",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_InkToolbarToolButton};

    static PyGetSetDef getset_InkToolbarToolButton_Static[] = {
        { "is_extension_glyph_shown_property", reinterpret_cast<getter>(InkToolbarToolButton_get_IsExtensionGlyphShownProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_InkToolbarToolButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarToolButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarToolButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarToolButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarToolButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.InkToolbarToolButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_InkToolbarToolButton_Static
    };

    // ----- ListBox class --------------------

    struct PyWinrtListBox;
    using BasePyWinrtListBox = winrt::Windows::UI::Xaml::Controls::ListBoxT<PyWinrtListBox, py::IPywinrtObject>;

    struct PyWinrtListBox : py::py_obj_ref, BasePyWinrtListBox
    {
        PyWinrtListBox(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtListBox() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtListBox* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ListBox(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::ListBox>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtListBox>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::ListBox instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListBox(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ListBox_ScrollIntoView(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListBox", L"ScrollIntoView", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListBox>().ScrollIntoView(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListBox_SelectAll(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListBox", L"SelectAll", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListBox>().SelectAll();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListBox_get_SelectionMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListBox", L"SelectionMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListBox>().SelectionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListBox_put_SelectionMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListBox", L"SelectionMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SelectionMode>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListBox>().SelectionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListBox_get_SelectedItems(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListBox", L"SelectedItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListBox>().SelectedItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListBox_get_SingleSelectionFollowsFocus(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListBox", L"SingleSelectionFollowsFocus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListBox>().SingleSelectionFollowsFocus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListBox_put_SingleSelectionFollowsFocus(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListBox", L"SingleSelectionFollowsFocus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListBox>().SingleSelectionFollowsFocus(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListBox_get_SelectionModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListBox", L"SelectionModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListBox::SelectionModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListBox_get_SingleSelectionFollowsFocusProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListBox", L"SingleSelectionFollowsFocusProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListBox::SingleSelectionFollowsFocusProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ListBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::ListBox>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::ListBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListBox[] = {
        { "scroll_into_view", reinterpret_cast<PyCFunction>(ListBox_ScrollIntoView), METH_VARARGS, nullptr },
        { "select_all", reinterpret_cast<PyCFunction>(ListBox_SelectAll), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ListBox, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListBox), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListBox[] = {
        { "selection_mode", reinterpret_cast<getter>(ListBox_get_SelectionMode), reinterpret_cast<setter>(ListBox_put_SelectionMode), nullptr, nullptr },
        { "selected_items", reinterpret_cast<getter>(ListBox_get_SelectedItems), nullptr, nullptr, nullptr },
        { "single_selection_follows_focus", reinterpret_cast<getter>(ListBox_get_SingleSelectionFollowsFocus), reinterpret_cast<setter>(ListBox_put_SingleSelectionFollowsFocus), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ListBox[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListBox) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListBox) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListBox) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListBox) },
        { }
    };

    static PyType_Spec type_spec_ListBox = {
        "winrt._winrt_windows_ui_xaml_controls_2.ListBox",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ListBox};

    static PyGetSetDef getset_ListBox_Static[] = {
        { "selection_mode_property", reinterpret_cast<getter>(ListBox_get_SelectionModeProperty), nullptr, nullptr, nullptr },
        { "single_selection_follows_focus_property", reinterpret_cast<getter>(ListBox_get_SingleSelectionFollowsFocusProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ListBox_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListBox_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListBox_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListBox_Static) },
        { }
    };

    static PyType_Spec type_spec_ListBox_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.ListBox_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ListBox_Static
    };

    // ----- ListBoxItem class --------------------

    struct PyWinrtListBoxItem;
    using BasePyWinrtListBoxItem = winrt::Windows::UI::Xaml::Controls::ListBoxItemT<PyWinrtListBoxItem, py::IPywinrtObject>;

    struct PyWinrtListBoxItem : py::py_obj_ref, BasePyWinrtListBoxItem
    {
        PyWinrtListBoxItem(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtListBoxItem() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtListBoxItem* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ListBoxItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::ListBoxItem>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtListBoxItem>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::ListBoxItem instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListBoxItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListBoxItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::ListBoxItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListBoxItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::ListBoxItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListBoxItem[] = {
        { "_assign_array_", _assign_array_ListBoxItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListBoxItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListBoxItem[] = {
        { }
    };

    static PyType_Slot _type_slots_ListBoxItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListBoxItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListBoxItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListBoxItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListBoxItem) },
        { }
    };

    static PyType_Spec type_spec_ListBoxItem = {
        "winrt._winrt_windows_ui_xaml_controls_2.ListBoxItem",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ListBoxItem};

    static PyGetSetDef getset_ListBoxItem_Static[] = {
        { }
    };

    static PyMethodDef methods_ListBoxItem_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListBoxItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListBoxItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListBoxItem_Static) },
        { }
    };

    static PyType_Spec type_spec_ListBoxItem_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.ListBoxItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ListBoxItem_Static
    };

    // ----- ListPickerFlyout class --------------------

    static PyObject* _new_ListPickerFlyout(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::ListPickerFlyout instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListPickerFlyout(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ListPickerFlyout_ShowAtAsync(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"ShowAtAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::FrameworkElement>(args, 0);

                return py::convert(self->obj.ShowAtAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListPickerFlyout_get_SelectionMode(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"SelectionMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListPickerFlyout_put_SelectionMode(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"SelectionMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ListPickerFlyoutSelectionMode>(arg);

            self->obj.SelectionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListPickerFlyout_get_SelectedValuePath(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"SelectedValuePath");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedValuePath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListPickerFlyout_put_SelectedValuePath(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"SelectedValuePath");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SelectedValuePath(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListPickerFlyout_get_SelectedValue(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"SelectedValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListPickerFlyout_put_SelectedValue(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"SelectedValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.SelectedValue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListPickerFlyout_get_SelectedItem(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"SelectedItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListPickerFlyout_put_SelectedItem(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"SelectedItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.SelectedItem(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListPickerFlyout_get_SelectedIndex(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"SelectedIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListPickerFlyout_put_SelectedIndex(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"SelectedIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.SelectedIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListPickerFlyout_get_ItemsSource(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"ItemsSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ItemsSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListPickerFlyout_put_ItemsSource(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"ItemsSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.ItemsSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListPickerFlyout_get_ItemTemplate(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"ItemTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ItemTemplate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListPickerFlyout_put_ItemTemplate(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"ItemTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DataTemplate>(arg);

            self->obj.ItemTemplate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListPickerFlyout_get_DisplayMemberPath(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"DisplayMemberPath");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayMemberPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListPickerFlyout_put_DisplayMemberPath(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"DisplayMemberPath");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayMemberPath(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListPickerFlyout_get_SelectedItems(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"SelectedItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListPickerFlyout_get_DisplayMemberPathProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"DisplayMemberPathProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListPickerFlyout::DisplayMemberPathProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListPickerFlyout_get_ItemTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"ItemTemplateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListPickerFlyout::ItemTemplateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListPickerFlyout_get_ItemsSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"ItemsSourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListPickerFlyout::ItemsSourceProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListPickerFlyout_get_SelectedIndexProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"SelectedIndexProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListPickerFlyout::SelectedIndexProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListPickerFlyout_get_SelectedItemProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"SelectedItemProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListPickerFlyout::SelectedItemProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListPickerFlyout_get_SelectedValuePathProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"SelectedValuePathProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListPickerFlyout::SelectedValuePathProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListPickerFlyout_get_SelectedValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"SelectedValueProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListPickerFlyout::SelectedValueProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListPickerFlyout_get_SelectionModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"SelectionModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListPickerFlyout::SelectionModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListPickerFlyout_add_ItemsPicked(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"ItemsPicked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::ListPickerFlyout, winrt::Windows::UI::Xaml::Controls::ItemsPickedEventArgs>>(arg);

            return py::convert(self->obj.ItemsPicked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListPickerFlyout_remove_ItemsPicked(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"ItemsPicked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ItemsPicked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ListPickerFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::ListPickerFlyout>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListPickerFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::ListPickerFlyout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListPickerFlyout[] = {
        { "show_at_async", reinterpret_cast<PyCFunction>(ListPickerFlyout_ShowAtAsync), METH_VARARGS, nullptr },
        { "add_items_picked", reinterpret_cast<PyCFunction>(ListPickerFlyout_add_ItemsPicked), METH_O, nullptr },
        { "remove_items_picked", reinterpret_cast<PyCFunction>(ListPickerFlyout_remove_ItemsPicked), METH_O, nullptr },
        { "_assign_array_", _assign_array_ListPickerFlyout, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListPickerFlyout), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListPickerFlyout[] = {
        { "selection_mode", reinterpret_cast<getter>(ListPickerFlyout_get_SelectionMode), reinterpret_cast<setter>(ListPickerFlyout_put_SelectionMode), nullptr, nullptr },
        { "selected_value_path", reinterpret_cast<getter>(ListPickerFlyout_get_SelectedValuePath), reinterpret_cast<setter>(ListPickerFlyout_put_SelectedValuePath), nullptr, nullptr },
        { "selected_value", reinterpret_cast<getter>(ListPickerFlyout_get_SelectedValue), reinterpret_cast<setter>(ListPickerFlyout_put_SelectedValue), nullptr, nullptr },
        { "selected_item", reinterpret_cast<getter>(ListPickerFlyout_get_SelectedItem), reinterpret_cast<setter>(ListPickerFlyout_put_SelectedItem), nullptr, nullptr },
        { "selected_index", reinterpret_cast<getter>(ListPickerFlyout_get_SelectedIndex), reinterpret_cast<setter>(ListPickerFlyout_put_SelectedIndex), nullptr, nullptr },
        { "items_source", reinterpret_cast<getter>(ListPickerFlyout_get_ItemsSource), reinterpret_cast<setter>(ListPickerFlyout_put_ItemsSource), nullptr, nullptr },
        { "item_template", reinterpret_cast<getter>(ListPickerFlyout_get_ItemTemplate), reinterpret_cast<setter>(ListPickerFlyout_put_ItemTemplate), nullptr, nullptr },
        { "display_member_path", reinterpret_cast<getter>(ListPickerFlyout_get_DisplayMemberPath), reinterpret_cast<setter>(ListPickerFlyout_put_DisplayMemberPath), nullptr, nullptr },
        { "selected_items", reinterpret_cast<getter>(ListPickerFlyout_get_SelectedItems), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ListPickerFlyout[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListPickerFlyout) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListPickerFlyout) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListPickerFlyout) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListPickerFlyout) },
        { }
    };

    static PyType_Spec type_spec_ListPickerFlyout = {
        "winrt._winrt_windows_ui_xaml_controls_2.ListPickerFlyout",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListPickerFlyout};

    static PyGetSetDef getset_ListPickerFlyout_Static[] = {
        { "display_member_path_property", reinterpret_cast<getter>(ListPickerFlyout_get_DisplayMemberPathProperty), nullptr, nullptr, nullptr },
        { "item_template_property", reinterpret_cast<getter>(ListPickerFlyout_get_ItemTemplateProperty), nullptr, nullptr, nullptr },
        { "items_source_property", reinterpret_cast<getter>(ListPickerFlyout_get_ItemsSourceProperty), nullptr, nullptr, nullptr },
        { "selected_index_property", reinterpret_cast<getter>(ListPickerFlyout_get_SelectedIndexProperty), nullptr, nullptr, nullptr },
        { "selected_item_property", reinterpret_cast<getter>(ListPickerFlyout_get_SelectedItemProperty), nullptr, nullptr, nullptr },
        { "selected_value_path_property", reinterpret_cast<getter>(ListPickerFlyout_get_SelectedValuePathProperty), nullptr, nullptr, nullptr },
        { "selected_value_property", reinterpret_cast<getter>(ListPickerFlyout_get_SelectedValueProperty), nullptr, nullptr, nullptr },
        { "selection_mode_property", reinterpret_cast<getter>(ListPickerFlyout_get_SelectionModeProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ListPickerFlyout_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListPickerFlyout_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListPickerFlyout_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListPickerFlyout_Static) },
        { }
    };

    static PyType_Spec type_spec_ListPickerFlyout_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.ListPickerFlyout_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ListPickerFlyout_Static
    };

    // ----- ListView class --------------------

    struct PyWinrtListView;
    using BasePyWinrtListView = winrt::Windows::UI::Xaml::Controls::ListViewT<PyWinrtListView, py::IPywinrtObject>;

    struct PyWinrtListView : py::py_obj_ref, BasePyWinrtListView
    {
        PyWinrtListView(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtListView() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtListView* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ListView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::ListView>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtListView>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::ListView instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListView(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::ListView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::ListView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListView[] = {
        { "_assign_array_", _assign_array_ListView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListView[] = {
        { }
    };

    static PyType_Slot _type_slots_ListView[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListView) },
        { }
    };

    static PyType_Spec type_spec_ListView = {
        "winrt._winrt_windows_ui_xaml_controls_2.ListView",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ListView};

    static PyGetSetDef getset_ListView_Static[] = {
        { }
    };

    static PyMethodDef methods_ListView_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListView_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListView_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListView_Static) },
        { }
    };

    static PyType_Spec type_spec_ListView_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.ListView_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ListView_Static
    };

    // ----- ListViewBase class --------------------

    struct PyWinrtListViewBase;
    using BasePyWinrtListViewBase = winrt::Windows::UI::Xaml::Controls::ListViewBaseT<PyWinrtListViewBase, py::IPywinrtObject>;

    struct PyWinrtListViewBase : py::py_obj_ref, BasePyWinrtListViewBase
    {

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtListViewBase* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ListViewBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::ListViewBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::ListViewBase>::type_name);
        return nullptr;
    }

    static void _dealloc_ListViewBase(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ListViewBase_CompleteViewChange(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"CompleteViewChange", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().CompleteViewChange();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_CompleteViewChangeFrom(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"CompleteViewChangeFrom", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SemanticZoomLocation>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SemanticZoomLocation>(args, 1);

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().CompleteViewChangeFrom(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_CompleteViewChangeTo(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"CompleteViewChangeTo", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SemanticZoomLocation>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SemanticZoomLocation>(args, 1);

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().CompleteViewChangeTo(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_DeselectRange(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"DeselectRange", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Data::ItemIndexRange>(args, 0);

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().DeselectRange(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_InitializeViewChange(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"InitializeViewChange", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().InitializeViewChange();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_IsDragSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsDragSource", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().IsDragSource());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_LoadMoreItemsAsync(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"LoadMoreItemsAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().LoadMoreItemsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_MakeVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"MakeVisible", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SemanticZoomLocation>(args, 0);

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().MakeVisible(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_PrepareConnectedAnimation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"PrepareConnectedAnimation", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().PrepareConnectedAnimation(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_ScrollIntoView(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ScrollIntoView", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().ScrollIntoView(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_ScrollIntoViewWithAlignment(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ScrollIntoView", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ScrollIntoViewAlignment>(args, 1);

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().ScrollIntoView(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_SelectAll(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SelectAll", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().SelectAll();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_SelectRange(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SelectRange", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Data::ItemIndexRange>(args, 0);

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().SelectRange(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_SetDesiredContainerUpdateDuration(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SetDesiredContainerUpdateDuration", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().SetDesiredContainerUpdateDuration(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_StartViewChangeFrom(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"StartViewChangeFrom", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SemanticZoomLocation>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SemanticZoomLocation>(args, 1);

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().StartViewChangeFrom(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_StartViewChangeTo(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"StartViewChangeTo", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SemanticZoomLocation>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SemanticZoomLocation>(args, 1);

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().StartViewChangeTo(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_TryStartConnectedAnimationAsync(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"TryStartConnectedAnimationAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::ConnectedAnimation>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().TryStartConnectedAnimationAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_SelectionMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SelectionMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().SelectionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_SelectionMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SelectionMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ListViewSelectionMode>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().SelectionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_IsSwipeEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsSwipeEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().IsSwipeEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_IsSwipeEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsSwipeEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().IsSwipeEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_IsItemClickEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsItemClickEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().IsItemClickEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_IsItemClickEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsItemClickEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().IsItemClickEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_IncrementalLoadingTrigger(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IncrementalLoadingTrigger");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().IncrementalLoadingTrigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_IncrementalLoadingTrigger(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IncrementalLoadingTrigger");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::IncrementalLoadingTrigger>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().IncrementalLoadingTrigger(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_IncrementalLoadingThreshold(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IncrementalLoadingThreshold");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().IncrementalLoadingThreshold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_IncrementalLoadingThreshold(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IncrementalLoadingThreshold");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().IncrementalLoadingThreshold(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_HeaderTransitions(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"HeaderTransitions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().HeaderTransitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_HeaderTransitions(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"HeaderTransitions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::TransitionCollection>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().HeaderTransitions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_HeaderTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"HeaderTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().HeaderTemplate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_HeaderTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"HeaderTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DataTemplate>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().HeaderTemplate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_Header(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"Header");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().Header());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_Header(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"Header");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().Header(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_DataFetchSize(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"DataFetchSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().DataFetchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_DataFetchSize(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"DataFetchSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().DataFetchSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_CanReorderItems(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"CanReorderItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().CanReorderItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_CanReorderItems(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"CanReorderItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().CanReorderItems(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_CanDragItems(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"CanDragItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().CanDragItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_CanDragItems(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"CanDragItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().CanDragItems(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_SelectedItems(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SelectedItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().SelectedItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_ShowsScrollingPlaceholders(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ShowsScrollingPlaceholders");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().ShowsScrollingPlaceholders());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_ShowsScrollingPlaceholders(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ShowsScrollingPlaceholders");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().ShowsScrollingPlaceholders(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_FooterTransitions(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"FooterTransitions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().FooterTransitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_FooterTransitions(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"FooterTransitions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::TransitionCollection>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().FooterTransitions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_FooterTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"FooterTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().FooterTemplate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_FooterTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"FooterTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DataTemplate>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().FooterTemplate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_Footer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"Footer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().Footer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_Footer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"Footer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().Footer(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_ReorderMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ReorderMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().ReorderMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_ReorderMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ReorderMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ListViewReorderMode>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().ReorderMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_IsMultiSelectCheckBoxEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsMultiSelectCheckBoxEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().IsMultiSelectCheckBoxEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_IsMultiSelectCheckBoxEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsMultiSelectCheckBoxEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().IsMultiSelectCheckBoxEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_SelectedRanges(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SelectedRanges");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().SelectedRanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_SingleSelectionFollowsFocus(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SingleSelectionFollowsFocus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().SingleSelectionFollowsFocus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_SingleSelectionFollowsFocus(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SingleSelectionFollowsFocus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().SingleSelectionFollowsFocus(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_SemanticZoomOwner(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SemanticZoomOwner");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().SemanticZoomOwner());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_SemanticZoomOwner(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SemanticZoomOwner");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SemanticZoom>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().SemanticZoomOwner(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_IsZoomedInView(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsZoomedInView");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().IsZoomedInView());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_IsZoomedInView(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsZoomedInView");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().IsZoomedInView(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_IsActiveView(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsActiveView");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().IsActiveView());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_IsActiveView(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsActiveView");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().IsActiveView(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_CanDragItemsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"CanDragItemsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::CanDragItemsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_CanReorderItemsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"CanReorderItemsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::CanReorderItemsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_DataFetchSizeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"DataFetchSizeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::DataFetchSizeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_HeaderProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"HeaderProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::HeaderProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_HeaderTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"HeaderTemplateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::HeaderTemplateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_HeaderTransitionsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"HeaderTransitionsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::HeaderTransitionsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_IncrementalLoadingThresholdProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IncrementalLoadingThresholdProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::IncrementalLoadingThresholdProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_IncrementalLoadingTriggerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IncrementalLoadingTriggerProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::IncrementalLoadingTriggerProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_IsActiveViewProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsActiveViewProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::IsActiveViewProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_IsItemClickEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsItemClickEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::IsItemClickEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_IsSwipeEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsSwipeEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::IsSwipeEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_IsZoomedInViewProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsZoomedInViewProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::IsZoomedInViewProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_SelectionModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SelectionModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::SelectionModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_SemanticZoomOwnerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SemanticZoomOwnerProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::SemanticZoomOwnerProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_FooterProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"FooterProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::FooterProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_FooterTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"FooterTemplateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::FooterTemplateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_FooterTransitionsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"FooterTransitionsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::FooterTransitionsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_ShowsScrollingPlaceholdersProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ShowsScrollingPlaceholdersProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::ShowsScrollingPlaceholdersProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_ReorderModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ReorderModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::ReorderModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_IsMultiSelectCheckBoxEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsMultiSelectCheckBoxEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::IsMultiSelectCheckBoxEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_SingleSelectionFollowsFocusProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SingleSelectionFollowsFocusProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::SingleSelectionFollowsFocusProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_add_DragItemsStarting(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"DragItemsStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::DragItemsStartingEventHandler>(arg);

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().DragItemsStarting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_remove_DragItemsStarting(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"DragItemsStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().DragItemsStarting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_add_ItemClick(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ItemClick");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ItemClickEventHandler>(arg);

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().ItemClick(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_remove_ItemClick(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ItemClick");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().ItemClick(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_add_ContainerContentChanging(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ContainerContentChanging");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::ListViewBase, winrt::Windows::UI::Xaml::Controls::ContainerContentChangingEventArgs>>(arg);

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().ContainerContentChanging(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_remove_ContainerContentChanging(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ContainerContentChanging");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().ContainerContentChanging(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_add_ChoosingGroupHeaderContainer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ChoosingGroupHeaderContainer");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::ListViewBase, winrt::Windows::UI::Xaml::Controls::ChoosingGroupHeaderContainerEventArgs>>(arg);

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().ChoosingGroupHeaderContainer(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_remove_ChoosingGroupHeaderContainer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ChoosingGroupHeaderContainer");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().ChoosingGroupHeaderContainer(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_add_ChoosingItemContainer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ChoosingItemContainer");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::ListViewBase, winrt::Windows::UI::Xaml::Controls::ChoosingItemContainerEventArgs>>(arg);

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().ChoosingItemContainer(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_remove_ChoosingItemContainer(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ChoosingItemContainer");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().ChoosingItemContainer(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_add_DragItemsCompleted(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"DragItemsCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::ListViewBase, winrt::Windows::UI::Xaml::Controls::DragItemsCompletedEventArgs>>(arg);

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().DragItemsCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_remove_DragItemsCompleted(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"DragItemsCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewBase>().DragItemsCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ListViewBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::ListViewBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::ListViewBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewBase[] = {
        { "complete_view_change", reinterpret_cast<PyCFunction>(ListViewBase_CompleteViewChange), METH_VARARGS, nullptr },
        { "complete_view_change_from", reinterpret_cast<PyCFunction>(ListViewBase_CompleteViewChangeFrom), METH_VARARGS, nullptr },
        { "complete_view_change_to", reinterpret_cast<PyCFunction>(ListViewBase_CompleteViewChangeTo), METH_VARARGS, nullptr },
        { "deselect_range", reinterpret_cast<PyCFunction>(ListViewBase_DeselectRange), METH_VARARGS, nullptr },
        { "initialize_view_change", reinterpret_cast<PyCFunction>(ListViewBase_InitializeViewChange), METH_VARARGS, nullptr },
        { "is_drag_source", reinterpret_cast<PyCFunction>(ListViewBase_IsDragSource), METH_VARARGS, nullptr },
        { "load_more_items_async", reinterpret_cast<PyCFunction>(ListViewBase_LoadMoreItemsAsync), METH_VARARGS, nullptr },
        { "make_visible", reinterpret_cast<PyCFunction>(ListViewBase_MakeVisible), METH_VARARGS, nullptr },
        { "prepare_connected_animation", reinterpret_cast<PyCFunction>(ListViewBase_PrepareConnectedAnimation), METH_VARARGS, nullptr },
        { "scroll_into_view", reinterpret_cast<PyCFunction>(ListViewBase_ScrollIntoView), METH_VARARGS, nullptr },
        { "scroll_into_view_with_alignment", reinterpret_cast<PyCFunction>(ListViewBase_ScrollIntoViewWithAlignment), METH_VARARGS, nullptr },
        { "select_all", reinterpret_cast<PyCFunction>(ListViewBase_SelectAll), METH_VARARGS, nullptr },
        { "select_range", reinterpret_cast<PyCFunction>(ListViewBase_SelectRange), METH_VARARGS, nullptr },
        { "set_desired_container_update_duration", reinterpret_cast<PyCFunction>(ListViewBase_SetDesiredContainerUpdateDuration), METH_VARARGS, nullptr },
        { "start_view_change_from", reinterpret_cast<PyCFunction>(ListViewBase_StartViewChangeFrom), METH_VARARGS, nullptr },
        { "start_view_change_to", reinterpret_cast<PyCFunction>(ListViewBase_StartViewChangeTo), METH_VARARGS, nullptr },
        { "try_start_connected_animation_async", reinterpret_cast<PyCFunction>(ListViewBase_TryStartConnectedAnimationAsync), METH_VARARGS, nullptr },
        { "add_drag_items_starting", reinterpret_cast<PyCFunction>(ListViewBase_add_DragItemsStarting), METH_O, nullptr },
        { "remove_drag_items_starting", reinterpret_cast<PyCFunction>(ListViewBase_remove_DragItemsStarting), METH_O, nullptr },
        { "add_item_click", reinterpret_cast<PyCFunction>(ListViewBase_add_ItemClick), METH_O, nullptr },
        { "remove_item_click", reinterpret_cast<PyCFunction>(ListViewBase_remove_ItemClick), METH_O, nullptr },
        { "add_container_content_changing", reinterpret_cast<PyCFunction>(ListViewBase_add_ContainerContentChanging), METH_O, nullptr },
        { "remove_container_content_changing", reinterpret_cast<PyCFunction>(ListViewBase_remove_ContainerContentChanging), METH_O, nullptr },
        { "add_choosing_group_header_container", reinterpret_cast<PyCFunction>(ListViewBase_add_ChoosingGroupHeaderContainer), METH_O, nullptr },
        { "remove_choosing_group_header_container", reinterpret_cast<PyCFunction>(ListViewBase_remove_ChoosingGroupHeaderContainer), METH_O, nullptr },
        { "add_choosing_item_container", reinterpret_cast<PyCFunction>(ListViewBase_add_ChoosingItemContainer), METH_O, nullptr },
        { "remove_choosing_item_container", reinterpret_cast<PyCFunction>(ListViewBase_remove_ChoosingItemContainer), METH_O, nullptr },
        { "add_drag_items_completed", reinterpret_cast<PyCFunction>(ListViewBase_add_DragItemsCompleted), METH_O, nullptr },
        { "remove_drag_items_completed", reinterpret_cast<PyCFunction>(ListViewBase_remove_DragItemsCompleted), METH_O, nullptr },
        { "_assign_array_", _assign_array_ListViewBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewBase[] = {
        { "selection_mode", reinterpret_cast<getter>(ListViewBase_get_SelectionMode), reinterpret_cast<setter>(ListViewBase_put_SelectionMode), nullptr, nullptr },
        { "is_swipe_enabled", reinterpret_cast<getter>(ListViewBase_get_IsSwipeEnabled), reinterpret_cast<setter>(ListViewBase_put_IsSwipeEnabled), nullptr, nullptr },
        { "is_item_click_enabled", reinterpret_cast<getter>(ListViewBase_get_IsItemClickEnabled), reinterpret_cast<setter>(ListViewBase_put_IsItemClickEnabled), nullptr, nullptr },
        { "incremental_loading_trigger", reinterpret_cast<getter>(ListViewBase_get_IncrementalLoadingTrigger), reinterpret_cast<setter>(ListViewBase_put_IncrementalLoadingTrigger), nullptr, nullptr },
        { "incremental_loading_threshold", reinterpret_cast<getter>(ListViewBase_get_IncrementalLoadingThreshold), reinterpret_cast<setter>(ListViewBase_put_IncrementalLoadingThreshold), nullptr, nullptr },
        { "header_transitions", reinterpret_cast<getter>(ListViewBase_get_HeaderTransitions), reinterpret_cast<setter>(ListViewBase_put_HeaderTransitions), nullptr, nullptr },
        { "header_template", reinterpret_cast<getter>(ListViewBase_get_HeaderTemplate), reinterpret_cast<setter>(ListViewBase_put_HeaderTemplate), nullptr, nullptr },
        { "header", reinterpret_cast<getter>(ListViewBase_get_Header), reinterpret_cast<setter>(ListViewBase_put_Header), nullptr, nullptr },
        { "data_fetch_size", reinterpret_cast<getter>(ListViewBase_get_DataFetchSize), reinterpret_cast<setter>(ListViewBase_put_DataFetchSize), nullptr, nullptr },
        { "can_reorder_items", reinterpret_cast<getter>(ListViewBase_get_CanReorderItems), reinterpret_cast<setter>(ListViewBase_put_CanReorderItems), nullptr, nullptr },
        { "can_drag_items", reinterpret_cast<getter>(ListViewBase_get_CanDragItems), reinterpret_cast<setter>(ListViewBase_put_CanDragItems), nullptr, nullptr },
        { "selected_items", reinterpret_cast<getter>(ListViewBase_get_SelectedItems), nullptr, nullptr, nullptr },
        { "shows_scrolling_placeholders", reinterpret_cast<getter>(ListViewBase_get_ShowsScrollingPlaceholders), reinterpret_cast<setter>(ListViewBase_put_ShowsScrollingPlaceholders), nullptr, nullptr },
        { "footer_transitions", reinterpret_cast<getter>(ListViewBase_get_FooterTransitions), reinterpret_cast<setter>(ListViewBase_put_FooterTransitions), nullptr, nullptr },
        { "footer_template", reinterpret_cast<getter>(ListViewBase_get_FooterTemplate), reinterpret_cast<setter>(ListViewBase_put_FooterTemplate), nullptr, nullptr },
        { "footer", reinterpret_cast<getter>(ListViewBase_get_Footer), reinterpret_cast<setter>(ListViewBase_put_Footer), nullptr, nullptr },
        { "reorder_mode", reinterpret_cast<getter>(ListViewBase_get_ReorderMode), reinterpret_cast<setter>(ListViewBase_put_ReorderMode), nullptr, nullptr },
        { "is_multi_select_check_box_enabled", reinterpret_cast<getter>(ListViewBase_get_IsMultiSelectCheckBoxEnabled), reinterpret_cast<setter>(ListViewBase_put_IsMultiSelectCheckBoxEnabled), nullptr, nullptr },
        { "selected_ranges", reinterpret_cast<getter>(ListViewBase_get_SelectedRanges), nullptr, nullptr, nullptr },
        { "single_selection_follows_focus", reinterpret_cast<getter>(ListViewBase_get_SingleSelectionFollowsFocus), reinterpret_cast<setter>(ListViewBase_put_SingleSelectionFollowsFocus), nullptr, nullptr },
        { "semantic_zoom_owner", reinterpret_cast<getter>(ListViewBase_get_SemanticZoomOwner), reinterpret_cast<setter>(ListViewBase_put_SemanticZoomOwner), nullptr, nullptr },
        { "is_zoomed_in_view", reinterpret_cast<getter>(ListViewBase_get_IsZoomedInView), reinterpret_cast<setter>(ListViewBase_put_IsZoomedInView), nullptr, nullptr },
        { "is_active_view", reinterpret_cast<getter>(ListViewBase_get_IsActiveView), reinterpret_cast<setter>(ListViewBase_put_IsActiveView), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ListViewBase[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewBase) },
        { }
    };

    static PyType_Spec type_spec_ListViewBase = {
        "winrt._winrt_windows_ui_xaml_controls_2.ListViewBase",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ListViewBase};

    static PyGetSetDef getset_ListViewBase_Static[] = {
        { "can_drag_items_property", reinterpret_cast<getter>(ListViewBase_get_CanDragItemsProperty), nullptr, nullptr, nullptr },
        { "can_reorder_items_property", reinterpret_cast<getter>(ListViewBase_get_CanReorderItemsProperty), nullptr, nullptr, nullptr },
        { "data_fetch_size_property", reinterpret_cast<getter>(ListViewBase_get_DataFetchSizeProperty), nullptr, nullptr, nullptr },
        { "header_property", reinterpret_cast<getter>(ListViewBase_get_HeaderProperty), nullptr, nullptr, nullptr },
        { "header_template_property", reinterpret_cast<getter>(ListViewBase_get_HeaderTemplateProperty), nullptr, nullptr, nullptr },
        { "header_transitions_property", reinterpret_cast<getter>(ListViewBase_get_HeaderTransitionsProperty), nullptr, nullptr, nullptr },
        { "incremental_loading_threshold_property", reinterpret_cast<getter>(ListViewBase_get_IncrementalLoadingThresholdProperty), nullptr, nullptr, nullptr },
        { "incremental_loading_trigger_property", reinterpret_cast<getter>(ListViewBase_get_IncrementalLoadingTriggerProperty), nullptr, nullptr, nullptr },
        { "is_active_view_property", reinterpret_cast<getter>(ListViewBase_get_IsActiveViewProperty), nullptr, nullptr, nullptr },
        { "is_item_click_enabled_property", reinterpret_cast<getter>(ListViewBase_get_IsItemClickEnabledProperty), nullptr, nullptr, nullptr },
        { "is_swipe_enabled_property", reinterpret_cast<getter>(ListViewBase_get_IsSwipeEnabledProperty), nullptr, nullptr, nullptr },
        { "is_zoomed_in_view_property", reinterpret_cast<getter>(ListViewBase_get_IsZoomedInViewProperty), nullptr, nullptr, nullptr },
        { "selection_mode_property", reinterpret_cast<getter>(ListViewBase_get_SelectionModeProperty), nullptr, nullptr, nullptr },
        { "semantic_zoom_owner_property", reinterpret_cast<getter>(ListViewBase_get_SemanticZoomOwnerProperty), nullptr, nullptr, nullptr },
        { "footer_property", reinterpret_cast<getter>(ListViewBase_get_FooterProperty), nullptr, nullptr, nullptr },
        { "footer_template_property", reinterpret_cast<getter>(ListViewBase_get_FooterTemplateProperty), nullptr, nullptr, nullptr },
        { "footer_transitions_property", reinterpret_cast<getter>(ListViewBase_get_FooterTransitionsProperty), nullptr, nullptr, nullptr },
        { "shows_scrolling_placeholders_property", reinterpret_cast<getter>(ListViewBase_get_ShowsScrollingPlaceholdersProperty), nullptr, nullptr, nullptr },
        { "reorder_mode_property", reinterpret_cast<getter>(ListViewBase_get_ReorderModeProperty), nullptr, nullptr, nullptr },
        { "is_multi_select_check_box_enabled_property", reinterpret_cast<getter>(ListViewBase_get_IsMultiSelectCheckBoxEnabledProperty), nullptr, nullptr, nullptr },
        { "single_selection_follows_focus_property", reinterpret_cast<getter>(ListViewBase_get_SingleSelectionFollowsFocusProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ListViewBase_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListViewBase_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListViewBase_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListViewBase_Static) },
        { }
    };

    static PyType_Spec type_spec_ListViewBase_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.ListViewBase_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ListViewBase_Static
    };

    // ----- ListViewItem class --------------------

    struct PyWinrtListViewItem;
    using BasePyWinrtListViewItem = winrt::Windows::UI::Xaml::Controls::ListViewItemT<PyWinrtListViewItem, py::IPywinrtObject>;

    struct PyWinrtListViewItem : py::py_obj_ref, BasePyWinrtListViewItem
    {
        PyWinrtListViewItem(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtListViewItem() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtListViewItem* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ListViewItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::ListViewItem>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtListViewItem>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::ListViewItem instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListViewItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ListViewItem_get_TemplateSettings(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewItem", L"TemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ListViewItem>().TemplateSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ListViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::ListViewItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::ListViewItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewItem[] = {
        { "_assign_array_", _assign_array_ListViewItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewItem[] = {
        { "template_settings", reinterpret_cast<getter>(ListViewItem_get_TemplateSettings), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ListViewItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewItem) },
        { }
    };

    static PyType_Spec type_spec_ListViewItem = {
        "winrt._winrt_windows_ui_xaml_controls_2.ListViewItem",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ListViewItem};

    static PyGetSetDef getset_ListViewItem_Static[] = {
        { }
    };

    static PyMethodDef methods_ListViewItem_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListViewItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListViewItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListViewItem_Static) },
        { }
    };

    static PyType_Spec type_spec_ListViewItem_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.ListViewItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ListViewItem_Static
    };

    // ----- MenuBarItemFlyout class --------------------

    struct PyWinrtMenuBarItemFlyout;
    using BasePyWinrtMenuBarItemFlyout = winrt::Windows::UI::Xaml::Controls::MenuBarItemFlyoutT<PyWinrtMenuBarItemFlyout, py::IPywinrtObject>;

    struct PyWinrtMenuBarItemFlyout : py::py_obj_ref, BasePyWinrtMenuBarItemFlyout
    {
        PyWinrtMenuBarItemFlyout(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtMenuBarItemFlyout() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtMenuBarItemFlyout* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_MenuBarItemFlyout(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::MenuBarItemFlyout>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtMenuBarItemFlyout>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::MenuBarItemFlyout instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MenuBarItemFlyout(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MenuBarItemFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::MenuBarItemFlyout>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MenuBarItemFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::MenuBarItemFlyout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MenuBarItemFlyout[] = {
        { "_assign_array_", _assign_array_MenuBarItemFlyout, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MenuBarItemFlyout), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MenuBarItemFlyout[] = {
        { }
    };

    static PyType_Slot _type_slots_MenuBarItemFlyout[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MenuBarItemFlyout) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MenuBarItemFlyout) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MenuBarItemFlyout) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MenuBarItemFlyout) },
        { }
    };

    static PyType_Spec type_spec_MenuBarItemFlyout = {
        "winrt._winrt_windows_ui_xaml_controls_2.MenuBarItemFlyout",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_MenuBarItemFlyout};

    static PyGetSetDef getset_MenuBarItemFlyout_Static[] = {
        { }
    };

    static PyMethodDef methods_MenuBarItemFlyout_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MenuBarItemFlyout_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MenuBarItemFlyout_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MenuBarItemFlyout_Static) },
        { }
    };

    static PyType_Spec type_spec_MenuBarItemFlyout_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.MenuBarItemFlyout_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_MenuBarItemFlyout_Static
    };

    // ----- MenuFlyout class --------------------

    struct PyWinrtMenuFlyout;
    using BasePyWinrtMenuFlyout = winrt::Windows::UI::Xaml::Controls::MenuFlyoutT<PyWinrtMenuFlyout, py::IPywinrtObject>;

    struct PyWinrtMenuFlyout : py::py_obj_ref, BasePyWinrtMenuFlyout
    {
        PyWinrtMenuFlyout(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtMenuFlyout() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtMenuFlyout* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_MenuFlyout(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::MenuFlyout>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtMenuFlyout>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::MenuFlyout instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MenuFlyout(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MenuFlyout_ShowAt(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.MenuFlyout", L"ShowAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::MenuFlyout>().ShowAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MenuFlyout_get_MenuFlyoutPresenterStyle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.MenuFlyout", L"MenuFlyoutPresenterStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::MenuFlyout>().MenuFlyoutPresenterStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MenuFlyout_put_MenuFlyoutPresenterStyle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.MenuFlyout", L"MenuFlyoutPresenterStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Style>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::MenuFlyout>().MenuFlyoutPresenterStyle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MenuFlyout_get_Items(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.MenuFlyout", L"Items");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::MenuFlyout>().Items());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MenuFlyout_get_MenuFlyoutPresenterStyleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.MenuFlyout", L"MenuFlyoutPresenterStyleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::MenuFlyout::MenuFlyoutPresenterStyleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MenuFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::MenuFlyout>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MenuFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::MenuFlyout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MenuFlyout[] = {
        { "show_at", reinterpret_cast<PyCFunction>(MenuFlyout_ShowAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MenuFlyout, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MenuFlyout), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MenuFlyout[] = {
        { "menu_flyout_presenter_style", reinterpret_cast<getter>(MenuFlyout_get_MenuFlyoutPresenterStyle), reinterpret_cast<setter>(MenuFlyout_put_MenuFlyoutPresenterStyle), nullptr, nullptr },
        { "items", reinterpret_cast<getter>(MenuFlyout_get_Items), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MenuFlyout[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MenuFlyout) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MenuFlyout) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MenuFlyout) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MenuFlyout) },
        { }
    };

    static PyType_Spec type_spec_MenuFlyout = {
        "winrt._winrt_windows_ui_xaml_controls_2.MenuFlyout",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_MenuFlyout};

    static PyGetSetDef getset_MenuFlyout_Static[] = {
        { "menu_flyout_presenter_style_property", reinterpret_cast<getter>(MenuFlyout_get_MenuFlyoutPresenterStyleProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_MenuFlyout_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MenuFlyout_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MenuFlyout_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MenuFlyout_Static) },
        { }
    };

    static PyType_Spec type_spec_MenuFlyout_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.MenuFlyout_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_MenuFlyout_Static
    };

    // ----- NavigationViewItem class --------------------

    struct PyWinrtNavigationViewItem;
    using BasePyWinrtNavigationViewItem = winrt::Windows::UI::Xaml::Controls::NavigationViewItemT<PyWinrtNavigationViewItem, py::IPywinrtObject>;

    struct PyWinrtNavigationViewItem : py::py_obj_ref, BasePyWinrtNavigationViewItem
    {
        PyWinrtNavigationViewItem(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtNavigationViewItem() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtNavigationViewItem* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_NavigationViewItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::NavigationViewItem>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtNavigationViewItem>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::NavigationViewItem instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NavigationViewItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NavigationViewItem_get_Icon(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.NavigationViewItem", L"Icon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::NavigationViewItem>().Icon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationViewItem_put_Icon(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.NavigationViewItem", L"Icon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::IconElement>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::NavigationViewItem>().Icon(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationViewItem_get_CompactPaneLength(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.NavigationViewItem", L"CompactPaneLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::NavigationViewItem>().CompactPaneLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItem_get_SelectsOnInvoked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.NavigationViewItem", L"SelectsOnInvoked");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::NavigationViewItem>().SelectsOnInvoked());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationViewItem_put_SelectsOnInvoked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.NavigationViewItem", L"SelectsOnInvoked");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::NavigationViewItem>().SelectsOnInvoked(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationViewItem_get_CompactPaneLengthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.NavigationViewItem", L"CompactPaneLengthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::NavigationViewItem::CompactPaneLengthProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItem_get_IconProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.NavigationViewItem", L"IconProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::NavigationViewItem::IconProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItem_get_SelectsOnInvokedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.NavigationViewItem", L"SelectsOnInvokedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::NavigationViewItem::SelectsOnInvokedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NavigationViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::NavigationViewItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::NavigationViewItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewItem[] = {
        { "_assign_array_", _assign_array_NavigationViewItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NavigationViewItem[] = {
        { "icon", reinterpret_cast<getter>(NavigationViewItem_get_Icon), reinterpret_cast<setter>(NavigationViewItem_put_Icon), nullptr, nullptr },
        { "compact_pane_length", reinterpret_cast<getter>(NavigationViewItem_get_CompactPaneLength), nullptr, nullptr, nullptr },
        { "selects_on_invoked", reinterpret_cast<getter>(NavigationViewItem_get_SelectsOnInvoked), reinterpret_cast<setter>(NavigationViewItem_put_SelectsOnInvoked), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NavigationViewItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewItem) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItem = {
        "winrt._winrt_windows_ui_xaml_controls_2.NavigationViewItem",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_NavigationViewItem};

    static PyGetSetDef getset_NavigationViewItem_Static[] = {
        { "compact_pane_length_property", reinterpret_cast<getter>(NavigationViewItem_get_CompactPaneLengthProperty), nullptr, nullptr, nullptr },
        { "icon_property", reinterpret_cast<getter>(NavigationViewItem_get_IconProperty), nullptr, nullptr, nullptr },
        { "selects_on_invoked_property", reinterpret_cast<getter>(NavigationViewItem_get_SelectsOnInvokedProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_NavigationViewItem_Static[] = {
        { }
    };

    static PyType_Slot type_slots_NavigationViewItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NavigationViewItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NavigationViewItem_Static) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItem_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.NavigationViewItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_NavigationViewItem_Static
    };

    // ----- NavigationViewItemBase class --------------------

    static PyObject* _new_NavigationViewItemBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::NavigationViewItemBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::NavigationViewItemBase>::type_name);
        return nullptr;
    }

    static void _dealloc_NavigationViewItemBase(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_NavigationViewItemBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::NavigationViewItemBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewItemBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::NavigationViewItemBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewItemBase[] = {
        { "_assign_array_", _assign_array_NavigationViewItemBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewItemBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NavigationViewItemBase[] = {
        { }
    };

    static PyType_Slot _type_slots_NavigationViewItemBase[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewItemBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewItemBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewItemBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewItemBase) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItemBase = {
        "winrt._winrt_windows_ui_xaml_controls_2.NavigationViewItemBase",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_NavigationViewItemBase};

    static PyGetSetDef getset_NavigationViewItemBase_Static[] = {
        { }
    };

    static PyMethodDef methods_NavigationViewItemBase_Static[] = {
        { }
    };

    static PyType_Slot type_slots_NavigationViewItemBase_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NavigationViewItemBase_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NavigationViewItemBase_Static) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItemBase_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.NavigationViewItemBase_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_NavigationViewItemBase_Static
    };

    // ----- NavigationViewItemHeader class --------------------

    struct PyWinrtNavigationViewItemHeader;
    using BasePyWinrtNavigationViewItemHeader = winrt::Windows::UI::Xaml::Controls::NavigationViewItemHeaderT<PyWinrtNavigationViewItemHeader, py::IPywinrtObject>;

    struct PyWinrtNavigationViewItemHeader : py::py_obj_ref, BasePyWinrtNavigationViewItemHeader
    {
        PyWinrtNavigationViewItemHeader(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtNavigationViewItemHeader() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtNavigationViewItemHeader* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_NavigationViewItemHeader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::NavigationViewItemHeader>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtNavigationViewItemHeader>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::NavigationViewItemHeader instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NavigationViewItemHeader(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_NavigationViewItemHeader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::NavigationViewItemHeader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewItemHeader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::NavigationViewItemHeader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewItemHeader[] = {
        { "_assign_array_", _assign_array_NavigationViewItemHeader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewItemHeader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NavigationViewItemHeader[] = {
        { }
    };

    static PyType_Slot _type_slots_NavigationViewItemHeader[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewItemHeader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewItemHeader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewItemHeader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewItemHeader) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItemHeader = {
        "winrt._winrt_windows_ui_xaml_controls_2.NavigationViewItemHeader",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_NavigationViewItemHeader};

    static PyGetSetDef getset_NavigationViewItemHeader_Static[] = {
        { }
    };

    static PyMethodDef methods_NavigationViewItemHeader_Static[] = {
        { }
    };

    static PyType_Slot type_slots_NavigationViewItemHeader_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NavigationViewItemHeader_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NavigationViewItemHeader_Static) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItemHeader_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.NavigationViewItemHeader_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_NavigationViewItemHeader_Static
    };

    // ----- NavigationViewItemSeparator class --------------------

    struct PyWinrtNavigationViewItemSeparator;
    using BasePyWinrtNavigationViewItemSeparator = winrt::Windows::UI::Xaml::Controls::NavigationViewItemSeparatorT<PyWinrtNavigationViewItemSeparator, py::IPywinrtObject>;

    struct PyWinrtNavigationViewItemSeparator : py::py_obj_ref, BasePyWinrtNavigationViewItemSeparator
    {
        PyWinrtNavigationViewItemSeparator(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtNavigationViewItemSeparator() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtNavigationViewItemSeparator* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_NavigationViewItemSeparator(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::NavigationViewItemSeparator>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtNavigationViewItemSeparator>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::NavigationViewItemSeparator instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NavigationViewItemSeparator(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_NavigationViewItemSeparator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::NavigationViewItemSeparator>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewItemSeparator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::NavigationViewItemSeparator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewItemSeparator[] = {
        { "_assign_array_", _assign_array_NavigationViewItemSeparator, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewItemSeparator), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NavigationViewItemSeparator[] = {
        { }
    };

    static PyType_Slot _type_slots_NavigationViewItemSeparator[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewItemSeparator) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewItemSeparator) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewItemSeparator) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewItemSeparator) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItemSeparator = {
        "winrt._winrt_windows_ui_xaml_controls_2.NavigationViewItemSeparator",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_NavigationViewItemSeparator};

    static PyGetSetDef getset_NavigationViewItemSeparator_Static[] = {
        { }
    };

    static PyMethodDef methods_NavigationViewItemSeparator_Static[] = {
        { }
    };

    static PyType_Slot type_slots_NavigationViewItemSeparator_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NavigationViewItemSeparator_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NavigationViewItemSeparator_Static) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItemSeparator_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.NavigationViewItemSeparator_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_NavigationViewItemSeparator_Static
    };

    // ----- NavigationViewList class --------------------

    struct PyWinrtNavigationViewList;
    using BasePyWinrtNavigationViewList = winrt::Windows::UI::Xaml::Controls::NavigationViewListT<PyWinrtNavigationViewList, py::IPywinrtObject>;

    struct PyWinrtNavigationViewList : py::py_obj_ref, BasePyWinrtNavigationViewList
    {
        PyWinrtNavigationViewList(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtNavigationViewList() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtNavigationViewList* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_NavigationViewList(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::NavigationViewList>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtNavigationViewList>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::NavigationViewList instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NavigationViewList(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_NavigationViewList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::NavigationViewList>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::NavigationViewList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewList[] = {
        { "_assign_array_", _assign_array_NavigationViewList, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewList), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NavigationViewList[] = {
        { }
    };

    static PyType_Slot _type_slots_NavigationViewList[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewList) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewList) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewList) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewList) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewList = {
        "winrt._winrt_windows_ui_xaml_controls_2.NavigationViewList",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_NavigationViewList};

    static PyGetSetDef getset_NavigationViewList_Static[] = {
        { }
    };

    static PyMethodDef methods_NavigationViewList_Static[] = {
        { }
    };

    static PyType_Slot type_slots_NavigationViewList_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NavigationViewList_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NavigationViewList_Static) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewList_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.NavigationViewList_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_NavigationViewList_Static
    };

    // ----- PickerFlyout class --------------------

    static PyObject* _new_PickerFlyout(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::PickerFlyout instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PickerFlyout(py::wrapper::Windows::UI::Xaml::Controls::PickerFlyout* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PickerFlyout_ShowAtAsync(py::wrapper::Windows::UI::Xaml::Controls::PickerFlyout* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.PickerFlyout", L"ShowAtAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::FrameworkElement>(args, 0);

                return py::convert(self->obj.ShowAtAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PickerFlyout_get_Content(py::wrapper::Windows::UI::Xaml::Controls::PickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.PickerFlyout", L"Content");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PickerFlyout_put_Content(py::wrapper::Windows::UI::Xaml::Controls::PickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.PickerFlyout", L"Content");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(arg);

            self->obj.Content(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PickerFlyout_get_ConfirmationButtonsVisible(py::wrapper::Windows::UI::Xaml::Controls::PickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.PickerFlyout", L"ConfirmationButtonsVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ConfirmationButtonsVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PickerFlyout_put_ConfirmationButtonsVisible(py::wrapper::Windows::UI::Xaml::Controls::PickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.PickerFlyout", L"ConfirmationButtonsVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConfirmationButtonsVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PickerFlyout_get_ConfirmationButtonsVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.PickerFlyout", L"ConfirmationButtonsVisibleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::PickerFlyout::ConfirmationButtonsVisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PickerFlyout_get_ContentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.PickerFlyout", L"ContentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::PickerFlyout::ContentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PickerFlyout_add_Confirmed(py::wrapper::Windows::UI::Xaml::Controls::PickerFlyout* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.PickerFlyout", L"Confirmed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::PickerFlyout, winrt::Windows::UI::Xaml::Controls::PickerConfirmedEventArgs>>(arg);

            return py::convert(self->obj.Confirmed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PickerFlyout_remove_Confirmed(py::wrapper::Windows::UI::Xaml::Controls::PickerFlyout* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.PickerFlyout", L"Confirmed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Confirmed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PickerFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::PickerFlyout>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PickerFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::PickerFlyout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PickerFlyout[] = {
        { "show_at_async", reinterpret_cast<PyCFunction>(PickerFlyout_ShowAtAsync), METH_VARARGS, nullptr },
        { "add_confirmed", reinterpret_cast<PyCFunction>(PickerFlyout_add_Confirmed), METH_O, nullptr },
        { "remove_confirmed", reinterpret_cast<PyCFunction>(PickerFlyout_remove_Confirmed), METH_O, nullptr },
        { "_assign_array_", _assign_array_PickerFlyout, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PickerFlyout), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PickerFlyout[] = {
        { "content", reinterpret_cast<getter>(PickerFlyout_get_Content), reinterpret_cast<setter>(PickerFlyout_put_Content), nullptr, nullptr },
        { "confirmation_buttons_visible", reinterpret_cast<getter>(PickerFlyout_get_ConfirmationButtonsVisible), reinterpret_cast<setter>(PickerFlyout_put_ConfirmationButtonsVisible), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PickerFlyout[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PickerFlyout) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PickerFlyout) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PickerFlyout) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PickerFlyout) },
        { }
    };

    static PyType_Spec type_spec_PickerFlyout = {
        "winrt._winrt_windows_ui_xaml_controls_2.PickerFlyout",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::PickerFlyout),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PickerFlyout};

    static PyGetSetDef getset_PickerFlyout_Static[] = {
        { "confirmation_buttons_visible_property", reinterpret_cast<getter>(PickerFlyout_get_ConfirmationButtonsVisibleProperty), nullptr, nullptr, nullptr },
        { "content_property", reinterpret_cast<getter>(PickerFlyout_get_ContentProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_PickerFlyout_Static[] = {
        { }
    };

    static PyType_Slot type_slots_PickerFlyout_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PickerFlyout_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PickerFlyout_Static) },
        { }
    };

    static PyType_Spec type_spec_PickerFlyout_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.PickerFlyout_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PickerFlyout_Static
    };

    // ----- ProgressBar class --------------------

    struct PyWinrtProgressBar;
    using BasePyWinrtProgressBar = winrt::Windows::UI::Xaml::Controls::ProgressBarT<PyWinrtProgressBar, py::IPywinrtObject>;

    struct PyWinrtProgressBar : py::py_obj_ref, BasePyWinrtProgressBar
    {
        PyWinrtProgressBar(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtProgressBar() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtProgressBar* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ProgressBar(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::ProgressBar>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtProgressBar>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::ProgressBar instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ProgressBar(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProgressBar_get_ShowPaused(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ProgressBar", L"ShowPaused");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ProgressBar>().ShowPaused());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProgressBar_put_ShowPaused(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ProgressBar", L"ShowPaused");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ProgressBar>().ShowPaused(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProgressBar_get_ShowError(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ProgressBar", L"ShowError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ProgressBar>().ShowError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProgressBar_put_ShowError(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ProgressBar", L"ShowError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ProgressBar>().ShowError(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProgressBar_get_IsIndeterminate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ProgressBar", L"IsIndeterminate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ProgressBar>().IsIndeterminate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProgressBar_put_IsIndeterminate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ProgressBar", L"IsIndeterminate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ProgressBar>().IsIndeterminate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProgressBar_get_TemplateSettings(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ProgressBar", L"TemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::ProgressBar>().TemplateSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressBar_get_IsIndeterminateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ProgressBar", L"IsIndeterminateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ProgressBar::IsIndeterminateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressBar_get_ShowErrorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ProgressBar", L"ShowErrorProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ProgressBar::ShowErrorProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressBar_get_ShowPausedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ProgressBar", L"ShowPausedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ProgressBar::ShowPausedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProgressBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::ProgressBar>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProgressBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::ProgressBar>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProgressBar[] = {
        { "_assign_array_", _assign_array_ProgressBar, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProgressBar), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProgressBar[] = {
        { "show_paused", reinterpret_cast<getter>(ProgressBar_get_ShowPaused), reinterpret_cast<setter>(ProgressBar_put_ShowPaused), nullptr, nullptr },
        { "show_error", reinterpret_cast<getter>(ProgressBar_get_ShowError), reinterpret_cast<setter>(ProgressBar_put_ShowError), nullptr, nullptr },
        { "is_indeterminate", reinterpret_cast<getter>(ProgressBar_get_IsIndeterminate), reinterpret_cast<setter>(ProgressBar_put_IsIndeterminate), nullptr, nullptr },
        { "template_settings", reinterpret_cast<getter>(ProgressBar_get_TemplateSettings), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProgressBar[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProgressBar) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProgressBar) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProgressBar) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProgressBar) },
        { }
    };

    static PyType_Spec type_spec_ProgressBar = {
        "winrt._winrt_windows_ui_xaml_controls_2.ProgressBar",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ProgressBar};

    static PyGetSetDef getset_ProgressBar_Static[] = {
        { "is_indeterminate_property", reinterpret_cast<getter>(ProgressBar_get_IsIndeterminateProperty), nullptr, nullptr, nullptr },
        { "show_error_property", reinterpret_cast<getter>(ProgressBar_get_ShowErrorProperty), nullptr, nullptr, nullptr },
        { "show_paused_property", reinterpret_cast<getter>(ProgressBar_get_ShowPausedProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ProgressBar_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ProgressBar_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ProgressBar_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ProgressBar_Static) },
        { }
    };

    static PyType_Spec type_spec_ProgressBar_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.ProgressBar_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ProgressBar_Static
    };

    // ----- RadioButton class --------------------

    struct PyWinrtRadioButton;
    using BasePyWinrtRadioButton = winrt::Windows::UI::Xaml::Controls::RadioButtonT<PyWinrtRadioButton, py::IPywinrtObject>;

    struct PyWinrtRadioButton : py::py_obj_ref, BasePyWinrtRadioButton
    {
        PyWinrtRadioButton(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtRadioButton() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtRadioButton* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_RadioButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::RadioButton>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtRadioButton>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::RadioButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RadioButton(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RadioButton_get_GroupName(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.RadioButton", L"GroupName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::RadioButton>().GroupName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadioButton_put_GroupName(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.RadioButton", L"GroupName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::RadioButton>().GroupName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RadioButton_get_GroupNameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.RadioButton", L"GroupNameProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::RadioButton::GroupNameProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RadioButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::RadioButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RadioButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::RadioButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadioButton[] = {
        { "_assign_array_", _assign_array_RadioButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RadioButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RadioButton[] = {
        { "group_name", reinterpret_cast<getter>(RadioButton_get_GroupName), reinterpret_cast<setter>(RadioButton_put_GroupName), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RadioButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RadioButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RadioButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RadioButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RadioButton) },
        { }
    };

    static PyType_Spec type_spec_RadioButton = {
        "winrt._winrt_windows_ui_xaml_controls_2.RadioButton",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_RadioButton};

    static PyGetSetDef getset_RadioButton_Static[] = {
        { "group_name_property", reinterpret_cast<getter>(RadioButton_get_GroupNameProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_RadioButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RadioButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RadioButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RadioButton_Static) },
        { }
    };

    static PyType_Spec type_spec_RadioButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.RadioButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_RadioButton_Static
    };

    // ----- Slider class --------------------

    struct PyWinrtSlider;
    using BasePyWinrtSlider = winrt::Windows::UI::Xaml::Controls::SliderT<PyWinrtSlider, py::IPywinrtObject>;

    struct PyWinrtSlider : py::py_obj_ref, BasePyWinrtSlider
    {
        PyWinrtSlider(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtSlider() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtSlider* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_Slider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::Slider>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtSlider>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::Slider instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Slider(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Slider_get_TickPlacement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"TickPlacement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Slider>().TickPlacement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_TickPlacement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"TickPlacement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::TickPlacement>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Slider>().TickPlacement(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_TickFrequency(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"TickFrequency");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Slider>().TickFrequency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_TickFrequency(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"TickFrequency");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Slider>().TickFrequency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_ThumbToolTipValueConverter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"ThumbToolTipValueConverter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Slider>().ThumbToolTipValueConverter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_ThumbToolTipValueConverter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"ThumbToolTipValueConverter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Data::IValueConverter>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Slider>().ThumbToolTipValueConverter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_StepFrequency(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"StepFrequency");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Slider>().StepFrequency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_StepFrequency(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"StepFrequency");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Slider>().StepFrequency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_SnapsTo(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"SnapsTo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Slider>().SnapsTo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_SnapsTo(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"SnapsTo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::SliderSnapsTo>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Slider>().SnapsTo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_Orientation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Slider>().Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_Orientation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Orientation>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Slider>().Orientation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_IsThumbToolTipEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"IsThumbToolTipEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Slider>().IsThumbToolTipEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_IsThumbToolTipEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"IsThumbToolTipEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Slider>().IsThumbToolTipEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_IsDirectionReversed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"IsDirectionReversed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Slider>().IsDirectionReversed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_IsDirectionReversed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"IsDirectionReversed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Slider>().IsDirectionReversed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_IntermediateValue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"IntermediateValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Slider>().IntermediateValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_IntermediateValue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"IntermediateValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Slider>().IntermediateValue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_HeaderTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"HeaderTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Slider>().HeaderTemplate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_HeaderTemplate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"HeaderTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DataTemplate>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Slider>().HeaderTemplate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_Header(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"Header");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Slider>().Header());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_Header(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"Header");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Slider>().Header(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_IntermediateValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"IntermediateValueProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Slider::IntermediateValueProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_IsDirectionReversedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"IsDirectionReversedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Slider::IsDirectionReversedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_IsThumbToolTipEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"IsThumbToolTipEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Slider::IsThumbToolTipEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_OrientationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"OrientationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Slider::OrientationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_SnapsToProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"SnapsToProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Slider::SnapsToProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_StepFrequencyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"StepFrequencyProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Slider::StepFrequencyProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_ThumbToolTipValueConverterProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"ThumbToolTipValueConverterProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Slider::ThumbToolTipValueConverterProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_TickFrequencyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"TickFrequencyProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Slider::TickFrequencyProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_TickPlacementProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"TickPlacementProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Slider::TickPlacementProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_HeaderProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"HeaderProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Slider::HeaderProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_HeaderTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"HeaderTemplateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Slider::HeaderTemplateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Slider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Slider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Slider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Slider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Slider[] = {
        { "_assign_array_", _assign_array_Slider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Slider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Slider[] = {
        { "tick_placement", reinterpret_cast<getter>(Slider_get_TickPlacement), reinterpret_cast<setter>(Slider_put_TickPlacement), nullptr, nullptr },
        { "tick_frequency", reinterpret_cast<getter>(Slider_get_TickFrequency), reinterpret_cast<setter>(Slider_put_TickFrequency), nullptr, nullptr },
        { "thumb_tool_tip_value_converter", reinterpret_cast<getter>(Slider_get_ThumbToolTipValueConverter), reinterpret_cast<setter>(Slider_put_ThumbToolTipValueConverter), nullptr, nullptr },
        { "step_frequency", reinterpret_cast<getter>(Slider_get_StepFrequency), reinterpret_cast<setter>(Slider_put_StepFrequency), nullptr, nullptr },
        { "snaps_to", reinterpret_cast<getter>(Slider_get_SnapsTo), reinterpret_cast<setter>(Slider_put_SnapsTo), nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(Slider_get_Orientation), reinterpret_cast<setter>(Slider_put_Orientation), nullptr, nullptr },
        { "is_thumb_tool_tip_enabled", reinterpret_cast<getter>(Slider_get_IsThumbToolTipEnabled), reinterpret_cast<setter>(Slider_put_IsThumbToolTipEnabled), nullptr, nullptr },
        { "is_direction_reversed", reinterpret_cast<getter>(Slider_get_IsDirectionReversed), reinterpret_cast<setter>(Slider_put_IsDirectionReversed), nullptr, nullptr },
        { "intermediate_value", reinterpret_cast<getter>(Slider_get_IntermediateValue), reinterpret_cast<setter>(Slider_put_IntermediateValue), nullptr, nullptr },
        { "header_template", reinterpret_cast<getter>(Slider_get_HeaderTemplate), reinterpret_cast<setter>(Slider_put_HeaderTemplate), nullptr, nullptr },
        { "header", reinterpret_cast<getter>(Slider_get_Header), reinterpret_cast<setter>(Slider_put_Header), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Slider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Slider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Slider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Slider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Slider) },
        { }
    };

    static PyType_Spec type_spec_Slider = {
        "winrt._winrt_windows_ui_xaml_controls_2.Slider",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_Slider};

    static PyGetSetDef getset_Slider_Static[] = {
        { "intermediate_value_property", reinterpret_cast<getter>(Slider_get_IntermediateValueProperty), nullptr, nullptr, nullptr },
        { "is_direction_reversed_property", reinterpret_cast<getter>(Slider_get_IsDirectionReversedProperty), nullptr, nullptr, nullptr },
        { "is_thumb_tool_tip_enabled_property", reinterpret_cast<getter>(Slider_get_IsThumbToolTipEnabledProperty), nullptr, nullptr, nullptr },
        { "orientation_property", reinterpret_cast<getter>(Slider_get_OrientationProperty), nullptr, nullptr, nullptr },
        { "snaps_to_property", reinterpret_cast<getter>(Slider_get_SnapsToProperty), nullptr, nullptr, nullptr },
        { "step_frequency_property", reinterpret_cast<getter>(Slider_get_StepFrequencyProperty), nullptr, nullptr, nullptr },
        { "thumb_tool_tip_value_converter_property", reinterpret_cast<getter>(Slider_get_ThumbToolTipValueConverterProperty), nullptr, nullptr, nullptr },
        { "tick_frequency_property", reinterpret_cast<getter>(Slider_get_TickFrequencyProperty), nullptr, nullptr, nullptr },
        { "tick_placement_property", reinterpret_cast<getter>(Slider_get_TickPlacementProperty), nullptr, nullptr, nullptr },
        { "header_property", reinterpret_cast<getter>(Slider_get_HeaderProperty), nullptr, nullptr, nullptr },
        { "header_template_property", reinterpret_cast<getter>(Slider_get_HeaderTemplateProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Slider_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Slider_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Slider_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Slider_Static) },
        { }
    };

    static PyType_Spec type_spec_Slider_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.Slider_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_Slider_Static
    };

    // ----- TextCommandBarFlyout class --------------------

    struct PyWinrtTextCommandBarFlyout;
    using BasePyWinrtTextCommandBarFlyout = winrt::Windows::UI::Xaml::Controls::TextCommandBarFlyoutT<PyWinrtTextCommandBarFlyout, py::IPywinrtObject>;

    struct PyWinrtTextCommandBarFlyout : py::py_obj_ref, BasePyWinrtTextCommandBarFlyout
    {
        PyWinrtTextCommandBarFlyout(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtTextCommandBarFlyout() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtTextCommandBarFlyout* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_TextCommandBarFlyout(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::TextCommandBarFlyout>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtTextCommandBarFlyout>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::TextCommandBarFlyout instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TextCommandBarFlyout(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TextCommandBarFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::TextCommandBarFlyout>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TextCommandBarFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::TextCommandBarFlyout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TextCommandBarFlyout[] = {
        { "_assign_array_", _assign_array_TextCommandBarFlyout, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TextCommandBarFlyout), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TextCommandBarFlyout[] = {
        { }
    };

    static PyType_Slot _type_slots_TextCommandBarFlyout[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TextCommandBarFlyout) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TextCommandBarFlyout) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TextCommandBarFlyout) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TextCommandBarFlyout) },
        { }
    };

    static PyType_Spec type_spec_TextCommandBarFlyout = {
        "winrt._winrt_windows_ui_xaml_controls_2.TextCommandBarFlyout",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_TextCommandBarFlyout};

    static PyGetSetDef getset_TextCommandBarFlyout_Static[] = {
        { }
    };

    static PyMethodDef methods_TextCommandBarFlyout_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TextCommandBarFlyout_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TextCommandBarFlyout_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TextCommandBarFlyout_Static) },
        { }
    };

    static PyType_Spec type_spec_TextCommandBarFlyout_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.TextCommandBarFlyout_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_TextCommandBarFlyout_Static
    };

    // ----- TimePickerFlyout class --------------------

    static PyObject* _new_TimePickerFlyout(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::TimePickerFlyout instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimePickerFlyout(py::wrapper::Windows::UI::Xaml::Controls::TimePickerFlyout* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimePickerFlyout_ShowAtAsync(py::wrapper::Windows::UI::Xaml::Controls::TimePickerFlyout* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.TimePickerFlyout", L"ShowAtAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::FrameworkElement>(args, 0);

                return py::convert(self->obj.ShowAtAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimePickerFlyout_get_Time(py::wrapper::Windows::UI::Xaml::Controls::TimePickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TimePickerFlyout", L"Time");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Time());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimePickerFlyout_put_Time(py::wrapper::Windows::UI::Xaml::Controls::TimePickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TimePickerFlyout", L"Time");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Time(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimePickerFlyout_get_MinuteIncrement(py::wrapper::Windows::UI::Xaml::Controls::TimePickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TimePickerFlyout", L"MinuteIncrement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinuteIncrement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimePickerFlyout_put_MinuteIncrement(py::wrapper::Windows::UI::Xaml::Controls::TimePickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TimePickerFlyout", L"MinuteIncrement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.MinuteIncrement(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimePickerFlyout_get_ClockIdentifier(py::wrapper::Windows::UI::Xaml::Controls::TimePickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TimePickerFlyout", L"ClockIdentifier");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ClockIdentifier());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimePickerFlyout_put_ClockIdentifier(py::wrapper::Windows::UI::Xaml::Controls::TimePickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TimePickerFlyout", L"ClockIdentifier");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ClockIdentifier(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimePickerFlyout_get_ClockIdentifierProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TimePickerFlyout", L"ClockIdentifierProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::TimePickerFlyout::ClockIdentifierProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimePickerFlyout_get_MinuteIncrementProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TimePickerFlyout", L"MinuteIncrementProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::TimePickerFlyout::MinuteIncrementProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimePickerFlyout_get_TimeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TimePickerFlyout", L"TimeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::TimePickerFlyout::TimeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimePickerFlyout_add_TimePicked(py::wrapper::Windows::UI::Xaml::Controls::TimePickerFlyout* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.TimePickerFlyout", L"TimePicked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::TimePickerFlyout, winrt::Windows::UI::Xaml::Controls::TimePickedEventArgs>>(arg);

            return py::convert(self->obj.TimePicked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimePickerFlyout_remove_TimePicked(py::wrapper::Windows::UI::Xaml::Controls::TimePickerFlyout* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.TimePickerFlyout", L"TimePicked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TimePicked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TimePickerFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::TimePickerFlyout>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimePickerFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::TimePickerFlyout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimePickerFlyout[] = {
        { "show_at_async", reinterpret_cast<PyCFunction>(TimePickerFlyout_ShowAtAsync), METH_VARARGS, nullptr },
        { "add_time_picked", reinterpret_cast<PyCFunction>(TimePickerFlyout_add_TimePicked), METH_O, nullptr },
        { "remove_time_picked", reinterpret_cast<PyCFunction>(TimePickerFlyout_remove_TimePicked), METH_O, nullptr },
        { "_assign_array_", _assign_array_TimePickerFlyout, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimePickerFlyout), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimePickerFlyout[] = {
        { "time", reinterpret_cast<getter>(TimePickerFlyout_get_Time), reinterpret_cast<setter>(TimePickerFlyout_put_Time), nullptr, nullptr },
        { "minute_increment", reinterpret_cast<getter>(TimePickerFlyout_get_MinuteIncrement), reinterpret_cast<setter>(TimePickerFlyout_put_MinuteIncrement), nullptr, nullptr },
        { "clock_identifier", reinterpret_cast<getter>(TimePickerFlyout_get_ClockIdentifier), reinterpret_cast<setter>(TimePickerFlyout_put_ClockIdentifier), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimePickerFlyout[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimePickerFlyout) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimePickerFlyout) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimePickerFlyout) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimePickerFlyout) },
        { }
    };

    static PyType_Spec type_spec_TimePickerFlyout = {
        "winrt._winrt_windows_ui_xaml_controls_2.TimePickerFlyout",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::TimePickerFlyout),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimePickerFlyout};

    static PyGetSetDef getset_TimePickerFlyout_Static[] = {
        { "clock_identifier_property", reinterpret_cast<getter>(TimePickerFlyout_get_ClockIdentifierProperty), nullptr, nullptr, nullptr },
        { "minute_increment_property", reinterpret_cast<getter>(TimePickerFlyout_get_MinuteIncrementProperty), nullptr, nullptr, nullptr },
        { "time_property", reinterpret_cast<getter>(TimePickerFlyout_get_TimeProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_TimePickerFlyout_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TimePickerFlyout_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TimePickerFlyout_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TimePickerFlyout_Static) },
        { }
    };

    static PyType_Spec type_spec_TimePickerFlyout_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.TimePickerFlyout_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TimePickerFlyout_Static
    };

    // ----- TreeViewItem class --------------------

    struct PyWinrtTreeViewItem;
    using BasePyWinrtTreeViewItem = winrt::Windows::UI::Xaml::Controls::TreeViewItemT<PyWinrtTreeViewItem, py::IPywinrtObject>;

    struct PyWinrtTreeViewItem : py::py_obj_ref, BasePyWinrtTreeViewItem
    {
        PyWinrtTreeViewItem(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtTreeViewItem() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtTreeViewItem* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_TreeViewItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::TreeViewItem>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtTreeViewItem>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::TreeViewItem instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TreeViewItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TreeViewItem_get_IsExpanded(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"IsExpanded");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::TreeViewItem>().IsExpanded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_IsExpanded(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"IsExpanded");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::TreeViewItem>().IsExpanded(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_GlyphSize(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"GlyphSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::TreeViewItem>().GlyphSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_GlyphSize(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"GlyphSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::TreeViewItem>().GlyphSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_GlyphOpacity(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"GlyphOpacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::TreeViewItem>().GlyphOpacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_GlyphOpacity(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"GlyphOpacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::TreeViewItem>().GlyphOpacity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_GlyphBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"GlyphBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::TreeViewItem>().GlyphBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_GlyphBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"GlyphBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::TreeViewItem>().GlyphBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_ExpandedGlyph(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"ExpandedGlyph");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::TreeViewItem>().ExpandedGlyph());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_ExpandedGlyph(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"ExpandedGlyph");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::TreeViewItem>().ExpandedGlyph(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_CollapsedGlyph(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"CollapsedGlyph");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::TreeViewItem>().CollapsedGlyph());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_CollapsedGlyph(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"CollapsedGlyph");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::TreeViewItem>().CollapsedGlyph(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_TreeViewItemTemplateSettings(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"TreeViewItemTemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::TreeViewItem>().TreeViewItemTemplateSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_ItemsSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"ItemsSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::TreeViewItem>().ItemsSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_ItemsSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"ItemsSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::TreeViewItem>().ItemsSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_HasUnrealizedChildren(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"HasUnrealizedChildren");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::TreeViewItem>().HasUnrealizedChildren());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_HasUnrealizedChildren(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"HasUnrealizedChildren");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::TreeViewItem>().HasUnrealizedChildren(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_CollapsedGlyphProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"CollapsedGlyphProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::TreeViewItem::CollapsedGlyphProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_ExpandedGlyphProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"ExpandedGlyphProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::TreeViewItem::ExpandedGlyphProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_GlyphBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"GlyphBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::TreeViewItem::GlyphBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_GlyphOpacityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"GlyphOpacityProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::TreeViewItem::GlyphOpacityProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_GlyphSizeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"GlyphSizeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::TreeViewItem::GlyphSizeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_IsExpandedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"IsExpandedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::TreeViewItem::IsExpandedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_TreeViewItemTemplateSettingsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"TreeViewItemTemplateSettingsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::TreeViewItem::TreeViewItemTemplateSettingsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_HasUnrealizedChildrenProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"HasUnrealizedChildrenProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::TreeViewItem::HasUnrealizedChildrenProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_ItemsSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"ItemsSourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::TreeViewItem::ItemsSourceProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TreeViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::TreeViewItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TreeViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::TreeViewItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TreeViewItem[] = {
        { "_assign_array_", _assign_array_TreeViewItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TreeViewItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TreeViewItem[] = {
        { "is_expanded", reinterpret_cast<getter>(TreeViewItem_get_IsExpanded), reinterpret_cast<setter>(TreeViewItem_put_IsExpanded), nullptr, nullptr },
        { "glyph_size", reinterpret_cast<getter>(TreeViewItem_get_GlyphSize), reinterpret_cast<setter>(TreeViewItem_put_GlyphSize), nullptr, nullptr },
        { "glyph_opacity", reinterpret_cast<getter>(TreeViewItem_get_GlyphOpacity), reinterpret_cast<setter>(TreeViewItem_put_GlyphOpacity), nullptr, nullptr },
        { "glyph_brush", reinterpret_cast<getter>(TreeViewItem_get_GlyphBrush), reinterpret_cast<setter>(TreeViewItem_put_GlyphBrush), nullptr, nullptr },
        { "expanded_glyph", reinterpret_cast<getter>(TreeViewItem_get_ExpandedGlyph), reinterpret_cast<setter>(TreeViewItem_put_ExpandedGlyph), nullptr, nullptr },
        { "collapsed_glyph", reinterpret_cast<getter>(TreeViewItem_get_CollapsedGlyph), reinterpret_cast<setter>(TreeViewItem_put_CollapsedGlyph), nullptr, nullptr },
        { "tree_view_item_template_settings", reinterpret_cast<getter>(TreeViewItem_get_TreeViewItemTemplateSettings), nullptr, nullptr, nullptr },
        { "items_source", reinterpret_cast<getter>(TreeViewItem_get_ItemsSource), reinterpret_cast<setter>(TreeViewItem_put_ItemsSource), nullptr, nullptr },
        { "has_unrealized_children", reinterpret_cast<getter>(TreeViewItem_get_HasUnrealizedChildren), reinterpret_cast<setter>(TreeViewItem_put_HasUnrealizedChildren), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TreeViewItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TreeViewItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TreeViewItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TreeViewItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TreeViewItem) },
        { }
    };

    static PyType_Spec type_spec_TreeViewItem = {
        "winrt._winrt_windows_ui_xaml_controls_2.TreeViewItem",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_TreeViewItem};

    static PyGetSetDef getset_TreeViewItem_Static[] = {
        { "collapsed_glyph_property", reinterpret_cast<getter>(TreeViewItem_get_CollapsedGlyphProperty), nullptr, nullptr, nullptr },
        { "expanded_glyph_property", reinterpret_cast<getter>(TreeViewItem_get_ExpandedGlyphProperty), nullptr, nullptr, nullptr },
        { "glyph_brush_property", reinterpret_cast<getter>(TreeViewItem_get_GlyphBrushProperty), nullptr, nullptr, nullptr },
        { "glyph_opacity_property", reinterpret_cast<getter>(TreeViewItem_get_GlyphOpacityProperty), nullptr, nullptr, nullptr },
        { "glyph_size_property", reinterpret_cast<getter>(TreeViewItem_get_GlyphSizeProperty), nullptr, nullptr, nullptr },
        { "is_expanded_property", reinterpret_cast<getter>(TreeViewItem_get_IsExpandedProperty), nullptr, nullptr, nullptr },
        { "tree_view_item_template_settings_property", reinterpret_cast<getter>(TreeViewItem_get_TreeViewItemTemplateSettingsProperty), nullptr, nullptr, nullptr },
        { "has_unrealized_children_property", reinterpret_cast<getter>(TreeViewItem_get_HasUnrealizedChildrenProperty), nullptr, nullptr, nullptr },
        { "items_source_property", reinterpret_cast<getter>(TreeViewItem_get_ItemsSourceProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_TreeViewItem_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TreeViewItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TreeViewItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TreeViewItem_Static) },
        { }
    };

    static PyType_Spec type_spec_TreeViewItem_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.TreeViewItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_TreeViewItem_Static
    };

    // ----- TreeViewList class --------------------

    struct PyWinrtTreeViewList;
    using BasePyWinrtTreeViewList = winrt::Windows::UI::Xaml::Controls::TreeViewListT<PyWinrtTreeViewList, py::IPywinrtObject>;

    struct PyWinrtTreeViewList : py::py_obj_ref, BasePyWinrtTreeViewList
    {
        PyWinrtTreeViewList(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtTreeViewList() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtTreeViewList* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_TreeViewList(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::TreeViewList>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtTreeViewList>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::TreeViewList instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TreeViewList(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TreeViewList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::TreeViewList>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TreeViewList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::TreeViewList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TreeViewList[] = {
        { "_assign_array_", _assign_array_TreeViewList, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TreeViewList), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TreeViewList[] = {
        { }
    };

    static PyType_Slot _type_slots_TreeViewList[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TreeViewList) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TreeViewList) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TreeViewList) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TreeViewList) },
        { }
    };

    static PyType_Spec type_spec_TreeViewList = {
        "winrt._winrt_windows_ui_xaml_controls_2.TreeViewList",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_TreeViewList};

    static PyGetSetDef getset_TreeViewList_Static[] = {
        { }
    };

    static PyMethodDef methods_TreeViewList_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TreeViewList_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TreeViewList_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TreeViewList_Static) },
        { }
    };

    static PyType_Spec type_spec_TreeViewList_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.TreeViewList_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_TreeViewList_Static
    };

    // ----- VirtualizingStackPanel class --------------------

    static PyObject* _new_VirtualizingStackPanel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::VirtualizingStackPanel instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VirtualizingStackPanel(py::wrapper::Windows::UI::Xaml::Controls::VirtualizingStackPanel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VirtualizingStackPanel_GetIsVirtualizing(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"GetIsVirtualizing", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::VirtualizingStackPanel::GetIsVirtualizing(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VirtualizingStackPanel_GetVirtualizationMode(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"GetVirtualizationMode", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::VirtualizingStackPanel::GetVirtualizationMode(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VirtualizingStackPanel_OnCleanUpVirtualizedItem(PyObject* /*unused*/, PyObject* /* unused */) noexcept
    {
        PyErr_SetString(PyExc_RuntimeError, "cannot call protected method");
        return nullptr;
    }

    static PyObject* VirtualizingStackPanel_SetVirtualizationMode(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"SetVirtualizationMode", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::VirtualizationMode>(args, 1);

                winrt::Windows::UI::Xaml::Controls::VirtualizingStackPanel::SetVirtualizationMode(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VirtualizingStackPanel_get_Orientation(py::wrapper::Windows::UI::Xaml::Controls::VirtualizingStackPanel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VirtualizingStackPanel_put_Orientation(py::wrapper::Windows::UI::Xaml::Controls::VirtualizingStackPanel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Orientation>(arg);

            self->obj.Orientation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VirtualizingStackPanel_get_AreScrollSnapPointsRegular(py::wrapper::Windows::UI::Xaml::Controls::VirtualizingStackPanel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"AreScrollSnapPointsRegular");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AreScrollSnapPointsRegular());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VirtualizingStackPanel_put_AreScrollSnapPointsRegular(py::wrapper::Windows::UI::Xaml::Controls::VirtualizingStackPanel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"AreScrollSnapPointsRegular");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AreScrollSnapPointsRegular(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VirtualizingStackPanel_get_AreScrollSnapPointsRegularProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"AreScrollSnapPointsRegularProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::VirtualizingStackPanel::AreScrollSnapPointsRegularProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VirtualizingStackPanel_get_IsVirtualizingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"IsVirtualizingProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::VirtualizingStackPanel::IsVirtualizingProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VirtualizingStackPanel_get_OrientationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"OrientationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::VirtualizingStackPanel::OrientationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VirtualizingStackPanel_get_VirtualizationModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"VirtualizationModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::VirtualizingStackPanel::VirtualizationModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VirtualizingStackPanel_add_CleanUpVirtualizedItemEvent(py::wrapper::Windows::UI::Xaml::Controls::VirtualizingStackPanel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"CleanUpVirtualizedItemEvent");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::CleanUpVirtualizedItemEventHandler>(arg);

            return py::convert(self->obj.CleanUpVirtualizedItemEvent(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VirtualizingStackPanel_remove_CleanUpVirtualizedItemEvent(py::wrapper::Windows::UI::Xaml::Controls::VirtualizingStackPanel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"CleanUpVirtualizedItemEvent");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CleanUpVirtualizedItemEvent(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VirtualizingStackPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::VirtualizingStackPanel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VirtualizingStackPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::VirtualizingStackPanel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VirtualizingStackPanel[] = {
        { "_on_clean_up_virtualized_item", reinterpret_cast<PyCFunction>(VirtualizingStackPanel_OnCleanUpVirtualizedItem), METH_VARARGS, nullptr },
        { "add_clean_up_virtualized_item_event", reinterpret_cast<PyCFunction>(VirtualizingStackPanel_add_CleanUpVirtualizedItemEvent), METH_O, nullptr },
        { "remove_clean_up_virtualized_item_event", reinterpret_cast<PyCFunction>(VirtualizingStackPanel_remove_CleanUpVirtualizedItemEvent), METH_O, nullptr },
        { "_assign_array_", _assign_array_VirtualizingStackPanel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VirtualizingStackPanel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VirtualizingStackPanel[] = {
        { "orientation", reinterpret_cast<getter>(VirtualizingStackPanel_get_Orientation), reinterpret_cast<setter>(VirtualizingStackPanel_put_Orientation), nullptr, nullptr },
        { "are_scroll_snap_points_regular", reinterpret_cast<getter>(VirtualizingStackPanel_get_AreScrollSnapPointsRegular), reinterpret_cast<setter>(VirtualizingStackPanel_put_AreScrollSnapPointsRegular), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VirtualizingStackPanel[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VirtualizingStackPanel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VirtualizingStackPanel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VirtualizingStackPanel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VirtualizingStackPanel) },
        { }
    };

    static PyType_Spec type_spec_VirtualizingStackPanel = {
        "winrt._winrt_windows_ui_xaml_controls_2.VirtualizingStackPanel",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::VirtualizingStackPanel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VirtualizingStackPanel};

    static PyGetSetDef getset_VirtualizingStackPanel_Static[] = {
        { "are_scroll_snap_points_regular_property", reinterpret_cast<getter>(VirtualizingStackPanel_get_AreScrollSnapPointsRegularProperty), nullptr, nullptr, nullptr },
        { "is_virtualizing_property", reinterpret_cast<getter>(VirtualizingStackPanel_get_IsVirtualizingProperty), nullptr, nullptr, nullptr },
        { "orientation_property", reinterpret_cast<getter>(VirtualizingStackPanel_get_OrientationProperty), nullptr, nullptr, nullptr },
        { "virtualization_mode_property", reinterpret_cast<getter>(VirtualizingStackPanel_get_VirtualizationModeProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_VirtualizingStackPanel_Static[] = {
        { "get_is_virtualizing", reinterpret_cast<PyCFunction>(VirtualizingStackPanel_GetIsVirtualizing), METH_VARARGS, nullptr },
        { "get_virtualization_mode", reinterpret_cast<PyCFunction>(VirtualizingStackPanel_GetVirtualizationMode), METH_VARARGS, nullptr },
        { "set_virtualization_mode", reinterpret_cast<PyCFunction>(VirtualizingStackPanel_SetVirtualizationMode), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_VirtualizingStackPanel_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_VirtualizingStackPanel_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_VirtualizingStackPanel_Static) },
        { }
    };

    static PyType_Spec type_spec_VirtualizingStackPanel_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.VirtualizingStackPanel_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_VirtualizingStackPanel_Static
    };

    // ----- WrapGrid class --------------------

    static PyObject* _new_WrapGrid(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::WrapGrid instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WrapGrid(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WrapGrid_get_VerticalChildrenAlignment(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"VerticalChildrenAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticalChildrenAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WrapGrid_put_VerticalChildrenAlignment(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"VerticalChildrenAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::VerticalAlignment>(arg);

            self->obj.VerticalChildrenAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WrapGrid_get_Orientation(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WrapGrid_put_Orientation(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Orientation>(arg);

            self->obj.Orientation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WrapGrid_get_MaximumRowsOrColumns(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"MaximumRowsOrColumns");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaximumRowsOrColumns());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WrapGrid_put_MaximumRowsOrColumns(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"MaximumRowsOrColumns");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.MaximumRowsOrColumns(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WrapGrid_get_ItemWidth(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"ItemWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ItemWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WrapGrid_put_ItemWidth(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"ItemWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.ItemWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WrapGrid_get_ItemHeight(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"ItemHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ItemHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WrapGrid_put_ItemHeight(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"ItemHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.ItemHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WrapGrid_get_HorizontalChildrenAlignment(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"HorizontalChildrenAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontalChildrenAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WrapGrid_put_HorizontalChildrenAlignment(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"HorizontalChildrenAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::HorizontalAlignment>(arg);

            self->obj.HorizontalChildrenAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WrapGrid_get_HorizontalChildrenAlignmentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"HorizontalChildrenAlignmentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::WrapGrid::HorizontalChildrenAlignmentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WrapGrid_get_ItemHeightProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"ItemHeightProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::WrapGrid::ItemHeightProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WrapGrid_get_ItemWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"ItemWidthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::WrapGrid::ItemWidthProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WrapGrid_get_MaximumRowsOrColumnsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"MaximumRowsOrColumnsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::WrapGrid::MaximumRowsOrColumnsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WrapGrid_get_OrientationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"OrientationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::WrapGrid::OrientationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WrapGrid_get_VerticalChildrenAlignmentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"VerticalChildrenAlignmentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::WrapGrid::VerticalChildrenAlignmentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WrapGrid(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::WrapGrid>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WrapGrid(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::WrapGrid>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WrapGrid[] = {
        { "_assign_array_", _assign_array_WrapGrid, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WrapGrid), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WrapGrid[] = {
        { "vertical_children_alignment", reinterpret_cast<getter>(WrapGrid_get_VerticalChildrenAlignment), reinterpret_cast<setter>(WrapGrid_put_VerticalChildrenAlignment), nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(WrapGrid_get_Orientation), reinterpret_cast<setter>(WrapGrid_put_Orientation), nullptr, nullptr },
        { "maximum_rows_or_columns", reinterpret_cast<getter>(WrapGrid_get_MaximumRowsOrColumns), reinterpret_cast<setter>(WrapGrid_put_MaximumRowsOrColumns), nullptr, nullptr },
        { "item_width", reinterpret_cast<getter>(WrapGrid_get_ItemWidth), reinterpret_cast<setter>(WrapGrid_put_ItemWidth), nullptr, nullptr },
        { "item_height", reinterpret_cast<getter>(WrapGrid_get_ItemHeight), reinterpret_cast<setter>(WrapGrid_put_ItemHeight), nullptr, nullptr },
        { "horizontal_children_alignment", reinterpret_cast<getter>(WrapGrid_get_HorizontalChildrenAlignment), reinterpret_cast<setter>(WrapGrid_put_HorizontalChildrenAlignment), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WrapGrid[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WrapGrid) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WrapGrid) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WrapGrid) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WrapGrid) },
        { }
    };

    static PyType_Spec type_spec_WrapGrid = {
        "winrt._winrt_windows_ui_xaml_controls_2.WrapGrid",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WrapGrid};

    static PyGetSetDef getset_WrapGrid_Static[] = {
        { "horizontal_children_alignment_property", reinterpret_cast<getter>(WrapGrid_get_HorizontalChildrenAlignmentProperty), nullptr, nullptr, nullptr },
        { "item_height_property", reinterpret_cast<getter>(WrapGrid_get_ItemHeightProperty), nullptr, nullptr, nullptr },
        { "item_width_property", reinterpret_cast<getter>(WrapGrid_get_ItemWidthProperty), nullptr, nullptr, nullptr },
        { "maximum_rows_or_columns_property", reinterpret_cast<getter>(WrapGrid_get_MaximumRowsOrColumnsProperty), nullptr, nullptr, nullptr },
        { "orientation_property", reinterpret_cast<getter>(WrapGrid_get_OrientationProperty), nullptr, nullptr, nullptr },
        { "vertical_children_alignment_property", reinterpret_cast<getter>(WrapGrid_get_VerticalChildrenAlignmentProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_WrapGrid_Static[] = {
        { }
    };

    static PyType_Slot type_slots_WrapGrid_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_WrapGrid_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_WrapGrid_Static) },
        { }
    };

    static PyType_Spec type_spec_WrapGrid_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_2.WrapGrid_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_WrapGrid_Static
    };

    // ----- Windows.UI.Xaml.Controls Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.UI.Xaml.Controls");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_ui_xaml_controls_2",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::UI::Xaml::Controls

PyMODINIT_FUNC PyInit__winrt_windows_ui_xaml_controls_2(void) noexcept
{
    using namespace py::cpp::Windows::UI::Xaml::Controls;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_primitives_module{PyImport_ImportModule("winrt._winrt_windows_ui_xaml_controls_primitives")};
    if (!windows_ui_xaml_controls_primitives_module)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_primitives_ToggleButton_type{PyObject_GetAttrString(windows_ui_xaml_controls_primitives_module.get(), "ToggleButton")};
    if (!windows_ui_xaml_controls_primitives_ToggleButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_primitives_ButtonBase_type{PyObject_GetAttrString(windows_ui_xaml_controls_primitives_module.get(), "ButtonBase")};
    if (!windows_ui_xaml_controls_primitives_ButtonBase_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_primitives_Selector_type{PyObject_GetAttrString(windows_ui_xaml_controls_primitives_module.get(), "Selector")};
    if (!windows_ui_xaml_controls_primitives_Selector_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_primitives_SelectorItem_type{PyObject_GetAttrString(windows_ui_xaml_controls_primitives_module.get(), "SelectorItem")};
    if (!windows_ui_xaml_controls_primitives_SelectorItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_primitives_FlyoutBase_type{PyObject_GetAttrString(windows_ui_xaml_controls_primitives_module.get(), "FlyoutBase")};
    if (!windows_ui_xaml_controls_primitives_FlyoutBase_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_primitives_PickerFlyoutBase_type{PyObject_GetAttrString(windows_ui_xaml_controls_primitives_module.get(), "PickerFlyoutBase")};
    if (!windows_ui_xaml_controls_primitives_PickerFlyoutBase_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_primitives_RangeBase_type{PyObject_GetAttrString(windows_ui_xaml_controls_primitives_module.get(), "RangeBase")};
    if (!windows_ui_xaml_controls_primitives_RangeBase_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_primitives_OrientedVirtualizingPanel_type{PyObject_GetAttrString(windows_ui_xaml_controls_primitives_module.get(), "OrientedVirtualizingPanel")};
    if (!windows_ui_xaml_controls_primitives_OrientedVirtualizingPanel_type)
    {
        return nullptr;
    }

    py::pyobj_handle Button_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_primitives_ButtonBase_type.get())))};
    if (!Button_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Button_Static{PyType_FromSpecWithBases(&type_spec_Button_Static, Button_Static_bases.get())};
    if (!type_Button_Static)
    {
        return nullptr;
    }

    py::pyobj_handle Button_bases{PyTuple_Pack(1, windows_ui_xaml_controls_primitives_ButtonBase_type.get())};
    if (!Button_bases)
    {
        return nullptr;
    }

    py::pytype_handle Button_type{py::register_python_type(module.get(), &type_spec_Button, Button_bases.get(), reinterpret_cast<PyTypeObject*>(type_Button_Static.get()))};
    if (!Button_type)
    {
        return nullptr;
    }

    py::pyobj_handle AppBarButton_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(Button_type.get())))};
    if (!AppBarButton_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppBarButton_Static{PyType_FromSpecWithBases(&type_spec_AppBarButton_Static, AppBarButton_Static_bases.get())};
    if (!type_AppBarButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle AppBarButton_bases{PyTuple_Pack(1, Button_type.get())};
    if (!AppBarButton_bases)
    {
        return nullptr;
    }

    py::pytype_handle AppBarButton_type{py::register_python_type(module.get(), &type_spec_AppBarButton, AppBarButton_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppBarButton_Static.get()))};
    if (!AppBarButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle AppBarToggleButton_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_primitives_ToggleButton_type.get())))};
    if (!AppBarToggleButton_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppBarToggleButton_Static{PyType_FromSpecWithBases(&type_spec_AppBarToggleButton_Static, AppBarToggleButton_Static_bases.get())};
    if (!type_AppBarToggleButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle AppBarToggleButton_bases{PyTuple_Pack(1, windows_ui_xaml_controls_primitives_ToggleButton_type.get())};
    if (!AppBarToggleButton_bases)
    {
        return nullptr;
    }

    py::pytype_handle AppBarToggleButton_type{py::register_python_type(module.get(), &type_spec_AppBarToggleButton, AppBarToggleButton_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppBarToggleButton_Static.get()))};
    if (!AppBarToggleButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle CheckBox_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_primitives_ToggleButton_type.get())))};
    if (!CheckBox_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CheckBox_Static{PyType_FromSpecWithBases(&type_spec_CheckBox_Static, CheckBox_Static_bases.get())};
    if (!type_CheckBox_Static)
    {
        return nullptr;
    }

    py::pyobj_handle CheckBox_bases{PyTuple_Pack(1, windows_ui_xaml_controls_primitives_ToggleButton_type.get())};
    if (!CheckBox_bases)
    {
        return nullptr;
    }

    py::pytype_handle CheckBox_type{py::register_python_type(module.get(), &type_spec_CheckBox, CheckBox_bases.get(), reinterpret_cast<PyTypeObject*>(type_CheckBox_Static.get()))};
    if (!CheckBox_type)
    {
        return nullptr;
    }

    py::pyobj_handle ComboBox_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_primitives_Selector_type.get())))};
    if (!ComboBox_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ComboBox_Static{PyType_FromSpecWithBases(&type_spec_ComboBox_Static, ComboBox_Static_bases.get())};
    if (!type_ComboBox_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ComboBox_bases{PyTuple_Pack(1, windows_ui_xaml_controls_primitives_Selector_type.get())};
    if (!ComboBox_bases)
    {
        return nullptr;
    }

    py::pytype_handle ComboBox_type{py::register_python_type(module.get(), &type_spec_ComboBox, ComboBox_bases.get(), reinterpret_cast<PyTypeObject*>(type_ComboBox_Static.get()))};
    if (!ComboBox_type)
    {
        return nullptr;
    }

    py::pyobj_handle ComboBoxItem_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_primitives_SelectorItem_type.get())))};
    if (!ComboBoxItem_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ComboBoxItem_Static{PyType_FromSpecWithBases(&type_spec_ComboBoxItem_Static, ComboBoxItem_Static_bases.get())};
    if (!type_ComboBoxItem_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ComboBoxItem_bases{PyTuple_Pack(1, windows_ui_xaml_controls_primitives_SelectorItem_type.get())};
    if (!ComboBoxItem_bases)
    {
        return nullptr;
    }

    py::pytype_handle ComboBoxItem_type{py::register_python_type(module.get(), &type_spec_ComboBoxItem, ComboBoxItem_bases.get(), reinterpret_cast<PyTypeObject*>(type_ComboBoxItem_Static.get()))};
    if (!ComboBoxItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle CommandBarFlyout_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_primitives_FlyoutBase_type.get())))};
    if (!CommandBarFlyout_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CommandBarFlyout_Static{PyType_FromSpecWithBases(&type_spec_CommandBarFlyout_Static, CommandBarFlyout_Static_bases.get())};
    if (!type_CommandBarFlyout_Static)
    {
        return nullptr;
    }

    py::pyobj_handle CommandBarFlyout_bases{PyTuple_Pack(1, windows_ui_xaml_controls_primitives_FlyoutBase_type.get())};
    if (!CommandBarFlyout_bases)
    {
        return nullptr;
    }

    py::pytype_handle CommandBarFlyout_type{py::register_python_type(module.get(), &type_spec_CommandBarFlyout, CommandBarFlyout_bases.get(), reinterpret_cast<PyTypeObject*>(type_CommandBarFlyout_Static.get()))};
    if (!CommandBarFlyout_type)
    {
        return nullptr;
    }

    py::pyobj_handle DatePickerFlyout_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_primitives_PickerFlyoutBase_type.get())))};
    if (!DatePickerFlyout_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_DatePickerFlyout_Static{PyType_FromSpecWithBases(&type_spec_DatePickerFlyout_Static, DatePickerFlyout_Static_bases.get())};
    if (!type_DatePickerFlyout_Static)
    {
        return nullptr;
    }

    py::pyobj_handle DatePickerFlyout_bases{PyTuple_Pack(1, windows_ui_xaml_controls_primitives_PickerFlyoutBase_type.get())};
    if (!DatePickerFlyout_bases)
    {
        return nullptr;
    }

    py::pytype_handle DatePickerFlyout_type{py::register_python_type(module.get(), &type_spec_DatePickerFlyout, DatePickerFlyout_bases.get(), reinterpret_cast<PyTypeObject*>(type_DatePickerFlyout_Static.get()))};
    if (!DatePickerFlyout_type)
    {
        return nullptr;
    }

    py::pyobj_handle DropDownButton_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(Button_type.get())))};
    if (!DropDownButton_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_DropDownButton_Static{PyType_FromSpecWithBases(&type_spec_DropDownButton_Static, DropDownButton_Static_bases.get())};
    if (!type_DropDownButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle DropDownButton_bases{PyTuple_Pack(1, Button_type.get())};
    if (!DropDownButton_bases)
    {
        return nullptr;
    }

    py::pytype_handle DropDownButton_type{py::register_python_type(module.get(), &type_spec_DropDownButton, DropDownButton_bases.get(), reinterpret_cast<PyTypeObject*>(type_DropDownButton_Static.get()))};
    if (!DropDownButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle FlipView_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_primitives_Selector_type.get())))};
    if (!FlipView_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_FlipView_Static{PyType_FromSpecWithBases(&type_spec_FlipView_Static, FlipView_Static_bases.get())};
    if (!type_FlipView_Static)
    {
        return nullptr;
    }

    py::pyobj_handle FlipView_bases{PyTuple_Pack(1, windows_ui_xaml_controls_primitives_Selector_type.get())};
    if (!FlipView_bases)
    {
        return nullptr;
    }

    py::pytype_handle FlipView_type{py::register_python_type(module.get(), &type_spec_FlipView, FlipView_bases.get(), reinterpret_cast<PyTypeObject*>(type_FlipView_Static.get()))};
    if (!FlipView_type)
    {
        return nullptr;
    }

    py::pyobj_handle FlipViewItem_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_primitives_SelectorItem_type.get())))};
    if (!FlipViewItem_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_FlipViewItem_Static{PyType_FromSpecWithBases(&type_spec_FlipViewItem_Static, FlipViewItem_Static_bases.get())};
    if (!type_FlipViewItem_Static)
    {
        return nullptr;
    }

    py::pyobj_handle FlipViewItem_bases{PyTuple_Pack(1, windows_ui_xaml_controls_primitives_SelectorItem_type.get())};
    if (!FlipViewItem_bases)
    {
        return nullptr;
    }

    py::pytype_handle FlipViewItem_type{py::register_python_type(module.get(), &type_spec_FlipViewItem, FlipViewItem_bases.get(), reinterpret_cast<PyTypeObject*>(type_FlipViewItem_Static.get()))};
    if (!FlipViewItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle Flyout_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_primitives_FlyoutBase_type.get())))};
    if (!Flyout_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Flyout_Static{PyType_FromSpecWithBases(&type_spec_Flyout_Static, Flyout_Static_bases.get())};
    if (!type_Flyout_Static)
    {
        return nullptr;
    }

    py::pyobj_handle Flyout_bases{PyTuple_Pack(1, windows_ui_xaml_controls_primitives_FlyoutBase_type.get())};
    if (!Flyout_bases)
    {
        return nullptr;
    }

    py::pytype_handle Flyout_type{py::register_python_type(module.get(), &type_spec_Flyout, Flyout_bases.get(), reinterpret_cast<PyTypeObject*>(type_Flyout_Static.get()))};
    if (!Flyout_type)
    {
        return nullptr;
    }

    py::pyobj_handle ListViewBase_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_primitives_Selector_type.get())))};
    if (!ListViewBase_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListViewBase_Static{PyType_FromSpecWithBases(&type_spec_ListViewBase_Static, ListViewBase_Static_bases.get())};
    if (!type_ListViewBase_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ListViewBase_bases{PyTuple_Pack(1, windows_ui_xaml_controls_primitives_Selector_type.get())};
    if (!ListViewBase_bases)
    {
        return nullptr;
    }

    py::pytype_handle ListViewBase_type{py::register_python_type(module.get(), &type_spec_ListViewBase, ListViewBase_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListViewBase_Static.get()))};
    if (!ListViewBase_type)
    {
        return nullptr;
    }

    py::pyobj_handle GridView_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(ListViewBase_type.get())))};
    if (!GridView_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_GridView_Static{PyType_FromSpecWithBases(&type_spec_GridView_Static, GridView_Static_bases.get())};
    if (!type_GridView_Static)
    {
        return nullptr;
    }

    py::pyobj_handle GridView_bases{PyTuple_Pack(1, ListViewBase_type.get())};
    if (!GridView_bases)
    {
        return nullptr;
    }

    py::pytype_handle GridView_type{py::register_python_type(module.get(), &type_spec_GridView, GridView_bases.get(), reinterpret_cast<PyTypeObject*>(type_GridView_Static.get()))};
    if (!GridView_type)
    {
        return nullptr;
    }

    py::pyobj_handle GridViewItem_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_primitives_SelectorItem_type.get())))};
    if (!GridViewItem_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_GridViewItem_Static{PyType_FromSpecWithBases(&type_spec_GridViewItem_Static, GridViewItem_Static_bases.get())};
    if (!type_GridViewItem_Static)
    {
        return nullptr;
    }

    py::pyobj_handle GridViewItem_bases{PyTuple_Pack(1, windows_ui_xaml_controls_primitives_SelectorItem_type.get())};
    if (!GridViewItem_bases)
    {
        return nullptr;
    }

    py::pytype_handle GridViewItem_type{py::register_python_type(module.get(), &type_spec_GridViewItem, GridViewItem_bases.get(), reinterpret_cast<PyTypeObject*>(type_GridViewItem_Static.get()))};
    if (!GridViewItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle HyperlinkButton_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_primitives_ButtonBase_type.get())))};
    if (!HyperlinkButton_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_HyperlinkButton_Static{PyType_FromSpecWithBases(&type_spec_HyperlinkButton_Static, HyperlinkButton_Static_bases.get())};
    if (!type_HyperlinkButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle HyperlinkButton_bases{PyTuple_Pack(1, windows_ui_xaml_controls_primitives_ButtonBase_type.get())};
    if (!HyperlinkButton_bases)
    {
        return nullptr;
    }

    py::pytype_handle HyperlinkButton_type{py::register_python_type(module.get(), &type_spec_HyperlinkButton, HyperlinkButton_bases.get(), reinterpret_cast<PyTypeObject*>(type_HyperlinkButton_Static.get()))};
    if (!HyperlinkButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle RadioButton_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_primitives_ToggleButton_type.get())))};
    if (!RadioButton_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RadioButton_Static{PyType_FromSpecWithBases(&type_spec_RadioButton_Static, RadioButton_Static_bases.get())};
    if (!type_RadioButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RadioButton_bases{PyTuple_Pack(1, windows_ui_xaml_controls_primitives_ToggleButton_type.get())};
    if (!RadioButton_bases)
    {
        return nullptr;
    }

    py::pytype_handle RadioButton_type{py::register_python_type(module.get(), &type_spec_RadioButton, RadioButton_bases.get(), reinterpret_cast<PyTypeObject*>(type_RadioButton_Static.get()))};
    if (!RadioButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarToolButton_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(RadioButton_type.get())))};
    if (!InkToolbarToolButton_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarToolButton_Static{PyType_FromSpecWithBases(&type_spec_InkToolbarToolButton_Static, InkToolbarToolButton_Static_bases.get())};
    if (!type_InkToolbarToolButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarToolButton_bases{PyTuple_Pack(1, RadioButton_type.get())};
    if (!InkToolbarToolButton_bases)
    {
        return nullptr;
    }

    py::pytype_handle InkToolbarToolButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarToolButton, InkToolbarToolButton_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarToolButton_Static.get()))};
    if (!InkToolbarToolButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarPenButton_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(InkToolbarToolButton_type.get())))};
    if (!InkToolbarPenButton_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarPenButton_Static{PyType_FromSpecWithBases(&type_spec_InkToolbarPenButton_Static, InkToolbarPenButton_Static_bases.get())};
    if (!type_InkToolbarPenButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarPenButton_bases{PyTuple_Pack(1, InkToolbarToolButton_type.get())};
    if (!InkToolbarPenButton_bases)
    {
        return nullptr;
    }

    py::pytype_handle InkToolbarPenButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarPenButton, InkToolbarPenButton_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarPenButton_Static.get()))};
    if (!InkToolbarPenButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarBallpointPenButton_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(InkToolbarPenButton_type.get())))};
    if (!InkToolbarBallpointPenButton_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarBallpointPenButton_Static{PyType_FromSpecWithBases(&type_spec_InkToolbarBallpointPenButton_Static, InkToolbarBallpointPenButton_Static_bases.get())};
    if (!type_InkToolbarBallpointPenButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarBallpointPenButton_bases{PyTuple_Pack(1, InkToolbarPenButton_type.get())};
    if (!InkToolbarBallpointPenButton_bases)
    {
        return nullptr;
    }

    py::pytype_handle InkToolbarBallpointPenButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarBallpointPenButton, InkToolbarBallpointPenButton_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarBallpointPenButton_Static.get()))};
    if (!InkToolbarBallpointPenButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarCustomPenButton_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(InkToolbarPenButton_type.get())))};
    if (!InkToolbarCustomPenButton_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarCustomPenButton_Static{PyType_FromSpecWithBases(&type_spec_InkToolbarCustomPenButton_Static, InkToolbarCustomPenButton_Static_bases.get())};
    if (!type_InkToolbarCustomPenButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarCustomPenButton_bases{PyTuple_Pack(1, InkToolbarPenButton_type.get())};
    if (!InkToolbarCustomPenButton_bases)
    {
        return nullptr;
    }

    py::pytype_handle InkToolbarCustomPenButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarCustomPenButton, InkToolbarCustomPenButton_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarCustomPenButton_Static.get()))};
    if (!InkToolbarCustomPenButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarToggleButton_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(CheckBox_type.get())))};
    if (!InkToolbarToggleButton_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarToggleButton_Static{PyType_FromSpecWithBases(&type_spec_InkToolbarToggleButton_Static, InkToolbarToggleButton_Static_bases.get())};
    if (!type_InkToolbarToggleButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarToggleButton_bases{PyTuple_Pack(1, CheckBox_type.get())};
    if (!InkToolbarToggleButton_bases)
    {
        return nullptr;
    }

    py::pytype_handle InkToolbarToggleButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarToggleButton, InkToolbarToggleButton_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarToggleButton_Static.get()))};
    if (!InkToolbarToggleButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarCustomToggleButton_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(InkToolbarToggleButton_type.get())))};
    if (!InkToolbarCustomToggleButton_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarCustomToggleButton_Static{PyType_FromSpecWithBases(&type_spec_InkToolbarCustomToggleButton_Static, InkToolbarCustomToggleButton_Static_bases.get())};
    if (!type_InkToolbarCustomToggleButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarCustomToggleButton_bases{PyTuple_Pack(1, InkToolbarToggleButton_type.get())};
    if (!InkToolbarCustomToggleButton_bases)
    {
        return nullptr;
    }

    py::pytype_handle InkToolbarCustomToggleButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarCustomToggleButton, InkToolbarCustomToggleButton_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarCustomToggleButton_Static.get()))};
    if (!InkToolbarCustomToggleButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarCustomToolButton_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(InkToolbarToolButton_type.get())))};
    if (!InkToolbarCustomToolButton_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarCustomToolButton_Static{PyType_FromSpecWithBases(&type_spec_InkToolbarCustomToolButton_Static, InkToolbarCustomToolButton_Static_bases.get())};
    if (!type_InkToolbarCustomToolButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarCustomToolButton_bases{PyTuple_Pack(1, InkToolbarToolButton_type.get())};
    if (!InkToolbarCustomToolButton_bases)
    {
        return nullptr;
    }

    py::pytype_handle InkToolbarCustomToolButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarCustomToolButton, InkToolbarCustomToolButton_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarCustomToolButton_Static.get()))};
    if (!InkToolbarCustomToolButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarEraserButton_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(InkToolbarToolButton_type.get())))};
    if (!InkToolbarEraserButton_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarEraserButton_Static{PyType_FromSpecWithBases(&type_spec_InkToolbarEraserButton_Static, InkToolbarEraserButton_Static_bases.get())};
    if (!type_InkToolbarEraserButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarEraserButton_bases{PyTuple_Pack(1, InkToolbarToolButton_type.get())};
    if (!InkToolbarEraserButton_bases)
    {
        return nullptr;
    }

    py::pytype_handle InkToolbarEraserButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarEraserButton, InkToolbarEraserButton_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarEraserButton_Static.get()))};
    if (!InkToolbarEraserButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarFlyoutItem_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_primitives_ButtonBase_type.get())))};
    if (!InkToolbarFlyoutItem_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarFlyoutItem_Static{PyType_FromSpecWithBases(&type_spec_InkToolbarFlyoutItem_Static, InkToolbarFlyoutItem_Static_bases.get())};
    if (!type_InkToolbarFlyoutItem_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarFlyoutItem_bases{PyTuple_Pack(1, windows_ui_xaml_controls_primitives_ButtonBase_type.get())};
    if (!InkToolbarFlyoutItem_bases)
    {
        return nullptr;
    }

    py::pytype_handle InkToolbarFlyoutItem_type{py::register_python_type(module.get(), &type_spec_InkToolbarFlyoutItem, InkToolbarFlyoutItem_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarFlyoutItem_Static.get()))};
    if (!InkToolbarFlyoutItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarHighlighterButton_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(InkToolbarPenButton_type.get())))};
    if (!InkToolbarHighlighterButton_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarHighlighterButton_Static{PyType_FromSpecWithBases(&type_spec_InkToolbarHighlighterButton_Static, InkToolbarHighlighterButton_Static_bases.get())};
    if (!type_InkToolbarHighlighterButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarHighlighterButton_bases{PyTuple_Pack(1, InkToolbarPenButton_type.get())};
    if (!InkToolbarHighlighterButton_bases)
    {
        return nullptr;
    }

    py::pytype_handle InkToolbarHighlighterButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarHighlighterButton, InkToolbarHighlighterButton_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarHighlighterButton_Static.get()))};
    if (!InkToolbarHighlighterButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarMenuButton_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_primitives_ToggleButton_type.get())))};
    if (!InkToolbarMenuButton_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarMenuButton_Static{PyType_FromSpecWithBases(&type_spec_InkToolbarMenuButton_Static, InkToolbarMenuButton_Static_bases.get())};
    if (!type_InkToolbarMenuButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarMenuButton_bases{PyTuple_Pack(1, windows_ui_xaml_controls_primitives_ToggleButton_type.get())};
    if (!InkToolbarMenuButton_bases)
    {
        return nullptr;
    }

    py::pytype_handle InkToolbarMenuButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarMenuButton, InkToolbarMenuButton_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarMenuButton_Static.get()))};
    if (!InkToolbarMenuButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarPencilButton_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(InkToolbarPenButton_type.get())))};
    if (!InkToolbarPencilButton_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarPencilButton_Static{PyType_FromSpecWithBases(&type_spec_InkToolbarPencilButton_Static, InkToolbarPencilButton_Static_bases.get())};
    if (!type_InkToolbarPencilButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarPencilButton_bases{PyTuple_Pack(1, InkToolbarPenButton_type.get())};
    if (!InkToolbarPencilButton_bases)
    {
        return nullptr;
    }

    py::pytype_handle InkToolbarPencilButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarPencilButton, InkToolbarPencilButton_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarPencilButton_Static.get()))};
    if (!InkToolbarPencilButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarRulerButton_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(InkToolbarToggleButton_type.get())))};
    if (!InkToolbarRulerButton_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarRulerButton_Static{PyType_FromSpecWithBases(&type_spec_InkToolbarRulerButton_Static, InkToolbarRulerButton_Static_bases.get())};
    if (!type_InkToolbarRulerButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarRulerButton_bases{PyTuple_Pack(1, InkToolbarToggleButton_type.get())};
    if (!InkToolbarRulerButton_bases)
    {
        return nullptr;
    }

    py::pytype_handle InkToolbarRulerButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarRulerButton, InkToolbarRulerButton_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarRulerButton_Static.get()))};
    if (!InkToolbarRulerButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarStencilButton_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(InkToolbarMenuButton_type.get())))};
    if (!InkToolbarStencilButton_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarStencilButton_Static{PyType_FromSpecWithBases(&type_spec_InkToolbarStencilButton_Static, InkToolbarStencilButton_Static_bases.get())};
    if (!type_InkToolbarStencilButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarStencilButton_bases{PyTuple_Pack(1, InkToolbarMenuButton_type.get())};
    if (!InkToolbarStencilButton_bases)
    {
        return nullptr;
    }

    py::pytype_handle InkToolbarStencilButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarStencilButton, InkToolbarStencilButton_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarStencilButton_Static.get()))};
    if (!InkToolbarStencilButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle ListBox_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_primitives_Selector_type.get())))};
    if (!ListBox_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListBox_Static{PyType_FromSpecWithBases(&type_spec_ListBox_Static, ListBox_Static_bases.get())};
    if (!type_ListBox_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ListBox_bases{PyTuple_Pack(1, windows_ui_xaml_controls_primitives_Selector_type.get())};
    if (!ListBox_bases)
    {
        return nullptr;
    }

    py::pytype_handle ListBox_type{py::register_python_type(module.get(), &type_spec_ListBox, ListBox_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListBox_Static.get()))};
    if (!ListBox_type)
    {
        return nullptr;
    }

    py::pyobj_handle ListBoxItem_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_primitives_SelectorItem_type.get())))};
    if (!ListBoxItem_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListBoxItem_Static{PyType_FromSpecWithBases(&type_spec_ListBoxItem_Static, ListBoxItem_Static_bases.get())};
    if (!type_ListBoxItem_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ListBoxItem_bases{PyTuple_Pack(1, windows_ui_xaml_controls_primitives_SelectorItem_type.get())};
    if (!ListBoxItem_bases)
    {
        return nullptr;
    }

    py::pytype_handle ListBoxItem_type{py::register_python_type(module.get(), &type_spec_ListBoxItem, ListBoxItem_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListBoxItem_Static.get()))};
    if (!ListBoxItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle ListPickerFlyout_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_primitives_PickerFlyoutBase_type.get())))};
    if (!ListPickerFlyout_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListPickerFlyout_Static{PyType_FromSpecWithBases(&type_spec_ListPickerFlyout_Static, ListPickerFlyout_Static_bases.get())};
    if (!type_ListPickerFlyout_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ListPickerFlyout_bases{PyTuple_Pack(1, windows_ui_xaml_controls_primitives_PickerFlyoutBase_type.get())};
    if (!ListPickerFlyout_bases)
    {
        return nullptr;
    }

    py::pytype_handle ListPickerFlyout_type{py::register_python_type(module.get(), &type_spec_ListPickerFlyout, ListPickerFlyout_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListPickerFlyout_Static.get()))};
    if (!ListPickerFlyout_type)
    {
        return nullptr;
    }

    py::pyobj_handle ListView_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(ListViewBase_type.get())))};
    if (!ListView_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListView_Static{PyType_FromSpecWithBases(&type_spec_ListView_Static, ListView_Static_bases.get())};
    if (!type_ListView_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ListView_bases{PyTuple_Pack(1, ListViewBase_type.get())};
    if (!ListView_bases)
    {
        return nullptr;
    }

    py::pytype_handle ListView_type{py::register_python_type(module.get(), &type_spec_ListView, ListView_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListView_Static.get()))};
    if (!ListView_type)
    {
        return nullptr;
    }

    py::pyobj_handle ListViewItem_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_primitives_SelectorItem_type.get())))};
    if (!ListViewItem_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListViewItem_Static{PyType_FromSpecWithBases(&type_spec_ListViewItem_Static, ListViewItem_Static_bases.get())};
    if (!type_ListViewItem_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ListViewItem_bases{PyTuple_Pack(1, windows_ui_xaml_controls_primitives_SelectorItem_type.get())};
    if (!ListViewItem_bases)
    {
        return nullptr;
    }

    py::pytype_handle ListViewItem_type{py::register_python_type(module.get(), &type_spec_ListViewItem, ListViewItem_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListViewItem_Static.get()))};
    if (!ListViewItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle MenuFlyout_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_primitives_FlyoutBase_type.get())))};
    if (!MenuFlyout_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_MenuFlyout_Static{PyType_FromSpecWithBases(&type_spec_MenuFlyout_Static, MenuFlyout_Static_bases.get())};
    if (!type_MenuFlyout_Static)
    {
        return nullptr;
    }

    py::pyobj_handle MenuFlyout_bases{PyTuple_Pack(1, windows_ui_xaml_controls_primitives_FlyoutBase_type.get())};
    if (!MenuFlyout_bases)
    {
        return nullptr;
    }

    py::pytype_handle MenuFlyout_type{py::register_python_type(module.get(), &type_spec_MenuFlyout, MenuFlyout_bases.get(), reinterpret_cast<PyTypeObject*>(type_MenuFlyout_Static.get()))};
    if (!MenuFlyout_type)
    {
        return nullptr;
    }

    py::pyobj_handle MenuBarItemFlyout_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(MenuFlyout_type.get())))};
    if (!MenuBarItemFlyout_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_MenuBarItemFlyout_Static{PyType_FromSpecWithBases(&type_spec_MenuBarItemFlyout_Static, MenuBarItemFlyout_Static_bases.get())};
    if (!type_MenuBarItemFlyout_Static)
    {
        return nullptr;
    }

    py::pyobj_handle MenuBarItemFlyout_bases{PyTuple_Pack(1, MenuFlyout_type.get())};
    if (!MenuBarItemFlyout_bases)
    {
        return nullptr;
    }

    py::pytype_handle MenuBarItemFlyout_type{py::register_python_type(module.get(), &type_spec_MenuBarItemFlyout, MenuBarItemFlyout_bases.get(), reinterpret_cast<PyTypeObject*>(type_MenuBarItemFlyout_Static.get()))};
    if (!MenuBarItemFlyout_type)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItemBase_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(ListViewItem_type.get())))};
    if (!NavigationViewItemBase_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_NavigationViewItemBase_Static{PyType_FromSpecWithBases(&type_spec_NavigationViewItemBase_Static, NavigationViewItemBase_Static_bases.get())};
    if (!type_NavigationViewItemBase_Static)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItemBase_bases{PyTuple_Pack(1, ListViewItem_type.get())};
    if (!NavigationViewItemBase_bases)
    {
        return nullptr;
    }

    py::pytype_handle NavigationViewItemBase_type{py::register_python_type(module.get(), &type_spec_NavigationViewItemBase, NavigationViewItemBase_bases.get(), reinterpret_cast<PyTypeObject*>(type_NavigationViewItemBase_Static.get()))};
    if (!NavigationViewItemBase_type)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItem_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(NavigationViewItemBase_type.get())))};
    if (!NavigationViewItem_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_NavigationViewItem_Static{PyType_FromSpecWithBases(&type_spec_NavigationViewItem_Static, NavigationViewItem_Static_bases.get())};
    if (!type_NavigationViewItem_Static)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItem_bases{PyTuple_Pack(1, NavigationViewItemBase_type.get())};
    if (!NavigationViewItem_bases)
    {
        return nullptr;
    }

    py::pytype_handle NavigationViewItem_type{py::register_python_type(module.get(), &type_spec_NavigationViewItem, NavigationViewItem_bases.get(), reinterpret_cast<PyTypeObject*>(type_NavigationViewItem_Static.get()))};
    if (!NavigationViewItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItemHeader_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(NavigationViewItemBase_type.get())))};
    if (!NavigationViewItemHeader_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_NavigationViewItemHeader_Static{PyType_FromSpecWithBases(&type_spec_NavigationViewItemHeader_Static, NavigationViewItemHeader_Static_bases.get())};
    if (!type_NavigationViewItemHeader_Static)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItemHeader_bases{PyTuple_Pack(1, NavigationViewItemBase_type.get())};
    if (!NavigationViewItemHeader_bases)
    {
        return nullptr;
    }

    py::pytype_handle NavigationViewItemHeader_type{py::register_python_type(module.get(), &type_spec_NavigationViewItemHeader, NavigationViewItemHeader_bases.get(), reinterpret_cast<PyTypeObject*>(type_NavigationViewItemHeader_Static.get()))};
    if (!NavigationViewItemHeader_type)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItemSeparator_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(NavigationViewItemBase_type.get())))};
    if (!NavigationViewItemSeparator_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_NavigationViewItemSeparator_Static{PyType_FromSpecWithBases(&type_spec_NavigationViewItemSeparator_Static, NavigationViewItemSeparator_Static_bases.get())};
    if (!type_NavigationViewItemSeparator_Static)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItemSeparator_bases{PyTuple_Pack(1, NavigationViewItemBase_type.get())};
    if (!NavigationViewItemSeparator_bases)
    {
        return nullptr;
    }

    py::pytype_handle NavigationViewItemSeparator_type{py::register_python_type(module.get(), &type_spec_NavigationViewItemSeparator, NavigationViewItemSeparator_bases.get(), reinterpret_cast<PyTypeObject*>(type_NavigationViewItemSeparator_Static.get()))};
    if (!NavigationViewItemSeparator_type)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewList_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(ListView_type.get())))};
    if (!NavigationViewList_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_NavigationViewList_Static{PyType_FromSpecWithBases(&type_spec_NavigationViewList_Static, NavigationViewList_Static_bases.get())};
    if (!type_NavigationViewList_Static)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewList_bases{PyTuple_Pack(1, ListView_type.get())};
    if (!NavigationViewList_bases)
    {
        return nullptr;
    }

    py::pytype_handle NavigationViewList_type{py::register_python_type(module.get(), &type_spec_NavigationViewList, NavigationViewList_bases.get(), reinterpret_cast<PyTypeObject*>(type_NavigationViewList_Static.get()))};
    if (!NavigationViewList_type)
    {
        return nullptr;
    }

    py::pyobj_handle PickerFlyout_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_primitives_PickerFlyoutBase_type.get())))};
    if (!PickerFlyout_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PickerFlyout_Static{PyType_FromSpecWithBases(&type_spec_PickerFlyout_Static, PickerFlyout_Static_bases.get())};
    if (!type_PickerFlyout_Static)
    {
        return nullptr;
    }

    py::pyobj_handle PickerFlyout_bases{PyTuple_Pack(1, windows_ui_xaml_controls_primitives_PickerFlyoutBase_type.get())};
    if (!PickerFlyout_bases)
    {
        return nullptr;
    }

    py::pytype_handle PickerFlyout_type{py::register_python_type(module.get(), &type_spec_PickerFlyout, PickerFlyout_bases.get(), reinterpret_cast<PyTypeObject*>(type_PickerFlyout_Static.get()))};
    if (!PickerFlyout_type)
    {
        return nullptr;
    }

    py::pyobj_handle ProgressBar_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_primitives_RangeBase_type.get())))};
    if (!ProgressBar_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ProgressBar_Static{PyType_FromSpecWithBases(&type_spec_ProgressBar_Static, ProgressBar_Static_bases.get())};
    if (!type_ProgressBar_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ProgressBar_bases{PyTuple_Pack(1, windows_ui_xaml_controls_primitives_RangeBase_type.get())};
    if (!ProgressBar_bases)
    {
        return nullptr;
    }

    py::pytype_handle ProgressBar_type{py::register_python_type(module.get(), &type_spec_ProgressBar, ProgressBar_bases.get(), reinterpret_cast<PyTypeObject*>(type_ProgressBar_Static.get()))};
    if (!ProgressBar_type)
    {
        return nullptr;
    }

    py::pyobj_handle Slider_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_primitives_RangeBase_type.get())))};
    if (!Slider_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Slider_Static{PyType_FromSpecWithBases(&type_spec_Slider_Static, Slider_Static_bases.get())};
    if (!type_Slider_Static)
    {
        return nullptr;
    }

    py::pyobj_handle Slider_bases{PyTuple_Pack(1, windows_ui_xaml_controls_primitives_RangeBase_type.get())};
    if (!Slider_bases)
    {
        return nullptr;
    }

    py::pytype_handle Slider_type{py::register_python_type(module.get(), &type_spec_Slider, Slider_bases.get(), reinterpret_cast<PyTypeObject*>(type_Slider_Static.get()))};
    if (!Slider_type)
    {
        return nullptr;
    }

    py::pyobj_handle TextCommandBarFlyout_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(CommandBarFlyout_type.get())))};
    if (!TextCommandBarFlyout_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TextCommandBarFlyout_Static{PyType_FromSpecWithBases(&type_spec_TextCommandBarFlyout_Static, TextCommandBarFlyout_Static_bases.get())};
    if (!type_TextCommandBarFlyout_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TextCommandBarFlyout_bases{PyTuple_Pack(1, CommandBarFlyout_type.get())};
    if (!TextCommandBarFlyout_bases)
    {
        return nullptr;
    }

    py::pytype_handle TextCommandBarFlyout_type{py::register_python_type(module.get(), &type_spec_TextCommandBarFlyout, TextCommandBarFlyout_bases.get(), reinterpret_cast<PyTypeObject*>(type_TextCommandBarFlyout_Static.get()))};
    if (!TextCommandBarFlyout_type)
    {
        return nullptr;
    }

    py::pyobj_handle TimePickerFlyout_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_primitives_PickerFlyoutBase_type.get())))};
    if (!TimePickerFlyout_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TimePickerFlyout_Static{PyType_FromSpecWithBases(&type_spec_TimePickerFlyout_Static, TimePickerFlyout_Static_bases.get())};
    if (!type_TimePickerFlyout_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TimePickerFlyout_bases{PyTuple_Pack(1, windows_ui_xaml_controls_primitives_PickerFlyoutBase_type.get())};
    if (!TimePickerFlyout_bases)
    {
        return nullptr;
    }

    py::pytype_handle TimePickerFlyout_type{py::register_python_type(module.get(), &type_spec_TimePickerFlyout, TimePickerFlyout_bases.get(), reinterpret_cast<PyTypeObject*>(type_TimePickerFlyout_Static.get()))};
    if (!TimePickerFlyout_type)
    {
        return nullptr;
    }

    py::pyobj_handle TreeViewItem_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(ListViewItem_type.get())))};
    if (!TreeViewItem_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TreeViewItem_Static{PyType_FromSpecWithBases(&type_spec_TreeViewItem_Static, TreeViewItem_Static_bases.get())};
    if (!type_TreeViewItem_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TreeViewItem_bases{PyTuple_Pack(1, ListViewItem_type.get())};
    if (!TreeViewItem_bases)
    {
        return nullptr;
    }

    py::pytype_handle TreeViewItem_type{py::register_python_type(module.get(), &type_spec_TreeViewItem, TreeViewItem_bases.get(), reinterpret_cast<PyTypeObject*>(type_TreeViewItem_Static.get()))};
    if (!TreeViewItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle TreeViewList_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(ListView_type.get())))};
    if (!TreeViewList_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TreeViewList_Static{PyType_FromSpecWithBases(&type_spec_TreeViewList_Static, TreeViewList_Static_bases.get())};
    if (!type_TreeViewList_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TreeViewList_bases{PyTuple_Pack(1, ListView_type.get())};
    if (!TreeViewList_bases)
    {
        return nullptr;
    }

    py::pytype_handle TreeViewList_type{py::register_python_type(module.get(), &type_spec_TreeViewList, TreeViewList_bases.get(), reinterpret_cast<PyTypeObject*>(type_TreeViewList_Static.get()))};
    if (!TreeViewList_type)
    {
        return nullptr;
    }

    py::pyobj_handle VirtualizingStackPanel_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_primitives_OrientedVirtualizingPanel_type.get())))};
    if (!VirtualizingStackPanel_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_VirtualizingStackPanel_Static{PyType_FromSpecWithBases(&type_spec_VirtualizingStackPanel_Static, VirtualizingStackPanel_Static_bases.get())};
    if (!type_VirtualizingStackPanel_Static)
    {
        return nullptr;
    }

    py::pyobj_handle VirtualizingStackPanel_bases{PyTuple_Pack(1, windows_ui_xaml_controls_primitives_OrientedVirtualizingPanel_type.get())};
    if (!VirtualizingStackPanel_bases)
    {
        return nullptr;
    }

    py::pytype_handle VirtualizingStackPanel_type{py::register_python_type(module.get(), &type_spec_VirtualizingStackPanel, VirtualizingStackPanel_bases.get(), reinterpret_cast<PyTypeObject*>(type_VirtualizingStackPanel_Static.get()))};
    if (!VirtualizingStackPanel_type)
    {
        return nullptr;
    }

    py::pyobj_handle WrapGrid_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_primitives_OrientedVirtualizingPanel_type.get())))};
    if (!WrapGrid_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_WrapGrid_Static{PyType_FromSpecWithBases(&type_spec_WrapGrid_Static, WrapGrid_Static_bases.get())};
    if (!type_WrapGrid_Static)
    {
        return nullptr;
    }

    py::pyobj_handle WrapGrid_bases{PyTuple_Pack(1, windows_ui_xaml_controls_primitives_OrientedVirtualizingPanel_type.get())};
    if (!WrapGrid_bases)
    {
        return nullptr;
    }

    py::pytype_handle WrapGrid_type{py::register_python_type(module.get(), &type_spec_WrapGrid, WrapGrid_bases.get(), reinterpret_cast<PyTypeObject*>(type_WrapGrid_Static.get()))};
    if (!WrapGrid_type)
    {
        return nullptr;
    }


    return module.detach();
}
