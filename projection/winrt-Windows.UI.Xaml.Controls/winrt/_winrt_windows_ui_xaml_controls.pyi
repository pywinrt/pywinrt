# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.applicationmodel.contacts
import winrt.windows.applicationmodel.datatransfer
import winrt.windows.applicationmodel.search
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.globalization
import winrt.windows.media.capture
import winrt.windows.media.casting
import winrt.windows.media.core
import winrt.windows.media.playto
import winrt.windows.media.playback
import winrt.windows.media.protection
import winrt.windows.storage.streams
import winrt.windows.system
import winrt.windows.ui
import winrt.windows.ui.composition
import winrt.windows.ui.core
import winrt.windows.ui.input.inking
import winrt.windows.ui.text
import winrt.windows.ui.xaml
import winrt.windows.ui.xaml.automation
import winrt.windows.ui.xaml.controls.primitives
import winrt.windows.ui.xaml.data
import winrt.windows.ui.xaml.documents
import winrt.windows.ui.xaml.input
import winrt.windows.ui.xaml.interop
import winrt.windows.ui.xaml.media
import winrt.windows.ui.xaml.media.animation
import winrt.windows.ui.xaml.navigation
import winrt.windows.web
import winrt.windows.web.http

from winrt.windows.ui.xaml.controls import AppBarClosedDisplayMode, AutoSuggestionBoxTextChangeReason, BackgroundSizing, CalendarViewDisplayMode, CalendarViewSelectionMode, CandidateWindowAlignment, CharacterCasing, ClickMode, ColorPickerHsvChannel, ColorSpectrumComponents, ColorSpectrumShape, ComboBoxSelectionChangedTrigger, CommandBarDefaultLabelPosition, CommandBarDynamicOverflowAction, CommandBarLabelPosition, CommandBarOverflowButtonVisibility, ContentDialogButton, ContentDialogPlacement, ContentDialogResult, ContentLinkChangeKind, DisabledFormattingAccelerators, HandwritingPanelPlacementAlignment, IncrementalLoadingTrigger, InkToolbarButtonFlyoutPlacement, InkToolbarFlyoutItemKind, InkToolbarInitialControls, InkToolbarMenuKind, InkToolbarStencilKind, InkToolbarToggle, InkToolbarTool, ItemsUpdatingScrollMode, LightDismissOverlayMode, ListPickerFlyoutSelectionMode, ListViewReorderMode, ListViewSelectionMode, NavigationViewBackButtonVisible, NavigationViewDisplayMode, NavigationViewOverflowLabelMode, NavigationViewPaneDisplayMode, NavigationViewSelectionFollowsFocus, NavigationViewShoulderNavigationEnabled, Orientation, PanelScrollingDirection, ParallaxSourceOffsetKind, PasswordRevealMode, PivotHeaderFocusVisualPlacement, PivotSlideInAnimationGroup, RefreshPullDirection, RefreshVisualizerOrientation, RefreshVisualizerState, RequiresPointer, RichEditClipboardFormat, ScrollBarVisibility, ScrollIntoViewAlignment, ScrollMode, SelectionMode, SnapPointsType, SplitViewDisplayMode, SplitViewPanePlacement, StretchDirection, SwipeBehaviorOnInvoked, SwipeMode, Symbol, TreeViewSelectionMode, TwoPaneViewMode, TwoPaneViewPriority, TwoPaneViewTallModeConfiguration, TwoPaneViewWideModeConfiguration, VirtualizationMode, WebViewExecutionMode, WebViewPermissionState, WebViewPermissionType, ZoomMode
from winrt.windows.ui.xaml.controls import BackClickEventHandler, CalendarViewDayItemChangingEventHandler, CleanUpVirtualizedItemEventHandler, ContextMenuOpeningEventHandler, DragItemsStartingEventHandler, HubSectionHeaderClickEventHandler, ItemClickEventHandler, ListViewItemToKeyHandler, ListViewKeyToItemHandler, NotifyEventHandler, SectionsInViewChangedEventHandler, SelectionChangedEventHandler, SemanticZoomViewChangedEventHandler, TextChangedEventHandler, TextControlPasteEventHandler, WebViewNavigationFailedEventHandler

Self = typing.TypeVar('Self')

@typing.final
class AnchorRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AnchorRequestedEventArgs: ...
    @_property
    def anchor(self) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    @anchor.setter
    def anchor(self, value: typing.Optional[winrt.windows.ui.xaml.UIElement]) -> None: ...
    @_property
    def anchor_candidates(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.ui.xaml.UIElement]]: ...

@typing.final
class AppBar_Static(type):
    @_property
    def is_open_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_sticky_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def closed_display_mode_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def light_dismiss_overlay_mode_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class AppBar(winrt.system.Object, metaclass=AppBar_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBar: ...
    def __new__(cls: typing.Type[AppBar]) -> AppBar:...
    def on_closed(self, e: typing.Optional[winrt.system.Object], /) -> None: ...
    def on_closing(self, e: typing.Optional[winrt.system.Object], /) -> None: ...
    def on_opened(self, e: typing.Optional[winrt.system.Object], /) -> None: ...
    def on_opening(self, e: typing.Optional[winrt.system.Object], /) -> None: ...
    def add_closed(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_opened(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_opened(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_closing(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_opening(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_opening(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def is_sticky(self) -> bool: ...
    @is_sticky.setter
    def is_sticky(self, value: bool) -> None: ...
    @_property
    def is_open(self) -> bool: ...
    @is_open.setter
    def is_open(self, value: bool) -> None: ...
    @_property
    def closed_display_mode(self) -> AppBarClosedDisplayMode: ...
    @closed_display_mode.setter
    def closed_display_mode(self, value: AppBarClosedDisplayMode) -> None: ...
    @_property
    def template_settings(self) -> typing.Optional[winrt.windows.ui.xaml.controls.primitives.AppBarTemplateSettings]: ...
    @_property
    def light_dismiss_overlay_mode(self) -> LightDismissOverlayMode: ...
    @light_dismiss_overlay_mode.setter
    def light_dismiss_overlay_mode(self, value: LightDismissOverlayMode) -> None: ...

@typing.final
class AppBarButton_Static(type):
    @_property
    def icon_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_compact_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def label_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def dynamic_overflow_order_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_in_overflow_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def label_position_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def keyboard_accelerator_text_override_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class AppBarButton(winrt.system.Object, metaclass=AppBarButton_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBarButton: ...
    def __new__(cls: typing.Type[AppBarButton]) -> AppBarButton:...
    @_property
    def label(self) -> str: ...
    @label.setter
    def label(self, value: str) -> None: ...
    @_property
    def icon(self) -> typing.Optional[IconElement]: ...
    @icon.setter
    def icon(self, value: typing.Optional[IconElement]) -> None: ...
    @_property
    def label_position(self) -> CommandBarLabelPosition: ...
    @label_position.setter
    def label_position(self, value: CommandBarLabelPosition) -> None: ...
    @_property
    def keyboard_accelerator_text_override(self) -> str: ...
    @keyboard_accelerator_text_override.setter
    def keyboard_accelerator_text_override(self, value: str) -> None: ...
    @_property
    def template_settings(self) -> typing.Optional[winrt.windows.ui.xaml.controls.primitives.AppBarButtonTemplateSettings]: ...
    @_property
    def is_compact(self) -> bool: ...
    @is_compact.setter
    def is_compact(self, value: bool) -> None: ...
    @_property
    def dynamic_overflow_order(self) -> winrt.system.Int32: ...
    @dynamic_overflow_order.setter
    def dynamic_overflow_order(self, value: winrt.system.Int32) -> None: ...
    @_property
    def is_in_overflow(self) -> bool: ...

@typing.final
class AppBarElementContainer_Static(type):
    @_property
    def dynamic_overflow_order_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_compact_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_in_overflow_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class AppBarElementContainer(winrt.system.Object, metaclass=AppBarElementContainer_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBarElementContainer: ...
    def __new__(cls: typing.Type[AppBarElementContainer]) -> AppBarElementContainer:...
    @_property
    def is_compact(self) -> bool: ...
    @is_compact.setter
    def is_compact(self, value: bool) -> None: ...
    @_property
    def dynamic_overflow_order(self) -> winrt.system.Int32: ...
    @dynamic_overflow_order.setter
    def dynamic_overflow_order(self, value: winrt.system.Int32) -> None: ...
    @_property
    def is_in_overflow(self) -> bool: ...

@typing.final
class AppBarSeparator_Static(type):
    @_property
    def is_compact_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def dynamic_overflow_order_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_in_overflow_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class AppBarSeparator(winrt.system.Object, metaclass=AppBarSeparator_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBarSeparator: ...
    def __new__(cls: typing.Type[AppBarSeparator]) -> AppBarSeparator:...
    @_property
    def is_compact(self) -> bool: ...
    @is_compact.setter
    def is_compact(self, value: bool) -> None: ...
    @_property
    def dynamic_overflow_order(self) -> winrt.system.Int32: ...
    @dynamic_overflow_order.setter
    def dynamic_overflow_order(self, value: winrt.system.Int32) -> None: ...
    @_property
    def is_in_overflow(self) -> bool: ...

@typing.final
class AppBarToggleButton_Static(type):
    @_property
    def icon_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_compact_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def label_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def dynamic_overflow_order_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_in_overflow_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def label_position_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def keyboard_accelerator_text_override_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class AppBarToggleButton(winrt.system.Object, metaclass=AppBarToggleButton_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBarToggleButton: ...
    def __new__(cls: typing.Type[AppBarToggleButton]) -> AppBarToggleButton:...
    @_property
    def label(self) -> str: ...
    @label.setter
    def label(self, value: str) -> None: ...
    @_property
    def icon(self) -> typing.Optional[IconElement]: ...
    @icon.setter
    def icon(self, value: typing.Optional[IconElement]) -> None: ...
    @_property
    def label_position(self) -> CommandBarLabelPosition: ...
    @label_position.setter
    def label_position(self, value: CommandBarLabelPosition) -> None: ...
    @_property
    def keyboard_accelerator_text_override(self) -> str: ...
    @keyboard_accelerator_text_override.setter
    def keyboard_accelerator_text_override(self, value: str) -> None: ...
    @_property
    def template_settings(self) -> typing.Optional[winrt.windows.ui.xaml.controls.primitives.AppBarToggleButtonTemplateSettings]: ...
    @_property
    def is_compact(self) -> bool: ...
    @is_compact.setter
    def is_compact(self, value: bool) -> None: ...
    @_property
    def dynamic_overflow_order(self) -> winrt.system.Int32: ...
    @dynamic_overflow_order.setter
    def dynamic_overflow_order(self, value: winrt.system.Int32) -> None: ...
    @_property
    def is_in_overflow(self) -> bool: ...

@typing.final
class AutoSuggestBox_Static(type):
    @_property
    def auto_maximize_suggestion_area_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def header_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_suggestion_list_open_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def max_suggestion_list_height_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def placeholder_text_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def text_box_style_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def text_member_path_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def text_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def update_text_on_select_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def query_icon_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def light_dismiss_overlay_mode_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def description_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class AutoSuggestBox(winrt.system.Object, metaclass=AutoSuggestBox_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AutoSuggestBox: ...
    def __new__(cls: typing.Type[AutoSuggestBox]) -> AutoSuggestBox:...
    def add_suggestion_chosen(self, handler: winrt.windows.foundation.TypedEventHandler[AutoSuggestBox, AutoSuggestBoxSuggestionChosenEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_suggestion_chosen(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_text_changed(self, handler: winrt.windows.foundation.TypedEventHandler[AutoSuggestBox, AutoSuggestBoxTextChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_text_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_query_submitted(self, handler: winrt.windows.foundation.TypedEventHandler[AutoSuggestBox, AutoSuggestBoxQuerySubmittedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_query_submitted(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def update_text_on_select(self) -> bool: ...
    @update_text_on_select.setter
    def update_text_on_select(self, value: bool) -> None: ...
    @_property
    def text_member_path(self) -> str: ...
    @text_member_path.setter
    def text_member_path(self, value: str) -> None: ...
    @_property
    def text_box_style(self) -> typing.Optional[winrt.windows.ui.xaml.Style]: ...
    @text_box_style.setter
    def text_box_style(self, value: typing.Optional[winrt.windows.ui.xaml.Style]) -> None: ...
    @_property
    def text(self) -> str: ...
    @text.setter
    def text(self, value: str) -> None: ...
    @_property
    def placeholder_text(self) -> str: ...
    @placeholder_text.setter
    def placeholder_text(self, value: str) -> None: ...
    @_property
    def max_suggestion_list_height(self) -> winrt.system.Double: ...
    @max_suggestion_list_height.setter
    def max_suggestion_list_height(self, value: winrt.system.Double) -> None: ...
    @_property
    def is_suggestion_list_open(self) -> bool: ...
    @is_suggestion_list_open.setter
    def is_suggestion_list_open(self, value: bool) -> None: ...
    @_property
    def header(self) -> typing.Optional[winrt.system.Object]: ...
    @header.setter
    def header(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def auto_maximize_suggestion_area(self) -> bool: ...
    @auto_maximize_suggestion_area.setter
    def auto_maximize_suggestion_area(self, value: bool) -> None: ...
    @_property
    def query_icon(self) -> typing.Optional[IconElement]: ...
    @query_icon.setter
    def query_icon(self, value: typing.Optional[IconElement]) -> None: ...
    @_property
    def light_dismiss_overlay_mode(self) -> LightDismissOverlayMode: ...
    @light_dismiss_overlay_mode.setter
    def light_dismiss_overlay_mode(self, value: LightDismissOverlayMode) -> None: ...
    @_property
    def description(self) -> typing.Optional[winrt.system.Object]: ...
    @description.setter
    def description(self, value: typing.Optional[winrt.system.Object]) -> None: ...

@typing.final
class AutoSuggestBoxQuerySubmittedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AutoSuggestBoxQuerySubmittedEventArgs: ...
    def __new__(cls: typing.Type[AutoSuggestBoxQuerySubmittedEventArgs]) -> AutoSuggestBoxQuerySubmittedEventArgs:...
    @_property
    def chosen_suggestion(self) -> typing.Optional[winrt.system.Object]: ...
    @_property
    def query_text(self) -> str: ...

@typing.final
class AutoSuggestBoxSuggestionChosenEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AutoSuggestBoxSuggestionChosenEventArgs: ...
    def __new__(cls: typing.Type[AutoSuggestBoxSuggestionChosenEventArgs]) -> AutoSuggestBoxSuggestionChosenEventArgs:...
    @_property
    def selected_item(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class AutoSuggestBoxTextChangedEventArgs_Static(type):
    @_property
    def reason_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class AutoSuggestBoxTextChangedEventArgs(winrt.system.Object, metaclass=AutoSuggestBoxTextChangedEventArgs_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AutoSuggestBoxTextChangedEventArgs: ...
    def __new__(cls: typing.Type[AutoSuggestBoxTextChangedEventArgs]) -> AutoSuggestBoxTextChangedEventArgs:...
    def check_current(self) -> bool: ...
    @_property
    def reason(self) -> AutoSuggestionBoxTextChangeReason: ...
    @reason.setter
    def reason(self, value: AutoSuggestionBoxTextChangeReason) -> None: ...

@typing.final
class BackClickEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BackClickEventArgs: ...
    def __new__(cls: typing.Type[BackClickEventArgs]) -> BackClickEventArgs:...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...

@typing.final
class BitmapIcon_Static(type):
    @_property
    def uri_source_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def show_as_monochrome_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class BitmapIcon(winrt.system.Object, metaclass=BitmapIcon_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BitmapIcon: ...
    def __new__(cls: typing.Type[BitmapIcon]) -> BitmapIcon:...
    @_property
    def uri_source(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @uri_source.setter
    def uri_source(self, value: typing.Optional[winrt.windows.foundation.Uri]) -> None: ...
    @_property
    def show_as_monochrome(self) -> bool: ...
    @show_as_monochrome.setter
    def show_as_monochrome(self, value: bool) -> None: ...

@typing.final
class BitmapIconSource_Static(type):
    @_property
    def show_as_monochrome_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def uri_source_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class BitmapIconSource(winrt.system.Object, metaclass=BitmapIconSource_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BitmapIconSource: ...
    def __new__(cls: typing.Type[BitmapIconSource]) -> BitmapIconSource:...
    @_property
    def uri_source(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @uri_source.setter
    def uri_source(self, value: typing.Optional[winrt.windows.foundation.Uri]) -> None: ...
    @_property
    def show_as_monochrome(self) -> bool: ...
    @show_as_monochrome.setter
    def show_as_monochrome(self, value: bool) -> None: ...

@typing.final
class Border_Static(type):
    @_property
    def background_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def border_brush_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def border_thickness_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def child_transitions_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def corner_radius_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def padding_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def background_sizing_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class Border(winrt.system.Object, metaclass=Border_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Border: ...
    def __new__(cls: typing.Type[Border]) -> Border:...
    @_property
    def padding(self) -> winrt.windows.ui.xaml.Thickness: ...
    @padding.setter
    def padding(self, value: winrt.windows.ui.xaml.Thickness) -> None: ...
    @_property
    def corner_radius(self) -> winrt.windows.ui.xaml.CornerRadius: ...
    @corner_radius.setter
    def corner_radius(self, value: winrt.windows.ui.xaml.CornerRadius) -> None: ...
    @_property
    def child_transitions(self) -> typing.Optional[winrt.windows.ui.xaml.media.animation.TransitionCollection]: ...
    @child_transitions.setter
    def child_transitions(self, value: typing.Optional[winrt.windows.ui.xaml.media.animation.TransitionCollection]) -> None: ...
    @_property
    def child(self) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    @child.setter
    def child(self, value: typing.Optional[winrt.windows.ui.xaml.UIElement]) -> None: ...
    @_property
    def border_thickness(self) -> winrt.windows.ui.xaml.Thickness: ...
    @border_thickness.setter
    def border_thickness(self, value: winrt.windows.ui.xaml.Thickness) -> None: ...
    @_property
    def border_brush(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @border_brush.setter
    def border_brush(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def background(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @background.setter
    def background(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def background_transition(self) -> typing.Optional[winrt.windows.ui.xaml.BrushTransition]: ...
    @background_transition.setter
    def background_transition(self, value: typing.Optional[winrt.windows.ui.xaml.BrushTransition]) -> None: ...
    @_property
    def background_sizing(self) -> BackgroundSizing: ...
    @background_sizing.setter
    def background_sizing(self, value: BackgroundSizing) -> None: ...

@typing.final
class Button_Static(type):
    @_property
    def flyout_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class Button(winrt.system.Object, metaclass=Button_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Button: ...
    def __new__(cls: typing.Type[Button]) -> Button:...
    @_property
    def flyout(self) -> typing.Optional[winrt.windows.ui.xaml.controls.primitives.FlyoutBase]: ...
    @flyout.setter
    def flyout(self, value: typing.Optional[winrt.windows.ui.xaml.controls.primitives.FlyoutBase]) -> None: ...

@typing.final
class CalendarDatePicker_Static(type):
    @_property
    def calendar_identifier_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def calendar_view_style_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def date_format_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def date_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def day_of_week_format_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def display_mode_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def first_day_of_week_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def header_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def header_template_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_calendar_open_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_group_label_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_out_of_scope_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_today_highlighted_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def max_date_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def min_date_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def placeholder_text_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def light_dismiss_overlay_mode_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def description_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class CalendarDatePicker(winrt.system.Object, metaclass=CalendarDatePicker_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CalendarDatePicker: ...
    def __new__(cls: typing.Type[CalendarDatePicker]) -> CalendarDatePicker:...
    def set_display_date(self, date: datetime.datetime, /) -> None: ...
    def set_year_decade_display_dimensions(self, columns: winrt.system.Int32, rows: winrt.system.Int32, /) -> None: ...
    def add_calendar_view_day_item_changing(self, handler: typing.Optional[CalendarViewDayItemChangingEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_calendar_view_day_item_changing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_closed(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_date_changed(self, handler: winrt.windows.foundation.TypedEventHandler[CalendarDatePicker, CalendarDatePickerDateChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_date_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_opened(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_opened(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def placeholder_text(self) -> str: ...
    @placeholder_text.setter
    def placeholder_text(self, value: str) -> None: ...
    @_property
    def min_date(self) -> datetime.datetime: ...
    @min_date.setter
    def min_date(self, value: datetime.datetime) -> None: ...
    @_property
    def max_date(self) -> datetime.datetime: ...
    @max_date.setter
    def max_date(self, value: datetime.datetime) -> None: ...
    @_property
    def is_today_highlighted(self) -> bool: ...
    @is_today_highlighted.setter
    def is_today_highlighted(self, value: bool) -> None: ...
    @_property
    def is_out_of_scope_enabled(self) -> bool: ...
    @is_out_of_scope_enabled.setter
    def is_out_of_scope_enabled(self, value: bool) -> None: ...
    @_property
    def is_group_label_visible(self) -> bool: ...
    @is_group_label_visible.setter
    def is_group_label_visible(self, value: bool) -> None: ...
    @_property
    def is_calendar_open(self) -> bool: ...
    @is_calendar_open.setter
    def is_calendar_open(self, value: bool) -> None: ...
    @_property
    def header_template(self) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @header_template.setter
    def header_template(self, value: typing.Optional[winrt.windows.ui.xaml.DataTemplate]) -> None: ...
    @_property
    def header(self) -> typing.Optional[winrt.system.Object]: ...
    @header.setter
    def header(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def first_day_of_week(self) -> winrt.windows.globalization.DayOfWeek: ...
    @first_day_of_week.setter
    def first_day_of_week(self, value: winrt.windows.globalization.DayOfWeek) -> None: ...
    @_property
    def display_mode(self) -> CalendarViewDisplayMode: ...
    @display_mode.setter
    def display_mode(self, value: CalendarViewDisplayMode) -> None: ...
    @_property
    def day_of_week_format(self) -> str: ...
    @day_of_week_format.setter
    def day_of_week_format(self, value: str) -> None: ...
    @_property
    def date_format(self) -> str: ...
    @date_format.setter
    def date_format(self, value: str) -> None: ...
    @_property
    def date(self) -> typing.Optional[typing.Optional[datetime.datetime]]: ...
    @date.setter
    def date(self, value: typing.Optional[typing.Optional[datetime.datetime]]) -> None: ...
    @_property
    def calendar_view_style(self) -> typing.Optional[winrt.windows.ui.xaml.Style]: ...
    @calendar_view_style.setter
    def calendar_view_style(self, value: typing.Optional[winrt.windows.ui.xaml.Style]) -> None: ...
    @_property
    def calendar_identifier(self) -> str: ...
    @calendar_identifier.setter
    def calendar_identifier(self, value: str) -> None: ...
    @_property
    def light_dismiss_overlay_mode(self) -> LightDismissOverlayMode: ...
    @light_dismiss_overlay_mode.setter
    def light_dismiss_overlay_mode(self, value: LightDismissOverlayMode) -> None: ...
    @_property
    def description(self) -> typing.Optional[winrt.system.Object]: ...
    @description.setter
    def description(self, value: typing.Optional[winrt.system.Object]) -> None: ...

@typing.final
class CalendarDatePickerDateChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CalendarDatePickerDateChangedEventArgs: ...
    @_property
    def new_date(self) -> typing.Optional[typing.Optional[datetime.datetime]]: ...
    @_property
    def old_date(self) -> typing.Optional[typing.Optional[datetime.datetime]]: ...

@typing.final
class CalendarView_Static(type):
    @_property
    def is_out_of_scope_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_today_highlighted_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def max_date_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def min_date_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def month_year_item_font_family_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def month_year_item_font_size_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def month_year_item_font_style_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def month_year_item_font_weight_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def number_of_weeks_in_view_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def first_day_of_week_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def out_of_scope_background_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def out_of_scope_foreground_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def pressed_border_brush_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def pressed_foreground_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selected_border_brush_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selected_foreground_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selected_hover_border_brush_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selected_pressed_border_brush_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selection_mode_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def template_settings_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def today_font_weight_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def today_foreground_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def vertical_day_item_alignment_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def vertical_first_of_month_label_alignment_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def blackout_foreground_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def calendar_identifier_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def calendar_item_background_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def calendar_item_border_brush_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def calendar_item_border_thickness_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def calendar_item_foreground_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def calendar_view_day_item_style_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def day_item_font_family_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def day_item_font_size_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def day_item_font_style_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def day_item_font_weight_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def day_of_week_format_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def display_mode_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selected_dates_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def first_of_month_label_font_family_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def first_of_month_label_font_size_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def first_of_month_label_font_style_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def first_of_month_label_font_weight_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def first_of_year_decade_label_font_family_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def first_of_year_decade_label_font_size_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def first_of_year_decade_label_font_style_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def first_of_year_decade_label_font_weight_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def focus_border_brush_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def horizontal_day_item_alignment_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def horizontal_first_of_month_label_alignment_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def hover_border_brush_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_group_label_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def blackout_background_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def blackout_strikethrough_brush_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def calendar_item_corner_radius_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def calendar_item_disabled_background_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def calendar_item_hover_background_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def calendar_item_pressed_background_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def day_item_margin_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def disabled_foreground_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def first_of_month_label_margin_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def month_year_item_margin_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def out_of_scope_hover_foreground_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def out_of_scope_pressed_foreground_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selected_disabled_border_brush_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selected_disabled_foreground_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selected_hover_foreground_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selected_pressed_foreground_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def today_background_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def today_blackout_background_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def today_blackout_foreground_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def today_disabled_background_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def today_hover_background_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def today_pressed_background_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def today_selected_inner_border_brush_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def first_of_year_decade_label_margin_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class CalendarView(winrt.system.Object, metaclass=CalendarView_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CalendarView: ...
    def __new__(cls: typing.Type[CalendarView]) -> CalendarView:...
    def set_display_date(self, date: datetime.datetime, /) -> None: ...
    def set_year_decade_display_dimensions(self, columns: winrt.system.Int32, rows: winrt.system.Int32, /) -> None: ...
    def add_calendar_view_day_item_changing(self, handler: winrt.windows.foundation.TypedEventHandler[CalendarView, CalendarViewDayItemChangingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_calendar_view_day_item_changing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_selected_dates_changed(self, handler: winrt.windows.foundation.TypedEventHandler[CalendarView, CalendarViewSelectedDatesChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_selected_dates_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def first_of_month_label_font_weight(self) -> winrt.windows.ui.text.FontWeight: ...
    @first_of_month_label_font_weight.setter
    def first_of_month_label_font_weight(self, value: winrt.windows.ui.text.FontWeight) -> None: ...
    @_property
    def first_of_month_label_font_style(self) -> winrt.windows.ui.text.FontStyle: ...
    @first_of_month_label_font_style.setter
    def first_of_month_label_font_style(self, value: winrt.windows.ui.text.FontStyle) -> None: ...
    @_property
    def first_of_month_label_font_size(self) -> winrt.system.Double: ...
    @first_of_month_label_font_size.setter
    def first_of_month_label_font_size(self, value: winrt.system.Double) -> None: ...
    @_property
    def first_of_month_label_font_family(self) -> typing.Optional[winrt.windows.ui.xaml.media.FontFamily]: ...
    @first_of_month_label_font_family.setter
    def first_of_month_label_font_family(self, value: typing.Optional[winrt.windows.ui.xaml.media.FontFamily]) -> None: ...
    @_property
    def first_day_of_week(self) -> winrt.windows.globalization.DayOfWeek: ...
    @first_day_of_week.setter
    def first_day_of_week(self, value: winrt.windows.globalization.DayOfWeek) -> None: ...
    @_property
    def display_mode(self) -> CalendarViewDisplayMode: ...
    @display_mode.setter
    def display_mode(self, value: CalendarViewDisplayMode) -> None: ...
    @_property
    def day_of_week_format(self) -> str: ...
    @day_of_week_format.setter
    def day_of_week_format(self, value: str) -> None: ...
    @_property
    def day_item_font_weight(self) -> winrt.windows.ui.text.FontWeight: ...
    @day_item_font_weight.setter
    def day_item_font_weight(self, value: winrt.windows.ui.text.FontWeight) -> None: ...
    @_property
    def is_today_highlighted(self) -> bool: ...
    @is_today_highlighted.setter
    def is_today_highlighted(self, value: bool) -> None: ...
    @_property
    def day_item_font_size(self) -> winrt.system.Double: ...
    @day_item_font_size.setter
    def day_item_font_size(self, value: winrt.system.Double) -> None: ...
    @_property
    def day_item_font_family(self) -> typing.Optional[winrt.windows.ui.xaml.media.FontFamily]: ...
    @day_item_font_family.setter
    def day_item_font_family(self, value: typing.Optional[winrt.windows.ui.xaml.media.FontFamily]) -> None: ...
    @_property
    def calendar_view_day_item_style(self) -> typing.Optional[winrt.windows.ui.xaml.Style]: ...
    @calendar_view_day_item_style.setter
    def calendar_view_day_item_style(self, value: typing.Optional[winrt.windows.ui.xaml.Style]) -> None: ...
    @_property
    def calendar_item_foreground(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @calendar_item_foreground.setter
    def calendar_item_foreground(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def calendar_item_border_thickness(self) -> winrt.windows.ui.xaml.Thickness: ...
    @calendar_item_border_thickness.setter
    def calendar_item_border_thickness(self, value: winrt.windows.ui.xaml.Thickness) -> None: ...
    @_property
    def calendar_item_border_brush(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @calendar_item_border_brush.setter
    def calendar_item_border_brush(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def calendar_item_background(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @calendar_item_background.setter
    def calendar_item_background(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def calendar_identifier(self) -> str: ...
    @calendar_identifier.setter
    def calendar_identifier(self, value: str) -> None: ...
    @_property
    def out_of_scope_background(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @out_of_scope_background.setter
    def out_of_scope_background(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def blackout_foreground(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @blackout_foreground.setter
    def blackout_foreground(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def first_of_year_decade_label_font_family(self) -> typing.Optional[winrt.windows.ui.xaml.media.FontFamily]: ...
    @first_of_year_decade_label_font_family.setter
    def first_of_year_decade_label_font_family(self, value: typing.Optional[winrt.windows.ui.xaml.media.FontFamily]) -> None: ...
    @_property
    def number_of_weeks_in_view(self) -> winrt.system.Int32: ...
    @number_of_weeks_in_view.setter
    def number_of_weeks_in_view(self, value: winrt.system.Int32) -> None: ...
    @_property
    def month_year_item_font_weight(self) -> winrt.windows.ui.text.FontWeight: ...
    @month_year_item_font_weight.setter
    def month_year_item_font_weight(self, value: winrt.windows.ui.text.FontWeight) -> None: ...
    @_property
    def month_year_item_font_style(self) -> winrt.windows.ui.text.FontStyle: ...
    @month_year_item_font_style.setter
    def month_year_item_font_style(self, value: winrt.windows.ui.text.FontStyle) -> None: ...
    @_property
    def month_year_item_font_size(self) -> winrt.system.Double: ...
    @month_year_item_font_size.setter
    def month_year_item_font_size(self, value: winrt.system.Double) -> None: ...
    @_property
    def month_year_item_font_family(self) -> typing.Optional[winrt.windows.ui.xaml.media.FontFamily]: ...
    @month_year_item_font_family.setter
    def month_year_item_font_family(self, value: typing.Optional[winrt.windows.ui.xaml.media.FontFamily]) -> None: ...
    @_property
    def min_date(self) -> datetime.datetime: ...
    @min_date.setter
    def min_date(self, value: datetime.datetime) -> None: ...
    @_property
    def max_date(self) -> datetime.datetime: ...
    @max_date.setter
    def max_date(self, value: datetime.datetime) -> None: ...
    @_property
    def out_of_scope_foreground(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @out_of_scope_foreground.setter
    def out_of_scope_foreground(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def is_out_of_scope_enabled(self) -> bool: ...
    @is_out_of_scope_enabled.setter
    def is_out_of_scope_enabled(self, value: bool) -> None: ...
    @_property
    def is_group_label_visible(self) -> bool: ...
    @is_group_label_visible.setter
    def is_group_label_visible(self, value: bool) -> None: ...
    @_property
    def hover_border_brush(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @hover_border_brush.setter
    def hover_border_brush(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def horizontal_first_of_month_label_alignment(self) -> winrt.windows.ui.xaml.HorizontalAlignment: ...
    @horizontal_first_of_month_label_alignment.setter
    def horizontal_first_of_month_label_alignment(self, value: winrt.windows.ui.xaml.HorizontalAlignment) -> None: ...
    @_property
    def horizontal_day_item_alignment(self) -> winrt.windows.ui.xaml.HorizontalAlignment: ...
    @horizontal_day_item_alignment.setter
    def horizontal_day_item_alignment(self, value: winrt.windows.ui.xaml.HorizontalAlignment) -> None: ...
    @_property
    def focus_border_brush(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @focus_border_brush.setter
    def focus_border_brush(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def first_of_year_decade_label_font_weight(self) -> winrt.windows.ui.text.FontWeight: ...
    @first_of_year_decade_label_font_weight.setter
    def first_of_year_decade_label_font_weight(self, value: winrt.windows.ui.text.FontWeight) -> None: ...
    @_property
    def first_of_year_decade_label_font_style(self) -> winrt.windows.ui.text.FontStyle: ...
    @first_of_year_decade_label_font_style.setter
    def first_of_year_decade_label_font_style(self, value: winrt.windows.ui.text.FontStyle) -> None: ...
    @_property
    def first_of_year_decade_label_font_size(self) -> winrt.system.Double: ...
    @first_of_year_decade_label_font_size.setter
    def first_of_year_decade_label_font_size(self, value: winrt.system.Double) -> None: ...
    @_property
    def day_item_font_style(self) -> winrt.windows.ui.text.FontStyle: ...
    @day_item_font_style.setter
    def day_item_font_style(self, value: winrt.windows.ui.text.FontStyle) -> None: ...
    @_property
    def vertical_first_of_month_label_alignment(self) -> winrt.windows.ui.xaml.VerticalAlignment: ...
    @vertical_first_of_month_label_alignment.setter
    def vertical_first_of_month_label_alignment(self, value: winrt.windows.ui.xaml.VerticalAlignment) -> None: ...
    @_property
    def vertical_day_item_alignment(self) -> winrt.windows.ui.xaml.VerticalAlignment: ...
    @vertical_day_item_alignment.setter
    def vertical_day_item_alignment(self, value: winrt.windows.ui.xaml.VerticalAlignment) -> None: ...
    @_property
    def today_foreground(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @today_foreground.setter
    def today_foreground(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def today_font_weight(self) -> winrt.windows.ui.text.FontWeight: ...
    @today_font_weight.setter
    def today_font_weight(self, value: winrt.windows.ui.text.FontWeight) -> None: ...
    @_property
    def selection_mode(self) -> CalendarViewSelectionMode: ...
    @selection_mode.setter
    def selection_mode(self, value: CalendarViewSelectionMode) -> None: ...
    @_property
    def selected_pressed_border_brush(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @selected_pressed_border_brush.setter
    def selected_pressed_border_brush(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def selected_hover_border_brush(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @selected_hover_border_brush.setter
    def selected_hover_border_brush(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def selected_foreground(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @selected_foreground.setter
    def selected_foreground(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def selected_border_brush(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @selected_border_brush.setter
    def selected_border_brush(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def pressed_foreground(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @pressed_foreground.setter
    def pressed_foreground(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def pressed_border_brush(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @pressed_border_brush.setter
    def pressed_border_brush(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def selected_dates(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[datetime.datetime]]: ...
    @_property
    def template_settings(self) -> typing.Optional[winrt.windows.ui.xaml.controls.primitives.CalendarViewTemplateSettings]: ...
    @_property
    def calendar_item_hover_background(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @calendar_item_hover_background.setter
    def calendar_item_hover_background(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def calendar_item_disabled_background(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @calendar_item_disabled_background.setter
    def calendar_item_disabled_background(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def calendar_item_corner_radius(self) -> winrt.windows.ui.xaml.CornerRadius: ...
    @calendar_item_corner_radius.setter
    def calendar_item_corner_radius(self, value: winrt.windows.ui.xaml.CornerRadius) -> None: ...
    @_property
    def blackout_strikethrough_brush(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @blackout_strikethrough_brush.setter
    def blackout_strikethrough_brush(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def blackout_background(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @blackout_background.setter
    def blackout_background(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def calendar_item_pressed_background(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @calendar_item_pressed_background.setter
    def calendar_item_pressed_background(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def today_selected_inner_border_brush(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @today_selected_inner_border_brush.setter
    def today_selected_inner_border_brush(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def today_pressed_background(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @today_pressed_background.setter
    def today_pressed_background(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def today_hover_background(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @today_hover_background.setter
    def today_hover_background(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def today_disabled_background(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @today_disabled_background.setter
    def today_disabled_background(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def today_blackout_foreground(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @today_blackout_foreground.setter
    def today_blackout_foreground(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def today_blackout_background(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @today_blackout_background.setter
    def today_blackout_background(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def today_background(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @today_background.setter
    def today_background(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def selected_pressed_foreground(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @selected_pressed_foreground.setter
    def selected_pressed_foreground(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def selected_hover_foreground(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @selected_hover_foreground.setter
    def selected_hover_foreground(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def selected_disabled_foreground(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @selected_disabled_foreground.setter
    def selected_disabled_foreground(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def selected_disabled_border_brush(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @selected_disabled_border_brush.setter
    def selected_disabled_border_brush(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def out_of_scope_pressed_foreground(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @out_of_scope_pressed_foreground.setter
    def out_of_scope_pressed_foreground(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def out_of_scope_hover_foreground(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @out_of_scope_hover_foreground.setter
    def out_of_scope_hover_foreground(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def month_year_item_margin(self) -> winrt.windows.ui.xaml.Thickness: ...
    @month_year_item_margin.setter
    def month_year_item_margin(self, value: winrt.windows.ui.xaml.Thickness) -> None: ...
    @_property
    def first_of_year_decade_label_margin(self) -> winrt.windows.ui.xaml.Thickness: ...
    @first_of_year_decade_label_margin.setter
    def first_of_year_decade_label_margin(self, value: winrt.windows.ui.xaml.Thickness) -> None: ...
    @_property
    def first_of_month_label_margin(self) -> winrt.windows.ui.xaml.Thickness: ...
    @first_of_month_label_margin.setter
    def first_of_month_label_margin(self, value: winrt.windows.ui.xaml.Thickness) -> None: ...
    @_property
    def disabled_foreground(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @disabled_foreground.setter
    def disabled_foreground(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def day_item_margin(self) -> winrt.windows.ui.xaml.Thickness: ...
    @day_item_margin.setter
    def day_item_margin(self, value: winrt.windows.ui.xaml.Thickness) -> None: ...

@typing.final
class CalendarViewDayItem_Static(type):
    @_property
    def date_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_blackout_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class CalendarViewDayItem(winrt.system.Object, metaclass=CalendarViewDayItem_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CalendarViewDayItem: ...
    def __new__(cls: typing.Type[CalendarViewDayItem]) -> CalendarViewDayItem:...
    def set_density_colors(self, colors: typing.Iterable[winrt.windows.ui.Color], /) -> None: ...
    @_property
    def is_blackout(self) -> bool: ...
    @is_blackout.setter
    def is_blackout(self, value: bool) -> None: ...
    @_property
    def date(self) -> datetime.datetime: ...

@typing.final
class CalendarViewDayItemChangingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CalendarViewDayItemChangingEventArgs: ...
    @typing.overload
    def register_update_callback(self, callback: winrt.windows.foundation.TypedEventHandler[CalendarView, CalendarViewDayItemChangingEventArgs], /) -> None: ...
    @typing.overload
    def register_update_callback(self, callback_phase: winrt.system.UInt32, callback: winrt.windows.foundation.TypedEventHandler[CalendarView, CalendarViewDayItemChangingEventArgs], /) -> None: ...
    @_property
    def in_recycle_queue(self) -> bool: ...
    @_property
    def item(self) -> typing.Optional[CalendarViewDayItem]: ...
    @_property
    def phase(self) -> winrt.system.UInt32: ...

@typing.final
class CalendarViewSelectedDatesChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CalendarViewSelectedDatesChangedEventArgs: ...
    @_property
    def added_dates(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[datetime.datetime]]: ...
    @_property
    def removed_dates(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[datetime.datetime]]: ...

@typing.final
class CandidateWindowBoundsChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CandidateWindowBoundsChangedEventArgs: ...
    @_property
    def bounds(self) -> winrt.windows.foundation.Rect: ...

@typing.final
class Canvas_Static(type):
    def get_left(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> winrt.system.Double: ...
    def get_top(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> winrt.system.Double: ...
    def get_z_index(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> winrt.system.Int32: ...
    def set_left(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], length: winrt.system.Double, /) -> None: ...
    def set_top(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], length: winrt.system.Double, /) -> None: ...
    def set_z_index(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: winrt.system.Int32, /) -> None: ...
    @_property
    def left_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def top_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def z_index_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class Canvas(winrt.system.Object, metaclass=Canvas_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Canvas: ...
    def __new__(cls: typing.Type[Canvas]) -> Canvas:...

@typing.final
class CaptureElement_Static(type):
    @_property
    def source_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def stretch_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class CaptureElement(winrt.system.Object, metaclass=CaptureElement_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CaptureElement: ...
    def __new__(cls: typing.Type[CaptureElement]) -> CaptureElement:...
    @_property
    def stretch(self) -> winrt.windows.ui.xaml.media.Stretch: ...
    @stretch.setter
    def stretch(self, value: winrt.windows.ui.xaml.media.Stretch) -> None: ...
    @_property
    def source(self) -> typing.Optional[winrt.windows.media.capture.MediaCapture]: ...
    @source.setter
    def source(self, value: typing.Optional[winrt.windows.media.capture.MediaCapture]) -> None: ...

@typing.final
class CheckBox(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CheckBox: ...
    def __new__(cls: typing.Type[CheckBox]) -> CheckBox:...

@typing.final
class ChoosingGroupHeaderContainerEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChoosingGroupHeaderContainerEventArgs: ...
    def __new__(cls: typing.Type[ChoosingGroupHeaderContainerEventArgs]) -> ChoosingGroupHeaderContainerEventArgs:...
    @_property
    def group_header_container(self) -> typing.Optional[ListViewBaseHeaderItem]: ...
    @group_header_container.setter
    def group_header_container(self, value: typing.Optional[ListViewBaseHeaderItem]) -> None: ...
    @_property
    def group(self) -> typing.Optional[winrt.system.Object]: ...
    @_property
    def group_index(self) -> winrt.system.Int32: ...

@typing.final
class ChoosingItemContainerEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChoosingItemContainerEventArgs: ...
    def __new__(cls: typing.Type[ChoosingItemContainerEventArgs]) -> ChoosingItemContainerEventArgs:...
    @_property
    def item_container(self) -> typing.Optional[winrt.windows.ui.xaml.controls.primitives.SelectorItem]: ...
    @item_container.setter
    def item_container(self, value: typing.Optional[winrt.windows.ui.xaml.controls.primitives.SelectorItem]) -> None: ...
    @_property
    def is_container_prepared(self) -> bool: ...
    @is_container_prepared.setter
    def is_container_prepared(self, value: bool) -> None: ...
    @_property
    def item(self) -> typing.Optional[winrt.system.Object]: ...
    @_property
    def item_index(self) -> winrt.system.Int32: ...

@typing.final
class CleanUpVirtualizedItemEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CleanUpVirtualizedItemEventArgs: ...
    @_property
    def cancel(self) -> bool: ...
    @cancel.setter
    def cancel(self, value: bool) -> None: ...
    @_property
    def u_i_element(self) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    @_property
    def value(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class ColorChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ColorChangedEventArgs: ...
    @_property
    def new_color(self) -> winrt.windows.ui.Color: ...
    @_property
    def old_color(self) -> winrt.windows.ui.Color: ...

@typing.final
class ColorPicker_Static(type):
    @_property
    def color_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def color_spectrum_components_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def color_spectrum_shape_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_alpha_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_alpha_slider_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_alpha_text_input_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_color_channel_text_input_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_color_preview_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_color_slider_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_color_spectrum_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_hex_input_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_more_button_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def max_hue_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def max_saturation_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def max_value_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def min_hue_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def min_saturation_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def min_value_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def previous_color_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class ColorPicker(winrt.system.Object, metaclass=ColorPicker_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ColorPicker: ...
    def __new__(cls: typing.Type[ColorPicker]) -> ColorPicker:...
    def add_color_changed(self, handler: winrt.windows.foundation.TypedEventHandler[ColorPicker, ColorChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_color_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def previous_color(self) -> typing.Optional[typing.Optional[winrt.windows.ui.Color]]: ...
    @previous_color.setter
    def previous_color(self, value: typing.Optional[typing.Optional[winrt.windows.ui.Color]]) -> None: ...
    @_property
    def min_value(self) -> winrt.system.Int32: ...
    @min_value.setter
    def min_value(self, value: winrt.system.Int32) -> None: ...
    @_property
    def min_saturation(self) -> winrt.system.Int32: ...
    @min_saturation.setter
    def min_saturation(self, value: winrt.system.Int32) -> None: ...
    @_property
    def min_hue(self) -> winrt.system.Int32: ...
    @min_hue.setter
    def min_hue(self, value: winrt.system.Int32) -> None: ...
    @_property
    def max_value(self) -> winrt.system.Int32: ...
    @max_value.setter
    def max_value(self, value: winrt.system.Int32) -> None: ...
    @_property
    def max_saturation(self) -> winrt.system.Int32: ...
    @max_saturation.setter
    def max_saturation(self, value: winrt.system.Int32) -> None: ...
    @_property
    def max_hue(self) -> winrt.system.Int32: ...
    @max_hue.setter
    def max_hue(self, value: winrt.system.Int32) -> None: ...
    @_property
    def is_more_button_visible(self) -> bool: ...
    @is_more_button_visible.setter
    def is_more_button_visible(self, value: bool) -> None: ...
    @_property
    def is_hex_input_visible(self) -> bool: ...
    @is_hex_input_visible.setter
    def is_hex_input_visible(self, value: bool) -> None: ...
    @_property
    def is_color_spectrum_visible(self) -> bool: ...
    @is_color_spectrum_visible.setter
    def is_color_spectrum_visible(self, value: bool) -> None: ...
    @_property
    def is_color_slider_visible(self) -> bool: ...
    @is_color_slider_visible.setter
    def is_color_slider_visible(self, value: bool) -> None: ...
    @_property
    def is_color_preview_visible(self) -> bool: ...
    @is_color_preview_visible.setter
    def is_color_preview_visible(self, value: bool) -> None: ...
    @_property
    def is_color_channel_text_input_visible(self) -> bool: ...
    @is_color_channel_text_input_visible.setter
    def is_color_channel_text_input_visible(self, value: bool) -> None: ...
    @_property
    def is_alpha_text_input_visible(self) -> bool: ...
    @is_alpha_text_input_visible.setter
    def is_alpha_text_input_visible(self, value: bool) -> None: ...
    @_property
    def is_alpha_slider_visible(self) -> bool: ...
    @is_alpha_slider_visible.setter
    def is_alpha_slider_visible(self, value: bool) -> None: ...
    @_property
    def is_alpha_enabled(self) -> bool: ...
    @is_alpha_enabled.setter
    def is_alpha_enabled(self, value: bool) -> None: ...
    @_property
    def color_spectrum_shape(self) -> ColorSpectrumShape: ...
    @color_spectrum_shape.setter
    def color_spectrum_shape(self, value: ColorSpectrumShape) -> None: ...
    @_property
    def color_spectrum_components(self) -> ColorSpectrumComponents: ...
    @color_spectrum_components.setter
    def color_spectrum_components(self, value: ColorSpectrumComponents) -> None: ...
    @_property
    def color(self) -> winrt.windows.ui.Color: ...
    @color.setter
    def color(self, value: winrt.windows.ui.Color) -> None: ...

@typing.final
class ColumnDefinition_Static(type):
    @_property
    def max_width_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def min_width_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def width_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class ColumnDefinition(winrt.system.Object, metaclass=ColumnDefinition_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ColumnDefinition: ...
    def __new__(cls: typing.Type[ColumnDefinition]) -> ColumnDefinition:...
    @_property
    def width(self) -> winrt.windows.ui.xaml.GridLength: ...
    @width.setter
    def width(self, value: winrt.windows.ui.xaml.GridLength) -> None: ...
    @_property
    def min_width(self) -> winrt.system.Double: ...
    @min_width.setter
    def min_width(self, value: winrt.system.Double) -> None: ...
    @_property
    def max_width(self) -> winrt.system.Double: ...
    @max_width.setter
    def max_width(self, value: winrt.system.Double) -> None: ...
    @_property
    def actual_width(self) -> winrt.system.Double: ...

@typing.final
class ColumnDefinitionCollection(winrt.system.Object, winrt._winrt.MutableSequence[ColumnDefinition]):
    def __len__(self) -> int: ...
    def __iter__(self) -> winrt.windows.foundation.collections.IIterator[ColumnDefinition]: ...
    @typing.overload
    def __getitem__(self, index: typing.SupportsIndex) -> ColumnDefinition: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[ColumnDefinition]: ...
    @typing.overload
    def __delitem__(self, index: typing.SupportsIndex) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: typing.SupportsIndex, value: ColumnDefinition) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[ColumnDefinition]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ColumnDefinitionCollection: ...
    def append(self, value: typing.Optional[ColumnDefinition], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[ColumnDefinition]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[ColumnDefinition]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[ColumnDefinition], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ColumnDefinition]]: ...
    def index_of(self, value: typing.Optional[ColumnDefinition], /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[ColumnDefinition], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[ColumnDefinition], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[ColumnDefinition], /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class ComboBox_Static(type):
    @_property
    def is_drop_down_open_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def max_drop_down_height_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def header_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def header_template_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def placeholder_text_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_text_search_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def light_dismiss_overlay_mode_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selection_changed_trigger_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def placeholder_foreground_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def description_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_editable_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def text_box_style_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def text_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class ComboBox(winrt.system.Object, metaclass=ComboBox_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ComboBox: ...
    def __new__(cls: typing.Type[ComboBox]) -> ComboBox:...
    def on_drop_down_closed(self, e: typing.Optional[winrt.system.Object], /) -> None: ...
    def on_drop_down_opened(self, e: typing.Optional[winrt.system.Object], /) -> None: ...
    def add_drop_down_closed(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_drop_down_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_drop_down_opened(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_drop_down_opened(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_text_submitted(self, handler: winrt.windows.foundation.TypedEventHandler[ComboBox, ComboBoxTextSubmittedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_text_submitted(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def max_drop_down_height(self) -> winrt.system.Double: ...
    @max_drop_down_height.setter
    def max_drop_down_height(self, value: winrt.system.Double) -> None: ...
    @_property
    def is_editable(self) -> bool: ...
    @is_editable.setter
    def is_editable(self, value: bool) -> None: ...
    @_property
    def is_drop_down_open(self) -> bool: ...
    @is_drop_down_open.setter
    def is_drop_down_open(self, value: bool) -> None: ...
    @_property
    def is_selection_box_highlighted(self) -> bool: ...
    @_property
    def selection_box_item(self) -> typing.Optional[winrt.system.Object]: ...
    @_property
    def selection_box_item_template(self) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @_property
    def template_settings(self) -> typing.Optional[winrt.windows.ui.xaml.controls.primitives.ComboBoxTemplateSettings]: ...
    @_property
    def placeholder_text(self) -> str: ...
    @placeholder_text.setter
    def placeholder_text(self, value: str) -> None: ...
    @_property
    def header_template(self) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @header_template.setter
    def header_template(self, value: typing.Optional[winrt.windows.ui.xaml.DataTemplate]) -> None: ...
    @_property
    def header(self) -> typing.Optional[winrt.system.Object]: ...
    @header.setter
    def header(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def light_dismiss_overlay_mode(self) -> LightDismissOverlayMode: ...
    @light_dismiss_overlay_mode.setter
    def light_dismiss_overlay_mode(self, value: LightDismissOverlayMode) -> None: ...
    @_property
    def is_text_search_enabled(self) -> bool: ...
    @is_text_search_enabled.setter
    def is_text_search_enabled(self, value: bool) -> None: ...
    @_property
    def selection_changed_trigger(self) -> ComboBoxSelectionChangedTrigger: ...
    @selection_changed_trigger.setter
    def selection_changed_trigger(self, value: ComboBoxSelectionChangedTrigger) -> None: ...
    @_property
    def placeholder_foreground(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @placeholder_foreground.setter
    def placeholder_foreground(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def text_box_style(self) -> typing.Optional[winrt.windows.ui.xaml.Style]: ...
    @text_box_style.setter
    def text_box_style(self, value: typing.Optional[winrt.windows.ui.xaml.Style]) -> None: ...
    @_property
    def text(self) -> str: ...
    @text.setter
    def text(self, value: str) -> None: ...
    @_property
    def description(self) -> typing.Optional[winrt.system.Object]: ...
    @description.setter
    def description(self, value: typing.Optional[winrt.system.Object]) -> None: ...

@typing.final
class ComboBoxItem(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ComboBoxItem: ...
    def __new__(cls: typing.Type[ComboBoxItem]) -> ComboBoxItem:...

@typing.final
class ComboBoxTextSubmittedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ComboBoxTextSubmittedEventArgs: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def text(self) -> str: ...

@typing.final
class CommandBar_Static(type):
    @_property
    def primary_commands_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def secondary_commands_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def command_bar_overflow_presenter_style_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def default_label_position_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_dynamic_overflow_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def overflow_button_visibility_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class CommandBar(winrt.system.Object, metaclass=CommandBar_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CommandBar: ...
    def __new__(cls: typing.Type[CommandBar]) -> CommandBar:...
    def add_dynamic_overflow_items_changing(self, handler: winrt.windows.foundation.TypedEventHandler[CommandBar, DynamicOverflowItemsChangingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_dynamic_overflow_items_changing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def primary_commands(self) -> typing.Optional[winrt.windows.foundation.collections.IObservableVector[ICommandBarElement]]: ...
    @_property
    def secondary_commands(self) -> typing.Optional[winrt.windows.foundation.collections.IObservableVector[ICommandBarElement]]: ...
    @_property
    def command_bar_overflow_presenter_style(self) -> typing.Optional[winrt.windows.ui.xaml.Style]: ...
    @command_bar_overflow_presenter_style.setter
    def command_bar_overflow_presenter_style(self, value: typing.Optional[winrt.windows.ui.xaml.Style]) -> None: ...
    @_property
    def command_bar_template_settings(self) -> typing.Optional[winrt.windows.ui.xaml.controls.primitives.CommandBarTemplateSettings]: ...
    @_property
    def overflow_button_visibility(self) -> CommandBarOverflowButtonVisibility: ...
    @overflow_button_visibility.setter
    def overflow_button_visibility(self, value: CommandBarOverflowButtonVisibility) -> None: ...
    @_property
    def is_dynamic_overflow_enabled(self) -> bool: ...
    @is_dynamic_overflow_enabled.setter
    def is_dynamic_overflow_enabled(self, value: bool) -> None: ...
    @_property
    def default_label_position(self) -> CommandBarDefaultLabelPosition: ...
    @default_label_position.setter
    def default_label_position(self, value: CommandBarDefaultLabelPosition) -> None: ...

@typing.final
class CommandBarFlyout(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CommandBarFlyout: ...
    def __new__(cls: typing.Type[CommandBarFlyout]) -> CommandBarFlyout:...
    @_property
    def primary_commands(self) -> typing.Optional[winrt.windows.foundation.collections.IObservableVector[ICommandBarElement]]: ...
    @_property
    def secondary_commands(self) -> typing.Optional[winrt.windows.foundation.collections.IObservableVector[ICommandBarElement]]: ...

@typing.final
class CommandBarOverflowPresenter(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CommandBarOverflowPresenter: ...
    def __new__(cls: typing.Type[CommandBarOverflowPresenter]) -> CommandBarOverflowPresenter:...

@typing.final
class ContainerContentChangingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContainerContentChangingEventArgs: ...
    def __new__(cls: typing.Type[ContainerContentChangingEventArgs]) -> ContainerContentChangingEventArgs:...
    @typing.overload
    def register_update_callback(self, callback: winrt.windows.foundation.TypedEventHandler[ListViewBase, ContainerContentChangingEventArgs], /) -> None: ...
    @typing.overload
    def register_update_callback(self, callback_phase: winrt.system.UInt32, callback: winrt.windows.foundation.TypedEventHandler[ListViewBase, ContainerContentChangingEventArgs], /) -> None: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def in_recycle_queue(self) -> bool: ...
    @_property
    def item(self) -> typing.Optional[winrt.system.Object]: ...
    @_property
    def item_container(self) -> typing.Optional[winrt.windows.ui.xaml.controls.primitives.SelectorItem]: ...
    @_property
    def item_index(self) -> winrt.system.Int32: ...
    @_property
    def phase(self) -> winrt.system.UInt32: ...

@typing.final
class ContentControl_Static(type):
    @_property
    def content_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def content_template_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def content_template_selector_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def content_transitions_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class ContentControl(winrt.system.Object, metaclass=ContentControl_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContentControl: ...
    def __new__(cls: typing.Type[ContentControl]) -> ContentControl:...
    def on_content_changed(self, old_content: typing.Optional[winrt.system.Object], new_content: typing.Optional[winrt.system.Object], /) -> None: ...
    def on_content_template_changed(self, old_content_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate], new_content_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate], /) -> None: ...
    def on_content_template_selector_changed(self, old_content_template_selector: typing.Optional[DataTemplateSelector], new_content_template_selector: typing.Optional[DataTemplateSelector], /) -> None: ...
    @_property
    def content_transitions(self) -> typing.Optional[winrt.windows.ui.xaml.media.animation.TransitionCollection]: ...
    @content_transitions.setter
    def content_transitions(self, value: typing.Optional[winrt.windows.ui.xaml.media.animation.TransitionCollection]) -> None: ...
    @_property
    def content_template_selector(self) -> typing.Optional[DataTemplateSelector]: ...
    @content_template_selector.setter
    def content_template_selector(self, value: typing.Optional[DataTemplateSelector]) -> None: ...
    @_property
    def content_template(self) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @content_template.setter
    def content_template(self, value: typing.Optional[winrt.windows.ui.xaml.DataTemplate]) -> None: ...
    @_property
    def content(self) -> typing.Optional[winrt.system.Object]: ...
    @content.setter
    def content(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def content_template_root(self) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...

@typing.final
class ContentDialog_Static(type):
    @_property
    def full_size_desired_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_primary_button_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_secondary_button_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def primary_button_command_parameter_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def primary_button_command_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def primary_button_text_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def secondary_button_command_parameter_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def secondary_button_command_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def secondary_button_text_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def title_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def title_template_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def close_button_command_parameter_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def close_button_command_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def close_button_style_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def close_button_text_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def default_button_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def primary_button_style_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def secondary_button_style_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class ContentDialog(winrt.system.Object, metaclass=ContentDialog_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContentDialog: ...
    def __new__(cls: typing.Type[ContentDialog]) -> ContentDialog:...
    def hide(self) -> None: ...
    @typing.overload
    def show_async(self) -> winrt.windows.foundation.IAsyncOperation[ContentDialogResult]: ...
    @typing.overload
    def show_async(self, placement: ContentDialogPlacement, /) -> winrt.windows.foundation.IAsyncOperation[ContentDialogResult]: ...
    def add_closed(self, handler: winrt.windows.foundation.TypedEventHandler[ContentDialog, ContentDialogClosedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_closing(self, handler: winrt.windows.foundation.TypedEventHandler[ContentDialog, ContentDialogClosingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_opened(self, handler: winrt.windows.foundation.TypedEventHandler[ContentDialog, ContentDialogOpenedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_opened(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_primary_button_click(self, handler: winrt.windows.foundation.TypedEventHandler[ContentDialog, ContentDialogButtonClickEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_primary_button_click(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_secondary_button_click(self, handler: winrt.windows.foundation.TypedEventHandler[ContentDialog, ContentDialogButtonClickEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_secondary_button_click(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_close_button_click(self, handler: winrt.windows.foundation.TypedEventHandler[ContentDialog, ContentDialogButtonClickEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_close_button_click(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def title_template(self) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @title_template.setter
    def title_template(self, value: typing.Optional[winrt.windows.ui.xaml.DataTemplate]) -> None: ...
    @_property
    def title(self) -> typing.Optional[winrt.system.Object]: ...
    @title.setter
    def title(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def secondary_button_text(self) -> str: ...
    @secondary_button_text.setter
    def secondary_button_text(self, value: str) -> None: ...
    @_property
    def secondary_button_command_parameter(self) -> typing.Optional[winrt.system.Object]: ...
    @secondary_button_command_parameter.setter
    def secondary_button_command_parameter(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def secondary_button_command(self) -> typing.Optional[winrt.windows.ui.xaml.input.ICommand]: ...
    @secondary_button_command.setter
    def secondary_button_command(self, value: typing.Optional[winrt.windows.ui.xaml.input.ICommand]) -> None: ...
    @_property
    def primary_button_text(self) -> str: ...
    @primary_button_text.setter
    def primary_button_text(self, value: str) -> None: ...
    @_property
    def primary_button_command_parameter(self) -> typing.Optional[winrt.system.Object]: ...
    @primary_button_command_parameter.setter
    def primary_button_command_parameter(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def primary_button_command(self) -> typing.Optional[winrt.windows.ui.xaml.input.ICommand]: ...
    @primary_button_command.setter
    def primary_button_command(self, value: typing.Optional[winrt.windows.ui.xaml.input.ICommand]) -> None: ...
    @_property
    def is_secondary_button_enabled(self) -> bool: ...
    @is_secondary_button_enabled.setter
    def is_secondary_button_enabled(self, value: bool) -> None: ...
    @_property
    def is_primary_button_enabled(self) -> bool: ...
    @is_primary_button_enabled.setter
    def is_primary_button_enabled(self, value: bool) -> None: ...
    @_property
    def full_size_desired(self) -> bool: ...
    @full_size_desired.setter
    def full_size_desired(self, value: bool) -> None: ...
    @_property
    def secondary_button_style(self) -> typing.Optional[winrt.windows.ui.xaml.Style]: ...
    @secondary_button_style.setter
    def secondary_button_style(self, value: typing.Optional[winrt.windows.ui.xaml.Style]) -> None: ...
    @_property
    def primary_button_style(self) -> typing.Optional[winrt.windows.ui.xaml.Style]: ...
    @primary_button_style.setter
    def primary_button_style(self, value: typing.Optional[winrt.windows.ui.xaml.Style]) -> None: ...
    @_property
    def default_button(self) -> ContentDialogButton: ...
    @default_button.setter
    def default_button(self, value: ContentDialogButton) -> None: ...
    @_property
    def close_button_text(self) -> str: ...
    @close_button_text.setter
    def close_button_text(self, value: str) -> None: ...
    @_property
    def close_button_style(self) -> typing.Optional[winrt.windows.ui.xaml.Style]: ...
    @close_button_style.setter
    def close_button_style(self, value: typing.Optional[winrt.windows.ui.xaml.Style]) -> None: ...
    @_property
    def close_button_command_parameter(self) -> typing.Optional[winrt.system.Object]: ...
    @close_button_command_parameter.setter
    def close_button_command_parameter(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def close_button_command(self) -> typing.Optional[winrt.windows.ui.xaml.input.ICommand]: ...
    @close_button_command.setter
    def close_button_command(self, value: typing.Optional[winrt.windows.ui.xaml.input.ICommand]) -> None: ...

@typing.final
class ContentDialogButtonClickDeferral(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContentDialogButtonClickDeferral: ...
    def complete(self) -> None: ...

@typing.final
class ContentDialogButtonClickEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContentDialogButtonClickEventArgs: ...
    def get_deferral(self) -> typing.Optional[ContentDialogButtonClickDeferral]: ...
    @_property
    def cancel(self) -> bool: ...
    @cancel.setter
    def cancel(self, value: bool) -> None: ...

@typing.final
class ContentDialogClosedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContentDialogClosedEventArgs: ...
    @_property
    def result(self) -> ContentDialogResult: ...

@typing.final
class ContentDialogClosingDeferral(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContentDialogClosingDeferral: ...
    def complete(self) -> None: ...

@typing.final
class ContentDialogClosingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContentDialogClosingEventArgs: ...
    def get_deferral(self) -> typing.Optional[ContentDialogClosingDeferral]: ...
    @_property
    def cancel(self) -> bool: ...
    @cancel.setter
    def cancel(self, value: bool) -> None: ...
    @_property
    def result(self) -> ContentDialogResult: ...

@typing.final
class ContentDialogOpenedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContentDialogOpenedEventArgs: ...

@typing.final
class ContentLinkChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContentLinkChangedEventArgs: ...
    @_property
    def change_kind(self) -> ContentLinkChangeKind: ...
    @_property
    def content_link_info(self) -> typing.Optional[winrt.windows.ui.text.ContentLinkInfo]: ...
    @_property
    def text_range(self) -> winrt.windows.ui.xaml.documents.TextRange: ...

@typing.final
class ContentPresenter_Static(type):
    @_property
    def character_spacing_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def content_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def content_template_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def content_template_selector_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def content_transitions_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def font_family_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def font_size_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def font_stretch_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def font_style_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def font_weight_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def foreground_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def optical_margin_alignment_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def text_line_bounds_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_text_scale_factor_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def background_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def border_brush_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def border_thickness_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def corner_radius_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def horizontal_content_alignment_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def line_height_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def line_stacking_strategy_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def max_lines_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def padding_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def text_wrapping_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def vertical_content_alignment_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def background_sizing_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class ContentPresenter(winrt.system.Object, metaclass=ContentPresenter_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContentPresenter: ...
    def __new__(cls: typing.Type[ContentPresenter]) -> ContentPresenter:...
    def on_content_template_changed(self, old_content_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate], new_content_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate], /) -> None: ...
    def on_content_template_selector_changed(self, old_content_template_selector: typing.Optional[DataTemplateSelector], new_content_template_selector: typing.Optional[DataTemplateSelector], /) -> None: ...
    @_property
    def foreground(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @foreground.setter
    def foreground(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def font_weight(self) -> winrt.windows.ui.text.FontWeight: ...
    @font_weight.setter
    def font_weight(self, value: winrt.windows.ui.text.FontWeight) -> None: ...
    @_property
    def font_style(self) -> winrt.windows.ui.text.FontStyle: ...
    @font_style.setter
    def font_style(self, value: winrt.windows.ui.text.FontStyle) -> None: ...
    @_property
    def font_stretch(self) -> winrt.windows.ui.text.FontStretch: ...
    @font_stretch.setter
    def font_stretch(self, value: winrt.windows.ui.text.FontStretch) -> None: ...
    @_property
    def font_size(self) -> winrt.system.Double: ...
    @font_size.setter
    def font_size(self, value: winrt.system.Double) -> None: ...
    @_property
    def font_family(self) -> typing.Optional[winrt.windows.ui.xaml.media.FontFamily]: ...
    @font_family.setter
    def font_family(self, value: typing.Optional[winrt.windows.ui.xaml.media.FontFamily]) -> None: ...
    @_property
    def content_transitions(self) -> typing.Optional[winrt.windows.ui.xaml.media.animation.TransitionCollection]: ...
    @content_transitions.setter
    def content_transitions(self, value: typing.Optional[winrt.windows.ui.xaml.media.animation.TransitionCollection]) -> None: ...
    @_property
    def content_template_selector(self) -> typing.Optional[DataTemplateSelector]: ...
    @content_template_selector.setter
    def content_template_selector(self, value: typing.Optional[DataTemplateSelector]) -> None: ...
    @_property
    def content_template(self) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @content_template.setter
    def content_template(self, value: typing.Optional[winrt.windows.ui.xaml.DataTemplate]) -> None: ...
    @_property
    def content(self) -> typing.Optional[winrt.system.Object]: ...
    @content.setter
    def content(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def character_spacing(self) -> winrt.system.Int32: ...
    @character_spacing.setter
    def character_spacing(self, value: winrt.system.Int32) -> None: ...
    @_property
    def text_line_bounds(self) -> winrt.windows.ui.xaml.TextLineBounds: ...
    @text_line_bounds.setter
    def text_line_bounds(self, value: winrt.windows.ui.xaml.TextLineBounds) -> None: ...
    @_property
    def optical_margin_alignment(self) -> winrt.windows.ui.xaml.OpticalMarginAlignment: ...
    @optical_margin_alignment.setter
    def optical_margin_alignment(self, value: winrt.windows.ui.xaml.OpticalMarginAlignment) -> None: ...
    @_property
    def is_text_scale_factor_enabled(self) -> bool: ...
    @is_text_scale_factor_enabled.setter
    def is_text_scale_factor_enabled(self, value: bool) -> None: ...
    @_property
    def vertical_content_alignment(self) -> winrt.windows.ui.xaml.VerticalAlignment: ...
    @vertical_content_alignment.setter
    def vertical_content_alignment(self, value: winrt.windows.ui.xaml.VerticalAlignment) -> None: ...
    @_property
    def text_wrapping(self) -> winrt.windows.ui.xaml.TextWrapping: ...
    @text_wrapping.setter
    def text_wrapping(self, value: winrt.windows.ui.xaml.TextWrapping) -> None: ...
    @_property
    def padding(self) -> winrt.windows.ui.xaml.Thickness: ...
    @padding.setter
    def padding(self, value: winrt.windows.ui.xaml.Thickness) -> None: ...
    @_property
    def max_lines(self) -> winrt.system.Int32: ...
    @max_lines.setter
    def max_lines(self, value: winrt.system.Int32) -> None: ...
    @_property
    def line_stacking_strategy(self) -> winrt.windows.ui.xaml.LineStackingStrategy: ...
    @line_stacking_strategy.setter
    def line_stacking_strategy(self, value: winrt.windows.ui.xaml.LineStackingStrategy) -> None: ...
    @_property
    def line_height(self) -> winrt.system.Double: ...
    @line_height.setter
    def line_height(self, value: winrt.system.Double) -> None: ...
    @_property
    def horizontal_content_alignment(self) -> winrt.windows.ui.xaml.HorizontalAlignment: ...
    @horizontal_content_alignment.setter
    def horizontal_content_alignment(self, value: winrt.windows.ui.xaml.HorizontalAlignment) -> None: ...
    @_property
    def corner_radius(self) -> winrt.windows.ui.xaml.CornerRadius: ...
    @corner_radius.setter
    def corner_radius(self, value: winrt.windows.ui.xaml.CornerRadius) -> None: ...
    @_property
    def border_thickness(self) -> winrt.windows.ui.xaml.Thickness: ...
    @border_thickness.setter
    def border_thickness(self, value: winrt.windows.ui.xaml.Thickness) -> None: ...
    @_property
    def border_brush(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @border_brush.setter
    def border_brush(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def background(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @background.setter
    def background(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def background_transition(self) -> typing.Optional[winrt.windows.ui.xaml.BrushTransition]: ...
    @background_transition.setter
    def background_transition(self, value: typing.Optional[winrt.windows.ui.xaml.BrushTransition]) -> None: ...
    @_property
    def background_sizing(self) -> BackgroundSizing: ...
    @background_sizing.setter
    def background_sizing(self, value: BackgroundSizing) -> None: ...

@typing.final
class ContextMenuEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContextMenuEventArgs: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def cursor_left(self) -> winrt.system.Double: ...
    @_property
    def cursor_top(self) -> winrt.system.Double: ...

@typing.final
class Control_Static(type):
    def get_is_template_focus_target(cls, element: typing.Optional[winrt.windows.ui.xaml.FrameworkElement], /) -> bool: ...
    def get_is_template_key_tip_target(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> bool: ...
    def set_is_template_focus_target(cls, element: typing.Optional[winrt.windows.ui.xaml.FrameworkElement], value: bool, /) -> None: ...
    def set_is_template_key_tip_target(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], value: bool, /) -> None: ...
    @_property
    def border_thickness_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def focus_state_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def font_family_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def font_size_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def font_stretch_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def font_style_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def font_weight_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def foreground_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def horizontal_content_alignment_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_tab_stop_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def padding_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def tab_index_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def tab_navigation_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def template_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def background_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def border_brush_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def vertical_content_alignment_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def character_spacing_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def default_style_key_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_text_scale_factor_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_template_focus_target_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def use_system_focus_visuals_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def element_sound_mode_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_focus_engaged_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_focus_engagement_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def requires_pointer_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def x_y_focus_down_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def x_y_focus_left_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def x_y_focus_right_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def x_y_focus_up_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def default_style_resource_uri_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_template_key_tip_target_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def corner_radius_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def background_sizing_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class Control(winrt.system.Object, metaclass=Control_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Control: ...
    def apply_template(self) -> bool: ...
    def focus(self, value: winrt.windows.ui.xaml.FocusState, /) -> bool: ...
    def get_template_child(self, child_name: str, /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    def on_character_received(self, e: typing.Optional[winrt.windows.ui.xaml.input.CharacterReceivedRoutedEventArgs], /) -> None: ...
    def on_double_tapped(self, e: typing.Optional[winrt.windows.ui.xaml.input.DoubleTappedRoutedEventArgs], /) -> None: ...
    def on_drag_enter(self, e: typing.Optional[winrt.windows.ui.xaml.DragEventArgs], /) -> None: ...
    def on_drag_leave(self, e: typing.Optional[winrt.windows.ui.xaml.DragEventArgs], /) -> None: ...
    def on_drag_over(self, e: typing.Optional[winrt.windows.ui.xaml.DragEventArgs], /) -> None: ...
    def on_drop(self, e: typing.Optional[winrt.windows.ui.xaml.DragEventArgs], /) -> None: ...
    def on_got_focus(self, e: typing.Optional[winrt.windows.ui.xaml.RoutedEventArgs], /) -> None: ...
    def on_holding(self, e: typing.Optional[winrt.windows.ui.xaml.input.HoldingRoutedEventArgs], /) -> None: ...
    def on_key_down(self, e: typing.Optional[winrt.windows.ui.xaml.input.KeyRoutedEventArgs], /) -> None: ...
    def on_key_up(self, e: typing.Optional[winrt.windows.ui.xaml.input.KeyRoutedEventArgs], /) -> None: ...
    def on_lost_focus(self, e: typing.Optional[winrt.windows.ui.xaml.RoutedEventArgs], /) -> None: ...
    def on_manipulation_completed(self, e: typing.Optional[winrt.windows.ui.xaml.input.ManipulationCompletedRoutedEventArgs], /) -> None: ...
    def on_manipulation_delta(self, e: typing.Optional[winrt.windows.ui.xaml.input.ManipulationDeltaRoutedEventArgs], /) -> None: ...
    def on_manipulation_inertia_starting(self, e: typing.Optional[winrt.windows.ui.xaml.input.ManipulationInertiaStartingRoutedEventArgs], /) -> None: ...
    def on_manipulation_started(self, e: typing.Optional[winrt.windows.ui.xaml.input.ManipulationStartedRoutedEventArgs], /) -> None: ...
    def on_manipulation_starting(self, e: typing.Optional[winrt.windows.ui.xaml.input.ManipulationStartingRoutedEventArgs], /) -> None: ...
    def on_pointer_canceled(self, e: typing.Optional[winrt.windows.ui.xaml.input.PointerRoutedEventArgs], /) -> None: ...
    def on_pointer_capture_lost(self, e: typing.Optional[winrt.windows.ui.xaml.input.PointerRoutedEventArgs], /) -> None: ...
    def on_pointer_entered(self, e: typing.Optional[winrt.windows.ui.xaml.input.PointerRoutedEventArgs], /) -> None: ...
    def on_pointer_exited(self, e: typing.Optional[winrt.windows.ui.xaml.input.PointerRoutedEventArgs], /) -> None: ...
    def on_pointer_moved(self, e: typing.Optional[winrt.windows.ui.xaml.input.PointerRoutedEventArgs], /) -> None: ...
    def on_pointer_pressed(self, e: typing.Optional[winrt.windows.ui.xaml.input.PointerRoutedEventArgs], /) -> None: ...
    def on_pointer_released(self, e: typing.Optional[winrt.windows.ui.xaml.input.PointerRoutedEventArgs], /) -> None: ...
    def on_pointer_wheel_changed(self, e: typing.Optional[winrt.windows.ui.xaml.input.PointerRoutedEventArgs], /) -> None: ...
    def on_preview_key_down(self, e: typing.Optional[winrt.windows.ui.xaml.input.KeyRoutedEventArgs], /) -> None: ...
    def on_preview_key_up(self, e: typing.Optional[winrt.windows.ui.xaml.input.KeyRoutedEventArgs], /) -> None: ...
    def on_right_tapped(self, e: typing.Optional[winrt.windows.ui.xaml.input.RightTappedRoutedEventArgs], /) -> None: ...
    def on_tapped(self, e: typing.Optional[winrt.windows.ui.xaml.input.TappedRoutedEventArgs], /) -> None: ...
    def remove_focus_engagement(self) -> None: ...
    def add_is_enabled_changed(self, handler: typing.Optional[winrt.windows.ui.xaml.DependencyPropertyChangedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_is_enabled_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_focus_disengaged(self, handler: winrt.windows.foundation.TypedEventHandler[Control, FocusDisengagedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_focus_disengaged(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_focus_engaged(self, handler: winrt.windows.foundation.TypedEventHandler[Control, FocusEngagedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_focus_engaged(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def padding(self) -> winrt.windows.ui.xaml.Thickness: ...
    @padding.setter
    def padding(self, value: winrt.windows.ui.xaml.Thickness) -> None: ...
    @_property
    def is_tab_stop(self) -> bool: ...
    @is_tab_stop.setter
    def is_tab_stop(self, value: bool) -> None: ...
    @_property
    def is_enabled(self) -> bool: ...
    @is_enabled.setter
    def is_enabled(self, value: bool) -> None: ...
    @_property
    def horizontal_content_alignment(self) -> winrt.windows.ui.xaml.HorizontalAlignment: ...
    @horizontal_content_alignment.setter
    def horizontal_content_alignment(self, value: winrt.windows.ui.xaml.HorizontalAlignment) -> None: ...
    @_property
    def foreground(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @foreground.setter
    def foreground(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def font_weight(self) -> winrt.windows.ui.text.FontWeight: ...
    @font_weight.setter
    def font_weight(self, value: winrt.windows.ui.text.FontWeight) -> None: ...
    @_property
    def font_style(self) -> winrt.windows.ui.text.FontStyle: ...
    @font_style.setter
    def font_style(self, value: winrt.windows.ui.text.FontStyle) -> None: ...
    @_property
    def font_stretch(self) -> winrt.windows.ui.text.FontStretch: ...
    @font_stretch.setter
    def font_stretch(self, value: winrt.windows.ui.text.FontStretch) -> None: ...
    @_property
    def font_size(self) -> winrt.system.Double: ...
    @font_size.setter
    def font_size(self, value: winrt.system.Double) -> None: ...
    @_property
    def font_family(self) -> typing.Optional[winrt.windows.ui.xaml.media.FontFamily]: ...
    @font_family.setter
    def font_family(self, value: typing.Optional[winrt.windows.ui.xaml.media.FontFamily]) -> None: ...
    @_property
    def tab_index(self) -> winrt.system.Int32: ...
    @tab_index.setter
    def tab_index(self, value: winrt.system.Int32) -> None: ...
    @_property
    def character_spacing(self) -> winrt.system.Int32: ...
    @character_spacing.setter
    def character_spacing(self, value: winrt.system.Int32) -> None: ...
    @_property
    def border_thickness(self) -> winrt.windows.ui.xaml.Thickness: ...
    @border_thickness.setter
    def border_thickness(self, value: winrt.windows.ui.xaml.Thickness) -> None: ...
    @_property
    def border_brush(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @border_brush.setter
    def border_brush(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def tab_navigation(self) -> winrt.windows.ui.xaml.input.KeyboardNavigationMode: ...
    @tab_navigation.setter
    def tab_navigation(self, value: winrt.windows.ui.xaml.input.KeyboardNavigationMode) -> None: ...
    @_property
    def background(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @background.setter
    def background(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def vertical_content_alignment(self) -> winrt.windows.ui.xaml.VerticalAlignment: ...
    @vertical_content_alignment.setter
    def vertical_content_alignment(self, value: winrt.windows.ui.xaml.VerticalAlignment) -> None: ...
    @_property
    def template(self) -> typing.Optional[ControlTemplate]: ...
    @template.setter
    def template(self, value: typing.Optional[ControlTemplate]) -> None: ...
    @_property
    def focus_state(self) -> winrt.windows.ui.xaml.FocusState: ...
    @_property
    def is_text_scale_factor_enabled(self) -> bool: ...
    @is_text_scale_factor_enabled.setter
    def is_text_scale_factor_enabled(self, value: bool) -> None: ...
    @_property
    def use_system_focus_visuals(self) -> bool: ...
    @use_system_focus_visuals.setter
    def use_system_focus_visuals(self, value: bool) -> None: ...
    @_property
    def x_y_focus_up(self) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    @x_y_focus_up.setter
    def x_y_focus_up(self, value: typing.Optional[winrt.windows.ui.xaml.DependencyObject]) -> None: ...
    @_property
    def x_y_focus_right(self) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    @x_y_focus_right.setter
    def x_y_focus_right(self, value: typing.Optional[winrt.windows.ui.xaml.DependencyObject]) -> None: ...
    @_property
    def x_y_focus_left(self) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    @x_y_focus_left.setter
    def x_y_focus_left(self, value: typing.Optional[winrt.windows.ui.xaml.DependencyObject]) -> None: ...
    @_property
    def x_y_focus_down(self) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    @x_y_focus_down.setter
    def x_y_focus_down(self, value: typing.Optional[winrt.windows.ui.xaml.DependencyObject]) -> None: ...
    @_property
    def requires_pointer(self) -> RequiresPointer: ...
    @requires_pointer.setter
    def requires_pointer(self, value: RequiresPointer) -> None: ...
    @_property
    def is_focus_engagement_enabled(self) -> bool: ...
    @is_focus_engagement_enabled.setter
    def is_focus_engagement_enabled(self, value: bool) -> None: ...
    @_property
    def is_focus_engaged(self) -> bool: ...
    @is_focus_engaged.setter
    def is_focus_engaged(self, value: bool) -> None: ...
    @_property
    def element_sound_mode(self) -> winrt.windows.ui.xaml.ElementSoundMode: ...
    @element_sound_mode.setter
    def element_sound_mode(self, value: winrt.windows.ui.xaml.ElementSoundMode) -> None: ...
    @_property
    def default_style_resource_uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @default_style_resource_uri.setter
    def default_style_resource_uri(self, value: typing.Optional[winrt.windows.foundation.Uri]) -> None: ...
    @_property
    def corner_radius(self) -> winrt.windows.ui.xaml.CornerRadius: ...
    @corner_radius.setter
    def corner_radius(self, value: winrt.windows.ui.xaml.CornerRadius) -> None: ...
    @_property
    def background_sizing(self) -> BackgroundSizing: ...
    @background_sizing.setter
    def background_sizing(self, value: BackgroundSizing) -> None: ...
    @_property
    def default_style_key(self) -> typing.Optional[winrt.system.Object]: ...
    @default_style_key.setter
    def default_style_key(self, value: typing.Optional[winrt.system.Object]) -> None: ...

@typing.final
class ControlTemplate(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ControlTemplate: ...
    def __new__(cls: typing.Type[ControlTemplate]) -> ControlTemplate:...
    @_property
    def target_type(self) -> winrt.windows.ui.xaml.interop.TypeName: ...
    @target_type.setter
    def target_type(self, value: winrt.windows.ui.xaml.interop.TypeName) -> None: ...

@typing.final
class DataTemplateSelector(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DataTemplateSelector: ...
    def __new__(cls: typing.Type[DataTemplateSelector]) -> DataTemplateSelector:...
    def get_element(self, args: typing.Optional[winrt.windows.ui.xaml.ElementFactoryGetArgs], /) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    def recycle_element(self, args: typing.Optional[winrt.windows.ui.xaml.ElementFactoryRecycleArgs], /) -> None: ...
    @typing.overload
    def select_template(self, item: typing.Optional[winrt.system.Object], /) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @typing.overload
    def select_template(self, item: typing.Optional[winrt.system.Object], container: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @typing.overload
    def select_template_core(self, item: typing.Optional[winrt.system.Object], /) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @typing.overload
    def select_template_core(self, item: typing.Optional[winrt.system.Object], container: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...

@typing.final
class DatePickedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DatePickedEventArgs: ...
    def __new__(cls: typing.Type[DatePickedEventArgs]) -> DatePickedEventArgs:...
    @_property
    def new_date(self) -> datetime.datetime: ...
    @_property
    def old_date(self) -> datetime.datetime: ...

@typing.final
class DatePicker_Static(type):
    @_property
    def calendar_identifier_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def date_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def day_format_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def day_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def header_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def header_template_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def max_year_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def min_year_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def month_format_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def month_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def orientation_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def year_format_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def year_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def light_dismiss_overlay_mode_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selected_date_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class DatePicker(winrt.system.Object, metaclass=DatePicker_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DatePicker: ...
    def __new__(cls: typing.Type[DatePicker]) -> DatePicker:...
    def add_date_changed(self, handler: winrt.windows.foundation.EventHandler[DatePickerValueChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_date_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_selected_date_changed(self, handler: winrt.windows.foundation.TypedEventHandler[DatePicker, DatePickerSelectedValueChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_selected_date_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def year_visible(self) -> bool: ...
    @year_visible.setter
    def year_visible(self, value: bool) -> None: ...
    @_property
    def year_format(self) -> str: ...
    @year_format.setter
    def year_format(self, value: str) -> None: ...
    @_property
    def orientation(self) -> Orientation: ...
    @orientation.setter
    def orientation(self, value: Orientation) -> None: ...
    @_property
    def month_visible(self) -> bool: ...
    @month_visible.setter
    def month_visible(self, value: bool) -> None: ...
    @_property
    def month_format(self) -> str: ...
    @month_format.setter
    def month_format(self, value: str) -> None: ...
    @_property
    def min_year(self) -> datetime.datetime: ...
    @min_year.setter
    def min_year(self, value: datetime.datetime) -> None: ...
    @_property
    def max_year(self) -> datetime.datetime: ...
    @max_year.setter
    def max_year(self, value: datetime.datetime) -> None: ...
    @_property
    def header_template(self) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @header_template.setter
    def header_template(self, value: typing.Optional[winrt.windows.ui.xaml.DataTemplate]) -> None: ...
    @_property
    def header(self) -> typing.Optional[winrt.system.Object]: ...
    @header.setter
    def header(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def day_visible(self) -> bool: ...
    @day_visible.setter
    def day_visible(self, value: bool) -> None: ...
    @_property
    def day_format(self) -> str: ...
    @day_format.setter
    def day_format(self, value: str) -> None: ...
    @_property
    def date(self) -> datetime.datetime: ...
    @date.setter
    def date(self, value: datetime.datetime) -> None: ...
    @_property
    def calendar_identifier(self) -> str: ...
    @calendar_identifier.setter
    def calendar_identifier(self, value: str) -> None: ...
    @_property
    def light_dismiss_overlay_mode(self) -> LightDismissOverlayMode: ...
    @light_dismiss_overlay_mode.setter
    def light_dismiss_overlay_mode(self, value: LightDismissOverlayMode) -> None: ...
    @_property
    def selected_date(self) -> typing.Optional[typing.Optional[datetime.datetime]]: ...
    @selected_date.setter
    def selected_date(self, value: typing.Optional[typing.Optional[datetime.datetime]]) -> None: ...

@typing.final
class DatePickerFlyout_Static(type):
    @_property
    def calendar_identifier_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def date_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def day_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def max_year_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def min_year_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def month_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def year_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def day_format_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def month_format_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def year_format_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class DatePickerFlyout(winrt.system.Object, metaclass=DatePickerFlyout_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DatePickerFlyout: ...
    def __new__(cls: typing.Type[DatePickerFlyout]) -> DatePickerFlyout:...
    def show_at_async(self, target: typing.Optional[winrt.windows.ui.xaml.FrameworkElement], /) -> winrt.windows.foundation.IAsyncOperation[typing.Optional[datetime.datetime]]: ...
    def add_date_picked(self, handler: winrt.windows.foundation.TypedEventHandler[DatePickerFlyout, DatePickedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_date_picked(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def year_visible(self) -> bool: ...
    @year_visible.setter
    def year_visible(self, value: bool) -> None: ...
    @_property
    def month_visible(self) -> bool: ...
    @month_visible.setter
    def month_visible(self, value: bool) -> None: ...
    @_property
    def min_year(self) -> datetime.datetime: ...
    @min_year.setter
    def min_year(self, value: datetime.datetime) -> None: ...
    @_property
    def max_year(self) -> datetime.datetime: ...
    @max_year.setter
    def max_year(self, value: datetime.datetime) -> None: ...
    @_property
    def day_visible(self) -> bool: ...
    @day_visible.setter
    def day_visible(self, value: bool) -> None: ...
    @_property
    def date(self) -> datetime.datetime: ...
    @date.setter
    def date(self, value: datetime.datetime) -> None: ...
    @_property
    def calendar_identifier(self) -> str: ...
    @calendar_identifier.setter
    def calendar_identifier(self, value: str) -> None: ...
    @_property
    def year_format(self) -> str: ...
    @year_format.setter
    def year_format(self, value: str) -> None: ...
    @_property
    def month_format(self) -> str: ...
    @month_format.setter
    def month_format(self, value: str) -> None: ...
    @_property
    def day_format(self) -> str: ...
    @day_format.setter
    def day_format(self, value: str) -> None: ...

@typing.final
class DatePickerFlyoutItem_Static(type):
    @_property
    def primary_text_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def secondary_text_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class DatePickerFlyoutItem(winrt.system.Object, metaclass=DatePickerFlyoutItem_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DatePickerFlyoutItem: ...
    def get_custom_property(self, name: str, /) -> typing.Optional[winrt.windows.ui.xaml.data.ICustomProperty]: ...
    def get_indexed_property(self, name: str, type: winrt.windows.ui.xaml.interop.TypeName, /) -> typing.Optional[winrt.windows.ui.xaml.data.ICustomProperty]: ...
    def get_string_representation(self) -> str: ...
    @_property
    def secondary_text(self) -> str: ...
    @secondary_text.setter
    def secondary_text(self, value: str) -> None: ...
    @_property
    def primary_text(self) -> str: ...
    @primary_text.setter
    def primary_text(self, value: str) -> None: ...
    @_property
    def type(self) -> winrt.windows.ui.xaml.interop.TypeName: ...

@typing.final
class DatePickerFlyoutPresenter_Static(type):
    @_property
    def is_default_shadow_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class DatePickerFlyoutPresenter(winrt.system.Object, metaclass=DatePickerFlyoutPresenter_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DatePickerFlyoutPresenter: ...
    @_property
    def is_default_shadow_enabled(self) -> bool: ...
    @is_default_shadow_enabled.setter
    def is_default_shadow_enabled(self, value: bool) -> None: ...

@typing.final
class DatePickerSelectedValueChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DatePickerSelectedValueChangedEventArgs: ...
    @_property
    def new_date(self) -> typing.Optional[typing.Optional[datetime.datetime]]: ...
    @_property
    def old_date(self) -> typing.Optional[typing.Optional[datetime.datetime]]: ...

@typing.final
class DatePickerValueChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DatePickerValueChangedEventArgs: ...
    @_property
    def new_date(self) -> datetime.datetime: ...
    @_property
    def old_date(self) -> datetime.datetime: ...

@typing.final
class DragItemsCompletedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DragItemsCompletedEventArgs: ...
    @_property
    def drop_result(self) -> winrt.windows.applicationmodel.datatransfer.DataPackageOperation: ...
    @_property
    def items(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Object]]: ...

@typing.final
class DragItemsStartingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DragItemsStartingEventArgs: ...
    def __new__(cls: typing.Type[DragItemsStartingEventArgs]) -> DragItemsStartingEventArgs:...
    @_property
    def cancel(self) -> bool: ...
    @cancel.setter
    def cancel(self, value: bool) -> None: ...
    @_property
    def data(self) -> typing.Optional[winrt.windows.applicationmodel.datatransfer.DataPackage]: ...
    @_property
    def items(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.system.Object]]: ...

@typing.final
class DropDownButton(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DropDownButton: ...
    def __new__(cls: typing.Type[DropDownButton]) -> DropDownButton:...

@typing.final
class DropDownButtonAutomationPeer(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DropDownButtonAutomationPeer: ...
    def __new__(cls: typing.Type[DropDownButtonAutomationPeer], owner: typing.Optional[DropDownButton]) -> DropDownButtonAutomationPeer:...
    def collapse(self) -> None: ...
    def expand(self) -> None: ...
    @_property
    def expand_collapse_state(self) -> winrt.windows.ui.xaml.automation.ExpandCollapseState: ...

@typing.final
class DynamicOverflowItemsChangingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DynamicOverflowItemsChangingEventArgs: ...
    def __new__(cls: typing.Type[DynamicOverflowItemsChangingEventArgs]) -> DynamicOverflowItemsChangingEventArgs:...
    @_property
    def action(self) -> CommandBarDynamicOverflowAction: ...

@typing.final
class FlipView_Static(type):
    @_property
    def use_touch_animations_for_all_navigation_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class FlipView(winrt.system.Object, metaclass=FlipView_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FlipView: ...
    def __new__(cls: typing.Type[FlipView]) -> FlipView:...
    @_property
    def use_touch_animations_for_all_navigation(self) -> bool: ...
    @use_touch_animations_for_all_navigation.setter
    def use_touch_animations_for_all_navigation(self, value: bool) -> None: ...

@typing.final
class FlipViewItem(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FlipViewItem: ...
    def __new__(cls: typing.Type[FlipViewItem]) -> FlipViewItem:...

@typing.final
class Flyout_Static(type):
    @_property
    def content_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def flyout_presenter_style_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class Flyout(winrt.system.Object, metaclass=Flyout_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Flyout: ...
    def __new__(cls: typing.Type[Flyout]) -> Flyout:...
    @_property
    def flyout_presenter_style(self) -> typing.Optional[winrt.windows.ui.xaml.Style]: ...
    @flyout_presenter_style.setter
    def flyout_presenter_style(self, value: typing.Optional[winrt.windows.ui.xaml.Style]) -> None: ...
    @_property
    def content(self) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    @content.setter
    def content(self, value: typing.Optional[winrt.windows.ui.xaml.UIElement]) -> None: ...

@typing.final
class FlyoutPresenter_Static(type):
    @_property
    def is_default_shadow_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class FlyoutPresenter(winrt.system.Object, metaclass=FlyoutPresenter_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FlyoutPresenter: ...
    def __new__(cls: typing.Type[FlyoutPresenter]) -> FlyoutPresenter:...
    @_property
    def is_default_shadow_enabled(self) -> bool: ...
    @is_default_shadow_enabled.setter
    def is_default_shadow_enabled(self, value: bool) -> None: ...

@typing.final
class FocusDisengagedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FocusDisengagedEventArgs: ...

@typing.final
class FocusEngagedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FocusEngagedEventArgs: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...

@typing.final
class FontIcon_Static(type):
    @_property
    def font_family_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def font_size_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def font_style_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def font_weight_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def glyph_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_text_scale_factor_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def mirrored_when_right_to_left_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class FontIcon(winrt.system.Object, metaclass=FontIcon_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FontIcon: ...
    def __new__(cls: typing.Type[FontIcon]) -> FontIcon:...
    @_property
    def glyph(self) -> str: ...
    @glyph.setter
    def glyph(self, value: str) -> None: ...
    @_property
    def font_weight(self) -> winrt.windows.ui.text.FontWeight: ...
    @font_weight.setter
    def font_weight(self, value: winrt.windows.ui.text.FontWeight) -> None: ...
    @_property
    def font_style(self) -> winrt.windows.ui.text.FontStyle: ...
    @font_style.setter
    def font_style(self, value: winrt.windows.ui.text.FontStyle) -> None: ...
    @_property
    def font_size(self) -> winrt.system.Double: ...
    @font_size.setter
    def font_size(self, value: winrt.system.Double) -> None: ...
    @_property
    def font_family(self) -> typing.Optional[winrt.windows.ui.xaml.media.FontFamily]: ...
    @font_family.setter
    def font_family(self, value: typing.Optional[winrt.windows.ui.xaml.media.FontFamily]) -> None: ...
    @_property
    def is_text_scale_factor_enabled(self) -> bool: ...
    @is_text_scale_factor_enabled.setter
    def is_text_scale_factor_enabled(self, value: bool) -> None: ...
    @_property
    def mirrored_when_right_to_left(self) -> bool: ...
    @mirrored_when_right_to_left.setter
    def mirrored_when_right_to_left(self, value: bool) -> None: ...

@typing.final
class FontIconSource_Static(type):
    @_property
    def font_family_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def font_size_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def font_style_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def font_weight_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def glyph_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_text_scale_factor_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def mirrored_when_right_to_left_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class FontIconSource(winrt.system.Object, metaclass=FontIconSource_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FontIconSource: ...
    def __new__(cls: typing.Type[FontIconSource]) -> FontIconSource:...
    @_property
    def mirrored_when_right_to_left(self) -> bool: ...
    @mirrored_when_right_to_left.setter
    def mirrored_when_right_to_left(self, value: bool) -> None: ...
    @_property
    def is_text_scale_factor_enabled(self) -> bool: ...
    @is_text_scale_factor_enabled.setter
    def is_text_scale_factor_enabled(self, value: bool) -> None: ...
    @_property
    def glyph(self) -> str: ...
    @glyph.setter
    def glyph(self, value: str) -> None: ...
    @_property
    def font_weight(self) -> winrt.windows.ui.text.FontWeight: ...
    @font_weight.setter
    def font_weight(self, value: winrt.windows.ui.text.FontWeight) -> None: ...
    @_property
    def font_style(self) -> winrt.windows.ui.text.FontStyle: ...
    @font_style.setter
    def font_style(self, value: winrt.windows.ui.text.FontStyle) -> None: ...
    @_property
    def font_size(self) -> winrt.system.Double: ...
    @font_size.setter
    def font_size(self, value: winrt.system.Double) -> None: ...
    @_property
    def font_family(self) -> typing.Optional[winrt.windows.ui.xaml.media.FontFamily]: ...
    @font_family.setter
    def font_family(self, value: typing.Optional[winrt.windows.ui.xaml.media.FontFamily]) -> None: ...

@typing.final
class Frame_Static(type):
    @_property
    def back_stack_depth_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def cache_size_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def can_go_back_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def can_go_forward_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def current_source_page_type_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def source_page_type_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def back_stack_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def forward_stack_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_navigation_stack_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class Frame(winrt.system.Object, metaclass=Frame_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Frame: ...
    def __new__(cls: typing.Type[Frame]) -> Frame:...
    def get_navigation_state(self) -> str: ...
    @typing.overload
    def go_back(self) -> None: ...
    @typing.overload
    def go_back(self, transition_info_override: typing.Optional[winrt.windows.ui.xaml.media.animation.NavigationTransitionInfo], /) -> None: ...
    def go_forward(self) -> None: ...
    @typing.overload
    def navigate(self, source_page_type: winrt.windows.ui.xaml.interop.TypeName, /) -> bool: ...
    @typing.overload
    def navigate(self, source_page_type: winrt.windows.ui.xaml.interop.TypeName, parameter: typing.Optional[winrt.system.Object], /) -> bool: ...
    @typing.overload
    def navigate(self, source_page_type: winrt.windows.ui.xaml.interop.TypeName, parameter: typing.Optional[winrt.system.Object], info_override: typing.Optional[winrt.windows.ui.xaml.media.animation.NavigationTransitionInfo], /) -> bool: ...
    def navigate_to_type(self, source_page_type: winrt.windows.ui.xaml.interop.TypeName, parameter: typing.Optional[winrt.system.Object], navigation_options: typing.Optional[winrt.windows.ui.xaml.navigation.FrameNavigationOptions], /) -> bool: ...
    @typing.overload
    def set_navigation_state(self, navigation_state: str, /) -> None: ...
    @typing.overload
    def set_navigation_state(self, navigation_state: str, suppress_navigate: bool, /) -> None: ...
    def add_navigated(self, handler: typing.Optional[winrt.windows.ui.xaml.navigation.NavigatedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_navigated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_navigating(self, handler: typing.Optional[winrt.windows.ui.xaml.navigation.NavigatingCancelEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_navigating(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_navigation_failed(self, handler: typing.Optional[winrt.windows.ui.xaml.navigation.NavigationFailedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_navigation_failed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_navigation_stopped(self, handler: typing.Optional[winrt.windows.ui.xaml.navigation.NavigationStoppedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_navigation_stopped(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def source_page_type(self) -> winrt.windows.ui.xaml.interop.TypeName: ...
    @source_page_type.setter
    def source_page_type(self, value: winrt.windows.ui.xaml.interop.TypeName) -> None: ...
    @_property
    def cache_size(self) -> winrt.system.Int32: ...
    @cache_size.setter
    def cache_size(self, value: winrt.system.Int32) -> None: ...
    @_property
    def back_stack_depth(self) -> winrt.system.Int32: ...
    @_property
    def can_go_back(self) -> bool: ...
    @_property
    def can_go_forward(self) -> bool: ...
    @_property
    def current_source_page_type(self) -> winrt.windows.ui.xaml.interop.TypeName: ...
    @_property
    def back_stack(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.ui.xaml.navigation.PageStackEntry]]: ...
    @_property
    def forward_stack(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.ui.xaml.navigation.PageStackEntry]]: ...
    @_property
    def is_navigation_stack_enabled(self) -> bool: ...
    @is_navigation_stack_enabled.setter
    def is_navigation_stack_enabled(self, value: bool) -> None: ...

@typing.final
class Grid_Static(type):
    def get_column(cls, element: typing.Optional[winrt.windows.ui.xaml.FrameworkElement], /) -> winrt.system.Int32: ...
    def get_column_span(cls, element: typing.Optional[winrt.windows.ui.xaml.FrameworkElement], /) -> winrt.system.Int32: ...
    def get_row(cls, element: typing.Optional[winrt.windows.ui.xaml.FrameworkElement], /) -> winrt.system.Int32: ...
    def get_row_span(cls, element: typing.Optional[winrt.windows.ui.xaml.FrameworkElement], /) -> winrt.system.Int32: ...
    def set_column(cls, element: typing.Optional[winrt.windows.ui.xaml.FrameworkElement], value: winrt.system.Int32, /) -> None: ...
    def set_column_span(cls, element: typing.Optional[winrt.windows.ui.xaml.FrameworkElement], value: winrt.system.Int32, /) -> None: ...
    def set_row(cls, element: typing.Optional[winrt.windows.ui.xaml.FrameworkElement], value: winrt.system.Int32, /) -> None: ...
    def set_row_span(cls, element: typing.Optional[winrt.windows.ui.xaml.FrameworkElement], value: winrt.system.Int32, /) -> None: ...
    @_property
    def column_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def column_span_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def row_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def row_span_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def border_brush_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def border_thickness_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def corner_radius_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def padding_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def column_spacing_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def row_spacing_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def background_sizing_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class Grid(winrt.system.Object, metaclass=Grid_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Grid: ...
    def __new__(cls: typing.Type[Grid]) -> Grid:...
    @_property
    def column_definitions(self) -> typing.Optional[ColumnDefinitionCollection]: ...
    @_property
    def row_definitions(self) -> typing.Optional[RowDefinitionCollection]: ...
    @_property
    def padding(self) -> winrt.windows.ui.xaml.Thickness: ...
    @padding.setter
    def padding(self, value: winrt.windows.ui.xaml.Thickness) -> None: ...
    @_property
    def corner_radius(self) -> winrt.windows.ui.xaml.CornerRadius: ...
    @corner_radius.setter
    def corner_radius(self, value: winrt.windows.ui.xaml.CornerRadius) -> None: ...
    @_property
    def border_thickness(self) -> winrt.windows.ui.xaml.Thickness: ...
    @border_thickness.setter
    def border_thickness(self, value: winrt.windows.ui.xaml.Thickness) -> None: ...
    @_property
    def border_brush(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @border_brush.setter
    def border_brush(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def row_spacing(self) -> winrt.system.Double: ...
    @row_spacing.setter
    def row_spacing(self, value: winrt.system.Double) -> None: ...
    @_property
    def column_spacing(self) -> winrt.system.Double: ...
    @column_spacing.setter
    def column_spacing(self, value: winrt.system.Double) -> None: ...
    @_property
    def background_sizing(self) -> BackgroundSizing: ...
    @background_sizing.setter
    def background_sizing(self, value: BackgroundSizing) -> None: ...

@typing.final
class GridView(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GridView: ...
    def __new__(cls: typing.Type[GridView]) -> GridView:...

@typing.final
class GridViewHeaderItem(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GridViewHeaderItem: ...
    def __new__(cls: typing.Type[GridViewHeaderItem]) -> GridViewHeaderItem:...

@typing.final
class GridViewItem(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GridViewItem: ...
    def __new__(cls: typing.Type[GridViewItem]) -> GridViewItem:...
    @_property
    def template_settings(self) -> typing.Optional[winrt.windows.ui.xaml.controls.primitives.GridViewItemTemplateSettings]: ...

@typing.final
class GroupItem(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GroupItem: ...
    def __new__(cls: typing.Type[GroupItem]) -> GroupItem:...

@typing.final
class GroupStyle(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GroupStyle: ...
    def __new__(cls: typing.Type[GroupStyle]) -> GroupStyle:...
    def add_property_changed(self, handler: typing.Optional[winrt.windows.ui.xaml.data.PropertyChangedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_property_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def panel(self) -> typing.Optional[ItemsPanelTemplate]: ...
    @panel.setter
    def panel(self, value: typing.Optional[ItemsPanelTemplate]) -> None: ...
    @_property
    def hides_if_empty(self) -> bool: ...
    @hides_if_empty.setter
    def hides_if_empty(self, value: bool) -> None: ...
    @_property
    def header_template_selector(self) -> typing.Optional[DataTemplateSelector]: ...
    @header_template_selector.setter
    def header_template_selector(self, value: typing.Optional[DataTemplateSelector]) -> None: ...
    @_property
    def header_template(self) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @header_template.setter
    def header_template(self, value: typing.Optional[winrt.windows.ui.xaml.DataTemplate]) -> None: ...
    @_property
    def container_style_selector(self) -> typing.Optional[StyleSelector]: ...
    @container_style_selector.setter
    def container_style_selector(self, value: typing.Optional[StyleSelector]) -> None: ...
    @_property
    def container_style(self) -> typing.Optional[winrt.windows.ui.xaml.Style]: ...
    @container_style.setter
    def container_style(self, value: typing.Optional[winrt.windows.ui.xaml.Style]) -> None: ...
    @_property
    def header_container_style(self) -> typing.Optional[winrt.windows.ui.xaml.Style]: ...
    @header_container_style.setter
    def header_container_style(self, value: typing.Optional[winrt.windows.ui.xaml.Style]) -> None: ...

@typing.final
class GroupStyleSelector(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GroupStyleSelector: ...
    def __new__(cls: typing.Type[GroupStyleSelector]) -> GroupStyleSelector:...
    def select_group_style(self, group: typing.Optional[winrt.system.Object], level: winrt.system.UInt32, /) -> typing.Optional[GroupStyle]: ...
    def select_group_style_core(self, group: typing.Optional[winrt.system.Object], level: winrt.system.UInt32, /) -> typing.Optional[GroupStyle]: ...

@typing.final
class HandwritingPanelClosedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HandwritingPanelClosedEventArgs: ...

@typing.final
class HandwritingPanelOpenedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HandwritingPanelOpenedEventArgs: ...

@typing.final
class HandwritingView_Static(type):
    @_property
    def are_candidates_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_open_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def placement_alignment_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def placement_target_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_command_bar_open_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_switch_to_keyboard_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class HandwritingView(winrt.system.Object, metaclass=HandwritingView_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HandwritingView: ...
    def __new__(cls: typing.Type[HandwritingView]) -> HandwritingView:...
    def get_candidates(self, candidates_session_id: winrt.system.UInt32, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]: ...
    def select_candidate(self, candidates_session_id: winrt.system.UInt32, selected_candidate_index: winrt.system.UInt32, /) -> None: ...
    def try_close(self) -> bool: ...
    def try_open(self) -> bool: ...
    def add_closed(self, handler: winrt.windows.foundation.TypedEventHandler[HandwritingView, HandwritingPanelClosedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_opened(self, handler: winrt.windows.foundation.TypedEventHandler[HandwritingView, HandwritingPanelOpenedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_opened(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_candidates_changed(self, handler: winrt.windows.foundation.TypedEventHandler[HandwritingView, HandwritingViewCandidatesChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_candidates_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_text_submitted(self, handler: winrt.windows.foundation.TypedEventHandler[HandwritingView, HandwritingViewTextSubmittedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_text_submitted(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def placement_target(self) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    @placement_target.setter
    def placement_target(self, value: typing.Optional[winrt.windows.ui.xaml.UIElement]) -> None: ...
    @_property
    def placement_alignment(self) -> HandwritingPanelPlacementAlignment: ...
    @placement_alignment.setter
    def placement_alignment(self, value: HandwritingPanelPlacementAlignment) -> None: ...
    @_property
    def are_candidates_enabled(self) -> bool: ...
    @are_candidates_enabled.setter
    def are_candidates_enabled(self, value: bool) -> None: ...
    @_property
    def is_open(self) -> bool: ...
    @_property
    def is_switch_to_keyboard_enabled(self) -> bool: ...
    @is_switch_to_keyboard_enabled.setter
    def is_switch_to_keyboard_enabled(self, value: bool) -> None: ...
    @_property
    def is_command_bar_open(self) -> bool: ...
    @is_command_bar_open.setter
    def is_command_bar_open(self, value: bool) -> None: ...
    @_property
    def input_device_types(self) -> winrt.windows.ui.core.CoreInputDeviceTypes: ...
    @input_device_types.setter
    def input_device_types(self, value: winrt.windows.ui.core.CoreInputDeviceTypes) -> None: ...

@typing.final
class HandwritingViewCandidatesChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HandwritingViewCandidatesChangedEventArgs: ...
    @_property
    def candidates_session_id(self) -> winrt.system.UInt32: ...

@typing.final
class HandwritingViewTextSubmittedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HandwritingViewTextSubmittedEventArgs: ...

@typing.final
class Hub_Static(type):
    @_property
    def default_section_index_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def header_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def header_template_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_active_view_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_zoomed_in_view_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def orientation_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def semantic_zoom_owner_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class Hub(winrt.system.Object, metaclass=Hub_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Hub: ...
    def __new__(cls: typing.Type[Hub]) -> Hub:...
    def complete_view_change(self) -> None: ...
    def complete_view_change_from(self, source: typing.Optional[SemanticZoomLocation], destination: typing.Optional[SemanticZoomLocation], /) -> None: ...
    def complete_view_change_to(self, source: typing.Optional[SemanticZoomLocation], destination: typing.Optional[SemanticZoomLocation], /) -> None: ...
    def initialize_view_change(self) -> None: ...
    def make_visible(self, item: typing.Optional[SemanticZoomLocation], /) -> None: ...
    def scroll_to_section(self, section: typing.Optional[HubSection], /) -> None: ...
    def start_view_change_from(self, source: typing.Optional[SemanticZoomLocation], destination: typing.Optional[SemanticZoomLocation], /) -> None: ...
    def start_view_change_to(self, source: typing.Optional[SemanticZoomLocation], destination: typing.Optional[SemanticZoomLocation], /) -> None: ...
    def add_section_header_click(self, handler: typing.Optional[HubSectionHeaderClickEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_section_header_click(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_sections_in_view_changed(self, handler: typing.Optional[SectionsInViewChangedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_sections_in_view_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def orientation(self) -> Orientation: ...
    @orientation.setter
    def orientation(self, value: Orientation) -> None: ...
    @_property
    def header_template(self) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @header_template.setter
    def header_template(self, value: typing.Optional[winrt.windows.ui.xaml.DataTemplate]) -> None: ...
    @_property
    def header(self) -> typing.Optional[winrt.system.Object]: ...
    @header.setter
    def header(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def default_section_index(self) -> winrt.system.Int32: ...
    @default_section_index.setter
    def default_section_index(self, value: winrt.system.Int32) -> None: ...
    @_property
    def section_headers(self) -> typing.Optional[winrt.windows.foundation.collections.IObservableVector[winrt.system.Object]]: ...
    @_property
    def sections(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[HubSection]]: ...
    @_property
    def sections_in_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[HubSection]]: ...
    @_property
    def semantic_zoom_owner(self) -> typing.Optional[SemanticZoom]: ...
    @semantic_zoom_owner.setter
    def semantic_zoom_owner(self, value: typing.Optional[SemanticZoom]) -> None: ...
    @_property
    def is_zoomed_in_view(self) -> bool: ...
    @is_zoomed_in_view.setter
    def is_zoomed_in_view(self, value: bool) -> None: ...
    @_property
    def is_active_view(self) -> bool: ...
    @is_active_view.setter
    def is_active_view(self, value: bool) -> None: ...

@typing.final
class HubSection_Static(type):
    @_property
    def content_template_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def header_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def header_template_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_header_interactive_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class HubSection(winrt.system.Object, metaclass=HubSection_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HubSection: ...
    def __new__(cls: typing.Type[HubSection]) -> HubSection:...
    @_property
    def is_header_interactive(self) -> bool: ...
    @is_header_interactive.setter
    def is_header_interactive(self, value: bool) -> None: ...
    @_property
    def header_template(self) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @header_template.setter
    def header_template(self, value: typing.Optional[winrt.windows.ui.xaml.DataTemplate]) -> None: ...
    @_property
    def header(self) -> typing.Optional[winrt.system.Object]: ...
    @header.setter
    def header(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def content_template(self) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @content_template.setter
    def content_template(self, value: typing.Optional[winrt.windows.ui.xaml.DataTemplate]) -> None: ...

@typing.final
class HubSectionCollection(winrt.system.Object, winrt._winrt.MutableSequence[HubSection]):
    def __len__(self) -> int: ...
    def __iter__(self) -> winrt.windows.foundation.collections.IIterator[HubSection]: ...
    @typing.overload
    def __getitem__(self, index: typing.SupportsIndex) -> HubSection: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[HubSection]: ...
    @typing.overload
    def __delitem__(self, index: typing.SupportsIndex) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: typing.SupportsIndex, value: HubSection) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[HubSection]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HubSectionCollection: ...
    def append(self, value: typing.Optional[HubSection], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[HubSection]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[HubSection]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[HubSection], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[HubSection]]: ...
    def index_of(self, value: typing.Optional[HubSection], /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[HubSection], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[HubSection], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[HubSection], /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class HubSectionHeaderClickEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HubSectionHeaderClickEventArgs: ...
    def __new__(cls: typing.Type[HubSectionHeaderClickEventArgs]) -> HubSectionHeaderClickEventArgs:...
    @_property
    def section(self) -> typing.Optional[HubSection]: ...

@typing.final
class HyperlinkButton_Static(type):
    @_property
    def navigate_uri_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class HyperlinkButton(winrt.system.Object, metaclass=HyperlinkButton_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HyperlinkButton: ...
    def __new__(cls: typing.Type[HyperlinkButton]) -> HyperlinkButton:...
    @_property
    def navigate_uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @navigate_uri.setter
    def navigate_uri(self, value: typing.Optional[winrt.windows.foundation.Uri]) -> None: ...

@typing.final
class IconElement_Static(type):
    @_property
    def foreground_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class IconElement(winrt.system.Object, metaclass=IconElement_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IconElement: ...
    @_property
    def foreground(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @foreground.setter
    def foreground(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...

@typing.final
class IconSource_Static(type):
    @_property
    def foreground_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class IconSource(winrt.system.Object, metaclass=IconSource_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IconSource: ...
    @_property
    def foreground(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @foreground.setter
    def foreground(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...

@typing.final
class IconSourceElement_Static(type):
    @_property
    def icon_source_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class IconSourceElement(winrt.system.Object, metaclass=IconSourceElement_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IconSourceElement: ...
    def __new__(cls: typing.Type[IconSourceElement]) -> IconSourceElement:...
    @_property
    def icon_source(self) -> typing.Optional[IconSource]: ...
    @icon_source.setter
    def icon_source(self, value: typing.Optional[IconSource]) -> None: ...

@typing.final
class Image_Static(type):
    @_property
    def nine_grid_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def play_to_source_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def source_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def stretch_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class Image(winrt.system.Object, metaclass=Image_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Image: ...
    def __new__(cls: typing.Type[Image]) -> Image:...
    def get_alpha_mask(self) -> typing.Optional[winrt.windows.ui.composition.CompositionBrush]: ...
    def get_as_casting_source(self) -> typing.Optional[winrt.windows.media.casting.CastingSource]: ...
    def add_image_failed(self, handler: typing.Optional[winrt.windows.ui.xaml.ExceptionRoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_image_failed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_image_opened(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_image_opened(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def stretch(self) -> winrt.windows.ui.xaml.media.Stretch: ...
    @stretch.setter
    def stretch(self, value: winrt.windows.ui.xaml.media.Stretch) -> None: ...
    @_property
    def source(self) -> typing.Optional[winrt.windows.ui.xaml.media.ImageSource]: ...
    @source.setter
    def source(self, value: typing.Optional[winrt.windows.ui.xaml.media.ImageSource]) -> None: ...
    @_property
    def nine_grid(self) -> winrt.windows.ui.xaml.Thickness: ...
    @nine_grid.setter
    def nine_grid(self, value: winrt.windows.ui.xaml.Thickness) -> None: ...
    @_property
    def play_to_source(self) -> typing.Optional[winrt.windows.media.playto.PlayToSource]: ...

@typing.final
class InkCanvas(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkCanvas: ...
    def __new__(cls: typing.Type[InkCanvas]) -> InkCanvas:...
    @_property
    def ink_presenter(self) -> typing.Optional[winrt.windows.ui.input.inking.InkPresenter]: ...

@typing.final
class InkToolbar_Static(type):
    @_property
    def active_tool_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def children_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def initial_controls_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def ink_drawing_attributes_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_ruler_button_checked_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def target_ink_canvas_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def button_flyout_placement_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_stencil_button_checked_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def orientation_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def target_ink_presenter_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class InkToolbar(winrt.system.Object, metaclass=InkToolbar_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbar: ...
    def __new__(cls: typing.Type[InkToolbar]) -> InkToolbar:...
    def get_menu_button(self, menu: InkToolbarMenuKind, /) -> typing.Optional[InkToolbarMenuButton]: ...
    def get_toggle_button(self, tool: InkToolbarToggle, /) -> typing.Optional[InkToolbarToggleButton]: ...
    def get_tool_button(self, tool: InkToolbarTool, /) -> typing.Optional[InkToolbarToolButton]: ...
    def add_active_tool_changed(self, handler: winrt.windows.foundation.TypedEventHandler[InkToolbar, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_active_tool_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_erase_all_clicked(self, handler: winrt.windows.foundation.TypedEventHandler[InkToolbar, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_erase_all_clicked(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_ink_drawing_attributes_changed(self, handler: winrt.windows.foundation.TypedEventHandler[InkToolbar, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_ink_drawing_attributes_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_is_ruler_button_checked_changed(self, handler: winrt.windows.foundation.TypedEventHandler[InkToolbar, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_is_ruler_button_checked_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_is_stencil_button_checked_changed(self, handler: winrt.windows.foundation.TypedEventHandler[InkToolbar, InkToolbarIsStencilButtonCheckedChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_is_stencil_button_checked_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def target_ink_canvas(self) -> typing.Optional[InkCanvas]: ...
    @target_ink_canvas.setter
    def target_ink_canvas(self, value: typing.Optional[InkCanvas]) -> None: ...
    @_property
    def is_ruler_button_checked(self) -> bool: ...
    @is_ruler_button_checked.setter
    def is_ruler_button_checked(self, value: bool) -> None: ...
    @_property
    def initial_controls(self) -> InkToolbarInitialControls: ...
    @initial_controls.setter
    def initial_controls(self, value: InkToolbarInitialControls) -> None: ...
    @_property
    def active_tool(self) -> typing.Optional[InkToolbarToolButton]: ...
    @active_tool.setter
    def active_tool(self, value: typing.Optional[InkToolbarToolButton]) -> None: ...
    @_property
    def children(self) -> typing.Optional[winrt.windows.ui.xaml.DependencyObjectCollection]: ...
    @_property
    def ink_drawing_attributes(self) -> typing.Optional[winrt.windows.ui.input.inking.InkDrawingAttributes]: ...
    @_property
    def orientation(self) -> Orientation: ...
    @orientation.setter
    def orientation(self, value: Orientation) -> None: ...
    @_property
    def is_stencil_button_checked(self) -> bool: ...
    @is_stencil_button_checked.setter
    def is_stencil_button_checked(self, value: bool) -> None: ...
    @_property
    def button_flyout_placement(self) -> InkToolbarButtonFlyoutPlacement: ...
    @button_flyout_placement.setter
    def button_flyout_placement(self, value: InkToolbarButtonFlyoutPlacement) -> None: ...
    @_property
    def target_ink_presenter(self) -> typing.Optional[winrt.windows.ui.input.inking.InkPresenter]: ...
    @target_ink_presenter.setter
    def target_ink_presenter(self, value: typing.Optional[winrt.windows.ui.input.inking.InkPresenter]) -> None: ...

@typing.final
class InkToolbarBallpointPenButton(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarBallpointPenButton: ...
    def __new__(cls: typing.Type[InkToolbarBallpointPenButton]) -> InkToolbarBallpointPenButton:...

@typing.final
class InkToolbarCustomPen(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarCustomPen: ...
    def create_ink_drawing_attributes(self, brush: typing.Optional[winrt.windows.ui.xaml.media.Brush], stroke_width: winrt.system.Double, /) -> typing.Optional[winrt.windows.ui.input.inking.InkDrawingAttributes]: ...
    def create_ink_drawing_attributes_core(self, brush: typing.Optional[winrt.windows.ui.xaml.media.Brush], stroke_width: winrt.system.Double, /) -> typing.Optional[winrt.windows.ui.input.inking.InkDrawingAttributes]: ...

@typing.final
class InkToolbarCustomPenButton_Static(type):
    @_property
    def configuration_content_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def custom_pen_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class InkToolbarCustomPenButton(winrt.system.Object, metaclass=InkToolbarCustomPenButton_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarCustomPenButton: ...
    def __new__(cls: typing.Type[InkToolbarCustomPenButton]) -> InkToolbarCustomPenButton:...
    @_property
    def custom_pen(self) -> typing.Optional[InkToolbarCustomPen]: ...
    @custom_pen.setter
    def custom_pen(self, value: typing.Optional[InkToolbarCustomPen]) -> None: ...
    @_property
    def configuration_content(self) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    @configuration_content.setter
    def configuration_content(self, value: typing.Optional[winrt.windows.ui.xaml.UIElement]) -> None: ...

@typing.final
class InkToolbarCustomToggleButton(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarCustomToggleButton: ...
    def __new__(cls: typing.Type[InkToolbarCustomToggleButton]) -> InkToolbarCustomToggleButton:...

@typing.final
class InkToolbarCustomToolButton_Static(type):
    @_property
    def configuration_content_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class InkToolbarCustomToolButton(winrt.system.Object, metaclass=InkToolbarCustomToolButton_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarCustomToolButton: ...
    def __new__(cls: typing.Type[InkToolbarCustomToolButton]) -> InkToolbarCustomToolButton:...
    @_property
    def configuration_content(self) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    @configuration_content.setter
    def configuration_content(self, value: typing.Optional[winrt.windows.ui.xaml.UIElement]) -> None: ...

@typing.final
class InkToolbarEraserButton_Static(type):
    @_property
    def is_clear_all_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class InkToolbarEraserButton(winrt.system.Object, metaclass=InkToolbarEraserButton_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarEraserButton: ...
    def __new__(cls: typing.Type[InkToolbarEraserButton]) -> InkToolbarEraserButton:...
    @_property
    def is_clear_all_visible(self) -> bool: ...
    @is_clear_all_visible.setter
    def is_clear_all_visible(self, value: bool) -> None: ...

@typing.final
class InkToolbarFlyoutItem_Static(type):
    @_property
    def is_checked_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def kind_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class InkToolbarFlyoutItem(winrt.system.Object, metaclass=InkToolbarFlyoutItem_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarFlyoutItem: ...
    def __new__(cls: typing.Type[InkToolbarFlyoutItem]) -> InkToolbarFlyoutItem:...
    def add_checked(self, handler: winrt.windows.foundation.TypedEventHandler[InkToolbarFlyoutItem, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_checked(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_unchecked(self, handler: winrt.windows.foundation.TypedEventHandler[InkToolbarFlyoutItem, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_unchecked(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def kind(self) -> InkToolbarFlyoutItemKind: ...
    @kind.setter
    def kind(self, value: InkToolbarFlyoutItemKind) -> None: ...
    @_property
    def is_checked(self) -> bool: ...
    @is_checked.setter
    def is_checked(self, value: bool) -> None: ...

@typing.final
class InkToolbarHighlighterButton(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarHighlighterButton: ...
    def __new__(cls: typing.Type[InkToolbarHighlighterButton]) -> InkToolbarHighlighterButton:...

@typing.final
class InkToolbarIsStencilButtonCheckedChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarIsStencilButtonCheckedChangedEventArgs: ...
    def __new__(cls: typing.Type[InkToolbarIsStencilButtonCheckedChangedEventArgs]) -> InkToolbarIsStencilButtonCheckedChangedEventArgs:...
    @_property
    def stencil_button(self) -> typing.Optional[InkToolbarStencilButton]: ...
    @_property
    def stencil_kind(self) -> InkToolbarStencilKind: ...

@typing.final
class InkToolbarMenuButton_Static(type):
    @_property
    def is_extension_glyph_shown_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class InkToolbarMenuButton(winrt.system.Object, metaclass=InkToolbarMenuButton_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarMenuButton: ...
    @_property
    def is_extension_glyph_shown(self) -> bool: ...
    @is_extension_glyph_shown.setter
    def is_extension_glyph_shown(self, value: bool) -> None: ...
    @_property
    def menu_kind(self) -> InkToolbarMenuKind: ...

@typing.final
class InkToolbarPenButton_Static(type):
    @_property
    def max_stroke_width_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def min_stroke_width_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def palette_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selected_brush_index_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selected_brush_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selected_stroke_width_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class InkToolbarPenButton(winrt.system.Object, metaclass=InkToolbarPenButton_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarPenButton: ...
    @_property
    def selected_stroke_width(self) -> winrt.system.Double: ...
    @selected_stroke_width.setter
    def selected_stroke_width(self, value: winrt.system.Double) -> None: ...
    @_property
    def selected_brush_index(self) -> winrt.system.Int32: ...
    @selected_brush_index.setter
    def selected_brush_index(self, value: winrt.system.Int32) -> None: ...
    @_property
    def palette(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.ui.xaml.media.Brush]]: ...
    @palette.setter
    def palette(self, value: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.ui.xaml.media.Brush]]) -> None: ...
    @_property
    def min_stroke_width(self) -> winrt.system.Double: ...
    @min_stroke_width.setter
    def min_stroke_width(self, value: winrt.system.Double) -> None: ...
    @_property
    def max_stroke_width(self) -> winrt.system.Double: ...
    @max_stroke_width.setter
    def max_stroke_width(self, value: winrt.system.Double) -> None: ...
    @_property
    def selected_brush(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...

@typing.final
class InkToolbarPenConfigurationControl_Static(type):
    @_property
    def pen_button_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class InkToolbarPenConfigurationControl(winrt.system.Object, metaclass=InkToolbarPenConfigurationControl_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarPenConfigurationControl: ...
    def __new__(cls: typing.Type[InkToolbarPenConfigurationControl]) -> InkToolbarPenConfigurationControl:...
    @_property
    def pen_button(self) -> typing.Optional[InkToolbarPenButton]: ...

@typing.final
class InkToolbarPencilButton(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarPencilButton: ...
    def __new__(cls: typing.Type[InkToolbarPencilButton]) -> InkToolbarPencilButton:...

@typing.final
class InkToolbarRulerButton_Static(type):
    @_property
    def ruler_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class InkToolbarRulerButton(winrt.system.Object, metaclass=InkToolbarRulerButton_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarRulerButton: ...
    def __new__(cls: typing.Type[InkToolbarRulerButton]) -> InkToolbarRulerButton:...
    @_property
    def ruler(self) -> typing.Optional[winrt.windows.ui.input.inking.InkPresenterRuler]: ...

@typing.final
class InkToolbarStencilButton_Static(type):
    @_property
    def is_protractor_item_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_ruler_item_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def protractor_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def ruler_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selected_stencil_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class InkToolbarStencilButton(winrt.system.Object, metaclass=InkToolbarStencilButton_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarStencilButton: ...
    def __new__(cls: typing.Type[InkToolbarStencilButton]) -> InkToolbarStencilButton:...
    @_property
    def selected_stencil(self) -> InkToolbarStencilKind: ...
    @selected_stencil.setter
    def selected_stencil(self, value: InkToolbarStencilKind) -> None: ...
    @_property
    def is_ruler_item_visible(self) -> bool: ...
    @is_ruler_item_visible.setter
    def is_ruler_item_visible(self, value: bool) -> None: ...
    @_property
    def is_protractor_item_visible(self) -> bool: ...
    @is_protractor_item_visible.setter
    def is_protractor_item_visible(self, value: bool) -> None: ...
    @_property
    def protractor(self) -> typing.Optional[winrt.windows.ui.input.inking.InkPresenterProtractor]: ...
    @_property
    def ruler(self) -> typing.Optional[winrt.windows.ui.input.inking.InkPresenterRuler]: ...

@typing.final
class InkToolbarToggleButton(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarToggleButton: ...
    @_property
    def toggle_kind(self) -> InkToolbarToggle: ...

@typing.final
class InkToolbarToolButton_Static(type):
    @_property
    def is_extension_glyph_shown_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class InkToolbarToolButton(winrt.system.Object, metaclass=InkToolbarToolButton_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarToolButton: ...
    @_property
    def is_extension_glyph_shown(self) -> bool: ...
    @is_extension_glyph_shown.setter
    def is_extension_glyph_shown(self, value: bool) -> None: ...
    @_property
    def tool_kind(self) -> InkToolbarTool: ...

@typing.final
class IsTextTrimmedChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IsTextTrimmedChangedEventArgs: ...

@typing.final
class ItemClickEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ItemClickEventArgs: ...
    def __new__(cls: typing.Type[ItemClickEventArgs]) -> ItemClickEventArgs:...
    @_property
    def clicked_item(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class ItemCollection(winrt.system.Object, winrt._winrt.MutableSequence[winrt.system.Object]):
    def __len__(self) -> int: ...
    def __iter__(self) -> winrt.windows.foundation.collections.IIterator[winrt.system.Object]: ...
    @typing.overload
    def __getitem__(self, index: typing.SupportsIndex) -> winrt.system.Object: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[winrt.system.Object]: ...
    @typing.overload
    def __delitem__(self, index: typing.SupportsIndex) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: typing.SupportsIndex, value: winrt.system.Object) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[winrt.system.Object]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ItemCollection: ...
    def append(self, value: typing.Optional[winrt.system.Object], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[winrt.system.Object]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[winrt.system.Object]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[winrt.system.Object], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Object]]: ...
    def index_of(self, value: typing.Optional[winrt.system.Object], /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[winrt.system.Object], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[winrt.system.Object], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[winrt.system.Object], /) -> None: ...
    def add_vector_changed(self, vhnd: winrt.windows.foundation.collections.VectorChangedEventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_vector_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class ItemContainerGenerator(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ItemContainerGenerator: ...
    def container_from_index(self, index: winrt.system.Int32, /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    def container_from_item(self, item: typing.Optional[winrt.system.Object], /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    def generate_next(self) -> typing.Tuple[typing.Optional[winrt.windows.ui.xaml.DependencyObject], bool]: ...
    def generator_position_from_index(self, item_index: winrt.system.Int32, /) -> winrt.windows.ui.xaml.controls.primitives.GeneratorPosition: ...
    def get_item_container_generator_for_panel(self, panel: typing.Optional[Panel], /) -> typing.Optional[ItemContainerGenerator]: ...
    def index_from_container(self, container: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> winrt.system.Int32: ...
    def index_from_generator_position(self, position: winrt.windows.ui.xaml.controls.primitives.GeneratorPosition, /) -> winrt.system.Int32: ...
    def item_from_container(self, container: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.system.Object]: ...
    def prepare_item_container(self, container: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> None: ...
    def recycle(self, position: winrt.windows.ui.xaml.controls.primitives.GeneratorPosition, count: winrt.system.Int32, /) -> None: ...
    def remove(self, position: winrt.windows.ui.xaml.controls.primitives.GeneratorPosition, count: winrt.system.Int32, /) -> None: ...
    def remove_all(self) -> None: ...
    def start_at(self, position: winrt.windows.ui.xaml.controls.primitives.GeneratorPosition, direction: winrt.windows.ui.xaml.controls.primitives.GeneratorDirection, allow_start_at_realized_item: bool, /) -> None: ...
    def stop(self) -> None: ...
    def add_items_changed(self, handler: typing.Optional[winrt.windows.ui.xaml.controls.primitives.ItemsChangedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_items_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

@typing.final
class ItemsControl_Static(type):
    def get_items_owner(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[ItemsControl]: ...
    def items_control_from_item_container(cls, container: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[ItemsControl]: ...
    @_property
    def display_member_path_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def group_style_selector_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_grouping_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def item_container_style_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def item_container_style_selector_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def item_container_transitions_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def item_template_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def item_template_selector_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def items_panel_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def items_source_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class ItemsControl(winrt.system.Object, metaclass=ItemsControl_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ItemsControl: ...
    def __new__(cls: typing.Type[ItemsControl]) -> ItemsControl:...
    def clear_container_for_item_override(self, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], item: typing.Optional[winrt.system.Object], /) -> None: ...
    def container_from_index(self, index: winrt.system.Int32, /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    def container_from_item(self, item: typing.Optional[winrt.system.Object], /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    def get_container_for_item_override(self) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    def group_header_container_from_item_container(self, item_container: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    def index_from_container(self, container: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> winrt.system.Int32: ...
    def is_item_its_own_container_override(self, item: typing.Optional[winrt.system.Object], /) -> bool: ...
    def item_from_container(self, container: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.system.Object]: ...
    def on_group_style_selector_changed(self, old_group_style_selector: typing.Optional[GroupStyleSelector], new_group_style_selector: typing.Optional[GroupStyleSelector], /) -> None: ...
    def on_item_container_style_changed(self, old_item_container_style: typing.Optional[winrt.windows.ui.xaml.Style], new_item_container_style: typing.Optional[winrt.windows.ui.xaml.Style], /) -> None: ...
    def on_item_container_style_selector_changed(self, old_item_container_style_selector: typing.Optional[StyleSelector], new_item_container_style_selector: typing.Optional[StyleSelector], /) -> None: ...
    def on_item_template_changed(self, old_item_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate], new_item_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate], /) -> None: ...
    def on_item_template_selector_changed(self, old_item_template_selector: typing.Optional[DataTemplateSelector], new_item_template_selector: typing.Optional[DataTemplateSelector], /) -> None: ...
    def on_items_changed(self, e: typing.Optional[winrt.system.Object], /) -> None: ...
    def prepare_container_for_item_override(self, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], item: typing.Optional[winrt.system.Object], /) -> None: ...
    @_property
    def items_source(self) -> typing.Optional[winrt.system.Object]: ...
    @items_source.setter
    def items_source(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def items_panel(self) -> typing.Optional[ItemsPanelTemplate]: ...
    @items_panel.setter
    def items_panel(self, value: typing.Optional[ItemsPanelTemplate]) -> None: ...
    @_property
    def item_template_selector(self) -> typing.Optional[DataTemplateSelector]: ...
    @item_template_selector.setter
    def item_template_selector(self, value: typing.Optional[DataTemplateSelector]) -> None: ...
    @_property
    def item_template(self) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @item_template.setter
    def item_template(self, value: typing.Optional[winrt.windows.ui.xaml.DataTemplate]) -> None: ...
    @_property
    def item_container_transitions(self) -> typing.Optional[winrt.windows.ui.xaml.media.animation.TransitionCollection]: ...
    @item_container_transitions.setter
    def item_container_transitions(self, value: typing.Optional[winrt.windows.ui.xaml.media.animation.TransitionCollection]) -> None: ...
    @_property
    def item_container_style_selector(self) -> typing.Optional[StyleSelector]: ...
    @item_container_style_selector.setter
    def item_container_style_selector(self, value: typing.Optional[StyleSelector]) -> None: ...
    @_property
    def item_container_style(self) -> typing.Optional[winrt.windows.ui.xaml.Style]: ...
    @item_container_style.setter
    def item_container_style(self, value: typing.Optional[winrt.windows.ui.xaml.Style]) -> None: ...
    @_property
    def group_style_selector(self) -> typing.Optional[GroupStyleSelector]: ...
    @group_style_selector.setter
    def group_style_selector(self, value: typing.Optional[GroupStyleSelector]) -> None: ...
    @_property
    def display_member_path(self) -> str: ...
    @display_member_path.setter
    def display_member_path(self, value: str) -> None: ...
    @_property
    def group_style(self) -> typing.Optional[winrt.windows.foundation.collections.IObservableVector[GroupStyle]]: ...
    @_property
    def is_grouping(self) -> bool: ...
    @_property
    def item_container_generator(self) -> typing.Optional[ItemContainerGenerator]: ...
    @_property
    def items(self) -> typing.Optional[ItemCollection]: ...
    @_property
    def items_panel_root(self) -> typing.Optional[Panel]: ...

@typing.final
class ItemsPanelTemplate(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ItemsPanelTemplate: ...
    def __new__(cls: typing.Type[ItemsPanelTemplate]) -> ItemsPanelTemplate:...

@typing.final
class ItemsPickedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ItemsPickedEventArgs: ...
    def __new__(cls: typing.Type[ItemsPickedEventArgs]) -> ItemsPickedEventArgs:...
    @_property
    def added_items(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.system.Object]]: ...
    @_property
    def removed_items(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.system.Object]]: ...

@typing.final
class ItemsPresenter_Static(type):
    @_property
    def header_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def header_template_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def header_transitions_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def padding_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def footer_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def footer_template_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def footer_transitions_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class ItemsPresenter(winrt.system.Object, metaclass=ItemsPresenter_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ItemsPresenter: ...
    def __new__(cls: typing.Type[ItemsPresenter]) -> ItemsPresenter:...
    def get_irregular_snap_points(self, orientation: Orientation, alignment: winrt.windows.ui.xaml.controls.primitives.SnapPointsAlignment, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Single]]: ...
    def get_regular_snap_points(self, orientation: Orientation, alignment: winrt.windows.ui.xaml.controls.primitives.SnapPointsAlignment, /) -> typing.Tuple[winrt.system.Single, winrt.system.Single]: ...
    def add_horizontal_snap_points_changed(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_horizontal_snap_points_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_vertical_snap_points_changed(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_vertical_snap_points_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def padding(self) -> winrt.windows.ui.xaml.Thickness: ...
    @padding.setter
    def padding(self, value: winrt.windows.ui.xaml.Thickness) -> None: ...
    @_property
    def header_transitions(self) -> typing.Optional[winrt.windows.ui.xaml.media.animation.TransitionCollection]: ...
    @header_transitions.setter
    def header_transitions(self, value: typing.Optional[winrt.windows.ui.xaml.media.animation.TransitionCollection]) -> None: ...
    @_property
    def header_template(self) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @header_template.setter
    def header_template(self, value: typing.Optional[winrt.windows.ui.xaml.DataTemplate]) -> None: ...
    @_property
    def header(self) -> typing.Optional[winrt.system.Object]: ...
    @header.setter
    def header(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def footer_transitions(self) -> typing.Optional[winrt.windows.ui.xaml.media.animation.TransitionCollection]: ...
    @footer_transitions.setter
    def footer_transitions(self, value: typing.Optional[winrt.windows.ui.xaml.media.animation.TransitionCollection]) -> None: ...
    @_property
    def footer_template(self) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @footer_template.setter
    def footer_template(self, value: typing.Optional[winrt.windows.ui.xaml.DataTemplate]) -> None: ...
    @_property
    def footer(self) -> typing.Optional[winrt.system.Object]: ...
    @footer.setter
    def footer(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def are_horizontal_snap_points_regular(self) -> bool: ...
    @_property
    def are_vertical_snap_points_regular(self) -> bool: ...

@typing.final
class ItemsStackPanel_Static(type):
    @_property
    def cache_length_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def group_header_placement_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def group_padding_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def orientation_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def are_sticky_group_headers_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class ItemsStackPanel(winrt.system.Object, metaclass=ItemsStackPanel_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ItemsStackPanel: ...
    def __new__(cls: typing.Type[ItemsStackPanel]) -> ItemsStackPanel:...
    @_property
    def orientation(self) -> Orientation: ...
    @orientation.setter
    def orientation(self, value: Orientation) -> None: ...
    @_property
    def items_updating_scroll_mode(self) -> ItemsUpdatingScrollMode: ...
    @items_updating_scroll_mode.setter
    def items_updating_scroll_mode(self, value: ItemsUpdatingScrollMode) -> None: ...
    @_property
    def group_padding(self) -> winrt.windows.ui.xaml.Thickness: ...
    @group_padding.setter
    def group_padding(self, value: winrt.windows.ui.xaml.Thickness) -> None: ...
    @_property
    def group_header_placement(self) -> winrt.windows.ui.xaml.controls.primitives.GroupHeaderPlacement: ...
    @group_header_placement.setter
    def group_header_placement(self, value: winrt.windows.ui.xaml.controls.primitives.GroupHeaderPlacement) -> None: ...
    @_property
    def cache_length(self) -> winrt.system.Double: ...
    @cache_length.setter
    def cache_length(self, value: winrt.system.Double) -> None: ...
    @_property
    def first_cache_index(self) -> winrt.system.Int32: ...
    @_property
    def first_visible_index(self) -> winrt.system.Int32: ...
    @_property
    def last_cache_index(self) -> winrt.system.Int32: ...
    @_property
    def last_visible_index(self) -> winrt.system.Int32: ...
    @_property
    def scrolling_direction(self) -> PanelScrollingDirection: ...
    @_property
    def are_sticky_group_headers_enabled(self) -> bool: ...
    @are_sticky_group_headers_enabled.setter
    def are_sticky_group_headers_enabled(self, value: bool) -> None: ...

@typing.final
class ItemsWrapGrid_Static(type):
    @_property
    def cache_length_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def group_header_placement_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def group_padding_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def item_height_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def item_width_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def maximum_rows_or_columns_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def orientation_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def are_sticky_group_headers_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class ItemsWrapGrid(winrt.system.Object, metaclass=ItemsWrapGrid_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ItemsWrapGrid: ...
    def __new__(cls: typing.Type[ItemsWrapGrid]) -> ItemsWrapGrid:...
    @_property
    def orientation(self) -> Orientation: ...
    @orientation.setter
    def orientation(self, value: Orientation) -> None: ...
    @_property
    def maximum_rows_or_columns(self) -> winrt.system.Int32: ...
    @maximum_rows_or_columns.setter
    def maximum_rows_or_columns(self, value: winrt.system.Int32) -> None: ...
    @_property
    def item_width(self) -> winrt.system.Double: ...
    @item_width.setter
    def item_width(self, value: winrt.system.Double) -> None: ...
    @_property
    def item_height(self) -> winrt.system.Double: ...
    @item_height.setter
    def item_height(self, value: winrt.system.Double) -> None: ...
    @_property
    def group_padding(self) -> winrt.windows.ui.xaml.Thickness: ...
    @group_padding.setter
    def group_padding(self, value: winrt.windows.ui.xaml.Thickness) -> None: ...
    @_property
    def group_header_placement(self) -> winrt.windows.ui.xaml.controls.primitives.GroupHeaderPlacement: ...
    @group_header_placement.setter
    def group_header_placement(self, value: winrt.windows.ui.xaml.controls.primitives.GroupHeaderPlacement) -> None: ...
    @_property
    def cache_length(self) -> winrt.system.Double: ...
    @cache_length.setter
    def cache_length(self, value: winrt.system.Double) -> None: ...
    @_property
    def first_cache_index(self) -> winrt.system.Int32: ...
    @_property
    def first_visible_index(self) -> winrt.system.Int32: ...
    @_property
    def last_cache_index(self) -> winrt.system.Int32: ...
    @_property
    def last_visible_index(self) -> winrt.system.Int32: ...
    @_property
    def scrolling_direction(self) -> PanelScrollingDirection: ...
    @_property
    def are_sticky_group_headers_enabled(self) -> bool: ...
    @are_sticky_group_headers_enabled.setter
    def are_sticky_group_headers_enabled(self, value: bool) -> None: ...

@typing.final
class ListBox_Static(type):
    @_property
    def selection_mode_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def single_selection_follows_focus_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class ListBox(winrt.system.Object, metaclass=ListBox_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ListBox: ...
    def __new__(cls: typing.Type[ListBox]) -> ListBox:...
    def scroll_into_view(self, item: typing.Optional[winrt.system.Object], /) -> None: ...
    def select_all(self) -> None: ...
    @_property
    def selection_mode(self) -> SelectionMode: ...
    @selection_mode.setter
    def selection_mode(self, value: SelectionMode) -> None: ...
    @_property
    def selected_items(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.system.Object]]: ...
    @_property
    def single_selection_follows_focus(self) -> bool: ...
    @single_selection_follows_focus.setter
    def single_selection_follows_focus(self, value: bool) -> None: ...

@typing.final
class ListBoxItem(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ListBoxItem: ...
    def __new__(cls: typing.Type[ListBoxItem]) -> ListBoxItem:...

@typing.final
class ListPickerFlyout_Static(type):
    @_property
    def display_member_path_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def item_template_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def items_source_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selected_index_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selected_item_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selected_value_path_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selected_value_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selection_mode_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class ListPickerFlyout(winrt.system.Object, metaclass=ListPickerFlyout_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ListPickerFlyout: ...
    def __new__(cls: typing.Type[ListPickerFlyout]) -> ListPickerFlyout:...
    def show_at_async(self, target: typing.Optional[winrt.windows.ui.xaml.FrameworkElement], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.system.Object]]: ...
    def add_items_picked(self, handler: winrt.windows.foundation.TypedEventHandler[ListPickerFlyout, ItemsPickedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_items_picked(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def selection_mode(self) -> ListPickerFlyoutSelectionMode: ...
    @selection_mode.setter
    def selection_mode(self, value: ListPickerFlyoutSelectionMode) -> None: ...
    @_property
    def selected_value_path(self) -> str: ...
    @selected_value_path.setter
    def selected_value_path(self, value: str) -> None: ...
    @_property
    def selected_value(self) -> typing.Optional[winrt.system.Object]: ...
    @selected_value.setter
    def selected_value(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def selected_item(self) -> typing.Optional[winrt.system.Object]: ...
    @selected_item.setter
    def selected_item(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def selected_index(self) -> winrt.system.Int32: ...
    @selected_index.setter
    def selected_index(self, value: winrt.system.Int32) -> None: ...
    @_property
    def items_source(self) -> typing.Optional[winrt.system.Object]: ...
    @items_source.setter
    def items_source(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def item_template(self) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @item_template.setter
    def item_template(self, value: typing.Optional[winrt.windows.ui.xaml.DataTemplate]) -> None: ...
    @_property
    def display_member_path(self) -> str: ...
    @display_member_path.setter
    def display_member_path(self, value: str) -> None: ...
    @_property
    def selected_items(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.system.Object]]: ...

@typing.final
class ListPickerFlyoutPresenter(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ListPickerFlyoutPresenter: ...

@typing.final
class ListView(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ListView: ...
    def __new__(cls: typing.Type[ListView]) -> ListView:...

@typing.final
class ListViewBase_Static(type):
    @_property
    def can_drag_items_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def can_reorder_items_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def data_fetch_size_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def header_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def header_template_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def header_transitions_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def incremental_loading_threshold_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def incremental_loading_trigger_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_active_view_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_item_click_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_swipe_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_zoomed_in_view_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selection_mode_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def semantic_zoom_owner_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def footer_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def footer_template_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def footer_transitions_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def shows_scrolling_placeholders_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def reorder_mode_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_multi_select_check_box_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def single_selection_follows_focus_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class ListViewBase(winrt.system.Object, metaclass=ListViewBase_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ListViewBase: ...
    def complete_view_change(self) -> None: ...
    def complete_view_change_from(self, source: typing.Optional[SemanticZoomLocation], destination: typing.Optional[SemanticZoomLocation], /) -> None: ...
    def complete_view_change_to(self, source: typing.Optional[SemanticZoomLocation], destination: typing.Optional[SemanticZoomLocation], /) -> None: ...
    def deselect_range(self, item_index_range: typing.Optional[winrt.windows.ui.xaml.data.ItemIndexRange], /) -> None: ...
    def initialize_view_change(self) -> None: ...
    def is_drag_source(self) -> bool: ...
    def load_more_items_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.ui.xaml.data.LoadMoreItemsResult]: ...
    def make_visible(self, item: typing.Optional[SemanticZoomLocation], /) -> None: ...
    def prepare_connected_animation(self, key: str, item: typing.Optional[winrt.system.Object], element_name: str, /) -> typing.Optional[winrt.windows.ui.xaml.media.animation.ConnectedAnimation]: ...
    @typing.overload
    def scroll_into_view(self, item: typing.Optional[winrt.system.Object], /) -> None: ...
    @typing.overload
    def scroll_into_view(self, item: typing.Optional[winrt.system.Object], alignment: ScrollIntoViewAlignment, /) -> None: ...
    def select_all(self) -> None: ...
    def select_range(self, item_index_range: typing.Optional[winrt.windows.ui.xaml.data.ItemIndexRange], /) -> None: ...
    def set_desired_container_update_duration(self, duration: datetime.timedelta, /) -> None: ...
    def start_view_change_from(self, source: typing.Optional[SemanticZoomLocation], destination: typing.Optional[SemanticZoomLocation], /) -> None: ...
    def start_view_change_to(self, source: typing.Optional[SemanticZoomLocation], destination: typing.Optional[SemanticZoomLocation], /) -> None: ...
    def try_start_connected_animation_async(self, animation: typing.Optional[winrt.windows.ui.xaml.media.animation.ConnectedAnimation], item: typing.Optional[winrt.system.Object], element_name: str, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def add_drag_items_starting(self, handler: typing.Optional[DragItemsStartingEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_drag_items_starting(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_item_click(self, handler: typing.Optional[ItemClickEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_item_click(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_container_content_changing(self, handler: winrt.windows.foundation.TypedEventHandler[ListViewBase, ContainerContentChangingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_container_content_changing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_choosing_group_header_container(self, handler: winrt.windows.foundation.TypedEventHandler[ListViewBase, ChoosingGroupHeaderContainerEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_choosing_group_header_container(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_choosing_item_container(self, handler: winrt.windows.foundation.TypedEventHandler[ListViewBase, ChoosingItemContainerEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_choosing_item_container(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_drag_items_completed(self, handler: winrt.windows.foundation.TypedEventHandler[ListViewBase, DragItemsCompletedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_drag_items_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def selection_mode(self) -> ListViewSelectionMode: ...
    @selection_mode.setter
    def selection_mode(self, value: ListViewSelectionMode) -> None: ...
    @_property
    def is_swipe_enabled(self) -> bool: ...
    @is_swipe_enabled.setter
    def is_swipe_enabled(self, value: bool) -> None: ...
    @_property
    def is_item_click_enabled(self) -> bool: ...
    @is_item_click_enabled.setter
    def is_item_click_enabled(self, value: bool) -> None: ...
    @_property
    def incremental_loading_trigger(self) -> IncrementalLoadingTrigger: ...
    @incremental_loading_trigger.setter
    def incremental_loading_trigger(self, value: IncrementalLoadingTrigger) -> None: ...
    @_property
    def incremental_loading_threshold(self) -> winrt.system.Double: ...
    @incremental_loading_threshold.setter
    def incremental_loading_threshold(self, value: winrt.system.Double) -> None: ...
    @_property
    def header_transitions(self) -> typing.Optional[winrt.windows.ui.xaml.media.animation.TransitionCollection]: ...
    @header_transitions.setter
    def header_transitions(self, value: typing.Optional[winrt.windows.ui.xaml.media.animation.TransitionCollection]) -> None: ...
    @_property
    def header_template(self) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @header_template.setter
    def header_template(self, value: typing.Optional[winrt.windows.ui.xaml.DataTemplate]) -> None: ...
    @_property
    def header(self) -> typing.Optional[winrt.system.Object]: ...
    @header.setter
    def header(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def data_fetch_size(self) -> winrt.system.Double: ...
    @data_fetch_size.setter
    def data_fetch_size(self, value: winrt.system.Double) -> None: ...
    @_property
    def can_reorder_items(self) -> bool: ...
    @can_reorder_items.setter
    def can_reorder_items(self, value: bool) -> None: ...
    @_property
    def can_drag_items(self) -> bool: ...
    @can_drag_items.setter
    def can_drag_items(self, value: bool) -> None: ...
    @_property
    def selected_items(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.system.Object]]: ...
    @_property
    def shows_scrolling_placeholders(self) -> bool: ...
    @shows_scrolling_placeholders.setter
    def shows_scrolling_placeholders(self, value: bool) -> None: ...
    @_property
    def footer_transitions(self) -> typing.Optional[winrt.windows.ui.xaml.media.animation.TransitionCollection]: ...
    @footer_transitions.setter
    def footer_transitions(self, value: typing.Optional[winrt.windows.ui.xaml.media.animation.TransitionCollection]) -> None: ...
    @_property
    def footer_template(self) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @footer_template.setter
    def footer_template(self, value: typing.Optional[winrt.windows.ui.xaml.DataTemplate]) -> None: ...
    @_property
    def footer(self) -> typing.Optional[winrt.system.Object]: ...
    @footer.setter
    def footer(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def reorder_mode(self) -> ListViewReorderMode: ...
    @reorder_mode.setter
    def reorder_mode(self, value: ListViewReorderMode) -> None: ...
    @_property
    def is_multi_select_check_box_enabled(self) -> bool: ...
    @is_multi_select_check_box_enabled.setter
    def is_multi_select_check_box_enabled(self, value: bool) -> None: ...
    @_property
    def selected_ranges(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.ui.xaml.data.ItemIndexRange]]: ...
    @_property
    def single_selection_follows_focus(self) -> bool: ...
    @single_selection_follows_focus.setter
    def single_selection_follows_focus(self, value: bool) -> None: ...
    @_property
    def semantic_zoom_owner(self) -> typing.Optional[SemanticZoom]: ...
    @semantic_zoom_owner.setter
    def semantic_zoom_owner(self, value: typing.Optional[SemanticZoom]) -> None: ...
    @_property
    def is_zoomed_in_view(self) -> bool: ...
    @is_zoomed_in_view.setter
    def is_zoomed_in_view(self, value: bool) -> None: ...
    @_property
    def is_active_view(self) -> bool: ...
    @is_active_view.setter
    def is_active_view(self, value: bool) -> None: ...

@typing.final
class ListViewBaseHeaderItem(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ListViewBaseHeaderItem: ...

@typing.final
class ListViewHeaderItem(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ListViewHeaderItem: ...
    def __new__(cls: typing.Type[ListViewHeaderItem]) -> ListViewHeaderItem:...

@typing.final
class ListViewItem(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ListViewItem: ...
    def __new__(cls: typing.Type[ListViewItem]) -> ListViewItem:...
    @_property
    def template_settings(self) -> typing.Optional[winrt.windows.ui.xaml.controls.primitives.ListViewItemTemplateSettings]: ...

@typing.final
class ListViewPersistenceHelper_Static(type):
    def get_relative_scroll_position(cls, list_view_base: typing.Optional[ListViewBase], item_to_key_handler: typing.Optional[ListViewItemToKeyHandler], /) -> str: ...
    def set_relative_scroll_position_async(cls, list_view_base: typing.Optional[ListViewBase], relative_scroll_position: str, key_to_item_handler: typing.Optional[ListViewKeyToItemHandler], /) -> winrt.windows.foundation.IAsyncAction: ...

@typing.final
class ListViewPersistenceHelper(winrt.system.Object, metaclass=ListViewPersistenceHelper_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ListViewPersistenceHelper: ...

@typing.final
class MediaElement_Static(type):
    @_property
    def download_progress_offset_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def source_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def stereo3_d_video_packing_mode_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def stereo3_d_video_render_mode_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def actual_stereo3_d_video_packing_mode_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def aspect_ratio_height_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def aspect_ratio_width_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def audio_category_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def audio_device_type_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def audio_stream_count_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def audio_stream_index_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def auto_play_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def balance_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def buffering_progress_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def can_pause_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def can_seek_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def current_state_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def default_playback_rate_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def volume_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def download_progress_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_audio_only_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_looping_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_muted_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_stereo3_d_video_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def natural_duration_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def natural_video_height_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def natural_video_width_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def play_to_source_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def playback_rate_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def position_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def poster_source_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def protection_manager_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def real_time_playback_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_full_window_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def play_to_preferred_source_uri_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def stretch_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def are_transport_controls_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class MediaElement(winrt.system.Object, metaclass=MediaElement_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaElement: ...
    def __new__(cls: typing.Type[MediaElement]) -> MediaElement:...
    def add_audio_effect(self, effect_i_d: str, effect_optional: bool, effect_configuration: typing.Optional[winrt.windows.foundation.collections.IPropertySet], /) -> None: ...
    def add_video_effect(self, effect_i_d: str, effect_optional: bool, effect_configuration: typing.Optional[winrt.windows.foundation.collections.IPropertySet], /) -> None: ...
    def can_play_type(self, type: str, /) -> winrt.windows.ui.xaml.media.MediaCanPlayResponse: ...
    def get_as_casting_source(self) -> typing.Optional[winrt.windows.media.casting.CastingSource]: ...
    def get_audio_stream_language(self, index: typing.Optional[winrt.system.Int32], /) -> str: ...
    def pause(self) -> None: ...
    def play(self) -> None: ...
    def remove_all_effects(self) -> None: ...
    def set_media_stream_source(self, source: typing.Optional[winrt.windows.media.core.IMediaSource], /) -> None: ...
    def set_playback_source(self, source: typing.Optional[winrt.windows.media.playback.IMediaPlaybackSource], /) -> None: ...
    def set_source(self, stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStream], mime_type: str, /) -> None: ...
    def stop(self) -> None: ...
    def add_buffering_progress_changed(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_buffering_progress_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_current_state_changed(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_current_state_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_download_progress_changed(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_download_progress_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_marker_reached(self, handler: typing.Optional[winrt.windows.ui.xaml.media.TimelineMarkerRoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_marker_reached(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_media_ended(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_media_ended(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_media_failed(self, handler: typing.Optional[winrt.windows.ui.xaml.ExceptionRoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_media_failed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_media_opened(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_media_opened(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_rate_changed(self, handler: typing.Optional[winrt.windows.ui.xaml.media.RateChangedRoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_rate_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_seek_completed(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_seek_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_volume_changed(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_volume_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_partial_media_failure_detected(self, handler: winrt.windows.foundation.TypedEventHandler[MediaElement, winrt.windows.ui.xaml.media.PartialMediaFailureDetectedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_partial_media_failure_detected(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def volume(self) -> winrt.system.Double: ...
    @volume.setter
    def volume(self, value: winrt.system.Double) -> None: ...
    @_property
    def stereo3_d_video_render_mode(self) -> winrt.windows.ui.xaml.media.Stereo3DVideoRenderMode: ...
    @stereo3_d_video_render_mode.setter
    def stereo3_d_video_render_mode(self, value: winrt.windows.ui.xaml.media.Stereo3DVideoRenderMode) -> None: ...
    @_property
    def stereo3_d_video_packing_mode(self) -> winrt.windows.ui.xaml.media.Stereo3DVideoPackingMode: ...
    @stereo3_d_video_packing_mode.setter
    def stereo3_d_video_packing_mode(self, value: winrt.windows.ui.xaml.media.Stereo3DVideoPackingMode) -> None: ...
    @_property
    def source(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @source.setter
    def source(self, value: typing.Optional[winrt.windows.foundation.Uri]) -> None: ...
    @_property
    def real_time_playback(self) -> bool: ...
    @real_time_playback.setter
    def real_time_playback(self, value: bool) -> None: ...
    @_property
    def protection_manager(self) -> typing.Optional[winrt.windows.media.protection.MediaProtectionManager]: ...
    @protection_manager.setter
    def protection_manager(self, value: typing.Optional[winrt.windows.media.protection.MediaProtectionManager]) -> None: ...
    @_property
    def poster_source(self) -> typing.Optional[winrt.windows.ui.xaml.media.ImageSource]: ...
    @poster_source.setter
    def poster_source(self, value: typing.Optional[winrt.windows.ui.xaml.media.ImageSource]) -> None: ...
    @_property
    def position(self) -> datetime.timedelta: ...
    @position.setter
    def position(self, value: datetime.timedelta) -> None: ...
    @_property
    def playback_rate(self) -> winrt.system.Double: ...
    @playback_rate.setter
    def playback_rate(self, value: winrt.system.Double) -> None: ...
    @_property
    def auto_play(self) -> bool: ...
    @auto_play.setter
    def auto_play(self, value: bool) -> None: ...
    @_property
    def audio_stream_index(self) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...
    @audio_stream_index.setter
    def audio_stream_index(self, value: typing.Optional[typing.Optional[winrt.system.Int32]]) -> None: ...
    @_property
    def is_muted(self) -> bool: ...
    @is_muted.setter
    def is_muted(self, value: bool) -> None: ...
    @_property
    def audio_device_type(self) -> winrt.windows.ui.xaml.media.AudioDeviceType: ...
    @audio_device_type.setter
    def audio_device_type(self, value: winrt.windows.ui.xaml.media.AudioDeviceType) -> None: ...
    @_property
    def audio_category(self) -> winrt.windows.ui.xaml.media.AudioCategory: ...
    @audio_category.setter
    def audio_category(self, value: winrt.windows.ui.xaml.media.AudioCategory) -> None: ...
    @_property
    def default_playback_rate(self) -> winrt.system.Double: ...
    @default_playback_rate.setter
    def default_playback_rate(self, value: winrt.system.Double) -> None: ...
    @_property
    def is_looping(self) -> bool: ...
    @is_looping.setter
    def is_looping(self, value: bool) -> None: ...
    @_property
    def balance(self) -> winrt.system.Double: ...
    @balance.setter
    def balance(self, value: winrt.system.Double) -> None: ...
    @_property
    def download_progress_offset(self) -> winrt.system.Double: ...
    @_property
    def is_audio_only(self) -> bool: ...
    @_property
    def is_stereo3_d_video(self) -> bool: ...
    @_property
    def markers(self) -> typing.Optional[winrt.windows.ui.xaml.media.TimelineMarkerCollection]: ...
    @_property
    def natural_duration(self) -> winrt.windows.ui.xaml.Duration: ...
    @_property
    def natural_video_height(self) -> winrt.system.Int32: ...
    @_property
    def natural_video_width(self) -> winrt.system.Int32: ...
    @_property
    def play_to_source(self) -> typing.Optional[winrt.windows.media.playto.PlayToSource]: ...
    @_property
    def actual_stereo3_d_video_packing_mode(self) -> winrt.windows.ui.xaml.media.Stereo3DVideoPackingMode: ...
    @_property
    def aspect_ratio_height(self) -> winrt.system.Int32: ...
    @_property
    def aspect_ratio_width(self) -> winrt.system.Int32: ...
    @_property
    def audio_stream_count(self) -> winrt.system.Int32: ...
    @_property
    def buffering_progress(self) -> winrt.system.Double: ...
    @_property
    def can_pause(self) -> bool: ...
    @_property
    def can_seek(self) -> bool: ...
    @_property
    def current_state(self) -> winrt.windows.ui.xaml.media.MediaElementState: ...
    @_property
    def download_progress(self) -> winrt.system.Double: ...
    @_property
    def stretch(self) -> winrt.windows.ui.xaml.media.Stretch: ...
    @stretch.setter
    def stretch(self, value: winrt.windows.ui.xaml.media.Stretch) -> None: ...
    @_property
    def play_to_preferred_source_uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @play_to_preferred_source_uri.setter
    def play_to_preferred_source_uri(self, value: typing.Optional[winrt.windows.foundation.Uri]) -> None: ...
    @_property
    def is_full_window(self) -> bool: ...
    @is_full_window.setter
    def is_full_window(self, value: bool) -> None: ...
    @_property
    def are_transport_controls_enabled(self) -> bool: ...
    @are_transport_controls_enabled.setter
    def are_transport_controls_enabled(self, value: bool) -> None: ...
    @_property
    def transport_controls(self) -> typing.Optional[MediaTransportControls]: ...
    @transport_controls.setter
    def transport_controls(self, value: typing.Optional[MediaTransportControls]) -> None: ...

@typing.final
class MediaPlayerElement_Static(type):
    @_property
    def are_transport_controls_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def auto_play_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_full_window_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def media_player_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def poster_source_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def source_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def stretch_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class MediaPlayerElement(winrt.system.Object, metaclass=MediaPlayerElement_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaPlayerElement: ...
    def __new__(cls: typing.Type[MediaPlayerElement]) -> MediaPlayerElement:...
    def set_media_player(self, media_player: typing.Optional[winrt.windows.media.playback.MediaPlayer], /) -> None: ...
    @_property
    def transport_controls(self) -> typing.Optional[MediaTransportControls]: ...
    @transport_controls.setter
    def transport_controls(self, value: typing.Optional[MediaTransportControls]) -> None: ...
    @_property
    def stretch(self) -> winrt.windows.ui.xaml.media.Stretch: ...
    @stretch.setter
    def stretch(self, value: winrt.windows.ui.xaml.media.Stretch) -> None: ...
    @_property
    def source(self) -> typing.Optional[winrt.windows.media.playback.IMediaPlaybackSource]: ...
    @source.setter
    def source(self, value: typing.Optional[winrt.windows.media.playback.IMediaPlaybackSource]) -> None: ...
    @_property
    def poster_source(self) -> typing.Optional[winrt.windows.ui.xaml.media.ImageSource]: ...
    @poster_source.setter
    def poster_source(self, value: typing.Optional[winrt.windows.ui.xaml.media.ImageSource]) -> None: ...
    @_property
    def is_full_window(self) -> bool: ...
    @is_full_window.setter
    def is_full_window(self, value: bool) -> None: ...
    @_property
    def auto_play(self) -> bool: ...
    @auto_play.setter
    def auto_play(self, value: bool) -> None: ...
    @_property
    def are_transport_controls_enabled(self) -> bool: ...
    @are_transport_controls_enabled.setter
    def are_transport_controls_enabled(self, value: bool) -> None: ...
    @_property
    def media_player(self) -> typing.Optional[winrt.windows.media.playback.MediaPlayer]: ...

@typing.final
class MediaPlayerPresenter_Static(type):
    @_property
    def is_full_window_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def media_player_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def stretch_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class MediaPlayerPresenter(winrt.system.Object, metaclass=MediaPlayerPresenter_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaPlayerPresenter: ...
    def __new__(cls: typing.Type[MediaPlayerPresenter]) -> MediaPlayerPresenter:...
    @_property
    def stretch(self) -> winrt.windows.ui.xaml.media.Stretch: ...
    @stretch.setter
    def stretch(self, value: winrt.windows.ui.xaml.media.Stretch) -> None: ...
    @_property
    def media_player(self) -> typing.Optional[winrt.windows.media.playback.MediaPlayer]: ...
    @media_player.setter
    def media_player(self, value: typing.Optional[winrt.windows.media.playback.MediaPlayer]) -> None: ...
    @_property
    def is_full_window(self) -> bool: ...
    @is_full_window.setter
    def is_full_window(self, value: bool) -> None: ...

@typing.final
class MediaTransportControls_Static(type):
    @_property
    def is_compact_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_fast_forward_button_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_fast_forward_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_fast_rewind_button_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_fast_rewind_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_full_window_button_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_full_window_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_playback_rate_button_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_playback_rate_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_seek_bar_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_seek_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_stop_button_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_stop_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_volume_button_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_volume_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_zoom_button_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_zoom_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def fast_play_fallback_behaviour_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_next_track_button_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_previous_track_button_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_skip_backward_button_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_skip_backward_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_skip_forward_button_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_skip_forward_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_repeat_button_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_repeat_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def show_and_hide_automatically_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_compact_overlay_button_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_compact_overlay_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class MediaTransportControls(winrt.system.Object, metaclass=MediaTransportControls_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaTransportControls: ...
    def __new__(cls: typing.Type[MediaTransportControls]) -> MediaTransportControls:...
    def hide(self) -> None: ...
    def show(self) -> None: ...
    def add_thumbnail_requested(self, handler: winrt.windows.foundation.TypedEventHandler[MediaTransportControls, winrt.windows.ui.xaml.media.MediaTransportControlsThumbnailRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_thumbnail_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def is_zoom_enabled(self) -> bool: ...
    @is_zoom_enabled.setter
    def is_zoom_enabled(self, value: bool) -> None: ...
    @_property
    def is_zoom_button_visible(self) -> bool: ...
    @is_zoom_button_visible.setter
    def is_zoom_button_visible(self, value: bool) -> None: ...
    @_property
    def is_volume_enabled(self) -> bool: ...
    @is_volume_enabled.setter
    def is_volume_enabled(self, value: bool) -> None: ...
    @_property
    def is_volume_button_visible(self) -> bool: ...
    @is_volume_button_visible.setter
    def is_volume_button_visible(self, value: bool) -> None: ...
    @_property
    def is_stop_enabled(self) -> bool: ...
    @is_stop_enabled.setter
    def is_stop_enabled(self, value: bool) -> None: ...
    @_property
    def is_stop_button_visible(self) -> bool: ...
    @is_stop_button_visible.setter
    def is_stop_button_visible(self, value: bool) -> None: ...
    @_property
    def is_seek_enabled(self) -> bool: ...
    @is_seek_enabled.setter
    def is_seek_enabled(self, value: bool) -> None: ...
    @_property
    def is_seek_bar_visible(self) -> bool: ...
    @is_seek_bar_visible.setter
    def is_seek_bar_visible(self, value: bool) -> None: ...
    @_property
    def is_playback_rate_enabled(self) -> bool: ...
    @is_playback_rate_enabled.setter
    def is_playback_rate_enabled(self, value: bool) -> None: ...
    @_property
    def is_playback_rate_button_visible(self) -> bool: ...
    @is_playback_rate_button_visible.setter
    def is_playback_rate_button_visible(self, value: bool) -> None: ...
    @_property
    def is_full_window_enabled(self) -> bool: ...
    @is_full_window_enabled.setter
    def is_full_window_enabled(self, value: bool) -> None: ...
    @_property
    def is_full_window_button_visible(self) -> bool: ...
    @is_full_window_button_visible.setter
    def is_full_window_button_visible(self, value: bool) -> None: ...
    @_property
    def is_fast_rewind_enabled(self) -> bool: ...
    @is_fast_rewind_enabled.setter
    def is_fast_rewind_enabled(self, value: bool) -> None: ...
    @_property
    def is_fast_rewind_button_visible(self) -> bool: ...
    @is_fast_rewind_button_visible.setter
    def is_fast_rewind_button_visible(self, value: bool) -> None: ...
    @_property
    def is_fast_forward_enabled(self) -> bool: ...
    @is_fast_forward_enabled.setter
    def is_fast_forward_enabled(self, value: bool) -> None: ...
    @_property
    def is_fast_forward_button_visible(self) -> bool: ...
    @is_fast_forward_button_visible.setter
    def is_fast_forward_button_visible(self, value: bool) -> None: ...
    @_property
    def is_compact(self) -> bool: ...
    @is_compact.setter
    def is_compact(self, value: bool) -> None: ...
    @_property
    def is_skip_forward_enabled(self) -> bool: ...
    @is_skip_forward_enabled.setter
    def is_skip_forward_enabled(self, value: bool) -> None: ...
    @_property
    def is_skip_forward_button_visible(self) -> bool: ...
    @is_skip_forward_button_visible.setter
    def is_skip_forward_button_visible(self, value: bool) -> None: ...
    @_property
    def is_skip_backward_enabled(self) -> bool: ...
    @is_skip_backward_enabled.setter
    def is_skip_backward_enabled(self, value: bool) -> None: ...
    @_property
    def is_skip_backward_button_visible(self) -> bool: ...
    @is_skip_backward_button_visible.setter
    def is_skip_backward_button_visible(self, value: bool) -> None: ...
    @_property
    def is_previous_track_button_visible(self) -> bool: ...
    @is_previous_track_button_visible.setter
    def is_previous_track_button_visible(self, value: bool) -> None: ...
    @_property
    def is_next_track_button_visible(self) -> bool: ...
    @is_next_track_button_visible.setter
    def is_next_track_button_visible(self, value: bool) -> None: ...
    @_property
    def fast_play_fallback_behaviour(self) -> winrt.windows.ui.xaml.media.FastPlayFallbackBehaviour: ...
    @fast_play_fallback_behaviour.setter
    def fast_play_fallback_behaviour(self, value: winrt.windows.ui.xaml.media.FastPlayFallbackBehaviour) -> None: ...
    @_property
    def show_and_hide_automatically(self) -> bool: ...
    @show_and_hide_automatically.setter
    def show_and_hide_automatically(self, value: bool) -> None: ...
    @_property
    def is_repeat_enabled(self) -> bool: ...
    @is_repeat_enabled.setter
    def is_repeat_enabled(self, value: bool) -> None: ...
    @_property
    def is_repeat_button_visible(self) -> bool: ...
    @is_repeat_button_visible.setter
    def is_repeat_button_visible(self, value: bool) -> None: ...
    @_property
    def is_compact_overlay_enabled(self) -> bool: ...
    @is_compact_overlay_enabled.setter
    def is_compact_overlay_enabled(self, value: bool) -> None: ...
    @_property
    def is_compact_overlay_button_visible(self) -> bool: ...
    @is_compact_overlay_button_visible.setter
    def is_compact_overlay_button_visible(self, value: bool) -> None: ...

@typing.final
class MediaTransportControlsHelper_Static(type):
    def get_dropout_order(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...
    def set_dropout_order(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: typing.Optional[winrt.system.Int32], /) -> None: ...
    @_property
    def dropout_order_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class MediaTransportControlsHelper(winrt.system.Object, metaclass=MediaTransportControlsHelper_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaTransportControlsHelper: ...

@typing.final
class MenuBar_Static(type):
    @_property
    def items_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class MenuBar(winrt.system.Object, metaclass=MenuBar_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MenuBar: ...
    def __new__(cls: typing.Type[MenuBar]) -> MenuBar:...
    @_property
    def items(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[MenuBarItem]]: ...

@typing.final
class MenuBarItem_Static(type):
    @_property
    def items_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def title_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class MenuBarItem(winrt.system.Object, metaclass=MenuBarItem_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MenuBarItem: ...
    def __new__(cls: typing.Type[MenuBarItem]) -> MenuBarItem:...
    @_property
    def title(self) -> str: ...
    @title.setter
    def title(self, value: str) -> None: ...
    @_property
    def items(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[MenuFlyoutItemBase]]: ...

@typing.final
class MenuBarItemFlyout(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MenuBarItemFlyout: ...
    def __new__(cls: typing.Type[MenuBarItemFlyout]) -> MenuBarItemFlyout:...

@typing.final
class MenuFlyout_Static(type):
    @_property
    def menu_flyout_presenter_style_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class MenuFlyout(winrt.system.Object, metaclass=MenuFlyout_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MenuFlyout: ...
    def __new__(cls: typing.Type[MenuFlyout]) -> MenuFlyout:...
    def show_at(self, target_element: typing.Optional[winrt.windows.ui.xaml.UIElement], point: winrt.windows.foundation.Point, /) -> None: ...
    @_property
    def menu_flyout_presenter_style(self) -> typing.Optional[winrt.windows.ui.xaml.Style]: ...
    @menu_flyout_presenter_style.setter
    def menu_flyout_presenter_style(self, value: typing.Optional[winrt.windows.ui.xaml.Style]) -> None: ...
    @_property
    def items(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[MenuFlyoutItemBase]]: ...

@typing.final
class MenuFlyoutItem_Static(type):
    @_property
    def command_parameter_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def command_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def text_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def icon_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def keyboard_accelerator_text_override_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class MenuFlyoutItem(winrt.system.Object, metaclass=MenuFlyoutItem_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MenuFlyoutItem: ...
    def __new__(cls: typing.Type[MenuFlyoutItem]) -> MenuFlyoutItem:...
    def add_click(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_click(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def text(self) -> str: ...
    @text.setter
    def text(self, value: str) -> None: ...
    @_property
    def command_parameter(self) -> typing.Optional[winrt.system.Object]: ...
    @command_parameter.setter
    def command_parameter(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def command(self) -> typing.Optional[winrt.windows.ui.xaml.input.ICommand]: ...
    @command.setter
    def command(self, value: typing.Optional[winrt.windows.ui.xaml.input.ICommand]) -> None: ...
    @_property
    def icon(self) -> typing.Optional[IconElement]: ...
    @icon.setter
    def icon(self, value: typing.Optional[IconElement]) -> None: ...
    @_property
    def keyboard_accelerator_text_override(self) -> str: ...
    @keyboard_accelerator_text_override.setter
    def keyboard_accelerator_text_override(self, value: str) -> None: ...
    @_property
    def template_settings(self) -> typing.Optional[winrt.windows.ui.xaml.controls.primitives.MenuFlyoutItemTemplateSettings]: ...

@typing.final
class MenuFlyoutItemBase(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MenuFlyoutItemBase: ...

@typing.final
class MenuFlyoutPresenter_Static(type):
    @_property
    def is_default_shadow_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class MenuFlyoutPresenter(winrt.system.Object, metaclass=MenuFlyoutPresenter_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MenuFlyoutPresenter: ...
    def __new__(cls: typing.Type[MenuFlyoutPresenter]) -> MenuFlyoutPresenter:...
    @_property
    def template_settings(self) -> typing.Optional[winrt.windows.ui.xaml.controls.primitives.MenuFlyoutPresenterTemplateSettings]: ...
    @_property
    def is_default_shadow_enabled(self) -> bool: ...
    @is_default_shadow_enabled.setter
    def is_default_shadow_enabled(self, value: bool) -> None: ...

@typing.final
class MenuFlyoutSeparator(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MenuFlyoutSeparator: ...
    def __new__(cls: typing.Type[MenuFlyoutSeparator]) -> MenuFlyoutSeparator:...

@typing.final
class MenuFlyoutSubItem_Static(type):
    @_property
    def text_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def icon_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class MenuFlyoutSubItem(winrt.system.Object, metaclass=MenuFlyoutSubItem_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MenuFlyoutSubItem: ...
    def __new__(cls: typing.Type[MenuFlyoutSubItem]) -> MenuFlyoutSubItem:...
    @_property
    def text(self) -> str: ...
    @text.setter
    def text(self, value: str) -> None: ...
    @_property
    def items(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[MenuFlyoutItemBase]]: ...
    @_property
    def icon(self) -> typing.Optional[IconElement]: ...
    @icon.setter
    def icon(self, value: typing.Optional[IconElement]) -> None: ...

@typing.final
class NavigationView_Static(type):
    @_property
    def expanded_mode_threshold_width_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_settings_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def menu_item_container_style_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def menu_item_container_style_selector_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def menu_item_template_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def menu_item_template_selector_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def menu_items_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def menu_items_source_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def open_pane_length_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def pane_footer_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def pane_toggle_button_style_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selected_item_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def always_show_header_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def auto_suggest_box_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def compact_mode_threshold_width_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def compact_pane_length_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def display_mode_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def settings_item_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def header_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def header_template_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_pane_open_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_pane_toggle_button_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_back_button_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_back_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def pane_title_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_pane_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def overflow_label_mode_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def pane_custom_content_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def pane_display_mode_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def pane_header_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selection_follows_focus_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def shoulder_navigation_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def template_settings_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def content_overlay_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class NavigationView(winrt.system.Object, metaclass=NavigationView_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NavigationView: ...
    def __new__(cls: typing.Type[NavigationView]) -> NavigationView:...
    def container_from_menu_item(self, item: typing.Optional[winrt.system.Object], /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    def menu_item_from_container(self, container: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.system.Object]: ...
    def add_display_mode_changed(self, handler: winrt.windows.foundation.TypedEventHandler[NavigationView, NavigationViewDisplayModeChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_display_mode_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_item_invoked(self, handler: winrt.windows.foundation.TypedEventHandler[NavigationView, NavigationViewItemInvokedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_item_invoked(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_selection_changed(self, handler: winrt.windows.foundation.TypedEventHandler[NavigationView, NavigationViewSelectionChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_selection_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_back_requested(self, handler: winrt.windows.foundation.TypedEventHandler[NavigationView, NavigationViewBackRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_back_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pane_closed(self, handler: winrt.windows.foundation.TypedEventHandler[NavigationView, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pane_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pane_closing(self, handler: winrt.windows.foundation.TypedEventHandler[NavigationView, NavigationViewPaneClosingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pane_closing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pane_opened(self, handler: winrt.windows.foundation.TypedEventHandler[NavigationView, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pane_opened(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pane_opening(self, handler: winrt.windows.foundation.TypedEventHandler[NavigationView, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pane_opening(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def menu_item_template_selector(self) -> typing.Optional[DataTemplateSelector]: ...
    @menu_item_template_selector.setter
    def menu_item_template_selector(self, value: typing.Optional[DataTemplateSelector]) -> None: ...
    @_property
    def menu_item_template(self) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @menu_item_template.setter
    def menu_item_template(self, value: typing.Optional[winrt.windows.ui.xaml.DataTemplate]) -> None: ...
    @_property
    def menu_item_container_style_selector(self) -> typing.Optional[StyleSelector]: ...
    @menu_item_container_style_selector.setter
    def menu_item_container_style_selector(self, value: typing.Optional[StyleSelector]) -> None: ...
    @_property
    def menu_item_container_style(self) -> typing.Optional[winrt.windows.ui.xaml.Style]: ...
    @menu_item_container_style.setter
    def menu_item_container_style(self, value: typing.Optional[winrt.windows.ui.xaml.Style]) -> None: ...
    @_property
    def is_settings_visible(self) -> bool: ...
    @is_settings_visible.setter
    def is_settings_visible(self, value: bool) -> None: ...
    @_property
    def is_pane_toggle_button_visible(self) -> bool: ...
    @is_pane_toggle_button_visible.setter
    def is_pane_toggle_button_visible(self, value: bool) -> None: ...
    @_property
    def is_pane_open(self) -> bool: ...
    @is_pane_open.setter
    def is_pane_open(self, value: bool) -> None: ...
    @_property
    def header_template(self) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @header_template.setter
    def header_template(self, value: typing.Optional[winrt.windows.ui.xaml.DataTemplate]) -> None: ...
    @_property
    def header(self) -> typing.Optional[winrt.system.Object]: ...
    @header.setter
    def header(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def expanded_mode_threshold_width(self) -> winrt.system.Double: ...
    @expanded_mode_threshold_width.setter
    def expanded_mode_threshold_width(self, value: winrt.system.Double) -> None: ...
    @_property
    def menu_items_source(self) -> typing.Optional[winrt.system.Object]: ...
    @menu_items_source.setter
    def menu_items_source(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def compact_pane_length(self) -> winrt.system.Double: ...
    @compact_pane_length.setter
    def compact_pane_length(self, value: winrt.system.Double) -> None: ...
    @_property
    def compact_mode_threshold_width(self) -> winrt.system.Double: ...
    @compact_mode_threshold_width.setter
    def compact_mode_threshold_width(self, value: winrt.system.Double) -> None: ...
    @_property
    def auto_suggest_box(self) -> typing.Optional[AutoSuggestBox]: ...
    @auto_suggest_box.setter
    def auto_suggest_box(self, value: typing.Optional[AutoSuggestBox]) -> None: ...
    @_property
    def open_pane_length(self) -> winrt.system.Double: ...
    @open_pane_length.setter
    def open_pane_length(self, value: winrt.system.Double) -> None: ...
    @_property
    def always_show_header(self) -> bool: ...
    @always_show_header.setter
    def always_show_header(self, value: bool) -> None: ...
    @_property
    def selected_item(self) -> typing.Optional[winrt.system.Object]: ...
    @selected_item.setter
    def selected_item(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def pane_toggle_button_style(self) -> typing.Optional[winrt.windows.ui.xaml.Style]: ...
    @pane_toggle_button_style.setter
    def pane_toggle_button_style(self, value: typing.Optional[winrt.windows.ui.xaml.Style]) -> None: ...
    @_property
    def pane_footer(self) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    @pane_footer.setter
    def pane_footer(self, value: typing.Optional[winrt.windows.ui.xaml.UIElement]) -> None: ...
    @_property
    def display_mode(self) -> NavigationViewDisplayMode: ...
    @_property
    def menu_items(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.system.Object]]: ...
    @_property
    def settings_item(self) -> typing.Optional[winrt.system.Object]: ...
    @_property
    def pane_title(self) -> str: ...
    @pane_title.setter
    def pane_title(self, value: str) -> None: ...
    @_property
    def is_back_enabled(self) -> bool: ...
    @is_back_enabled.setter
    def is_back_enabled(self, value: bool) -> None: ...
    @_property
    def is_back_button_visible(self) -> NavigationViewBackButtonVisible: ...
    @is_back_button_visible.setter
    def is_back_button_visible(self, value: NavigationViewBackButtonVisible) -> None: ...
    @_property
    def shoulder_navigation_enabled(self) -> NavigationViewShoulderNavigationEnabled: ...
    @shoulder_navigation_enabled.setter
    def shoulder_navigation_enabled(self, value: NavigationViewShoulderNavigationEnabled) -> None: ...
    @_property
    def selection_follows_focus(self) -> NavigationViewSelectionFollowsFocus: ...
    @selection_follows_focus.setter
    def selection_follows_focus(self, value: NavigationViewSelectionFollowsFocus) -> None: ...
    @_property
    def pane_header(self) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    @pane_header.setter
    def pane_header(self, value: typing.Optional[winrt.windows.ui.xaml.UIElement]) -> None: ...
    @_property
    def pane_display_mode(self) -> NavigationViewPaneDisplayMode: ...
    @pane_display_mode.setter
    def pane_display_mode(self, value: NavigationViewPaneDisplayMode) -> None: ...
    @_property
    def pane_custom_content(self) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    @pane_custom_content.setter
    def pane_custom_content(self, value: typing.Optional[winrt.windows.ui.xaml.UIElement]) -> None: ...
    @_property
    def overflow_label_mode(self) -> NavigationViewOverflowLabelMode: ...
    @overflow_label_mode.setter
    def overflow_label_mode(self, value: NavigationViewOverflowLabelMode) -> None: ...
    @_property
    def is_pane_visible(self) -> bool: ...
    @is_pane_visible.setter
    def is_pane_visible(self, value: bool) -> None: ...
    @_property
    def content_overlay(self) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    @content_overlay.setter
    def content_overlay(self, value: typing.Optional[winrt.windows.ui.xaml.UIElement]) -> None: ...
    @_property
    def template_settings(self) -> typing.Optional[NavigationViewTemplateSettings]: ...

@typing.final
class NavigationViewBackRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NavigationViewBackRequestedEventArgs: ...

@typing.final
class NavigationViewDisplayModeChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NavigationViewDisplayModeChangedEventArgs: ...
    @_property
    def display_mode(self) -> NavigationViewDisplayMode: ...

@typing.final
class NavigationViewItem_Static(type):
    @_property
    def compact_pane_length_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def icon_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selects_on_invoked_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class NavigationViewItem(winrt.system.Object, metaclass=NavigationViewItem_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NavigationViewItem: ...
    def __new__(cls: typing.Type[NavigationViewItem]) -> NavigationViewItem:...
    @_property
    def icon(self) -> typing.Optional[IconElement]: ...
    @icon.setter
    def icon(self, value: typing.Optional[IconElement]) -> None: ...
    @_property
    def compact_pane_length(self) -> winrt.system.Double: ...
    @_property
    def selects_on_invoked(self) -> bool: ...
    @selects_on_invoked.setter
    def selects_on_invoked(self, value: bool) -> None: ...

@typing.final
class NavigationViewItemBase(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NavigationViewItemBase: ...

@typing.final
class NavigationViewItemHeader(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NavigationViewItemHeader: ...
    def __new__(cls: typing.Type[NavigationViewItemHeader]) -> NavigationViewItemHeader:...

@typing.final
class NavigationViewItemInvokedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NavigationViewItemInvokedEventArgs: ...
    def __new__(cls: typing.Type[NavigationViewItemInvokedEventArgs]) -> NavigationViewItemInvokedEventArgs:...
    @_property
    def invoked_item(self) -> typing.Optional[winrt.system.Object]: ...
    @_property
    def is_settings_invoked(self) -> bool: ...
    @_property
    def invoked_item_container(self) -> typing.Optional[NavigationViewItemBase]: ...
    @_property
    def recommended_navigation_transition_info(self) -> typing.Optional[winrt.windows.ui.xaml.media.animation.NavigationTransitionInfo]: ...

@typing.final
class NavigationViewItemSeparator(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NavigationViewItemSeparator: ...
    def __new__(cls: typing.Type[NavigationViewItemSeparator]) -> NavigationViewItemSeparator:...

@typing.final
class NavigationViewList(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NavigationViewList: ...
    def __new__(cls: typing.Type[NavigationViewList]) -> NavigationViewList:...

@typing.final
class NavigationViewPaneClosingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NavigationViewPaneClosingEventArgs: ...
    @_property
    def cancel(self) -> bool: ...
    @cancel.setter
    def cancel(self, value: bool) -> None: ...

@typing.final
class NavigationViewSelectionChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NavigationViewSelectionChangedEventArgs: ...
    @_property
    def is_settings_selected(self) -> bool: ...
    @_property
    def selected_item(self) -> typing.Optional[winrt.system.Object]: ...
    @_property
    def recommended_navigation_transition_info(self) -> typing.Optional[winrt.windows.ui.xaml.media.animation.NavigationTransitionInfo]: ...
    @_property
    def selected_item_container(self) -> typing.Optional[NavigationViewItemBase]: ...

@typing.final
class NavigationViewTemplateSettings_Static(type):
    @_property
    def back_button_visibility_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def left_pane_visibility_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def overflow_button_visibility_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def pane_toggle_button_visibility_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def single_selection_follows_focus_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def top_padding_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def top_pane_visibility_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class NavigationViewTemplateSettings(winrt.system.Object, metaclass=NavigationViewTemplateSettings_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NavigationViewTemplateSettings: ...
    def __new__(cls: typing.Type[NavigationViewTemplateSettings]) -> NavigationViewTemplateSettings:...
    @_property
    def back_button_visibility(self) -> winrt.windows.ui.xaml.Visibility: ...
    @_property
    def left_pane_visibility(self) -> winrt.windows.ui.xaml.Visibility: ...
    @_property
    def overflow_button_visibility(self) -> winrt.windows.ui.xaml.Visibility: ...
    @_property
    def pane_toggle_button_visibility(self) -> winrt.windows.ui.xaml.Visibility: ...
    @_property
    def single_selection_follows_focus(self) -> bool: ...
    @_property
    def top_padding(self) -> winrt.system.Double: ...
    @_property
    def top_pane_visibility(self) -> winrt.windows.ui.xaml.Visibility: ...

@typing.final
class NotifyEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NotifyEventArgs: ...
    @_property
    def value(self) -> str: ...
    @_property
    def calling_uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...

@typing.final
class Page_Static(type):
    @_property
    def bottom_app_bar_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def frame_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def top_app_bar_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class Page(winrt.system.Object, metaclass=Page_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Page: ...
    def __new__(cls: typing.Type[Page]) -> Page:...
    def on_navigated_from(self, e: typing.Optional[winrt.windows.ui.xaml.navigation.NavigationEventArgs], /) -> None: ...
    def on_navigated_to(self, e: typing.Optional[winrt.windows.ui.xaml.navigation.NavigationEventArgs], /) -> None: ...
    def on_navigating_from(self, e: typing.Optional[winrt.windows.ui.xaml.navigation.NavigatingCancelEventArgs], /) -> None: ...
    @_property
    def top_app_bar(self) -> typing.Optional[AppBar]: ...
    @top_app_bar.setter
    def top_app_bar(self, value: typing.Optional[AppBar]) -> None: ...
    @_property
    def navigation_cache_mode(self) -> winrt.windows.ui.xaml.navigation.NavigationCacheMode: ...
    @navigation_cache_mode.setter
    def navigation_cache_mode(self, value: winrt.windows.ui.xaml.navigation.NavigationCacheMode) -> None: ...
    @_property
    def bottom_app_bar(self) -> typing.Optional[AppBar]: ...
    @bottom_app_bar.setter
    def bottom_app_bar(self, value: typing.Optional[AppBar]) -> None: ...
    @_property
    def frame(self) -> typing.Optional[Frame]: ...

@typing.final
class Panel_Static(type):
    @_property
    def background_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def children_transitions_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_items_host_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class Panel(winrt.system.Object, metaclass=Panel_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Panel: ...
    @_property
    def children_transitions(self) -> typing.Optional[winrt.windows.ui.xaml.media.animation.TransitionCollection]: ...
    @children_transitions.setter
    def children_transitions(self, value: typing.Optional[winrt.windows.ui.xaml.media.animation.TransitionCollection]) -> None: ...
    @_property
    def background(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @background.setter
    def background(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def children(self) -> typing.Optional[UIElementCollection]: ...
    @_property
    def is_items_host(self) -> bool: ...
    @_property
    def background_transition(self) -> typing.Optional[winrt.windows.ui.xaml.BrushTransition]: ...
    @background_transition.setter
    def background_transition(self, value: typing.Optional[winrt.windows.ui.xaml.BrushTransition]) -> None: ...

@typing.final
class ParallaxView_Static(type):
    @_property
    def child_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def horizontal_shift_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def horizontal_source_end_offset_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def horizontal_source_offset_kind_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def horizontal_source_start_offset_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_horizontal_shift_clamped_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_vertical_shift_clamped_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def max_horizontal_shift_ratio_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def max_vertical_shift_ratio_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def source_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def vertical_shift_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def vertical_source_end_offset_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def vertical_source_offset_kind_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def vertical_source_start_offset_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class ParallaxView(winrt.system.Object, metaclass=ParallaxView_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ParallaxView: ...
    def __new__(cls: typing.Type[ParallaxView]) -> ParallaxView:...
    def refresh_automatic_horizontal_offsets(self) -> None: ...
    def refresh_automatic_vertical_offsets(self) -> None: ...
    @_property
    def vertical_source_start_offset(self) -> winrt.system.Double: ...
    @vertical_source_start_offset.setter
    def vertical_source_start_offset(self, value: winrt.system.Double) -> None: ...
    @_property
    def vertical_source_offset_kind(self) -> ParallaxSourceOffsetKind: ...
    @vertical_source_offset_kind.setter
    def vertical_source_offset_kind(self, value: ParallaxSourceOffsetKind) -> None: ...
    @_property
    def vertical_source_end_offset(self) -> winrt.system.Double: ...
    @vertical_source_end_offset.setter
    def vertical_source_end_offset(self, value: winrt.system.Double) -> None: ...
    @_property
    def vertical_shift(self) -> winrt.system.Double: ...
    @vertical_shift.setter
    def vertical_shift(self, value: winrt.system.Double) -> None: ...
    @_property
    def source(self) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    @source.setter
    def source(self, value: typing.Optional[winrt.windows.ui.xaml.UIElement]) -> None: ...
    @_property
    def max_vertical_shift_ratio(self) -> winrt.system.Double: ...
    @max_vertical_shift_ratio.setter
    def max_vertical_shift_ratio(self, value: winrt.system.Double) -> None: ...
    @_property
    def max_horizontal_shift_ratio(self) -> winrt.system.Double: ...
    @max_horizontal_shift_ratio.setter
    def max_horizontal_shift_ratio(self, value: winrt.system.Double) -> None: ...
    @_property
    def is_vertical_shift_clamped(self) -> bool: ...
    @is_vertical_shift_clamped.setter
    def is_vertical_shift_clamped(self, value: bool) -> None: ...
    @_property
    def is_horizontal_shift_clamped(self) -> bool: ...
    @is_horizontal_shift_clamped.setter
    def is_horizontal_shift_clamped(self, value: bool) -> None: ...
    @_property
    def horizontal_source_start_offset(self) -> winrt.system.Double: ...
    @horizontal_source_start_offset.setter
    def horizontal_source_start_offset(self, value: winrt.system.Double) -> None: ...
    @_property
    def horizontal_source_offset_kind(self) -> ParallaxSourceOffsetKind: ...
    @horizontal_source_offset_kind.setter
    def horizontal_source_offset_kind(self, value: ParallaxSourceOffsetKind) -> None: ...
    @_property
    def horizontal_source_end_offset(self) -> winrt.system.Double: ...
    @horizontal_source_end_offset.setter
    def horizontal_source_end_offset(self, value: winrt.system.Double) -> None: ...
    @_property
    def horizontal_shift(self) -> winrt.system.Double: ...
    @horizontal_shift.setter
    def horizontal_shift(self, value: winrt.system.Double) -> None: ...
    @_property
    def child(self) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    @child.setter
    def child(self, value: typing.Optional[winrt.windows.ui.xaml.UIElement]) -> None: ...

@typing.final
class PasswordBox_Static(type):
    @_property
    def is_password_reveal_button_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def max_length_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def password_char_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def password_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def header_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def header_template_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def placeholder_text_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def prevent_keyboard_display_on_programmatic_focus_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selection_highlight_color_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def input_scope_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def password_reveal_mode_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def text_reading_order_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def can_paste_clipboard_content_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def description_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selection_flyout_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class PasswordBox(winrt.system.Object, metaclass=PasswordBox_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PasswordBox: ...
    def __new__(cls: typing.Type[PasswordBox]) -> PasswordBox:...
    def paste_from_clipboard(self) -> None: ...
    def select_all(self) -> None: ...
    def add_context_menu_opening(self, handler: typing.Optional[ContextMenuOpeningEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_context_menu_opening(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_password_changed(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_password_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_paste(self, handler: typing.Optional[TextControlPasteEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_paste(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_password_changing(self, handler: winrt.windows.foundation.TypedEventHandler[PasswordBox, PasswordBoxPasswordChangingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_password_changing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def password_char(self) -> str: ...
    @password_char.setter
    def password_char(self, value: str) -> None: ...
    @_property
    def password(self) -> str: ...
    @password.setter
    def password(self, value: str) -> None: ...
    @_property
    def max_length(self) -> winrt.system.Int32: ...
    @max_length.setter
    def max_length(self, value: winrt.system.Int32) -> None: ...
    @_property
    def is_password_reveal_button_enabled(self) -> bool: ...
    @is_password_reveal_button_enabled.setter
    def is_password_reveal_button_enabled(self, value: bool) -> None: ...
    @_property
    def selection_highlight_color(self) -> typing.Optional[winrt.windows.ui.xaml.media.SolidColorBrush]: ...
    @selection_highlight_color.setter
    def selection_highlight_color(self, value: typing.Optional[winrt.windows.ui.xaml.media.SolidColorBrush]) -> None: ...
    @_property
    def prevent_keyboard_display_on_programmatic_focus(self) -> bool: ...
    @prevent_keyboard_display_on_programmatic_focus.setter
    def prevent_keyboard_display_on_programmatic_focus(self, value: bool) -> None: ...
    @_property
    def placeholder_text(self) -> str: ...
    @placeholder_text.setter
    def placeholder_text(self, value: str) -> None: ...
    @_property
    def header_template(self) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @header_template.setter
    def header_template(self, value: typing.Optional[winrt.windows.ui.xaml.DataTemplate]) -> None: ...
    @_property
    def header(self) -> typing.Optional[winrt.system.Object]: ...
    @header.setter
    def header(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def text_reading_order(self) -> winrt.windows.ui.xaml.TextReadingOrder: ...
    @text_reading_order.setter
    def text_reading_order(self, value: winrt.windows.ui.xaml.TextReadingOrder) -> None: ...
    @_property
    def password_reveal_mode(self) -> PasswordRevealMode: ...
    @password_reveal_mode.setter
    def password_reveal_mode(self, value: PasswordRevealMode) -> None: ...
    @_property
    def input_scope(self) -> typing.Optional[winrt.windows.ui.xaml.input.InputScope]: ...
    @input_scope.setter
    def input_scope(self, value: typing.Optional[winrt.windows.ui.xaml.input.InputScope]) -> None: ...
    @_property
    def selection_flyout(self) -> typing.Optional[winrt.windows.ui.xaml.controls.primitives.FlyoutBase]: ...
    @selection_flyout.setter
    def selection_flyout(self, value: typing.Optional[winrt.windows.ui.xaml.controls.primitives.FlyoutBase]) -> None: ...
    @_property
    def description(self) -> typing.Optional[winrt.system.Object]: ...
    @description.setter
    def description(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def can_paste_clipboard_content(self) -> bool: ...

@typing.final
class PasswordBoxPasswordChangingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PasswordBoxPasswordChangingEventArgs: ...
    @_property
    def is_content_changing(self) -> bool: ...

@typing.final
class PathIcon_Static(type):
    @_property
    def data_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class PathIcon(winrt.system.Object, metaclass=PathIcon_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PathIcon: ...
    def __new__(cls: typing.Type[PathIcon]) -> PathIcon:...
    @_property
    def data(self) -> typing.Optional[winrt.windows.ui.xaml.media.Geometry]: ...
    @data.setter
    def data(self, value: typing.Optional[winrt.windows.ui.xaml.media.Geometry]) -> None: ...

@typing.final
class PathIconSource_Static(type):
    @_property
    def data_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class PathIconSource(winrt.system.Object, metaclass=PathIconSource_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PathIconSource: ...
    def __new__(cls: typing.Type[PathIconSource]) -> PathIconSource:...
    @_property
    def data(self) -> typing.Optional[winrt.windows.ui.xaml.media.Geometry]: ...
    @data.setter
    def data(self, value: typing.Optional[winrt.windows.ui.xaml.media.Geometry]) -> None: ...

@typing.final
class PersonPicture_Static(type):
    @_property
    def badge_glyph_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def badge_image_source_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def badge_number_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def badge_text_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def contact_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def display_name_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def initials_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_group_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def prefer_small_image_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def profile_picture_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class PersonPicture(winrt.system.Object, metaclass=PersonPicture_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PersonPicture: ...
    def __new__(cls: typing.Type[PersonPicture]) -> PersonPicture:...
    @_property
    def profile_picture(self) -> typing.Optional[winrt.windows.ui.xaml.media.ImageSource]: ...
    @profile_picture.setter
    def profile_picture(self, value: typing.Optional[winrt.windows.ui.xaml.media.ImageSource]) -> None: ...
    @_property
    def prefer_small_image(self) -> bool: ...
    @prefer_small_image.setter
    def prefer_small_image(self, value: bool) -> None: ...
    @_property
    def is_group(self) -> bool: ...
    @is_group.setter
    def is_group(self, value: bool) -> None: ...
    @_property
    def initials(self) -> str: ...
    @initials.setter
    def initials(self, value: str) -> None: ...
    @_property
    def display_name(self) -> str: ...
    @display_name.setter
    def display_name(self, value: str) -> None: ...
    @_property
    def contact(self) -> typing.Optional[winrt.windows.applicationmodel.contacts.Contact]: ...
    @contact.setter
    def contact(self, value: typing.Optional[winrt.windows.applicationmodel.contacts.Contact]) -> None: ...
    @_property
    def badge_text(self) -> str: ...
    @badge_text.setter
    def badge_text(self, value: str) -> None: ...
    @_property
    def badge_number(self) -> winrt.system.Int32: ...
    @badge_number.setter
    def badge_number(self, value: winrt.system.Int32) -> None: ...
    @_property
    def badge_image_source(self) -> typing.Optional[winrt.windows.ui.xaml.media.ImageSource]: ...
    @badge_image_source.setter
    def badge_image_source(self, value: typing.Optional[winrt.windows.ui.xaml.media.ImageSource]) -> None: ...
    @_property
    def badge_glyph(self) -> str: ...
    @badge_glyph.setter
    def badge_glyph(self, value: str) -> None: ...

@typing.final
class PickerConfirmedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PickerConfirmedEventArgs: ...
    def __new__(cls: typing.Type[PickerConfirmedEventArgs]) -> PickerConfirmedEventArgs:...

@typing.final
class PickerFlyout_Static(type):
    @_property
    def confirmation_buttons_visible_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def content_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class PickerFlyout(winrt.system.Object, metaclass=PickerFlyout_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PickerFlyout: ...
    def __new__(cls: typing.Type[PickerFlyout]) -> PickerFlyout:...
    def show_at_async(self, target: typing.Optional[winrt.windows.ui.xaml.FrameworkElement], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def add_confirmed(self, handler: winrt.windows.foundation.TypedEventHandler[PickerFlyout, PickerConfirmedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_confirmed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def content(self) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    @content.setter
    def content(self, value: typing.Optional[winrt.windows.ui.xaml.UIElement]) -> None: ...
    @_property
    def confirmation_buttons_visible(self) -> bool: ...
    @confirmation_buttons_visible.setter
    def confirmation_buttons_visible(self, value: bool) -> None: ...

@typing.final
class PickerFlyoutPresenter(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PickerFlyoutPresenter: ...

@typing.final
class Pivot_Static(type):
    def get_slide_in_animation_group(cls, element: typing.Optional[winrt.windows.ui.xaml.FrameworkElement], /) -> PivotSlideInAnimationGroup: ...
    def set_slide_in_animation_group(cls, element: typing.Optional[winrt.windows.ui.xaml.FrameworkElement], value: PivotSlideInAnimationGroup, /) -> None: ...
    @_property
    def header_template_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_locked_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selected_index_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selected_item_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def slide_in_animation_group_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def title_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def title_template_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def left_header_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def left_header_template_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def right_header_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def right_header_template_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def header_focus_visual_placement_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_header_items_carousel_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class Pivot(winrt.system.Object, metaclass=Pivot_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Pivot: ...
    def __new__(cls: typing.Type[Pivot]) -> Pivot:...
    def add_pivot_item_loaded(self, handler: winrt.windows.foundation.TypedEventHandler[Pivot, PivotItemEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pivot_item_loaded(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pivot_item_loading(self, handler: winrt.windows.foundation.TypedEventHandler[Pivot, PivotItemEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pivot_item_loading(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pivot_item_unloaded(self, handler: winrt.windows.foundation.TypedEventHandler[Pivot, PivotItemEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pivot_item_unloaded(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pivot_item_unloading(self, handler: winrt.windows.foundation.TypedEventHandler[Pivot, PivotItemEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pivot_item_unloading(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_selection_changed(self, handler: typing.Optional[SelectionChangedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_selection_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def title_template(self) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @title_template.setter
    def title_template(self, value: typing.Optional[winrt.windows.ui.xaml.DataTemplate]) -> None: ...
    @_property
    def title(self) -> typing.Optional[winrt.system.Object]: ...
    @title.setter
    def title(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def selected_item(self) -> typing.Optional[winrt.system.Object]: ...
    @selected_item.setter
    def selected_item(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def selected_index(self) -> winrt.system.Int32: ...
    @selected_index.setter
    def selected_index(self, value: winrt.system.Int32) -> None: ...
    @_property
    def is_locked(self) -> bool: ...
    @is_locked.setter
    def is_locked(self, value: bool) -> None: ...
    @_property
    def header_template(self) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @header_template.setter
    def header_template(self, value: typing.Optional[winrt.windows.ui.xaml.DataTemplate]) -> None: ...
    @_property
    def right_header_template(self) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @right_header_template.setter
    def right_header_template(self, value: typing.Optional[winrt.windows.ui.xaml.DataTemplate]) -> None: ...
    @_property
    def right_header(self) -> typing.Optional[winrt.system.Object]: ...
    @right_header.setter
    def right_header(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def left_header_template(self) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @left_header_template.setter
    def left_header_template(self, value: typing.Optional[winrt.windows.ui.xaml.DataTemplate]) -> None: ...
    @_property
    def left_header(self) -> typing.Optional[winrt.system.Object]: ...
    @left_header.setter
    def left_header(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def is_header_items_carousel_enabled(self) -> bool: ...
    @is_header_items_carousel_enabled.setter
    def is_header_items_carousel_enabled(self, value: bool) -> None: ...
    @_property
    def header_focus_visual_placement(self) -> PivotHeaderFocusVisualPlacement: ...
    @header_focus_visual_placement.setter
    def header_focus_visual_placement(self, value: PivotHeaderFocusVisualPlacement) -> None: ...

@typing.final
class PivotItem_Static(type):
    @_property
    def header_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class PivotItem(winrt.system.Object, metaclass=PivotItem_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PivotItem: ...
    def __new__(cls: typing.Type[PivotItem]) -> PivotItem:...
    @_property
    def header(self) -> typing.Optional[winrt.system.Object]: ...
    @header.setter
    def header(self, value: typing.Optional[winrt.system.Object]) -> None: ...

@typing.final
class PivotItemEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PivotItemEventArgs: ...
    def __new__(cls: typing.Type[PivotItemEventArgs]) -> PivotItemEventArgs:...
    @_property
    def item(self) -> typing.Optional[PivotItem]: ...
    @item.setter
    def item(self, value: typing.Optional[PivotItem]) -> None: ...

@typing.final
class ProgressBar_Static(type):
    @_property
    def is_indeterminate_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def show_error_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def show_paused_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class ProgressBar(winrt.system.Object, metaclass=ProgressBar_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProgressBar: ...
    def __new__(cls: typing.Type[ProgressBar]) -> ProgressBar:...
    @_property
    def show_paused(self) -> bool: ...
    @show_paused.setter
    def show_paused(self, value: bool) -> None: ...
    @_property
    def show_error(self) -> bool: ...
    @show_error.setter
    def show_error(self, value: bool) -> None: ...
    @_property
    def is_indeterminate(self) -> bool: ...
    @is_indeterminate.setter
    def is_indeterminate(self, value: bool) -> None: ...
    @_property
    def template_settings(self) -> typing.Optional[winrt.windows.ui.xaml.controls.primitives.ProgressBarTemplateSettings]: ...

@typing.final
class ProgressRing_Static(type):
    @_property
    def is_active_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class ProgressRing(winrt.system.Object, metaclass=ProgressRing_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProgressRing: ...
    def __new__(cls: typing.Type[ProgressRing]) -> ProgressRing:...
    @_property
    def is_active(self) -> bool: ...
    @is_active.setter
    def is_active(self, value: bool) -> None: ...
    @_property
    def template_settings(self) -> typing.Optional[winrt.windows.ui.xaml.controls.primitives.ProgressRingTemplateSettings]: ...

@typing.final
class RadioButton_Static(type):
    @_property
    def group_name_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class RadioButton(winrt.system.Object, metaclass=RadioButton_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadioButton: ...
    def __new__(cls: typing.Type[RadioButton]) -> RadioButton:...
    @_property
    def group_name(self) -> str: ...
    @group_name.setter
    def group_name(self, value: str) -> None: ...

@typing.final
class RatingControl_Static(type):
    @_property
    def caption_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def initial_set_value_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_clear_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_read_only_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def item_info_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def max_rating_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def placeholder_value_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def value_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class RatingControl(winrt.system.Object, metaclass=RatingControl_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RatingControl: ...
    def __new__(cls: typing.Type[RatingControl]) -> RatingControl:...
    def add_value_changed(self, handler: winrt.windows.foundation.TypedEventHandler[RatingControl, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_value_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def value(self) -> winrt.system.Double: ...
    @value.setter
    def value(self, value: winrt.system.Double) -> None: ...
    @_property
    def placeholder_value(self) -> winrt.system.Double: ...
    @placeholder_value.setter
    def placeholder_value(self, value: winrt.system.Double) -> None: ...
    @_property
    def max_rating(self) -> winrt.system.Int32: ...
    @max_rating.setter
    def max_rating(self, value: winrt.system.Int32) -> None: ...
    @_property
    def item_info(self) -> typing.Optional[RatingItemInfo]: ...
    @item_info.setter
    def item_info(self, value: typing.Optional[RatingItemInfo]) -> None: ...
    @_property
    def is_read_only(self) -> bool: ...
    @is_read_only.setter
    def is_read_only(self, value: bool) -> None: ...
    @_property
    def is_clear_enabled(self) -> bool: ...
    @is_clear_enabled.setter
    def is_clear_enabled(self, value: bool) -> None: ...
    @_property
    def initial_set_value(self) -> winrt.system.Int32: ...
    @initial_set_value.setter
    def initial_set_value(self, value: winrt.system.Int32) -> None: ...
    @_property
    def caption(self) -> str: ...
    @caption.setter
    def caption(self, value: str) -> None: ...

@typing.final
class RatingItemFontInfo_Static(type):
    @_property
    def disabled_glyph_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def glyph_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def placeholder_glyph_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def pointer_over_glyph_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def pointer_over_placeholder_glyph_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def unset_glyph_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class RatingItemFontInfo(winrt.system.Object, metaclass=RatingItemFontInfo_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RatingItemFontInfo: ...
    def __new__(cls: typing.Type[RatingItemFontInfo]) -> RatingItemFontInfo:...
    @_property
    def unset_glyph(self) -> str: ...
    @unset_glyph.setter
    def unset_glyph(self, value: str) -> None: ...
    @_property
    def pointer_over_placeholder_glyph(self) -> str: ...
    @pointer_over_placeholder_glyph.setter
    def pointer_over_placeholder_glyph(self, value: str) -> None: ...
    @_property
    def pointer_over_glyph(self) -> str: ...
    @pointer_over_glyph.setter
    def pointer_over_glyph(self, value: str) -> None: ...
    @_property
    def placeholder_glyph(self) -> str: ...
    @placeholder_glyph.setter
    def placeholder_glyph(self, value: str) -> None: ...
    @_property
    def glyph(self) -> str: ...
    @glyph.setter
    def glyph(self, value: str) -> None: ...
    @_property
    def disabled_glyph(self) -> str: ...
    @disabled_glyph.setter
    def disabled_glyph(self, value: str) -> None: ...

@typing.final
class RatingItemImageInfo_Static(type):
    @_property
    def disabled_image_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def image_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def placeholder_image_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def pointer_over_image_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def pointer_over_placeholder_image_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def unset_image_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class RatingItemImageInfo(winrt.system.Object, metaclass=RatingItemImageInfo_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RatingItemImageInfo: ...
    def __new__(cls: typing.Type[RatingItemImageInfo]) -> RatingItemImageInfo:...
    @_property
    def unset_image(self) -> typing.Optional[winrt.windows.ui.xaml.media.ImageSource]: ...
    @unset_image.setter
    def unset_image(self, value: typing.Optional[winrt.windows.ui.xaml.media.ImageSource]) -> None: ...
    @_property
    def pointer_over_placeholder_image(self) -> typing.Optional[winrt.windows.ui.xaml.media.ImageSource]: ...
    @pointer_over_placeholder_image.setter
    def pointer_over_placeholder_image(self, value: typing.Optional[winrt.windows.ui.xaml.media.ImageSource]) -> None: ...
    @_property
    def pointer_over_image(self) -> typing.Optional[winrt.windows.ui.xaml.media.ImageSource]: ...
    @pointer_over_image.setter
    def pointer_over_image(self, value: typing.Optional[winrt.windows.ui.xaml.media.ImageSource]) -> None: ...
    @_property
    def placeholder_image(self) -> typing.Optional[winrt.windows.ui.xaml.media.ImageSource]: ...
    @placeholder_image.setter
    def placeholder_image(self, value: typing.Optional[winrt.windows.ui.xaml.media.ImageSource]) -> None: ...
    @_property
    def image(self) -> typing.Optional[winrt.windows.ui.xaml.media.ImageSource]: ...
    @image.setter
    def image(self, value: typing.Optional[winrt.windows.ui.xaml.media.ImageSource]) -> None: ...
    @_property
    def disabled_image(self) -> typing.Optional[winrt.windows.ui.xaml.media.ImageSource]: ...
    @disabled_image.setter
    def disabled_image(self, value: typing.Optional[winrt.windows.ui.xaml.media.ImageSource]) -> None: ...

@typing.final
class RatingItemInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RatingItemInfo: ...
    def __new__(cls: typing.Type[RatingItemInfo]) -> RatingItemInfo:...

@typing.final
class RefreshContainer_Static(type):
    @_property
    def pull_direction_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def visualizer_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class RefreshContainer(winrt.system.Object, metaclass=RefreshContainer_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RefreshContainer: ...
    def __new__(cls: typing.Type[RefreshContainer]) -> RefreshContainer:...
    def request_refresh(self) -> None: ...
    def add_refresh_requested(self, handler: winrt.windows.foundation.TypedEventHandler[RefreshContainer, RefreshRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_refresh_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def visualizer(self) -> typing.Optional[RefreshVisualizer]: ...
    @visualizer.setter
    def visualizer(self, value: typing.Optional[RefreshVisualizer]) -> None: ...
    @_property
    def pull_direction(self) -> RefreshPullDirection: ...
    @pull_direction.setter
    def pull_direction(self, value: RefreshPullDirection) -> None: ...

@typing.final
class RefreshInteractionRatioChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RefreshInteractionRatioChangedEventArgs: ...
    @_property
    def interaction_ratio(self) -> winrt.system.Double: ...

@typing.final
class RefreshRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RefreshRequestedEventArgs: ...
    def get_deferral(self) -> typing.Optional[winrt.windows.foundation.Deferral]: ...

@typing.final
class RefreshStateChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RefreshStateChangedEventArgs: ...
    @_property
    def new_state(self) -> RefreshVisualizerState: ...
    @_property
    def old_state(self) -> RefreshVisualizerState: ...

@typing.final
class RefreshVisualizer_Static(type):
    @_property
    def content_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def info_provider_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def orientation_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def state_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class RefreshVisualizer(winrt.system.Object, metaclass=RefreshVisualizer_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RefreshVisualizer: ...
    def __new__(cls: typing.Type[RefreshVisualizer]) -> RefreshVisualizer:...
    def request_refresh(self) -> None: ...
    def add_refresh_requested(self, handler: winrt.windows.foundation.TypedEventHandler[RefreshVisualizer, RefreshRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_refresh_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_refresh_state_changed(self, handler: winrt.windows.foundation.TypedEventHandler[RefreshVisualizer, RefreshStateChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_refresh_state_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def orientation(self) -> RefreshVisualizerOrientation: ...
    @orientation.setter
    def orientation(self, value: RefreshVisualizerOrientation) -> None: ...
    @_property
    def content(self) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    @content.setter
    def content(self, value: typing.Optional[winrt.windows.ui.xaml.UIElement]) -> None: ...
    @_property
    def state(self) -> RefreshVisualizerState: ...

@typing.final
class RelativePanel_Static(type):
    def get_above(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> typing.Optional[winrt.system.Object]: ...
    def get_align_bottom_with(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> typing.Optional[winrt.system.Object]: ...
    def get_align_bottom_with_panel(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> bool: ...
    def get_align_horizontal_center_with(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> typing.Optional[winrt.system.Object]: ...
    def get_align_horizontal_center_with_panel(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> bool: ...
    def get_align_left_with(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> typing.Optional[winrt.system.Object]: ...
    def get_align_left_with_panel(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> bool: ...
    def get_align_right_with(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> typing.Optional[winrt.system.Object]: ...
    def get_align_right_with_panel(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> bool: ...
    def get_align_top_with(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> typing.Optional[winrt.system.Object]: ...
    def get_align_top_with_panel(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> bool: ...
    def get_align_vertical_center_with(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> typing.Optional[winrt.system.Object]: ...
    def get_align_vertical_center_with_panel(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> bool: ...
    def get_below(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> typing.Optional[winrt.system.Object]: ...
    def get_left_of(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> typing.Optional[winrt.system.Object]: ...
    def get_right_of(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> typing.Optional[winrt.system.Object]: ...
    def set_above(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: typing.Optional[winrt.system.Object], /) -> None: ...
    def set_align_bottom_with(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: typing.Optional[winrt.system.Object], /) -> None: ...
    def set_align_bottom_with_panel(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: bool, /) -> None: ...
    def set_align_horizontal_center_with(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: typing.Optional[winrt.system.Object], /) -> None: ...
    def set_align_horizontal_center_with_panel(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: bool, /) -> None: ...
    def set_align_left_with(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: typing.Optional[winrt.system.Object], /) -> None: ...
    def set_align_left_with_panel(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: bool, /) -> None: ...
    def set_align_right_with(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: typing.Optional[winrt.system.Object], /) -> None: ...
    def set_align_right_with_panel(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: bool, /) -> None: ...
    def set_align_top_with(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: typing.Optional[winrt.system.Object], /) -> None: ...
    def set_align_top_with_panel(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: bool, /) -> None: ...
    def set_align_vertical_center_with(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: typing.Optional[winrt.system.Object], /) -> None: ...
    def set_align_vertical_center_with_panel(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: bool, /) -> None: ...
    def set_below(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: typing.Optional[winrt.system.Object], /) -> None: ...
    def set_left_of(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: typing.Optional[winrt.system.Object], /) -> None: ...
    def set_right_of(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: typing.Optional[winrt.system.Object], /) -> None: ...
    @_property
    def above_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def align_bottom_with_panel_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def align_bottom_with_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def align_horizontal_center_with_panel_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def align_horizontal_center_with_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def align_left_with_panel_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def align_left_with_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def align_right_with_panel_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def align_right_with_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def align_top_with_panel_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def align_top_with_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def align_vertical_center_with_panel_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def align_vertical_center_with_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def below_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def border_brush_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def border_thickness_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def corner_radius_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def left_of_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def padding_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def right_of_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def background_sizing_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class RelativePanel(winrt.system.Object, metaclass=RelativePanel_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RelativePanel: ...
    def __new__(cls: typing.Type[RelativePanel]) -> RelativePanel:...
    @_property
    def padding(self) -> winrt.windows.ui.xaml.Thickness: ...
    @padding.setter
    def padding(self, value: winrt.windows.ui.xaml.Thickness) -> None: ...
    @_property
    def corner_radius(self) -> winrt.windows.ui.xaml.CornerRadius: ...
    @corner_radius.setter
    def corner_radius(self, value: winrt.windows.ui.xaml.CornerRadius) -> None: ...
    @_property
    def border_thickness(self) -> winrt.windows.ui.xaml.Thickness: ...
    @border_thickness.setter
    def border_thickness(self, value: winrt.windows.ui.xaml.Thickness) -> None: ...
    @_property
    def border_brush(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @border_brush.setter
    def border_brush(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def background_sizing(self) -> BackgroundSizing: ...
    @background_sizing.setter
    def background_sizing(self, value: BackgroundSizing) -> None: ...

@typing.final
class RichEditBox_Static(type):
    @_property
    def accepts_return_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def input_scope_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_read_only_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_spell_check_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_text_prediction_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def text_alignment_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def text_wrapping_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def header_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def header_template_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_color_font_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def placeholder_text_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def prevent_keyboard_display_on_programmatic_focus_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selection_highlight_color_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def desired_candidate_window_alignment_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def text_reading_order_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def clipboard_copy_format_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def max_length_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selection_highlight_color_when_not_focused_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def character_casing_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def disabled_formatting_accelerators_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def horizontal_text_alignment_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def content_link_background_color_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def content_link_foreground_color_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def content_link_providers_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def handwriting_view_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_handwriting_view_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def description_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def proofing_menu_flyout_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selection_flyout_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class RichEditBox(winrt.system.Object, metaclass=RichEditBox_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RichEditBox: ...
    def __new__(cls: typing.Type[RichEditBox]) -> RichEditBox:...
    def get_linguistic_alternatives_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[str]]: ...
    def add_context_menu_opening(self, handler: typing.Optional[ContextMenuOpeningEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_context_menu_opening(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_selection_changed(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_selection_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_text_changed(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_text_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_paste(self, handler: typing.Optional[TextControlPasteEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_paste(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_candidate_window_bounds_changed(self, handler: winrt.windows.foundation.TypedEventHandler[RichEditBox, CandidateWindowBoundsChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_candidate_window_bounds_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_text_changing(self, handler: winrt.windows.foundation.TypedEventHandler[RichEditBox, RichEditBoxTextChangingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_text_changing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_text_composition_changed(self, handler: winrt.windows.foundation.TypedEventHandler[RichEditBox, TextCompositionChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_text_composition_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_text_composition_ended(self, handler: winrt.windows.foundation.TypedEventHandler[RichEditBox, TextCompositionEndedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_text_composition_ended(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_text_composition_started(self, handler: winrt.windows.foundation.TypedEventHandler[RichEditBox, TextCompositionStartedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_text_composition_started(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_copying_to_clipboard(self, handler: winrt.windows.foundation.TypedEventHandler[RichEditBox, TextControlCopyingToClipboardEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_copying_to_clipboard(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_cutting_to_clipboard(self, handler: winrt.windows.foundation.TypedEventHandler[RichEditBox, TextControlCuttingToClipboardEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_cutting_to_clipboard(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_content_link_changed(self, handler: winrt.windows.foundation.TypedEventHandler[RichEditBox, ContentLinkChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_content_link_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_content_link_invoked(self, handler: winrt.windows.foundation.TypedEventHandler[RichEditBox, winrt.windows.ui.xaml.documents.ContentLinkInvokedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_content_link_invoked(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_selection_changing(self, handler: winrt.windows.foundation.TypedEventHandler[RichEditBox, RichEditBoxSelectionChangingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_selection_changing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def text_wrapping(self) -> winrt.windows.ui.xaml.TextWrapping: ...
    @text_wrapping.setter
    def text_wrapping(self, value: winrt.windows.ui.xaml.TextWrapping) -> None: ...
    @_property
    def text_alignment(self) -> winrt.windows.ui.xaml.TextAlignment: ...
    @text_alignment.setter
    def text_alignment(self, value: winrt.windows.ui.xaml.TextAlignment) -> None: ...
    @_property
    def is_text_prediction_enabled(self) -> bool: ...
    @is_text_prediction_enabled.setter
    def is_text_prediction_enabled(self, value: bool) -> None: ...
    @_property
    def is_spell_check_enabled(self) -> bool: ...
    @is_spell_check_enabled.setter
    def is_spell_check_enabled(self, value: bool) -> None: ...
    @_property
    def is_read_only(self) -> bool: ...
    @is_read_only.setter
    def is_read_only(self, value: bool) -> None: ...
    @_property
    def input_scope(self) -> typing.Optional[winrt.windows.ui.xaml.input.InputScope]: ...
    @input_scope.setter
    def input_scope(self, value: typing.Optional[winrt.windows.ui.xaml.input.InputScope]) -> None: ...
    @_property
    def accepts_return(self) -> bool: ...
    @accepts_return.setter
    def accepts_return(self, value: bool) -> None: ...
    @_property
    def document(self) -> typing.Optional[winrt.windows.ui.text.ITextDocument]: ...
    @_property
    def selection_highlight_color(self) -> typing.Optional[winrt.windows.ui.xaml.media.SolidColorBrush]: ...
    @selection_highlight_color.setter
    def selection_highlight_color(self, value: typing.Optional[winrt.windows.ui.xaml.media.SolidColorBrush]) -> None: ...
    @_property
    def prevent_keyboard_display_on_programmatic_focus(self) -> bool: ...
    @prevent_keyboard_display_on_programmatic_focus.setter
    def prevent_keyboard_display_on_programmatic_focus(self, value: bool) -> None: ...
    @_property
    def placeholder_text(self) -> str: ...
    @placeholder_text.setter
    def placeholder_text(self, value: str) -> None: ...
    @_property
    def is_color_font_enabled(self) -> bool: ...
    @is_color_font_enabled.setter
    def is_color_font_enabled(self, value: bool) -> None: ...
    @_property
    def header_template(self) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @header_template.setter
    def header_template(self, value: typing.Optional[winrt.windows.ui.xaml.DataTemplate]) -> None: ...
    @_property
    def header(self) -> typing.Optional[winrt.system.Object]: ...
    @header.setter
    def header(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def text_reading_order(self) -> winrt.windows.ui.xaml.TextReadingOrder: ...
    @text_reading_order.setter
    def text_reading_order(self, value: winrt.windows.ui.xaml.TextReadingOrder) -> None: ...
    @_property
    def desired_candidate_window_alignment(self) -> CandidateWindowAlignment: ...
    @desired_candidate_window_alignment.setter
    def desired_candidate_window_alignment(self, value: CandidateWindowAlignment) -> None: ...
    @_property
    def clipboard_copy_format(self) -> RichEditClipboardFormat: ...
    @clipboard_copy_format.setter
    def clipboard_copy_format(self, value: RichEditClipboardFormat) -> None: ...
    @_property
    def selection_highlight_color_when_not_focused(self) -> typing.Optional[winrt.windows.ui.xaml.media.SolidColorBrush]: ...
    @selection_highlight_color_when_not_focused.setter
    def selection_highlight_color_when_not_focused(self, value: typing.Optional[winrt.windows.ui.xaml.media.SolidColorBrush]) -> None: ...
    @_property
    def max_length(self) -> winrt.system.Int32: ...
    @max_length.setter
    def max_length(self, value: winrt.system.Int32) -> None: ...
    @_property
    def horizontal_text_alignment(self) -> winrt.windows.ui.xaml.TextAlignment: ...
    @horizontal_text_alignment.setter
    def horizontal_text_alignment(self, value: winrt.windows.ui.xaml.TextAlignment) -> None: ...
    @_property
    def disabled_formatting_accelerators(self) -> DisabledFormattingAccelerators: ...
    @disabled_formatting_accelerators.setter
    def disabled_formatting_accelerators(self, value: DisabledFormattingAccelerators) -> None: ...
    @_property
    def character_casing(self) -> CharacterCasing: ...
    @character_casing.setter
    def character_casing(self, value: CharacterCasing) -> None: ...
    @_property
    def is_handwriting_view_enabled(self) -> bool: ...
    @is_handwriting_view_enabled.setter
    def is_handwriting_view_enabled(self, value: bool) -> None: ...
    @_property
    def handwriting_view(self) -> typing.Optional[HandwritingView]: ...
    @handwriting_view.setter
    def handwriting_view(self, value: typing.Optional[HandwritingView]) -> None: ...
    @_property
    def content_link_providers(self) -> typing.Optional[winrt.windows.ui.xaml.documents.ContentLinkProviderCollection]: ...
    @content_link_providers.setter
    def content_link_providers(self, value: typing.Optional[winrt.windows.ui.xaml.documents.ContentLinkProviderCollection]) -> None: ...
    @_property
    def content_link_foreground_color(self) -> typing.Optional[winrt.windows.ui.xaml.media.SolidColorBrush]: ...
    @content_link_foreground_color.setter
    def content_link_foreground_color(self, value: typing.Optional[winrt.windows.ui.xaml.media.SolidColorBrush]) -> None: ...
    @_property
    def content_link_background_color(self) -> typing.Optional[winrt.windows.ui.xaml.media.SolidColorBrush]: ...
    @content_link_background_color.setter
    def content_link_background_color(self, value: typing.Optional[winrt.windows.ui.xaml.media.SolidColorBrush]) -> None: ...
    @_property
    def selection_flyout(self) -> typing.Optional[winrt.windows.ui.xaml.controls.primitives.FlyoutBase]: ...
    @selection_flyout.setter
    def selection_flyout(self, value: typing.Optional[winrt.windows.ui.xaml.controls.primitives.FlyoutBase]) -> None: ...
    @_property
    def description(self) -> typing.Optional[winrt.system.Object]: ...
    @description.setter
    def description(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def proofing_menu_flyout(self) -> typing.Optional[winrt.windows.ui.xaml.controls.primitives.FlyoutBase]: ...
    @_property
    def text_document(self) -> typing.Optional[winrt.windows.ui.text.RichEditTextDocument]: ...

@typing.final
class RichEditBoxSelectionChangingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RichEditBoxSelectionChangingEventArgs: ...
    @_property
    def cancel(self) -> bool: ...
    @cancel.setter
    def cancel(self, value: bool) -> None: ...
    @_property
    def selection_length(self) -> winrt.system.Int32: ...
    @_property
    def selection_start(self) -> winrt.system.Int32: ...

@typing.final
class RichEditBoxTextChangingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RichEditBoxTextChangingEventArgs: ...
    @_property
    def is_content_changing(self) -> bool: ...

@typing.final
class RichTextBlock_Static(type):
    @_property
    def character_spacing_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def font_family_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def font_size_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def font_stretch_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def font_style_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def font_weight_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def foreground_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def has_overflow_content_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_text_selection_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def line_height_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def line_stacking_strategy_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def overflow_content_target_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def padding_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selected_text_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def text_alignment_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def text_indent_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def text_trimming_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def text_wrapping_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_color_font_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def max_lines_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def optical_margin_alignment_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selection_highlight_color_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def text_line_bounds_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def text_reading_order_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_text_scale_factor_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def text_decorations_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def horizontal_text_alignment_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_text_trimmed_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selection_flyout_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class RichTextBlock(winrt.system.Object, metaclass=RichTextBlock_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RichTextBlock: ...
    def __new__(cls: typing.Type[RichTextBlock]) -> RichTextBlock:...
    def copy_selection_to_clipboard(self) -> None: ...
    def focus(self, value: winrt.windows.ui.xaml.FocusState, /) -> bool: ...
    def get_position_from_point(self, point: winrt.windows.foundation.Point, /) -> typing.Optional[winrt.windows.ui.xaml.documents.TextPointer]: ...
    def select(self, start: typing.Optional[winrt.windows.ui.xaml.documents.TextPointer], end: typing.Optional[winrt.windows.ui.xaml.documents.TextPointer], /) -> None: ...
    def select_all(self) -> None: ...
    def add_context_menu_opening(self, handler: typing.Optional[ContextMenuOpeningEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_context_menu_opening(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_selection_changed(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_selection_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_is_text_trimmed_changed(self, handler: winrt.windows.foundation.TypedEventHandler[RichTextBlock, IsTextTrimmedChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_is_text_trimmed_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def text_wrapping(self) -> winrt.windows.ui.xaml.TextWrapping: ...
    @text_wrapping.setter
    def text_wrapping(self, value: winrt.windows.ui.xaml.TextWrapping) -> None: ...
    @_property
    def text_trimming(self) -> winrt.windows.ui.xaml.TextTrimming: ...
    @text_trimming.setter
    def text_trimming(self, value: winrt.windows.ui.xaml.TextTrimming) -> None: ...
    @_property
    def text_indent(self) -> winrt.system.Double: ...
    @text_indent.setter
    def text_indent(self, value: winrt.system.Double) -> None: ...
    @_property
    def text_alignment(self) -> winrt.windows.ui.xaml.TextAlignment: ...
    @text_alignment.setter
    def text_alignment(self, value: winrt.windows.ui.xaml.TextAlignment) -> None: ...
    @_property
    def padding(self) -> winrt.windows.ui.xaml.Thickness: ...
    @padding.setter
    def padding(self, value: winrt.windows.ui.xaml.Thickness) -> None: ...
    @_property
    def foreground(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @foreground.setter
    def foreground(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def font_weight(self) -> winrt.windows.ui.text.FontWeight: ...
    @font_weight.setter
    def font_weight(self, value: winrt.windows.ui.text.FontWeight) -> None: ...
    @_property
    def font_style(self) -> winrt.windows.ui.text.FontStyle: ...
    @font_style.setter
    def font_style(self, value: winrt.windows.ui.text.FontStyle) -> None: ...
    @_property
    def font_stretch(self) -> winrt.windows.ui.text.FontStretch: ...
    @font_stretch.setter
    def font_stretch(self, value: winrt.windows.ui.text.FontStretch) -> None: ...
    @_property
    def font_size(self) -> winrt.system.Double: ...
    @font_size.setter
    def font_size(self, value: winrt.system.Double) -> None: ...
    @_property
    def font_family(self) -> typing.Optional[winrt.windows.ui.xaml.media.FontFamily]: ...
    @font_family.setter
    def font_family(self, value: typing.Optional[winrt.windows.ui.xaml.media.FontFamily]) -> None: ...
    @_property
    def overflow_content_target(self) -> typing.Optional[RichTextBlockOverflow]: ...
    @overflow_content_target.setter
    def overflow_content_target(self, value: typing.Optional[RichTextBlockOverflow]) -> None: ...
    @_property
    def line_stacking_strategy(self) -> winrt.windows.ui.xaml.LineStackingStrategy: ...
    @line_stacking_strategy.setter
    def line_stacking_strategy(self, value: winrt.windows.ui.xaml.LineStackingStrategy) -> None: ...
    @_property
    def character_spacing(self) -> winrt.system.Int32: ...
    @character_spacing.setter
    def character_spacing(self, value: winrt.system.Int32) -> None: ...
    @_property
    def line_height(self) -> winrt.system.Double: ...
    @line_height.setter
    def line_height(self, value: winrt.system.Double) -> None: ...
    @_property
    def is_text_selection_enabled(self) -> bool: ...
    @is_text_selection_enabled.setter
    def is_text_selection_enabled(self, value: bool) -> None: ...
    @_property
    def has_overflow_content(self) -> bool: ...
    @_property
    def selected_text(self) -> str: ...
    @_property
    def selection_end(self) -> typing.Optional[winrt.windows.ui.xaml.documents.TextPointer]: ...
    @_property
    def selection_start(self) -> typing.Optional[winrt.windows.ui.xaml.documents.TextPointer]: ...
    @_property
    def baseline_offset(self) -> winrt.system.Double: ...
    @_property
    def blocks(self) -> typing.Optional[winrt.windows.ui.xaml.documents.BlockCollection]: ...
    @_property
    def content_end(self) -> typing.Optional[winrt.windows.ui.xaml.documents.TextPointer]: ...
    @_property
    def content_start(self) -> typing.Optional[winrt.windows.ui.xaml.documents.TextPointer]: ...
    @_property
    def text_reading_order(self) -> winrt.windows.ui.xaml.TextReadingOrder: ...
    @text_reading_order.setter
    def text_reading_order(self, value: winrt.windows.ui.xaml.TextReadingOrder) -> None: ...
    @_property
    def text_line_bounds(self) -> winrt.windows.ui.xaml.TextLineBounds: ...
    @text_line_bounds.setter
    def text_line_bounds(self, value: winrt.windows.ui.xaml.TextLineBounds) -> None: ...
    @_property
    def selection_highlight_color(self) -> typing.Optional[winrt.windows.ui.xaml.media.SolidColorBrush]: ...
    @selection_highlight_color.setter
    def selection_highlight_color(self, value: typing.Optional[winrt.windows.ui.xaml.media.SolidColorBrush]) -> None: ...
    @_property
    def optical_margin_alignment(self) -> winrt.windows.ui.xaml.OpticalMarginAlignment: ...
    @optical_margin_alignment.setter
    def optical_margin_alignment(self, value: winrt.windows.ui.xaml.OpticalMarginAlignment) -> None: ...
    @_property
    def max_lines(self) -> winrt.system.Int32: ...
    @max_lines.setter
    def max_lines(self, value: winrt.system.Int32) -> None: ...
    @_property
    def is_color_font_enabled(self) -> bool: ...
    @is_color_font_enabled.setter
    def is_color_font_enabled(self, value: bool) -> None: ...
    @_property
    def is_text_scale_factor_enabled(self) -> bool: ...
    @is_text_scale_factor_enabled.setter
    def is_text_scale_factor_enabled(self, value: bool) -> None: ...
    @_property
    def text_decorations(self) -> winrt.windows.ui.text.TextDecorations: ...
    @text_decorations.setter
    def text_decorations(self, value: winrt.windows.ui.text.TextDecorations) -> None: ...
    @_property
    def horizontal_text_alignment(self) -> winrt.windows.ui.xaml.TextAlignment: ...
    @horizontal_text_alignment.setter
    def horizontal_text_alignment(self, value: winrt.windows.ui.xaml.TextAlignment) -> None: ...
    @_property
    def is_text_trimmed(self) -> bool: ...
    @_property
    def text_highlighters(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.ui.xaml.documents.TextHighlighter]]: ...
    @_property
    def selection_flyout(self) -> typing.Optional[winrt.windows.ui.xaml.controls.primitives.FlyoutBase]: ...
    @selection_flyout.setter
    def selection_flyout(self, value: typing.Optional[winrt.windows.ui.xaml.controls.primitives.FlyoutBase]) -> None: ...

@typing.final
class RichTextBlockOverflow_Static(type):
    @_property
    def has_overflow_content_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def overflow_content_target_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def padding_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def max_lines_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_text_trimmed_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class RichTextBlockOverflow(winrt.system.Object, metaclass=RichTextBlockOverflow_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RichTextBlockOverflow: ...
    def __new__(cls: typing.Type[RichTextBlockOverflow]) -> RichTextBlockOverflow:...
    def focus(self, value: winrt.windows.ui.xaml.FocusState, /) -> bool: ...
    def get_position_from_point(self, point: winrt.windows.foundation.Point, /) -> typing.Optional[winrt.windows.ui.xaml.documents.TextPointer]: ...
    def add_is_text_trimmed_changed(self, handler: winrt.windows.foundation.TypedEventHandler[RichTextBlockOverflow, IsTextTrimmedChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_is_text_trimmed_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def padding(self) -> winrt.windows.ui.xaml.Thickness: ...
    @padding.setter
    def padding(self, value: winrt.windows.ui.xaml.Thickness) -> None: ...
    @_property
    def overflow_content_target(self) -> typing.Optional[RichTextBlockOverflow]: ...
    @overflow_content_target.setter
    def overflow_content_target(self, value: typing.Optional[RichTextBlockOverflow]) -> None: ...
    @_property
    def baseline_offset(self) -> winrt.system.Double: ...
    @_property
    def content_end(self) -> typing.Optional[winrt.windows.ui.xaml.documents.TextPointer]: ...
    @_property
    def content_source(self) -> typing.Optional[RichTextBlock]: ...
    @_property
    def content_start(self) -> typing.Optional[winrt.windows.ui.xaml.documents.TextPointer]: ...
    @_property
    def has_overflow_content(self) -> bool: ...
    @_property
    def max_lines(self) -> winrt.system.Int32: ...
    @max_lines.setter
    def max_lines(self, value: winrt.system.Int32) -> None: ...
    @_property
    def is_text_trimmed(self) -> bool: ...

@typing.final
class RowDefinition_Static(type):
    @_property
    def height_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def max_height_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def min_height_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class RowDefinition(winrt.system.Object, metaclass=RowDefinition_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RowDefinition: ...
    def __new__(cls: typing.Type[RowDefinition]) -> RowDefinition:...
    @_property
    def min_height(self) -> winrt.system.Double: ...
    @min_height.setter
    def min_height(self, value: winrt.system.Double) -> None: ...
    @_property
    def max_height(self) -> winrt.system.Double: ...
    @max_height.setter
    def max_height(self, value: winrt.system.Double) -> None: ...
    @_property
    def height(self) -> winrt.windows.ui.xaml.GridLength: ...
    @height.setter
    def height(self, value: winrt.windows.ui.xaml.GridLength) -> None: ...
    @_property
    def actual_height(self) -> winrt.system.Double: ...

@typing.final
class RowDefinitionCollection(winrt.system.Object, winrt._winrt.MutableSequence[RowDefinition]):
    def __len__(self) -> int: ...
    def __iter__(self) -> winrt.windows.foundation.collections.IIterator[RowDefinition]: ...
    @typing.overload
    def __getitem__(self, index: typing.SupportsIndex) -> RowDefinition: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[RowDefinition]: ...
    @typing.overload
    def __delitem__(self, index: typing.SupportsIndex) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: typing.SupportsIndex, value: RowDefinition) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[RowDefinition]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RowDefinitionCollection: ...
    def append(self, value: typing.Optional[RowDefinition], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[RowDefinition]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[RowDefinition]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[RowDefinition], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[RowDefinition]]: ...
    def index_of(self, value: typing.Optional[RowDefinition], /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[RowDefinition], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[RowDefinition], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[RowDefinition], /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class ScrollContentPresenter_Static(type):
    @_property
    def can_content_render_outside_bounds_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def sizes_content_to_templated_parent_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class ScrollContentPresenter(winrt.system.Object, metaclass=ScrollContentPresenter_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ScrollContentPresenter: ...
    def __new__(cls: typing.Type[ScrollContentPresenter]) -> ScrollContentPresenter:...
    def line_down(self) -> None: ...
    def line_left(self) -> None: ...
    def line_right(self) -> None: ...
    def line_up(self) -> None: ...
    def make_visible(self, visual: typing.Optional[winrt.windows.ui.xaml.UIElement], rectangle: winrt.windows.foundation.Rect, /) -> winrt.windows.foundation.Rect: ...
    def mouse_wheel_down(self) -> None: ...
    def mouse_wheel_left(self) -> None: ...
    def mouse_wheel_right(self) -> None: ...
    def mouse_wheel_up(self) -> None: ...
    def page_down(self) -> None: ...
    def page_left(self) -> None: ...
    def page_right(self) -> None: ...
    def page_up(self) -> None: ...
    def set_horizontal_offset(self, offset: winrt.system.Double, /) -> None: ...
    def set_vertical_offset(self, offset: winrt.system.Double, /) -> None: ...
    @_property
    def scroll_owner(self) -> typing.Optional[winrt.system.Object]: ...
    @scroll_owner.setter
    def scroll_owner(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def can_vertically_scroll(self) -> bool: ...
    @can_vertically_scroll.setter
    def can_vertically_scroll(self, value: bool) -> None: ...
    @_property
    def can_horizontally_scroll(self) -> bool: ...
    @can_horizontally_scroll.setter
    def can_horizontally_scroll(self, value: bool) -> None: ...
    @_property
    def extent_height(self) -> winrt.system.Double: ...
    @_property
    def extent_width(self) -> winrt.system.Double: ...
    @_property
    def horizontal_offset(self) -> winrt.system.Double: ...
    @_property
    def vertical_offset(self) -> winrt.system.Double: ...
    @_property
    def viewport_height(self) -> winrt.system.Double: ...
    @_property
    def viewport_width(self) -> winrt.system.Double: ...
    @_property
    def sizes_content_to_templated_parent(self) -> bool: ...
    @sizes_content_to_templated_parent.setter
    def sizes_content_to_templated_parent(self, value: bool) -> None: ...
    @_property
    def can_content_render_outside_bounds(self) -> bool: ...
    @can_content_render_outside_bounds.setter
    def can_content_render_outside_bounds(self, value: bool) -> None: ...

@typing.final
class ScrollViewer_Static(type):
    def get_bring_into_view_on_focus_change(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> bool: ...
    def get_can_content_render_outside_bounds(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> bool: ...
    def get_horizontal_scroll_bar_visibility(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> ScrollBarVisibility: ...
    def get_horizontal_scroll_mode(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> ScrollMode: ...
    def get_is_deferred_scrolling_enabled(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> bool: ...
    def get_is_horizontal_rail_enabled(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> bool: ...
    def get_is_horizontal_scroll_chaining_enabled(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> bool: ...
    def get_is_scroll_inertia_enabled(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> bool: ...
    def get_is_vertical_rail_enabled(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> bool: ...
    def get_is_vertical_scroll_chaining_enabled(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> bool: ...
    def get_is_zoom_chaining_enabled(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> bool: ...
    def get_is_zoom_inertia_enabled(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> bool: ...
    def get_vertical_scroll_bar_visibility(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> ScrollBarVisibility: ...
    def get_vertical_scroll_mode(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> ScrollMode: ...
    def get_zoom_mode(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> ZoomMode: ...
    def set_bring_into_view_on_focus_change(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], bring_into_view_on_focus_change: bool, /) -> None: ...
    def set_can_content_render_outside_bounds(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], can_content_render_outside_bounds: bool, /) -> None: ...
    def set_horizontal_scroll_bar_visibility(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], horizontal_scroll_bar_visibility: ScrollBarVisibility, /) -> None: ...
    def set_horizontal_scroll_mode(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], horizontal_scroll_mode: ScrollMode, /) -> None: ...
    def set_is_deferred_scrolling_enabled(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], is_deferred_scrolling_enabled: bool, /) -> None: ...
    def set_is_horizontal_rail_enabled(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], is_horizontal_rail_enabled: bool, /) -> None: ...
    def set_is_horizontal_scroll_chaining_enabled(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], is_horizontal_scroll_chaining_enabled: bool, /) -> None: ...
    def set_is_scroll_inertia_enabled(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], is_scroll_inertia_enabled: bool, /) -> None: ...
    def set_is_vertical_rail_enabled(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], is_vertical_rail_enabled: bool, /) -> None: ...
    def set_is_vertical_scroll_chaining_enabled(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], is_vertical_scroll_chaining_enabled: bool, /) -> None: ...
    def set_is_zoom_chaining_enabled(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], is_zoom_chaining_enabled: bool, /) -> None: ...
    def set_is_zoom_inertia_enabled(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], is_zoom_inertia_enabled: bool, /) -> None: ...
    def set_vertical_scroll_bar_visibility(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], vertical_scroll_bar_visibility: ScrollBarVisibility, /) -> None: ...
    def set_vertical_scroll_mode(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], vertical_scroll_mode: ScrollMode, /) -> None: ...
    def set_zoom_mode(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], zoom_mode: ZoomMode, /) -> None: ...
    @_property
    def is_scroll_inertia_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def vertical_snap_points_type_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def viewport_height_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def viewport_width_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def zoom_factor_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def zoom_mode_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def zoom_snap_points_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def bring_into_view_on_focus_change_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def computed_horizontal_scroll_bar_visibility_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def computed_vertical_scroll_bar_visibility_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def extent_height_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def extent_width_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def horizontal_offset_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def horizontal_scroll_bar_visibility_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def horizontal_scroll_mode_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def horizontal_snap_points_alignment_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def horizontal_snap_points_type_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_deferred_scrolling_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_horizontal_rail_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_horizontal_scroll_chaining_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def zoom_snap_points_type_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_vertical_rail_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_vertical_scroll_chaining_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_zoom_chaining_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_zoom_inertia_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def max_zoom_factor_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def min_zoom_factor_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def scrollable_height_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def scrollable_width_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def vertical_offset_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def vertical_scroll_bar_visibility_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def vertical_scroll_mode_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def vertical_snap_points_alignment_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def left_header_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def top_header_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def top_left_header_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def horizontal_anchor_ratio_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def reduce_viewport_for_core_input_view_occlusions_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def vertical_anchor_ratio_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def can_content_render_outside_bounds_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class ScrollViewer(winrt.system.Object, metaclass=ScrollViewer_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ScrollViewer: ...
    def __new__(cls: typing.Type[ScrollViewer]) -> ScrollViewer:...
    @typing.overload
    def change_view(self, horizontal_offset: typing.Optional[winrt.system.Double], vertical_offset: typing.Optional[winrt.system.Double], zoom_factor: typing.Optional[winrt.system.Single], /) -> bool: ...
    @typing.overload
    def change_view(self, horizontal_offset: typing.Optional[winrt.system.Double], vertical_offset: typing.Optional[winrt.system.Double], zoom_factor: typing.Optional[winrt.system.Single], disable_animation: bool, /) -> bool: ...
    def invalidate_scroll_info(self) -> None: ...
    def register_anchor_candidate(self, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> None: ...
    def scroll_to_horizontal_offset(self, offset: winrt.system.Double, /) -> None: ...
    def scroll_to_vertical_offset(self, offset: winrt.system.Double, /) -> None: ...
    def unregister_anchor_candidate(self, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> None: ...
    def zoom_to_factor(self, factor: winrt.system.Single, /) -> None: ...
    def add_view_changed(self, handler: winrt.windows.foundation.EventHandler[ScrollViewerViewChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_view_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_view_changing(self, handler: winrt.windows.foundation.EventHandler[ScrollViewerViewChangingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_view_changing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_direct_manipulation_completed(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_direct_manipulation_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_direct_manipulation_started(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_direct_manipulation_started(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_anchor_requested(self, handler: winrt.windows.foundation.TypedEventHandler[ScrollViewer, AnchorRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_anchor_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def current_anchor(self) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    @_property
    def is_vertical_rail_enabled(self) -> bool: ...
    @is_vertical_rail_enabled.setter
    def is_vertical_rail_enabled(self, value: bool) -> None: ...
    @_property
    def is_scroll_inertia_enabled(self) -> bool: ...
    @is_scroll_inertia_enabled.setter
    def is_scroll_inertia_enabled(self, value: bool) -> None: ...
    @_property
    def is_horizontal_scroll_chaining_enabled(self) -> bool: ...
    @is_horizontal_scroll_chaining_enabled.setter
    def is_horizontal_scroll_chaining_enabled(self, value: bool) -> None: ...
    @_property
    def is_horizontal_rail_enabled(self) -> bool: ...
    @is_horizontal_rail_enabled.setter
    def is_horizontal_rail_enabled(self, value: bool) -> None: ...
    @_property
    def is_deferred_scrolling_enabled(self) -> bool: ...
    @is_deferred_scrolling_enabled.setter
    def is_deferred_scrolling_enabled(self, value: bool) -> None: ...
    @_property
    def horizontal_snap_points_type(self) -> SnapPointsType: ...
    @horizontal_snap_points_type.setter
    def horizontal_snap_points_type(self, value: SnapPointsType) -> None: ...
    @_property
    def horizontal_snap_points_alignment(self) -> winrt.windows.ui.xaml.controls.primitives.SnapPointsAlignment: ...
    @horizontal_snap_points_alignment.setter
    def horizontal_snap_points_alignment(self, value: winrt.windows.ui.xaml.controls.primitives.SnapPointsAlignment) -> None: ...
    @_property
    def horizontal_scroll_mode(self) -> ScrollMode: ...
    @horizontal_scroll_mode.setter
    def horizontal_scroll_mode(self, value: ScrollMode) -> None: ...
    @_property
    def horizontal_scroll_bar_visibility(self) -> ScrollBarVisibility: ...
    @horizontal_scroll_bar_visibility.setter
    def horizontal_scroll_bar_visibility(self, value: ScrollBarVisibility) -> None: ...
    @_property
    def min_zoom_factor(self) -> winrt.system.Single: ...
    @min_zoom_factor.setter
    def min_zoom_factor(self, value: winrt.system.Single) -> None: ...
    @_property
    def max_zoom_factor(self) -> winrt.system.Single: ...
    @max_zoom_factor.setter
    def max_zoom_factor(self, value: winrt.system.Single) -> None: ...
    @_property
    def is_zoom_inertia_enabled(self) -> bool: ...
    @is_zoom_inertia_enabled.setter
    def is_zoom_inertia_enabled(self, value: bool) -> None: ...
    @_property
    def is_zoom_chaining_enabled(self) -> bool: ...
    @is_zoom_chaining_enabled.setter
    def is_zoom_chaining_enabled(self, value: bool) -> None: ...
    @_property
    def is_vertical_scroll_chaining_enabled(self) -> bool: ...
    @is_vertical_scroll_chaining_enabled.setter
    def is_vertical_scroll_chaining_enabled(self, value: bool) -> None: ...
    @_property
    def bring_into_view_on_focus_change(self) -> bool: ...
    @bring_into_view_on_focus_change.setter
    def bring_into_view_on_focus_change(self, value: bool) -> None: ...
    @_property
    def zoom_snap_points_type(self) -> SnapPointsType: ...
    @zoom_snap_points_type.setter
    def zoom_snap_points_type(self, value: SnapPointsType) -> None: ...
    @_property
    def zoom_mode(self) -> ZoomMode: ...
    @zoom_mode.setter
    def zoom_mode(self, value: ZoomMode) -> None: ...
    @_property
    def vertical_snap_points_type(self) -> SnapPointsType: ...
    @vertical_snap_points_type.setter
    def vertical_snap_points_type(self, value: SnapPointsType) -> None: ...
    @_property
    def vertical_snap_points_alignment(self) -> winrt.windows.ui.xaml.controls.primitives.SnapPointsAlignment: ...
    @vertical_snap_points_alignment.setter
    def vertical_snap_points_alignment(self, value: winrt.windows.ui.xaml.controls.primitives.SnapPointsAlignment) -> None: ...
    @_property
    def vertical_scroll_mode(self) -> ScrollMode: ...
    @vertical_scroll_mode.setter
    def vertical_scroll_mode(self, value: ScrollMode) -> None: ...
    @_property
    def vertical_scroll_bar_visibility(self) -> ScrollBarVisibility: ...
    @vertical_scroll_bar_visibility.setter
    def vertical_scroll_bar_visibility(self, value: ScrollBarVisibility) -> None: ...
    @_property
    def computed_horizontal_scroll_bar_visibility(self) -> winrt.windows.ui.xaml.Visibility: ...
    @_property
    def computed_vertical_scroll_bar_visibility(self) -> winrt.windows.ui.xaml.Visibility: ...
    @_property
    def extent_height(self) -> winrt.system.Double: ...
    @_property
    def extent_width(self) -> winrt.system.Double: ...
    @_property
    def horizontal_offset(self) -> winrt.system.Double: ...
    @_property
    def scrollable_width(self) -> winrt.system.Double: ...
    @_property
    def vertical_offset(self) -> winrt.system.Double: ...
    @_property
    def viewport_height(self) -> winrt.system.Double: ...
    @_property
    def viewport_width(self) -> winrt.system.Double: ...
    @_property
    def zoom_factor(self) -> winrt.system.Single: ...
    @_property
    def zoom_snap_points(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.system.Single]]: ...
    @_property
    def scrollable_height(self) -> winrt.system.Double: ...
    @_property
    def top_left_header(self) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    @top_left_header.setter
    def top_left_header(self, value: typing.Optional[winrt.windows.ui.xaml.UIElement]) -> None: ...
    @_property
    def top_header(self) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    @top_header.setter
    def top_header(self, value: typing.Optional[winrt.windows.ui.xaml.UIElement]) -> None: ...
    @_property
    def left_header(self) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    @left_header.setter
    def left_header(self, value: typing.Optional[winrt.windows.ui.xaml.UIElement]) -> None: ...
    @_property
    def vertical_anchor_ratio(self) -> winrt.system.Double: ...
    @vertical_anchor_ratio.setter
    def vertical_anchor_ratio(self, value: winrt.system.Double) -> None: ...
    @_property
    def reduce_viewport_for_core_input_view_occlusions(self) -> bool: ...
    @reduce_viewport_for_core_input_view_occlusions.setter
    def reduce_viewport_for_core_input_view_occlusions(self, value: bool) -> None: ...
    @_property
    def horizontal_anchor_ratio(self) -> winrt.system.Double: ...
    @horizontal_anchor_ratio.setter
    def horizontal_anchor_ratio(self, value: winrt.system.Double) -> None: ...
    @_property
    def can_content_render_outside_bounds(self) -> bool: ...
    @can_content_render_outside_bounds.setter
    def can_content_render_outside_bounds(self, value: bool) -> None: ...

@typing.final
class ScrollViewerView(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ScrollViewerView: ...
    @_property
    def horizontal_offset(self) -> winrt.system.Double: ...
    @_property
    def vertical_offset(self) -> winrt.system.Double: ...
    @_property
    def zoom_factor(self) -> winrt.system.Single: ...

@typing.final
class ScrollViewerViewChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ScrollViewerViewChangedEventArgs: ...
    def __new__(cls: typing.Type[ScrollViewerViewChangedEventArgs]) -> ScrollViewerViewChangedEventArgs:...
    @_property
    def is_intermediate(self) -> bool: ...

@typing.final
class ScrollViewerViewChangingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ScrollViewerViewChangingEventArgs: ...
    @_property
    def final_view(self) -> typing.Optional[ScrollViewerView]: ...
    @_property
    def is_inertial(self) -> bool: ...
    @_property
    def next_view(self) -> typing.Optional[ScrollViewerView]: ...

@typing.final
class SearchBox_Static(type):
    @_property
    def choose_suggestion_on_enter_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def focus_on_keyboard_input_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def placeholder_text_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def query_text_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def search_history_context_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def search_history_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class SearchBox(winrt.system.Object, metaclass=SearchBox_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SearchBox: ...
    def __new__(cls: typing.Type[SearchBox]) -> SearchBox:...
    def set_local_content_suggestion_settings(self, settings: typing.Optional[winrt.windows.applicationmodel.search.LocalContentSuggestionSettings], /) -> None: ...
    def add_prepare_for_focus_on_keyboard_input(self, handler: winrt.windows.foundation.TypedEventHandler[SearchBox, winrt.windows.ui.xaml.RoutedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_prepare_for_focus_on_keyboard_input(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_query_changed(self, handler: winrt.windows.foundation.TypedEventHandler[SearchBox, SearchBoxQueryChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_query_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_query_submitted(self, handler: winrt.windows.foundation.TypedEventHandler[SearchBox, SearchBoxQuerySubmittedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_query_submitted(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_result_suggestion_chosen(self, handler: winrt.windows.foundation.TypedEventHandler[SearchBox, SearchBoxResultSuggestionChosenEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_result_suggestion_chosen(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_suggestions_requested(self, handler: winrt.windows.foundation.TypedEventHandler[SearchBox, SearchBoxSuggestionsRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_suggestions_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def search_history_enabled(self) -> bool: ...
    @search_history_enabled.setter
    def search_history_enabled(self, value: bool) -> None: ...
    @_property
    def search_history_context(self) -> str: ...
    @search_history_context.setter
    def search_history_context(self, value: str) -> None: ...
    @_property
    def query_text(self) -> str: ...
    @query_text.setter
    def query_text(self, value: str) -> None: ...
    @_property
    def placeholder_text(self) -> str: ...
    @placeholder_text.setter
    def placeholder_text(self, value: str) -> None: ...
    @_property
    def focus_on_keyboard_input(self) -> bool: ...
    @focus_on_keyboard_input.setter
    def focus_on_keyboard_input(self, value: bool) -> None: ...
    @_property
    def choose_suggestion_on_enter(self) -> bool: ...
    @choose_suggestion_on_enter.setter
    def choose_suggestion_on_enter(self, value: bool) -> None: ...

@typing.final
class SearchBoxQueryChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SearchBoxQueryChangedEventArgs: ...
    @_property
    def language(self) -> str: ...
    @_property
    def linguistic_details(self) -> typing.Optional[winrt.windows.applicationmodel.search.SearchQueryLinguisticDetails]: ...
    @_property
    def query_text(self) -> str: ...

@typing.final
class SearchBoxQuerySubmittedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SearchBoxQuerySubmittedEventArgs: ...
    @_property
    def key_modifiers(self) -> winrt.windows.system.VirtualKeyModifiers: ...
    @_property
    def language(self) -> str: ...
    @_property
    def linguistic_details(self) -> typing.Optional[winrt.windows.applicationmodel.search.SearchQueryLinguisticDetails]: ...
    @_property
    def query_text(self) -> str: ...

@typing.final
class SearchBoxResultSuggestionChosenEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SearchBoxResultSuggestionChosenEventArgs: ...
    def __new__(cls: typing.Type[SearchBoxResultSuggestionChosenEventArgs]) -> SearchBoxResultSuggestionChosenEventArgs:...
    @_property
    def key_modifiers(self) -> winrt.windows.system.VirtualKeyModifiers: ...
    @_property
    def tag(self) -> str: ...

@typing.final
class SearchBoxSuggestionsRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SearchBoxSuggestionsRequestedEventArgs: ...
    @_property
    def language(self) -> str: ...
    @_property
    def linguistic_details(self) -> typing.Optional[winrt.windows.applicationmodel.search.SearchQueryLinguisticDetails]: ...
    @_property
    def query_text(self) -> str: ...
    @_property
    def request(self) -> typing.Optional[winrt.windows.applicationmodel.search.SearchSuggestionsRequest]: ...

@typing.final
class SectionsInViewChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SectionsInViewChangedEventArgs: ...
    @_property
    def added_sections(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[HubSection]]: ...
    @_property
    def removed_sections(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[HubSection]]: ...

@typing.final
class SelectionChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SelectionChangedEventArgs: ...
    def __new__(cls: typing.Type[SelectionChangedEventArgs], removed_items: winrt.windows.foundation.collections.IVector[winrt.system.Object], added_items: winrt.windows.foundation.collections.IVector[winrt.system.Object]) -> SelectionChangedEventArgs:...
    @_property
    def added_items(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.system.Object]]: ...
    @_property
    def removed_items(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.system.Object]]: ...

@typing.final
class SemanticZoom_Static(type):
    @_property
    def can_change_views_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_zoom_out_button_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_zoomed_in_view_active_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def zoomed_in_view_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def zoomed_out_view_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class SemanticZoom(winrt.system.Object, metaclass=SemanticZoom_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SemanticZoom: ...
    def __new__(cls: typing.Type[SemanticZoom]) -> SemanticZoom:...
    def toggle_active_view(self) -> None: ...
    def add_view_change_completed(self, handler: typing.Optional[SemanticZoomViewChangedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_view_change_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_view_change_started(self, handler: typing.Optional[SemanticZoomViewChangedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_view_change_started(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def zoomed_out_view(self) -> typing.Optional[ISemanticZoomInformation]: ...
    @zoomed_out_view.setter
    def zoomed_out_view(self, value: typing.Optional[ISemanticZoomInformation]) -> None: ...
    @_property
    def zoomed_in_view(self) -> typing.Optional[ISemanticZoomInformation]: ...
    @zoomed_in_view.setter
    def zoomed_in_view(self, value: typing.Optional[ISemanticZoomInformation]) -> None: ...
    @_property
    def is_zoomed_in_view_active(self) -> bool: ...
    @is_zoomed_in_view_active.setter
    def is_zoomed_in_view_active(self, value: bool) -> None: ...
    @_property
    def is_zoom_out_button_enabled(self) -> bool: ...
    @is_zoom_out_button_enabled.setter
    def is_zoom_out_button_enabled(self, value: bool) -> None: ...
    @_property
    def can_change_views(self) -> bool: ...
    @can_change_views.setter
    def can_change_views(self, value: bool) -> None: ...

@typing.final
class SemanticZoomLocation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SemanticZoomLocation: ...
    def __new__(cls: typing.Type[SemanticZoomLocation]) -> SemanticZoomLocation:...
    @_property
    def item(self) -> typing.Optional[winrt.system.Object]: ...
    @item.setter
    def item(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def bounds(self) -> winrt.windows.foundation.Rect: ...
    @bounds.setter
    def bounds(self, value: winrt.windows.foundation.Rect) -> None: ...

@typing.final
class SemanticZoomViewChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SemanticZoomViewChangedEventArgs: ...
    def __new__(cls: typing.Type[SemanticZoomViewChangedEventArgs]) -> SemanticZoomViewChangedEventArgs:...
    @_property
    def source_item(self) -> typing.Optional[SemanticZoomLocation]: ...
    @source_item.setter
    def source_item(self, value: typing.Optional[SemanticZoomLocation]) -> None: ...
    @_property
    def is_source_zoomed_in_view(self) -> bool: ...
    @is_source_zoomed_in_view.setter
    def is_source_zoomed_in_view(self, value: bool) -> None: ...
    @_property
    def destination_item(self) -> typing.Optional[SemanticZoomLocation]: ...
    @destination_item.setter
    def destination_item(self, value: typing.Optional[SemanticZoomLocation]) -> None: ...

@typing.final
class SettingsFlyout_Static(type):
    @_property
    def header_background_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def header_foreground_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def icon_source_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def title_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class SettingsFlyout(winrt.system.Object, metaclass=SettingsFlyout_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SettingsFlyout: ...
    def __new__(cls: typing.Type[SettingsFlyout]) -> SettingsFlyout:...
    def hide(self) -> None: ...
    def show(self) -> None: ...
    def show_independent(self) -> None: ...
    def add_back_click(self, handler: typing.Optional[BackClickEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_back_click(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def title(self) -> str: ...
    @title.setter
    def title(self, value: str) -> None: ...
    @_property
    def icon_source(self) -> typing.Optional[winrt.windows.ui.xaml.media.ImageSource]: ...
    @icon_source.setter
    def icon_source(self, value: typing.Optional[winrt.windows.ui.xaml.media.ImageSource]) -> None: ...
    @_property
    def header_foreground(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @header_foreground.setter
    def header_foreground(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def header_background(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @header_background.setter
    def header_background(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def template_settings(self) -> typing.Optional[winrt.windows.ui.xaml.controls.primitives.SettingsFlyoutTemplateSettings]: ...

@typing.final
class Slider_Static(type):
    @_property
    def intermediate_value_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_direction_reversed_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_thumb_tool_tip_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def orientation_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def snaps_to_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def step_frequency_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def thumb_tool_tip_value_converter_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def tick_frequency_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def tick_placement_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def header_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def header_template_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class Slider(winrt.system.Object, metaclass=Slider_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Slider: ...
    def __new__(cls: typing.Type[Slider]) -> Slider:...
    @_property
    def tick_placement(self) -> winrt.windows.ui.xaml.controls.primitives.TickPlacement: ...
    @tick_placement.setter
    def tick_placement(self, value: winrt.windows.ui.xaml.controls.primitives.TickPlacement) -> None: ...
    @_property
    def tick_frequency(self) -> winrt.system.Double: ...
    @tick_frequency.setter
    def tick_frequency(self, value: winrt.system.Double) -> None: ...
    @_property
    def thumb_tool_tip_value_converter(self) -> typing.Optional[winrt.windows.ui.xaml.data.IValueConverter]: ...
    @thumb_tool_tip_value_converter.setter
    def thumb_tool_tip_value_converter(self, value: typing.Optional[winrt.windows.ui.xaml.data.IValueConverter]) -> None: ...
    @_property
    def step_frequency(self) -> winrt.system.Double: ...
    @step_frequency.setter
    def step_frequency(self, value: winrt.system.Double) -> None: ...
    @_property
    def snaps_to(self) -> winrt.windows.ui.xaml.controls.primitives.SliderSnapsTo: ...
    @snaps_to.setter
    def snaps_to(self, value: winrt.windows.ui.xaml.controls.primitives.SliderSnapsTo) -> None: ...
    @_property
    def orientation(self) -> Orientation: ...
    @orientation.setter
    def orientation(self, value: Orientation) -> None: ...
    @_property
    def is_thumb_tool_tip_enabled(self) -> bool: ...
    @is_thumb_tool_tip_enabled.setter
    def is_thumb_tool_tip_enabled(self, value: bool) -> None: ...
    @_property
    def is_direction_reversed(self) -> bool: ...
    @is_direction_reversed.setter
    def is_direction_reversed(self, value: bool) -> None: ...
    @_property
    def intermediate_value(self) -> winrt.system.Double: ...
    @intermediate_value.setter
    def intermediate_value(self, value: winrt.system.Double) -> None: ...
    @_property
    def header_template(self) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @header_template.setter
    def header_template(self, value: typing.Optional[winrt.windows.ui.xaml.DataTemplate]) -> None: ...
    @_property
    def header(self) -> typing.Optional[winrt.system.Object]: ...
    @header.setter
    def header(self, value: typing.Optional[winrt.system.Object]) -> None: ...

@typing.final
class SplitButton_Static(type):
    @_property
    def command_parameter_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def command_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def flyout_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class SplitButton(winrt.system.Object, metaclass=SplitButton_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SplitButton: ...
    def __new__(cls: typing.Type[SplitButton]) -> SplitButton:...
    def add_click(self, handler: winrt.windows.foundation.TypedEventHandler[SplitButton, SplitButtonClickEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_click(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def flyout(self) -> typing.Optional[winrt.windows.ui.xaml.controls.primitives.FlyoutBase]: ...
    @flyout.setter
    def flyout(self, value: typing.Optional[winrt.windows.ui.xaml.controls.primitives.FlyoutBase]) -> None: ...
    @_property
    def command_parameter(self) -> typing.Optional[winrt.system.Object]: ...
    @command_parameter.setter
    def command_parameter(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def command(self) -> typing.Optional[winrt.windows.ui.xaml.input.ICommand]: ...
    @command.setter
    def command(self, value: typing.Optional[winrt.windows.ui.xaml.input.ICommand]) -> None: ...

@typing.final
class SplitButtonAutomationPeer(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SplitButtonAutomationPeer: ...
    def __new__(cls: typing.Type[SplitButtonAutomationPeer], owner: typing.Optional[SplitButton]) -> SplitButtonAutomationPeer:...
    def collapse(self) -> None: ...
    def expand(self) -> None: ...
    def invoke(self) -> None: ...
    @_property
    def expand_collapse_state(self) -> winrt.windows.ui.xaml.automation.ExpandCollapseState: ...

@typing.final
class SplitButtonClickEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SplitButtonClickEventArgs: ...

@typing.final
class SplitView_Static(type):
    @_property
    def compact_pane_length_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def content_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def display_mode_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_pane_open_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def open_pane_length_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def pane_background_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def pane_placement_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def pane_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def template_settings_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def light_dismiss_overlay_mode_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class SplitView(winrt.system.Object, metaclass=SplitView_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SplitView: ...
    def __new__(cls: typing.Type[SplitView]) -> SplitView:...
    def add_pane_closed(self, handler: winrt.windows.foundation.TypedEventHandler[SplitView, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pane_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pane_closing(self, handler: winrt.windows.foundation.TypedEventHandler[SplitView, SplitViewPaneClosingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pane_closing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pane_opened(self, handler: winrt.windows.foundation.TypedEventHandler[SplitView, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pane_opened(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pane_opening(self, handler: winrt.windows.foundation.TypedEventHandler[SplitView, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pane_opening(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def pane_placement(self) -> SplitViewPanePlacement: ...
    @pane_placement.setter
    def pane_placement(self, value: SplitViewPanePlacement) -> None: ...
    @_property
    def pane_background(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @pane_background.setter
    def pane_background(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def pane(self) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    @pane.setter
    def pane(self, value: typing.Optional[winrt.windows.ui.xaml.UIElement]) -> None: ...
    @_property
    def open_pane_length(self) -> winrt.system.Double: ...
    @open_pane_length.setter
    def open_pane_length(self, value: winrt.system.Double) -> None: ...
    @_property
    def is_pane_open(self) -> bool: ...
    @is_pane_open.setter
    def is_pane_open(self, value: bool) -> None: ...
    @_property
    def display_mode(self) -> SplitViewDisplayMode: ...
    @display_mode.setter
    def display_mode(self, value: SplitViewDisplayMode) -> None: ...
    @_property
    def content(self) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    @content.setter
    def content(self, value: typing.Optional[winrt.windows.ui.xaml.UIElement]) -> None: ...
    @_property
    def compact_pane_length(self) -> winrt.system.Double: ...
    @compact_pane_length.setter
    def compact_pane_length(self, value: winrt.system.Double) -> None: ...
    @_property
    def template_settings(self) -> typing.Optional[winrt.windows.ui.xaml.controls.primitives.SplitViewTemplateSettings]: ...
    @_property
    def light_dismiss_overlay_mode(self) -> LightDismissOverlayMode: ...
    @light_dismiss_overlay_mode.setter
    def light_dismiss_overlay_mode(self, value: LightDismissOverlayMode) -> None: ...

@typing.final
class SplitViewPaneClosingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SplitViewPaneClosingEventArgs: ...
    @_property
    def cancel(self) -> bool: ...
    @cancel.setter
    def cancel(self, value: bool) -> None: ...

@typing.final
class StackPanel_Static(type):
    @_property
    def are_scroll_snap_points_regular_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def orientation_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def border_brush_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def border_thickness_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def corner_radius_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def padding_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def spacing_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def background_sizing_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class StackPanel(winrt.system.Object, metaclass=StackPanel_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StackPanel: ...
    def __new__(cls: typing.Type[StackPanel]) -> StackPanel:...
    def get_insertion_indexes(self, position: winrt.windows.foundation.Point, /) -> typing.Tuple[winrt.system.Int32, winrt.system.Int32]: ...
    def get_irregular_snap_points(self, orientation: Orientation, alignment: winrt.windows.ui.xaml.controls.primitives.SnapPointsAlignment, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Single]]: ...
    def get_regular_snap_points(self, orientation: Orientation, alignment: winrt.windows.ui.xaml.controls.primitives.SnapPointsAlignment, /) -> typing.Tuple[winrt.system.Single, winrt.system.Single]: ...
    def add_horizontal_snap_points_changed(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_horizontal_snap_points_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_vertical_snap_points_changed(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_vertical_snap_points_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def orientation(self) -> Orientation: ...
    @orientation.setter
    def orientation(self, value: Orientation) -> None: ...
    @_property
    def are_scroll_snap_points_regular(self) -> bool: ...
    @are_scroll_snap_points_regular.setter
    def are_scroll_snap_points_regular(self, value: bool) -> None: ...
    @_property
    def padding(self) -> winrt.windows.ui.xaml.Thickness: ...
    @padding.setter
    def padding(self, value: winrt.windows.ui.xaml.Thickness) -> None: ...
    @_property
    def corner_radius(self) -> winrt.windows.ui.xaml.CornerRadius: ...
    @corner_radius.setter
    def corner_radius(self, value: winrt.windows.ui.xaml.CornerRadius) -> None: ...
    @_property
    def border_thickness(self) -> winrt.windows.ui.xaml.Thickness: ...
    @border_thickness.setter
    def border_thickness(self, value: winrt.windows.ui.xaml.Thickness) -> None: ...
    @_property
    def border_brush(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @border_brush.setter
    def border_brush(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def spacing(self) -> winrt.system.Double: ...
    @spacing.setter
    def spacing(self, value: winrt.system.Double) -> None: ...
    @_property
    def background_sizing(self) -> BackgroundSizing: ...
    @background_sizing.setter
    def background_sizing(self, value: BackgroundSizing) -> None: ...
    @_property
    def are_horizontal_snap_points_regular(self) -> bool: ...
    @_property
    def are_vertical_snap_points_regular(self) -> bool: ...

@typing.final
class StyleSelector(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StyleSelector: ...
    def __new__(cls: typing.Type[StyleSelector]) -> StyleSelector:...
    def select_style(self, item: typing.Optional[winrt.system.Object], container: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.windows.ui.xaml.Style]: ...
    def select_style_core(self, item: typing.Optional[winrt.system.Object], container: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.windows.ui.xaml.Style]: ...

@typing.final
class SwapChainBackgroundPanel(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SwapChainBackgroundPanel: ...
    def __new__(cls: typing.Type[SwapChainBackgroundPanel]) -> SwapChainBackgroundPanel:...
    def create_core_independent_input_source(self, device_types: winrt.windows.ui.core.CoreInputDeviceTypes, /) -> typing.Optional[winrt.windows.ui.core.CoreIndependentInputSource]: ...

@typing.final
class SwapChainPanel_Static(type):
    @_property
    def composition_scale_x_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def composition_scale_y_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class SwapChainPanel(winrt.system.Object, metaclass=SwapChainPanel_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SwapChainPanel: ...
    def __new__(cls: typing.Type[SwapChainPanel]) -> SwapChainPanel:...
    def create_core_independent_input_source(self, device_types: winrt.windows.ui.core.CoreInputDeviceTypes, /) -> typing.Optional[winrt.windows.ui.core.CoreIndependentInputSource]: ...
    def add_composition_scale_changed(self, handler: winrt.windows.foundation.TypedEventHandler[SwapChainPanel, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_composition_scale_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def composition_scale_x(self) -> winrt.system.Single: ...
    @_property
    def composition_scale_y(self) -> winrt.system.Single: ...

@typing.final
class SwipeControl_Static(type):
    @_property
    def bottom_items_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def left_items_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def right_items_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def top_items_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class SwipeControl(winrt.system.Object, metaclass=SwipeControl_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SwipeControl: ...
    def __new__(cls: typing.Type[SwipeControl]) -> SwipeControl:...
    def close(self) -> None: ...
    @_property
    def top_items(self) -> typing.Optional[SwipeItems]: ...
    @top_items.setter
    def top_items(self, value: typing.Optional[SwipeItems]) -> None: ...
    @_property
    def right_items(self) -> typing.Optional[SwipeItems]: ...
    @right_items.setter
    def right_items(self, value: typing.Optional[SwipeItems]) -> None: ...
    @_property
    def left_items(self) -> typing.Optional[SwipeItems]: ...
    @left_items.setter
    def left_items(self, value: typing.Optional[SwipeItems]) -> None: ...
    @_property
    def bottom_items(self) -> typing.Optional[SwipeItems]: ...
    @bottom_items.setter
    def bottom_items(self, value: typing.Optional[SwipeItems]) -> None: ...

@typing.final
class SwipeItem_Static(type):
    @_property
    def background_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def behavior_on_invoked_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def command_parameter_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def command_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def foreground_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def icon_source_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def text_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class SwipeItem(winrt.system.Object, metaclass=SwipeItem_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SwipeItem: ...
    def __new__(cls: typing.Type[SwipeItem]) -> SwipeItem:...
    def add_invoked(self, handler: winrt.windows.foundation.TypedEventHandler[SwipeItem, SwipeItemInvokedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_invoked(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def text(self) -> str: ...
    @text.setter
    def text(self, value: str) -> None: ...
    @_property
    def icon_source(self) -> typing.Optional[IconSource]: ...
    @icon_source.setter
    def icon_source(self, value: typing.Optional[IconSource]) -> None: ...
    @_property
    def foreground(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @foreground.setter
    def foreground(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def command_parameter(self) -> typing.Optional[winrt.system.Object]: ...
    @command_parameter.setter
    def command_parameter(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def command(self) -> typing.Optional[winrt.windows.ui.xaml.input.ICommand]: ...
    @command.setter
    def command(self, value: typing.Optional[winrt.windows.ui.xaml.input.ICommand]) -> None: ...
    @_property
    def behavior_on_invoked(self) -> SwipeBehaviorOnInvoked: ...
    @behavior_on_invoked.setter
    def behavior_on_invoked(self, value: SwipeBehaviorOnInvoked) -> None: ...
    @_property
    def background(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @background.setter
    def background(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...

@typing.final
class SwipeItemInvokedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SwipeItemInvokedEventArgs: ...
    @_property
    def swipe_control(self) -> typing.Optional[SwipeControl]: ...

@typing.final
class SwipeItems_Static(type):
    @_property
    def mode_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class SwipeItems(winrt.system.Object, winrt._winrt.MutableSequence[SwipeItem], metaclass=SwipeItems_Static):
    def __len__(self) -> int: ...
    def __iter__(self) -> winrt.windows.foundation.collections.IIterator[SwipeItem]: ...
    @typing.overload
    def __getitem__(self, index: typing.SupportsIndex) -> SwipeItem: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[SwipeItem]: ...
    @typing.overload
    def __delitem__(self, index: typing.SupportsIndex) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: typing.SupportsIndex, value: SwipeItem) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[SwipeItem]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SwipeItems: ...
    def __new__(cls: typing.Type[SwipeItems]) -> SwipeItems:...
    def append(self, value: typing.Optional[SwipeItem], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[SwipeItem]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[SwipeItem]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[SwipeItem], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[SwipeItem]]: ...
    def index_of(self, value: typing.Optional[SwipeItem], /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[SwipeItem], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[SwipeItem], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[SwipeItem], /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...
    @_property
    def mode(self) -> SwipeMode: ...
    @mode.setter
    def mode(self, value: SwipeMode) -> None: ...

@typing.final
class SymbolIcon_Static(type):
    @_property
    def symbol_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class SymbolIcon(winrt.system.Object, metaclass=SymbolIcon_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SymbolIcon: ...
    @typing.overload
    def __new__(cls: typing.Type[SymbolIcon], symbol: Symbol) -> SymbolIcon:...
    @typing.overload
    def __new__(cls: typing.Type[SymbolIcon]) -> SymbolIcon:...
    @_property
    def symbol(self) -> Symbol: ...
    @symbol.setter
    def symbol(self, value: Symbol) -> None: ...

@typing.final
class SymbolIconSource_Static(type):
    @_property
    def symbol_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class SymbolIconSource(winrt.system.Object, metaclass=SymbolIconSource_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SymbolIconSource: ...
    def __new__(cls: typing.Type[SymbolIconSource]) -> SymbolIconSource:...
    @_property
    def symbol(self) -> Symbol: ...
    @symbol.setter
    def symbol(self, value: Symbol) -> None: ...

@typing.final
class TextBlock_Static(type):
    @_property
    def character_spacing_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def font_family_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def font_size_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def font_stretch_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def font_style_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def font_weight_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def foreground_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_text_selection_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def line_height_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def line_stacking_strategy_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def padding_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selected_text_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def text_alignment_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def text_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def text_trimming_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def text_wrapping_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_color_font_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def max_lines_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def optical_margin_alignment_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selection_highlight_color_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def text_line_bounds_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def text_reading_order_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_text_scale_factor_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def text_decorations_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def horizontal_text_alignment_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_text_trimmed_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selection_flyout_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class TextBlock(winrt.system.Object, metaclass=TextBlock_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextBlock: ...
    def __new__(cls: typing.Type[TextBlock]) -> TextBlock:...
    def copy_selection_to_clipboard(self) -> None: ...
    def focus(self, value: winrt.windows.ui.xaml.FocusState, /) -> bool: ...
    def get_alpha_mask(self) -> typing.Optional[winrt.windows.ui.composition.CompositionBrush]: ...
    def select(self, start: typing.Optional[winrt.windows.ui.xaml.documents.TextPointer], end: typing.Optional[winrt.windows.ui.xaml.documents.TextPointer], /) -> None: ...
    def select_all(self) -> None: ...
    def add_context_menu_opening(self, handler: typing.Optional[ContextMenuOpeningEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_context_menu_opening(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_selection_changed(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_selection_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_is_text_trimmed_changed(self, handler: winrt.windows.foundation.TypedEventHandler[TextBlock, IsTextTrimmedChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_is_text_trimmed_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def text_wrapping(self) -> winrt.windows.ui.xaml.TextWrapping: ...
    @text_wrapping.setter
    def text_wrapping(self, value: winrt.windows.ui.xaml.TextWrapping) -> None: ...
    @_property
    def text_trimming(self) -> winrt.windows.ui.xaml.TextTrimming: ...
    @text_trimming.setter
    def text_trimming(self, value: winrt.windows.ui.xaml.TextTrimming) -> None: ...
    @_property
    def text_alignment(self) -> winrt.windows.ui.xaml.TextAlignment: ...
    @text_alignment.setter
    def text_alignment(self, value: winrt.windows.ui.xaml.TextAlignment) -> None: ...
    @_property
    def text(self) -> str: ...
    @text.setter
    def text(self, value: str) -> None: ...
    @_property
    def padding(self) -> winrt.windows.ui.xaml.Thickness: ...
    @padding.setter
    def padding(self, value: winrt.windows.ui.xaml.Thickness) -> None: ...
    @_property
    def foreground(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @foreground.setter
    def foreground(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def font_weight(self) -> winrt.windows.ui.text.FontWeight: ...
    @font_weight.setter
    def font_weight(self, value: winrt.windows.ui.text.FontWeight) -> None: ...
    @_property
    def font_style(self) -> winrt.windows.ui.text.FontStyle: ...
    @font_style.setter
    def font_style(self, value: winrt.windows.ui.text.FontStyle) -> None: ...
    @_property
    def font_stretch(self) -> winrt.windows.ui.text.FontStretch: ...
    @font_stretch.setter
    def font_stretch(self, value: winrt.windows.ui.text.FontStretch) -> None: ...
    @_property
    def font_size(self) -> winrt.system.Double: ...
    @font_size.setter
    def font_size(self, value: winrt.system.Double) -> None: ...
    @_property
    def font_family(self) -> typing.Optional[winrt.windows.ui.xaml.media.FontFamily]: ...
    @font_family.setter
    def font_family(self, value: typing.Optional[winrt.windows.ui.xaml.media.FontFamily]) -> None: ...
    @_property
    def line_stacking_strategy(self) -> winrt.windows.ui.xaml.LineStackingStrategy: ...
    @line_stacking_strategy.setter
    def line_stacking_strategy(self, value: winrt.windows.ui.xaml.LineStackingStrategy) -> None: ...
    @_property
    def line_height(self) -> winrt.system.Double: ...
    @line_height.setter
    def line_height(self, value: winrt.system.Double) -> None: ...
    @_property
    def character_spacing(self) -> winrt.system.Int32: ...
    @character_spacing.setter
    def character_spacing(self, value: winrt.system.Int32) -> None: ...
    @_property
    def is_text_selection_enabled(self) -> bool: ...
    @is_text_selection_enabled.setter
    def is_text_selection_enabled(self, value: bool) -> None: ...
    @_property
    def selected_text(self) -> str: ...
    @_property
    def selection_end(self) -> typing.Optional[winrt.windows.ui.xaml.documents.TextPointer]: ...
    @_property
    def selection_start(self) -> typing.Optional[winrt.windows.ui.xaml.documents.TextPointer]: ...
    @_property
    def baseline_offset(self) -> winrt.system.Double: ...
    @_property
    def content_end(self) -> typing.Optional[winrt.windows.ui.xaml.documents.TextPointer]: ...
    @_property
    def content_start(self) -> typing.Optional[winrt.windows.ui.xaml.documents.TextPointer]: ...
    @_property
    def inlines(self) -> typing.Optional[winrt.windows.ui.xaml.documents.InlineCollection]: ...
    @_property
    def text_reading_order(self) -> winrt.windows.ui.xaml.TextReadingOrder: ...
    @text_reading_order.setter
    def text_reading_order(self, value: winrt.windows.ui.xaml.TextReadingOrder) -> None: ...
    @_property
    def text_line_bounds(self) -> winrt.windows.ui.xaml.TextLineBounds: ...
    @text_line_bounds.setter
    def text_line_bounds(self, value: winrt.windows.ui.xaml.TextLineBounds) -> None: ...
    @_property
    def selection_highlight_color(self) -> typing.Optional[winrt.windows.ui.xaml.media.SolidColorBrush]: ...
    @selection_highlight_color.setter
    def selection_highlight_color(self, value: typing.Optional[winrt.windows.ui.xaml.media.SolidColorBrush]) -> None: ...
    @_property
    def optical_margin_alignment(self) -> winrt.windows.ui.xaml.OpticalMarginAlignment: ...
    @optical_margin_alignment.setter
    def optical_margin_alignment(self, value: winrt.windows.ui.xaml.OpticalMarginAlignment) -> None: ...
    @_property
    def max_lines(self) -> winrt.system.Int32: ...
    @max_lines.setter
    def max_lines(self, value: winrt.system.Int32) -> None: ...
    @_property
    def is_color_font_enabled(self) -> bool: ...
    @is_color_font_enabled.setter
    def is_color_font_enabled(self, value: bool) -> None: ...
    @_property
    def is_text_scale_factor_enabled(self) -> bool: ...
    @is_text_scale_factor_enabled.setter
    def is_text_scale_factor_enabled(self, value: bool) -> None: ...
    @_property
    def text_decorations(self) -> winrt.windows.ui.text.TextDecorations: ...
    @text_decorations.setter
    def text_decorations(self, value: winrt.windows.ui.text.TextDecorations) -> None: ...
    @_property
    def horizontal_text_alignment(self) -> winrt.windows.ui.xaml.TextAlignment: ...
    @horizontal_text_alignment.setter
    def horizontal_text_alignment(self, value: winrt.windows.ui.xaml.TextAlignment) -> None: ...
    @_property
    def is_text_trimmed(self) -> bool: ...
    @_property
    def text_highlighters(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.ui.xaml.documents.TextHighlighter]]: ...
    @_property
    def selection_flyout(self) -> typing.Optional[winrt.windows.ui.xaml.controls.primitives.FlyoutBase]: ...
    @selection_flyout.setter
    def selection_flyout(self, value: typing.Optional[winrt.windows.ui.xaml.controls.primitives.FlyoutBase]) -> None: ...

@typing.final
class TextBox_Static(type):
    @_property
    def text_wrapping_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def text_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def text_alignment_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def max_length_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_text_prediction_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_spell_check_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_read_only_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def input_scope_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def accepts_return_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def header_template_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def header_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selection_highlight_color_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def prevent_keyboard_display_on_programmatic_focus_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def placeholder_text_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_color_font_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def desired_candidate_window_alignment_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def text_reading_order_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selection_highlight_color_when_not_focused_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def placeholder_foreground_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def horizontal_text_alignment_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def character_casing_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_handwriting_view_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def handwriting_view_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selection_flyout_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def proofing_menu_flyout_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def description_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def can_undo_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def can_redo_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def can_paste_clipboard_content_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class TextBox(winrt.system.Object, metaclass=TextBox_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextBox: ...
    def __new__(cls: typing.Type[TextBox]) -> TextBox:...
    def clear_undo_redo_history(self) -> None: ...
    def copy_selection_to_clipboard(self) -> None: ...
    def cut_selection_to_clipboard(self) -> None: ...
    def get_linguistic_alternatives_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[str]]: ...
    def get_rect_from_character_index(self, char_index: winrt.system.Int32, trailing_edge: bool, /) -> winrt.windows.foundation.Rect: ...
    def paste_from_clipboard(self) -> None: ...
    def redo(self) -> None: ...
    def select(self, start: winrt.system.Int32, length: winrt.system.Int32, /) -> None: ...
    def select_all(self) -> None: ...
    def undo(self) -> None: ...
    def add_context_menu_opening(self, handler: typing.Optional[ContextMenuOpeningEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_context_menu_opening(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_selection_changed(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_selection_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_text_changed(self, handler: typing.Optional[TextChangedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_text_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_paste(self, handler: typing.Optional[TextControlPasteEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_paste(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_candidate_window_bounds_changed(self, handler: winrt.windows.foundation.TypedEventHandler[TextBox, CandidateWindowBoundsChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_candidate_window_bounds_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_text_changing(self, handler: winrt.windows.foundation.TypedEventHandler[TextBox, TextBoxTextChangingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_text_changing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_text_composition_changed(self, handler: winrt.windows.foundation.TypedEventHandler[TextBox, TextCompositionChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_text_composition_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_text_composition_ended(self, handler: winrt.windows.foundation.TypedEventHandler[TextBox, TextCompositionEndedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_text_composition_ended(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_text_composition_started(self, handler: winrt.windows.foundation.TypedEventHandler[TextBox, TextCompositionStartedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_text_composition_started(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_before_text_changing(self, handler: winrt.windows.foundation.TypedEventHandler[TextBox, TextBoxBeforeTextChangingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_before_text_changing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_copying_to_clipboard(self, handler: winrt.windows.foundation.TypedEventHandler[TextBox, TextControlCopyingToClipboardEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_copying_to_clipboard(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_cutting_to_clipboard(self, handler: winrt.windows.foundation.TypedEventHandler[TextBox, TextControlCuttingToClipboardEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_cutting_to_clipboard(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_selection_changing(self, handler: winrt.windows.foundation.TypedEventHandler[TextBox, TextBoxSelectionChangingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_selection_changing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def text_wrapping(self) -> winrt.windows.ui.xaml.TextWrapping: ...
    @text_wrapping.setter
    def text_wrapping(self, value: winrt.windows.ui.xaml.TextWrapping) -> None: ...
    @_property
    def text_alignment(self) -> winrt.windows.ui.xaml.TextAlignment: ...
    @text_alignment.setter
    def text_alignment(self, value: winrt.windows.ui.xaml.TextAlignment) -> None: ...
    @_property
    def text(self) -> str: ...
    @text.setter
    def text(self, value: str) -> None: ...
    @_property
    def selection_start(self) -> winrt.system.Int32: ...
    @selection_start.setter
    def selection_start(self, value: winrt.system.Int32) -> None: ...
    @_property
    def selection_length(self) -> winrt.system.Int32: ...
    @selection_length.setter
    def selection_length(self, value: winrt.system.Int32) -> None: ...
    @_property
    def selected_text(self) -> str: ...
    @selected_text.setter
    def selected_text(self, value: str) -> None: ...
    @_property
    def max_length(self) -> winrt.system.Int32: ...
    @max_length.setter
    def max_length(self, value: winrt.system.Int32) -> None: ...
    @_property
    def is_text_prediction_enabled(self) -> bool: ...
    @is_text_prediction_enabled.setter
    def is_text_prediction_enabled(self, value: bool) -> None: ...
    @_property
    def is_spell_check_enabled(self) -> bool: ...
    @is_spell_check_enabled.setter
    def is_spell_check_enabled(self, value: bool) -> None: ...
    @_property
    def is_read_only(self) -> bool: ...
    @is_read_only.setter
    def is_read_only(self, value: bool) -> None: ...
    @_property
    def input_scope(self) -> typing.Optional[winrt.windows.ui.xaml.input.InputScope]: ...
    @input_scope.setter
    def input_scope(self, value: typing.Optional[winrt.windows.ui.xaml.input.InputScope]) -> None: ...
    @_property
    def accepts_return(self) -> bool: ...
    @accepts_return.setter
    def accepts_return(self, value: bool) -> None: ...
    @_property
    def is_color_font_enabled(self) -> bool: ...
    @is_color_font_enabled.setter
    def is_color_font_enabled(self, value: bool) -> None: ...
    @_property
    def placeholder_text(self) -> str: ...
    @placeholder_text.setter
    def placeholder_text(self, value: str) -> None: ...
    @_property
    def prevent_keyboard_display_on_programmatic_focus(self) -> bool: ...
    @prevent_keyboard_display_on_programmatic_focus.setter
    def prevent_keyboard_display_on_programmatic_focus(self, value: bool) -> None: ...
    @_property
    def selection_highlight_color(self) -> typing.Optional[winrt.windows.ui.xaml.media.SolidColorBrush]: ...
    @selection_highlight_color.setter
    def selection_highlight_color(self, value: typing.Optional[winrt.windows.ui.xaml.media.SolidColorBrush]) -> None: ...
    @_property
    def header_template(self) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @header_template.setter
    def header_template(self, value: typing.Optional[winrt.windows.ui.xaml.DataTemplate]) -> None: ...
    @_property
    def header(self) -> typing.Optional[winrt.system.Object]: ...
    @header.setter
    def header(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def desired_candidate_window_alignment(self) -> CandidateWindowAlignment: ...
    @desired_candidate_window_alignment.setter
    def desired_candidate_window_alignment(self, value: CandidateWindowAlignment) -> None: ...
    @_property
    def text_reading_order(self) -> winrt.windows.ui.xaml.TextReadingOrder: ...
    @text_reading_order.setter
    def text_reading_order(self, value: winrt.windows.ui.xaml.TextReadingOrder) -> None: ...
    @_property
    def selection_highlight_color_when_not_focused(self) -> typing.Optional[winrt.windows.ui.xaml.media.SolidColorBrush]: ...
    @selection_highlight_color_when_not_focused.setter
    def selection_highlight_color_when_not_focused(self, value: typing.Optional[winrt.windows.ui.xaml.media.SolidColorBrush]) -> None: ...
    @_property
    def placeholder_foreground(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @placeholder_foreground.setter
    def placeholder_foreground(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def horizontal_text_alignment(self) -> winrt.windows.ui.xaml.TextAlignment: ...
    @horizontal_text_alignment.setter
    def horizontal_text_alignment(self, value: winrt.windows.ui.xaml.TextAlignment) -> None: ...
    @_property
    def character_casing(self) -> CharacterCasing: ...
    @character_casing.setter
    def character_casing(self, value: CharacterCasing) -> None: ...
    @_property
    def is_handwriting_view_enabled(self) -> bool: ...
    @is_handwriting_view_enabled.setter
    def is_handwriting_view_enabled(self, value: bool) -> None: ...
    @_property
    def handwriting_view(self) -> typing.Optional[HandwritingView]: ...
    @handwriting_view.setter
    def handwriting_view(self, value: typing.Optional[HandwritingView]) -> None: ...
    @_property
    def selection_flyout(self) -> typing.Optional[winrt.windows.ui.xaml.controls.primitives.FlyoutBase]: ...
    @selection_flyout.setter
    def selection_flyout(self, value: typing.Optional[winrt.windows.ui.xaml.controls.primitives.FlyoutBase]) -> None: ...
    @_property
    def description(self) -> typing.Optional[winrt.system.Object]: ...
    @description.setter
    def description(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def can_paste_clipboard_content(self) -> bool: ...
    @_property
    def can_redo(self) -> bool: ...
    @_property
    def can_undo(self) -> bool: ...
    @_property
    def proofing_menu_flyout(self) -> typing.Optional[winrt.windows.ui.xaml.controls.primitives.FlyoutBase]: ...

@typing.final
class TextBoxBeforeTextChangingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextBoxBeforeTextChangingEventArgs: ...
    @_property
    def cancel(self) -> bool: ...
    @cancel.setter
    def cancel(self, value: bool) -> None: ...
    @_property
    def new_text(self) -> str: ...

@typing.final
class TextBoxSelectionChangingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextBoxSelectionChangingEventArgs: ...
    @_property
    def cancel(self) -> bool: ...
    @cancel.setter
    def cancel(self, value: bool) -> None: ...
    @_property
    def selection_length(self) -> winrt.system.Int32: ...
    @_property
    def selection_start(self) -> winrt.system.Int32: ...

@typing.final
class TextBoxTextChangingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextBoxTextChangingEventArgs: ...
    @_property
    def is_content_changing(self) -> bool: ...

@typing.final
class TextChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextChangedEventArgs: ...

@typing.final
class TextCommandBarFlyout(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextCommandBarFlyout: ...
    def __new__(cls: typing.Type[TextCommandBarFlyout]) -> TextCommandBarFlyout:...

@typing.final
class TextCompositionChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextCompositionChangedEventArgs: ...
    @_property
    def length(self) -> winrt.system.Int32: ...
    @_property
    def start_index(self) -> winrt.system.Int32: ...

@typing.final
class TextCompositionEndedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextCompositionEndedEventArgs: ...
    @_property
    def length(self) -> winrt.system.Int32: ...
    @_property
    def start_index(self) -> winrt.system.Int32: ...

@typing.final
class TextCompositionStartedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextCompositionStartedEventArgs: ...
    @_property
    def length(self) -> winrt.system.Int32: ...
    @_property
    def start_index(self) -> winrt.system.Int32: ...

@typing.final
class TextControlCopyingToClipboardEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextControlCopyingToClipboardEventArgs: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...

@typing.final
class TextControlCuttingToClipboardEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextControlCuttingToClipboardEventArgs: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...

@typing.final
class TextControlPasteEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextControlPasteEventArgs: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...

@typing.final
class TimePickedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimePickedEventArgs: ...
    def __new__(cls: typing.Type[TimePickedEventArgs]) -> TimePickedEventArgs:...
    @_property
    def new_time(self) -> datetime.timedelta: ...
    @_property
    def old_time(self) -> datetime.timedelta: ...

@typing.final
class TimePicker_Static(type):
    @_property
    def clock_identifier_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def header_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def header_template_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def minute_increment_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def time_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def light_dismiss_overlay_mode_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def selected_time_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class TimePicker(winrt.system.Object, metaclass=TimePicker_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimePicker: ...
    def __new__(cls: typing.Type[TimePicker]) -> TimePicker:...
    def add_time_changed(self, handler: winrt.windows.foundation.EventHandler[TimePickerValueChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_time_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_selected_time_changed(self, handler: winrt.windows.foundation.TypedEventHandler[TimePicker, TimePickerSelectedValueChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_selected_time_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def time(self) -> datetime.timedelta: ...
    @time.setter
    def time(self, value: datetime.timedelta) -> None: ...
    @_property
    def minute_increment(self) -> winrt.system.Int32: ...
    @minute_increment.setter
    def minute_increment(self, value: winrt.system.Int32) -> None: ...
    @_property
    def header_template(self) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @header_template.setter
    def header_template(self, value: typing.Optional[winrt.windows.ui.xaml.DataTemplate]) -> None: ...
    @_property
    def header(self) -> typing.Optional[winrt.system.Object]: ...
    @header.setter
    def header(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def clock_identifier(self) -> str: ...
    @clock_identifier.setter
    def clock_identifier(self, value: str) -> None: ...
    @_property
    def light_dismiss_overlay_mode(self) -> LightDismissOverlayMode: ...
    @light_dismiss_overlay_mode.setter
    def light_dismiss_overlay_mode(self, value: LightDismissOverlayMode) -> None: ...
    @_property
    def selected_time(self) -> typing.Optional[typing.Optional[datetime.timedelta]]: ...
    @selected_time.setter
    def selected_time(self, value: typing.Optional[typing.Optional[datetime.timedelta]]) -> None: ...

@typing.final
class TimePickerFlyout_Static(type):
    @_property
    def clock_identifier_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def minute_increment_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def time_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class TimePickerFlyout(winrt.system.Object, metaclass=TimePickerFlyout_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimePickerFlyout: ...
    def __new__(cls: typing.Type[TimePickerFlyout]) -> TimePickerFlyout:...
    def show_at_async(self, target: typing.Optional[winrt.windows.ui.xaml.FrameworkElement], /) -> winrt.windows.foundation.IAsyncOperation[typing.Optional[datetime.timedelta]]: ...
    def add_time_picked(self, handler: winrt.windows.foundation.TypedEventHandler[TimePickerFlyout, TimePickedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_time_picked(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def time(self) -> datetime.timedelta: ...
    @time.setter
    def time(self, value: datetime.timedelta) -> None: ...
    @_property
    def minute_increment(self) -> winrt.system.Int32: ...
    @minute_increment.setter
    def minute_increment(self, value: winrt.system.Int32) -> None: ...
    @_property
    def clock_identifier(self) -> str: ...
    @clock_identifier.setter
    def clock_identifier(self, value: str) -> None: ...

@typing.final
class TimePickerFlyoutPresenter_Static(type):
    @_property
    def is_default_shadow_enabled_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class TimePickerFlyoutPresenter(winrt.system.Object, metaclass=TimePickerFlyoutPresenter_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimePickerFlyoutPresenter: ...
    @_property
    def is_default_shadow_enabled(self) -> bool: ...
    @is_default_shadow_enabled.setter
    def is_default_shadow_enabled(self, value: bool) -> None: ...

@typing.final
class TimePickerSelectedValueChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimePickerSelectedValueChangedEventArgs: ...
    @_property
    def new_time(self) -> typing.Optional[typing.Optional[datetime.timedelta]]: ...
    @_property
    def old_time(self) -> typing.Optional[typing.Optional[datetime.timedelta]]: ...

@typing.final
class TimePickerValueChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimePickerValueChangedEventArgs: ...
    @_property
    def new_time(self) -> datetime.timedelta: ...
    @_property
    def old_time(self) -> datetime.timedelta: ...

@typing.final
class ToggleMenuFlyoutItem_Static(type):
    @_property
    def is_checked_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class ToggleMenuFlyoutItem(winrt.system.Object, metaclass=ToggleMenuFlyoutItem_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToggleMenuFlyoutItem: ...
    def __new__(cls: typing.Type[ToggleMenuFlyoutItem]) -> ToggleMenuFlyoutItem:...
    @_property
    def is_checked(self) -> bool: ...
    @is_checked.setter
    def is_checked(self, value: bool) -> None: ...

@typing.final
class ToggleSplitButton(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToggleSplitButton: ...
    def __new__(cls: typing.Type[ToggleSplitButton]) -> ToggleSplitButton:...
    def add_is_checked_changed(self, handler: winrt.windows.foundation.TypedEventHandler[ToggleSplitButton, ToggleSplitButtonIsCheckedChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_is_checked_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def is_checked(self) -> bool: ...
    @is_checked.setter
    def is_checked(self, value: bool) -> None: ...

@typing.final
class ToggleSplitButtonAutomationPeer(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToggleSplitButtonAutomationPeer: ...
    def __new__(cls: typing.Type[ToggleSplitButtonAutomationPeer], owner: typing.Optional[ToggleSplitButton]) -> ToggleSplitButtonAutomationPeer:...
    def collapse(self) -> None: ...
    def expand(self) -> None: ...
    def toggle(self) -> None: ...
    @_property
    def expand_collapse_state(self) -> winrt.windows.ui.xaml.automation.ExpandCollapseState: ...
    @_property
    def toggle_state(self) -> winrt.windows.ui.xaml.automation.ToggleState: ...

@typing.final
class ToggleSplitButtonIsCheckedChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToggleSplitButtonIsCheckedChangedEventArgs: ...

@typing.final
class ToggleSwitch_Static(type):
    @_property
    def header_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def header_template_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_on_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def off_content_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def off_content_template_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def on_content_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def on_content_template_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class ToggleSwitch(winrt.system.Object, metaclass=ToggleSwitch_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToggleSwitch: ...
    def __new__(cls: typing.Type[ToggleSwitch]) -> ToggleSwitch:...
    def on_header_changed(self, old_content: typing.Optional[winrt.system.Object], new_content: typing.Optional[winrt.system.Object], /) -> None: ...
    def on_off_content_changed(self, old_content: typing.Optional[winrt.system.Object], new_content: typing.Optional[winrt.system.Object], /) -> None: ...
    def on_on_content_changed(self, old_content: typing.Optional[winrt.system.Object], new_content: typing.Optional[winrt.system.Object], /) -> None: ...
    def on_toggled(self) -> None: ...
    def add_toggled(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_toggled(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def on_content_template(self) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @on_content_template.setter
    def on_content_template(self, value: typing.Optional[winrt.windows.ui.xaml.DataTemplate]) -> None: ...
    @_property
    def on_content(self) -> typing.Optional[winrt.system.Object]: ...
    @on_content.setter
    def on_content(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def off_content_template(self) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @off_content_template.setter
    def off_content_template(self, value: typing.Optional[winrt.windows.ui.xaml.DataTemplate]) -> None: ...
    @_property
    def off_content(self) -> typing.Optional[winrt.system.Object]: ...
    @off_content.setter
    def off_content(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def is_on(self) -> bool: ...
    @is_on.setter
    def is_on(self, value: bool) -> None: ...
    @_property
    def header_template(self) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @header_template.setter
    def header_template(self, value: typing.Optional[winrt.windows.ui.xaml.DataTemplate]) -> None: ...
    @_property
    def header(self) -> typing.Optional[winrt.system.Object]: ...
    @header.setter
    def header(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def template_settings(self) -> typing.Optional[winrt.windows.ui.xaml.controls.primitives.ToggleSwitchTemplateSettings]: ...

@typing.final
class ToolTip_Static(type):
    @_property
    def horizontal_offset_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_open_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def placement_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def placement_target_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def vertical_offset_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def placement_rect_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class ToolTip(winrt.system.Object, metaclass=ToolTip_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToolTip: ...
    def __new__(cls: typing.Type[ToolTip]) -> ToolTip:...
    def add_closed(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_opened(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_opened(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def vertical_offset(self) -> winrt.system.Double: ...
    @vertical_offset.setter
    def vertical_offset(self, value: winrt.system.Double) -> None: ...
    @_property
    def placement_target(self) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    @placement_target.setter
    def placement_target(self, value: typing.Optional[winrt.windows.ui.xaml.UIElement]) -> None: ...
    @_property
    def placement(self) -> winrt.windows.ui.xaml.controls.primitives.PlacementMode: ...
    @placement.setter
    def placement(self, value: winrt.windows.ui.xaml.controls.primitives.PlacementMode) -> None: ...
    @_property
    def is_open(self) -> bool: ...
    @is_open.setter
    def is_open(self, value: bool) -> None: ...
    @_property
    def horizontal_offset(self) -> winrt.system.Double: ...
    @horizontal_offset.setter
    def horizontal_offset(self, value: winrt.system.Double) -> None: ...
    @_property
    def template_settings(self) -> typing.Optional[winrt.windows.ui.xaml.controls.primitives.ToolTipTemplateSettings]: ...
    @_property
    def placement_rect(self) -> typing.Optional[typing.Optional[winrt.windows.foundation.Rect]]: ...
    @placement_rect.setter
    def placement_rect(self, value: typing.Optional[typing.Optional[winrt.windows.foundation.Rect]]) -> None: ...

@typing.final
class ToolTipService_Static(type):
    def get_placement(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> winrt.windows.ui.xaml.controls.primitives.PlacementMode: ...
    def get_placement_target(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    def get_tool_tip(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.system.Object]: ...
    def set_placement(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], value: winrt.windows.ui.xaml.controls.primitives.PlacementMode, /) -> None: ...
    def set_placement_target(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], value: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> None: ...
    def set_tool_tip(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], value: typing.Optional[winrt.system.Object], /) -> None: ...
    @_property
    def placement_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def placement_target_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def tool_tip_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class ToolTipService(winrt.system.Object, metaclass=ToolTipService_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToolTipService: ...

@typing.final
class TreeView_Static(type):
    @_property
    def selection_mode_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def can_drag_items_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def can_reorder_items_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def item_container_style_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def item_container_style_selector_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def item_container_transitions_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def item_template_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def item_template_selector_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def items_source_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class TreeView(winrt.system.Object, metaclass=TreeView_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TreeView: ...
    def __new__(cls: typing.Type[TreeView]) -> TreeView:...
    def collapse(self, value: typing.Optional[TreeViewNode], /) -> None: ...
    def container_from_item(self, item: typing.Optional[winrt.system.Object], /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    def container_from_node(self, node: typing.Optional[TreeViewNode], /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    def expand(self, value: typing.Optional[TreeViewNode], /) -> None: ...
    def item_from_container(self, container: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.system.Object]: ...
    def node_from_container(self, container: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[TreeViewNode]: ...
    def select_all(self) -> None: ...
    def add_collapsed(self, handler: winrt.windows.foundation.TypedEventHandler[TreeView, TreeViewCollapsedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_collapsed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_expanding(self, handler: winrt.windows.foundation.TypedEventHandler[TreeView, TreeViewExpandingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_expanding(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_item_invoked(self, handler: winrt.windows.foundation.TypedEventHandler[TreeView, TreeViewItemInvokedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_item_invoked(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_drag_items_completed(self, handler: winrt.windows.foundation.TypedEventHandler[TreeView, TreeViewDragItemsCompletedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_drag_items_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_drag_items_starting(self, handler: winrt.windows.foundation.TypedEventHandler[TreeView, TreeViewDragItemsStartingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_drag_items_starting(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def selection_mode(self) -> TreeViewSelectionMode: ...
    @selection_mode.setter
    def selection_mode(self, value: TreeViewSelectionMode) -> None: ...
    @_property
    def root_nodes(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[TreeViewNode]]: ...
    @_property
    def selected_nodes(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[TreeViewNode]]: ...
    @_property
    def items_source(self) -> typing.Optional[winrt.system.Object]: ...
    @items_source.setter
    def items_source(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def item_template_selector(self) -> typing.Optional[DataTemplateSelector]: ...
    @item_template_selector.setter
    def item_template_selector(self, value: typing.Optional[DataTemplateSelector]) -> None: ...
    @_property
    def item_template(self) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @item_template.setter
    def item_template(self, value: typing.Optional[winrt.windows.ui.xaml.DataTemplate]) -> None: ...
    @_property
    def item_container_transitions(self) -> typing.Optional[winrt.windows.ui.xaml.media.animation.TransitionCollection]: ...
    @item_container_transitions.setter
    def item_container_transitions(self, value: typing.Optional[winrt.windows.ui.xaml.media.animation.TransitionCollection]) -> None: ...
    @_property
    def item_container_style_selector(self) -> typing.Optional[StyleSelector]: ...
    @item_container_style_selector.setter
    def item_container_style_selector(self, value: typing.Optional[StyleSelector]) -> None: ...
    @_property
    def item_container_style(self) -> typing.Optional[winrt.windows.ui.xaml.Style]: ...
    @item_container_style.setter
    def item_container_style(self, value: typing.Optional[winrt.windows.ui.xaml.Style]) -> None: ...
    @_property
    def can_reorder_items(self) -> bool: ...
    @can_reorder_items.setter
    def can_reorder_items(self, value: bool) -> None: ...
    @_property
    def can_drag_items(self) -> bool: ...
    @can_drag_items.setter
    def can_drag_items(self, value: bool) -> None: ...

@typing.final
class TreeViewCollapsedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TreeViewCollapsedEventArgs: ...
    @_property
    def node(self) -> typing.Optional[TreeViewNode]: ...
    @_property
    def item(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class TreeViewDragItemsCompletedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TreeViewDragItemsCompletedEventArgs: ...
    @_property
    def drop_result(self) -> winrt.windows.applicationmodel.datatransfer.DataPackageOperation: ...
    @_property
    def items(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Object]]: ...

@typing.final
class TreeViewDragItemsStartingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TreeViewDragItemsStartingEventArgs: ...
    @_property
    def cancel(self) -> bool: ...
    @cancel.setter
    def cancel(self, value: bool) -> None: ...
    @_property
    def data(self) -> typing.Optional[winrt.windows.applicationmodel.datatransfer.DataPackage]: ...
    @_property
    def items(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.system.Object]]: ...

@typing.final
class TreeViewExpandingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TreeViewExpandingEventArgs: ...
    @_property
    def node(self) -> typing.Optional[TreeViewNode]: ...
    @_property
    def item(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class TreeViewItem_Static(type):
    @_property
    def collapsed_glyph_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def expanded_glyph_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def glyph_brush_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def glyph_opacity_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def glyph_size_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_expanded_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def tree_view_item_template_settings_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def has_unrealized_children_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def items_source_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class TreeViewItem(winrt.system.Object, metaclass=TreeViewItem_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TreeViewItem: ...
    def __new__(cls: typing.Type[TreeViewItem]) -> TreeViewItem:...
    @_property
    def is_expanded(self) -> bool: ...
    @is_expanded.setter
    def is_expanded(self, value: bool) -> None: ...
    @_property
    def glyph_size(self) -> winrt.system.Double: ...
    @glyph_size.setter
    def glyph_size(self, value: winrt.system.Double) -> None: ...
    @_property
    def glyph_opacity(self) -> winrt.system.Double: ...
    @glyph_opacity.setter
    def glyph_opacity(self, value: winrt.system.Double) -> None: ...
    @_property
    def glyph_brush(self) -> typing.Optional[winrt.windows.ui.xaml.media.Brush]: ...
    @glyph_brush.setter
    def glyph_brush(self, value: typing.Optional[winrt.windows.ui.xaml.media.Brush]) -> None: ...
    @_property
    def expanded_glyph(self) -> str: ...
    @expanded_glyph.setter
    def expanded_glyph(self, value: str) -> None: ...
    @_property
    def collapsed_glyph(self) -> str: ...
    @collapsed_glyph.setter
    def collapsed_glyph(self, value: str) -> None: ...
    @_property
    def tree_view_item_template_settings(self) -> typing.Optional[TreeViewItemTemplateSettings]: ...
    @_property
    def items_source(self) -> typing.Optional[winrt.system.Object]: ...
    @items_source.setter
    def items_source(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def has_unrealized_children(self) -> bool: ...
    @has_unrealized_children.setter
    def has_unrealized_children(self, value: bool) -> None: ...

@typing.final
class TreeViewItemInvokedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TreeViewItemInvokedEventArgs: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def invoked_item(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class TreeViewItemTemplateSettings_Static(type):
    @_property
    def collapsed_glyph_visibility_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def drag_items_count_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def expanded_glyph_visibility_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def indentation_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class TreeViewItemTemplateSettings(winrt.system.Object, metaclass=TreeViewItemTemplateSettings_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TreeViewItemTemplateSettings: ...
    def __new__(cls: typing.Type[TreeViewItemTemplateSettings]) -> TreeViewItemTemplateSettings:...
    @_property
    def collapsed_glyph_visibility(self) -> winrt.windows.ui.xaml.Visibility: ...
    @_property
    def drag_items_count(self) -> winrt.system.Int32: ...
    @_property
    def expanded_glyph_visibility(self) -> winrt.windows.ui.xaml.Visibility: ...
    @_property
    def indentation(self) -> winrt.windows.ui.xaml.Thickness: ...

@typing.final
class TreeViewList(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TreeViewList: ...
    def __new__(cls: typing.Type[TreeViewList]) -> TreeViewList:...

@typing.final
class TreeViewNode_Static(type):
    @_property
    def content_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def depth_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def has_children_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_expanded_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class TreeViewNode(winrt.system.Object, metaclass=TreeViewNode_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TreeViewNode: ...
    def __new__(cls: typing.Type[TreeViewNode]) -> TreeViewNode:...
    @_property
    def is_expanded(self) -> bool: ...
    @is_expanded.setter
    def is_expanded(self, value: bool) -> None: ...
    @_property
    def has_unrealized_children(self) -> bool: ...
    @has_unrealized_children.setter
    def has_unrealized_children(self, value: bool) -> None: ...
    @_property
    def content(self) -> typing.Optional[winrt.system.Object]: ...
    @content.setter
    def content(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def children(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[TreeViewNode]]: ...
    @_property
    def depth(self) -> winrt.system.Int32: ...
    @_property
    def has_children(self) -> bool: ...
    @_property
    def parent(self) -> typing.Optional[TreeViewNode]: ...

@typing.final
class TwoPaneView_Static(type):
    @_property
    def min_tall_mode_height_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def min_wide_mode_width_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def mode_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def pane1_length_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def pane1_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def pane2_length_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def pane2_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def pane_priority_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def tall_mode_configuration_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def wide_mode_configuration_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class TwoPaneView(winrt.system.Object, metaclass=TwoPaneView_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TwoPaneView: ...
    def __new__(cls: typing.Type[TwoPaneView]) -> TwoPaneView:...
    def add_mode_changed(self, handler: winrt.windows.foundation.TypedEventHandler[TwoPaneView, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_mode_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def wide_mode_configuration(self) -> TwoPaneViewWideModeConfiguration: ...
    @wide_mode_configuration.setter
    def wide_mode_configuration(self, value: TwoPaneViewWideModeConfiguration) -> None: ...
    @_property
    def tall_mode_configuration(self) -> TwoPaneViewTallModeConfiguration: ...
    @tall_mode_configuration.setter
    def tall_mode_configuration(self, value: TwoPaneViewTallModeConfiguration) -> None: ...
    @_property
    def pane_priority(self) -> TwoPaneViewPriority: ...
    @pane_priority.setter
    def pane_priority(self, value: TwoPaneViewPriority) -> None: ...
    @_property
    def pane2_length(self) -> winrt.windows.ui.xaml.GridLength: ...
    @pane2_length.setter
    def pane2_length(self, value: winrt.windows.ui.xaml.GridLength) -> None: ...
    @_property
    def pane2(self) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    @pane2.setter
    def pane2(self, value: typing.Optional[winrt.windows.ui.xaml.UIElement]) -> None: ...
    @_property
    def pane1_length(self) -> winrt.windows.ui.xaml.GridLength: ...
    @pane1_length.setter
    def pane1_length(self, value: winrt.windows.ui.xaml.GridLength) -> None: ...
    @_property
    def pane1(self) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    @pane1.setter
    def pane1(self, value: typing.Optional[winrt.windows.ui.xaml.UIElement]) -> None: ...
    @_property
    def min_wide_mode_width(self) -> winrt.system.Double: ...
    @min_wide_mode_width.setter
    def min_wide_mode_width(self, value: winrt.system.Double) -> None: ...
    @_property
    def min_tall_mode_height(self) -> winrt.system.Double: ...
    @min_tall_mode_height.setter
    def min_tall_mode_height(self, value: winrt.system.Double) -> None: ...
    @_property
    def mode(self) -> TwoPaneViewMode: ...

@typing.final
class UIElementCollection(winrt.system.Object, winrt._winrt.MutableSequence[winrt.windows.ui.xaml.UIElement]):
    def __len__(self) -> int: ...
    def __iter__(self) -> winrt.windows.foundation.collections.IIterator[winrt.windows.ui.xaml.UIElement]: ...
    @typing.overload
    def __getitem__(self, index: typing.SupportsIndex) -> winrt.windows.ui.xaml.UIElement: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[winrt.windows.ui.xaml.UIElement]: ...
    @typing.overload
    def __delitem__(self, index: typing.SupportsIndex) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: typing.SupportsIndex, value: winrt.windows.ui.xaml.UIElement) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[winrt.windows.ui.xaml.UIElement]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UIElementCollection: ...
    def append(self, value: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[winrt.windows.ui.xaml.UIElement]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[winrt.windows.ui.xaml.UIElement], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.ui.xaml.UIElement]]: ...
    def index_of(self, value: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> None: ...
    def move(self, old_index: winrt.system.UInt32, new_index: winrt.system.UInt32, /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[winrt.windows.ui.xaml.UIElement], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class UserControl_Static(type):
    @_property
    def content_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class UserControl(winrt.system.Object, metaclass=UserControl_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UserControl: ...
    def __new__(cls: typing.Type[UserControl]) -> UserControl:...
    @_property
    def content(self) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    @content.setter
    def content(self, value: typing.Optional[winrt.windows.ui.xaml.UIElement]) -> None: ...

@typing.final
class VariableSizedWrapGrid_Static(type):
    def get_column_span(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> winrt.system.Int32: ...
    def get_row_span(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> winrt.system.Int32: ...
    def set_column_span(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: winrt.system.Int32, /) -> None: ...
    def set_row_span(cls, element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: winrt.system.Int32, /) -> None: ...
    @_property
    def column_span_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def horizontal_children_alignment_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def item_height_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def item_width_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def maximum_rows_or_columns_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def orientation_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def row_span_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def vertical_children_alignment_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class VariableSizedWrapGrid(winrt.system.Object, metaclass=VariableSizedWrapGrid_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VariableSizedWrapGrid: ...
    def __new__(cls: typing.Type[VariableSizedWrapGrid]) -> VariableSizedWrapGrid:...
    @_property
    def vertical_children_alignment(self) -> winrt.windows.ui.xaml.VerticalAlignment: ...
    @vertical_children_alignment.setter
    def vertical_children_alignment(self, value: winrt.windows.ui.xaml.VerticalAlignment) -> None: ...
    @_property
    def orientation(self) -> Orientation: ...
    @orientation.setter
    def orientation(self, value: Orientation) -> None: ...
    @_property
    def maximum_rows_or_columns(self) -> winrt.system.Int32: ...
    @maximum_rows_or_columns.setter
    def maximum_rows_or_columns(self, value: winrt.system.Int32) -> None: ...
    @_property
    def item_width(self) -> winrt.system.Double: ...
    @item_width.setter
    def item_width(self, value: winrt.system.Double) -> None: ...
    @_property
    def item_height(self) -> winrt.system.Double: ...
    @item_height.setter
    def item_height(self, value: winrt.system.Double) -> None: ...
    @_property
    def horizontal_children_alignment(self) -> winrt.windows.ui.xaml.HorizontalAlignment: ...
    @horizontal_children_alignment.setter
    def horizontal_children_alignment(self, value: winrt.windows.ui.xaml.HorizontalAlignment) -> None: ...

@typing.final
class Viewbox_Static(type):
    @_property
    def stretch_direction_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def stretch_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class Viewbox(winrt.system.Object, metaclass=Viewbox_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Viewbox: ...
    def __new__(cls: typing.Type[Viewbox]) -> Viewbox:...
    @_property
    def stretch_direction(self) -> StretchDirection: ...
    @stretch_direction.setter
    def stretch_direction(self, value: StretchDirection) -> None: ...
    @_property
    def stretch(self) -> winrt.windows.ui.xaml.media.Stretch: ...
    @stretch.setter
    def stretch(self, value: winrt.windows.ui.xaml.media.Stretch) -> None: ...
    @_property
    def child(self) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    @child.setter
    def child(self, value: typing.Optional[winrt.windows.ui.xaml.UIElement]) -> None: ...

@typing.final
class VirtualizingPanel(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VirtualizingPanel: ...
    def add_internal_child(self, child: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> None: ...
    def bring_index_into_view(self, index: winrt.system.Int32, /) -> None: ...
    def insert_internal_child(self, index: winrt.system.Int32, child: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> None: ...
    def on_clear_children(self) -> None: ...
    def on_items_changed(self, sender: typing.Optional[winrt.system.Object], args: typing.Optional[winrt.windows.ui.xaml.controls.primitives.ItemsChangedEventArgs], /) -> None: ...
    def remove_internal_child_range(self, index: winrt.system.Int32, range: winrt.system.Int32, /) -> None: ...
    @_property
    def item_container_generator(self) -> typing.Optional[ItemContainerGenerator]: ...

@typing.final
class VirtualizingStackPanel_Static(type):
    def get_is_virtualizing(cls, o: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> bool: ...
    def get_virtualization_mode(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> VirtualizationMode: ...
    def set_virtualization_mode(cls, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], value: VirtualizationMode, /) -> None: ...
    @_property
    def are_scroll_snap_points_regular_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def is_virtualizing_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def orientation_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def virtualization_mode_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class VirtualizingStackPanel(winrt.system.Object, metaclass=VirtualizingStackPanel_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VirtualizingStackPanel: ...
    def __new__(cls: typing.Type[VirtualizingStackPanel]) -> VirtualizingStackPanel:...
    def on_clean_up_virtualized_item(self, e: typing.Optional[CleanUpVirtualizedItemEventArgs], /) -> None: ...
    def add_clean_up_virtualized_item_event(self, handler: typing.Optional[CleanUpVirtualizedItemEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_clean_up_virtualized_item_event(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def orientation(self) -> Orientation: ...
    @orientation.setter
    def orientation(self, value: Orientation) -> None: ...
    @_property
    def are_scroll_snap_points_regular(self) -> bool: ...
    @are_scroll_snap_points_regular.setter
    def are_scroll_snap_points_regular(self, value: bool) -> None: ...

@typing.final
class WebView_Static(type):
    def clear_temporary_web_data_async(cls) -> winrt.windows.foundation.IAsyncAction: ...
    @_property
    def allowed_script_notify_uris_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def any_script_notify_uri(cls) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]: ...
    @_property
    def data_transfer_package_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def source_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def can_go_back_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def can_go_forward_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def default_background_color_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def document_title_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def contains_full_screen_element_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def default_execution_mode(cls) -> WebViewExecutionMode: ...
    @_property
    def x_y_focus_down_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def x_y_focus_left_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def x_y_focus_right_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def x_y_focus_up_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class WebView(winrt.system.Object, metaclass=WebView_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebView: ...
    @typing.overload
    def __new__(cls: typing.Type[WebView], execution_mode: WebViewExecutionMode) -> WebView:...
    @typing.overload
    def __new__(cls: typing.Type[WebView]) -> WebView:...
    def add_web_allowed_object(self, name: str, p_object: typing.Optional[winrt.system.Object], /) -> None: ...
    def build_local_stream_uri(self, content_identifier: str, relative_path: str, /) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    def capture_preview_to_stream_async(self, stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStream], /) -> winrt.windows.foundation.IAsyncAction: ...
    def capture_selected_content_to_data_package_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.applicationmodel.datatransfer.DataPackage]: ...
    def deferred_permission_request_by_id(self, id: winrt.system.UInt32, /) -> typing.Optional[WebViewDeferredPermissionRequest]: ...
    def focus(self, value: winrt.windows.ui.xaml.FocusState, /) -> bool: ...
    def go_back(self) -> None: ...
    def go_forward(self) -> None: ...
    def invoke_script(self, script_name: str, arguments: winrt.system.Array[str], /) -> str: ...
    def invoke_script_async(self, script_name: str, arguments: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    def navigate(self, source: typing.Optional[winrt.windows.foundation.Uri], /) -> None: ...
    def navigate_to_local_stream_uri(self, source: typing.Optional[winrt.windows.foundation.Uri], stream_resolver: typing.Optional[winrt.windows.web.IUriToStreamResolver], /) -> None: ...
    def navigate_to_string(self, text: str, /) -> None: ...
    def navigate_with_http_request_message(self, request_message: typing.Optional[winrt.windows.web.http.HttpRequestMessage], /) -> None: ...
    def refresh(self) -> None: ...
    def stop(self) -> None: ...
    def add_load_completed(self, handler: typing.Optional[winrt.windows.ui.xaml.navigation.LoadCompletedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_load_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_navigation_failed(self, handler: typing.Optional[WebViewNavigationFailedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_navigation_failed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_script_notify(self, handler: typing.Optional[NotifyEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_script_notify(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_content_loading(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, WebViewContentLoadingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_content_loading(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_d_o_m_content_loaded(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, WebViewDOMContentLoadedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_d_o_m_content_loaded(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_frame_content_loading(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, WebViewContentLoadingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_frame_content_loading(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_frame_d_o_m_content_loaded(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, WebViewDOMContentLoadedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_frame_d_o_m_content_loaded(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_frame_navigation_completed(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, WebViewNavigationCompletedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_frame_navigation_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_frame_navigation_starting(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, WebViewNavigationStartingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_frame_navigation_starting(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_long_running_script_detected(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, WebViewLongRunningScriptDetectedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_long_running_script_detected(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_navigation_completed(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, WebViewNavigationCompletedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_navigation_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_navigation_starting(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, WebViewNavigationStartingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_navigation_starting(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_unsafe_content_warning_displaying(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_unsafe_content_warning_displaying(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_unviewable_content_identified(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, WebViewUnviewableContentIdentifiedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_unviewable_content_identified(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_contains_full_screen_element_changed(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_contains_full_screen_element_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_new_window_requested(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, WebViewNewWindowRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_new_window_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_permission_requested(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, WebViewPermissionRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_permission_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_unsupported_uri_scheme_identified(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, WebViewUnsupportedUriSchemeIdentifiedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_unsupported_uri_scheme_identified(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_separate_process_lost(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, WebViewSeparateProcessLostEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_separate_process_lost(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_web_resource_requested(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, WebViewWebResourceRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_web_resource_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def source(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @source.setter
    def source(self, value: typing.Optional[winrt.windows.foundation.Uri]) -> None: ...
    @_property
    def allowed_script_notify_uris(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]: ...
    @allowed_script_notify_uris.setter
    def allowed_script_notify_uris(self, value: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]) -> None: ...
    @_property
    def data_transfer_package(self) -> typing.Optional[winrt.windows.applicationmodel.datatransfer.DataPackage]: ...
    @_property
    def default_background_color(self) -> winrt.windows.ui.Color: ...
    @default_background_color.setter
    def default_background_color(self, value: winrt.windows.ui.Color) -> None: ...
    @_property
    def can_go_back(self) -> bool: ...
    @_property
    def can_go_forward(self) -> bool: ...
    @_property
    def document_title(self) -> str: ...
    @_property
    def contains_full_screen_element(self) -> bool: ...
    @_property
    def deferred_permission_requests(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[WebViewDeferredPermissionRequest]]: ...
    @_property
    def execution_mode(self) -> WebViewExecutionMode: ...
    @_property
    def settings(self) -> typing.Optional[WebViewSettings]: ...
    @_property
    def x_y_focus_up(self) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    @x_y_focus_up.setter
    def x_y_focus_up(self, value: typing.Optional[winrt.windows.ui.xaml.DependencyObject]) -> None: ...
    @_property
    def x_y_focus_right(self) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    @x_y_focus_right.setter
    def x_y_focus_right(self, value: typing.Optional[winrt.windows.ui.xaml.DependencyObject]) -> None: ...
    @_property
    def x_y_focus_left(self) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    @x_y_focus_left.setter
    def x_y_focus_left(self, value: typing.Optional[winrt.windows.ui.xaml.DependencyObject]) -> None: ...
    @_property
    def x_y_focus_down(self) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    @x_y_focus_down.setter
    def x_y_focus_down(self, value: typing.Optional[winrt.windows.ui.xaml.DependencyObject]) -> None: ...

@typing.final
class WebViewBrush_Static(type):
    @_property
    def source_name_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class WebViewBrush(winrt.system.Object, metaclass=WebViewBrush_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebViewBrush: ...
    def __new__(cls: typing.Type[WebViewBrush]) -> WebViewBrush:...
    def redraw(self) -> None: ...
    def set_source(self, source: typing.Optional[WebView], /) -> None: ...
    @_property
    def source_name(self) -> str: ...
    @source_name.setter
    def source_name(self, value: str) -> None: ...

@typing.final
class WebViewContentLoadingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebViewContentLoadingEventArgs: ...
    @_property
    def uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...

@typing.final
class WebViewDOMContentLoadedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebViewDOMContentLoadedEventArgs: ...
    @_property
    def uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...

@typing.final
class WebViewDeferredPermissionRequest(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebViewDeferredPermissionRequest: ...
    def allow(self) -> None: ...
    def deny(self) -> None: ...
    @_property
    def id(self) -> winrt.system.UInt32: ...
    @_property
    def permission_type(self) -> WebViewPermissionType: ...
    @_property
    def uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...

@typing.final
class WebViewLongRunningScriptDetectedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebViewLongRunningScriptDetectedEventArgs: ...
    @_property
    def stop_page_script_execution(self) -> bool: ...
    @stop_page_script_execution.setter
    def stop_page_script_execution(self, value: bool) -> None: ...
    @_property
    def execution_time(self) -> datetime.timedelta: ...

@typing.final
class WebViewNavigationCompletedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebViewNavigationCompletedEventArgs: ...
    @_property
    def is_success(self) -> bool: ...
    @_property
    def uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @_property
    def web_error_status(self) -> winrt.windows.web.WebErrorStatus: ...

@typing.final
class WebViewNavigationFailedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebViewNavigationFailedEventArgs: ...
    @_property
    def uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @_property
    def web_error_status(self) -> winrt.windows.web.WebErrorStatus: ...

@typing.final
class WebViewNavigationStartingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebViewNavigationStartingEventArgs: ...
    @_property
    def cancel(self) -> bool: ...
    @cancel.setter
    def cancel(self, value: bool) -> None: ...
    @_property
    def uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...

@typing.final
class WebViewNewWindowRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebViewNewWindowRequestedEventArgs: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def referrer(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @_property
    def uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...

@typing.final
class WebViewPermissionRequest(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebViewPermissionRequest: ...
    def allow(self) -> None: ...
    def defer(self) -> None: ...
    def deny(self) -> None: ...
    @_property
    def id(self) -> winrt.system.UInt32: ...
    @_property
    def permission_type(self) -> WebViewPermissionType: ...
    @_property
    def state(self) -> WebViewPermissionState: ...
    @_property
    def uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...

@typing.final
class WebViewPermissionRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebViewPermissionRequestedEventArgs: ...
    @_property
    def permission_request(self) -> typing.Optional[WebViewPermissionRequest]: ...

@typing.final
class WebViewSeparateProcessLostEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebViewSeparateProcessLostEventArgs: ...

@typing.final
class WebViewSettings(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebViewSettings: ...
    @_property
    def is_java_script_enabled(self) -> bool: ...
    @is_java_script_enabled.setter
    def is_java_script_enabled(self, value: bool) -> None: ...
    @_property
    def is_indexed_d_b_enabled(self) -> bool: ...
    @is_indexed_d_b_enabled.setter
    def is_indexed_d_b_enabled(self, value: bool) -> None: ...

@typing.final
class WebViewUnsupportedUriSchemeIdentifiedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebViewUnsupportedUriSchemeIdentifiedEventArgs: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...

@typing.final
class WebViewUnviewableContentIdentifiedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebViewUnviewableContentIdentifiedEventArgs: ...
    @_property
    def referrer(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @_property
    def uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @_property
    def media_type(self) -> str: ...

@typing.final
class WebViewWebResourceRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebViewWebResourceRequestedEventArgs: ...
    def get_deferral(self) -> typing.Optional[winrt.windows.foundation.Deferral]: ...
    @_property
    def response(self) -> typing.Optional[winrt.windows.web.http.HttpResponseMessage]: ...
    @response.setter
    def response(self, value: typing.Optional[winrt.windows.web.http.HttpResponseMessage]) -> None: ...
    @_property
    def request(self) -> typing.Optional[winrt.windows.web.http.HttpRequestMessage]: ...

@typing.final
class WrapGrid_Static(type):
    @_property
    def horizontal_children_alignment_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def item_height_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def item_width_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def maximum_rows_or_columns_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def orientation_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...
    @_property
    def vertical_children_alignment_property(cls) -> typing.Optional[winrt.windows.ui.xaml.DependencyProperty]: ...

@typing.final
class WrapGrid(winrt.system.Object, metaclass=WrapGrid_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WrapGrid: ...
    def __new__(cls: typing.Type[WrapGrid]) -> WrapGrid:...
    @_property
    def vertical_children_alignment(self) -> winrt.windows.ui.xaml.VerticalAlignment: ...
    @vertical_children_alignment.setter
    def vertical_children_alignment(self, value: winrt.windows.ui.xaml.VerticalAlignment) -> None: ...
    @_property
    def orientation(self) -> Orientation: ...
    @orientation.setter
    def orientation(self, value: Orientation) -> None: ...
    @_property
    def maximum_rows_or_columns(self) -> winrt.system.Int32: ...
    @maximum_rows_or_columns.setter
    def maximum_rows_or_columns(self, value: winrt.system.Int32) -> None: ...
    @_property
    def item_width(self) -> winrt.system.Double: ...
    @item_width.setter
    def item_width(self, value: winrt.system.Double) -> None: ...
    @_property
    def item_height(self) -> winrt.system.Double: ...
    @item_height.setter
    def item_height(self, value: winrt.system.Double) -> None: ...
    @_property
    def horizontal_children_alignment(self) -> winrt.windows.ui.xaml.HorizontalAlignment: ...
    @horizontal_children_alignment.setter
    def horizontal_children_alignment(self, value: winrt.windows.ui.xaml.HorizontalAlignment) -> None: ...

@typing.final
class ICommandBarElement(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ICommandBarElement: ...
    @_property
    def is_compact(self) -> bool: ...
    @is_compact.setter
    def is_compact(self, value: bool) -> None: ...

@typing.final
class ICommandBarElement2(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ICommandBarElement2: ...
    @_property
    def dynamic_overflow_order(self) -> winrt.system.Int32: ...
    @dynamic_overflow_order.setter
    def dynamic_overflow_order(self, value: winrt.system.Int32) -> None: ...
    @_property
    def is_in_overflow(self) -> bool: ...

@typing.final
class IInsertionPanel(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IInsertionPanel: ...
    def get_insertion_indexes(self, position: winrt.windows.foundation.Point, /) -> typing.Tuple[winrt.system.Int32, winrt.system.Int32]: ...

@typing.final
class IItemContainerMapping(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IItemContainerMapping: ...
    def container_from_index(self, index: winrt.system.Int32, /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    def container_from_item(self, item: typing.Optional[winrt.system.Object], /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    def index_from_container(self, container: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> winrt.system.Int32: ...
    def item_from_container(self, container: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class INavigate(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> INavigate: ...
    def navigate(self, source_page_type: winrt.windows.ui.xaml.interop.TypeName, /) -> bool: ...

@typing.final
class IScrollAnchorProvider(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IScrollAnchorProvider: ...
    def register_anchor_candidate(self, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> None: ...
    def unregister_anchor_candidate(self, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> None: ...
    @_property
    def current_anchor(self) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...

@typing.final
class ISemanticZoomInformation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ISemanticZoomInformation: ...
    def complete_view_change(self) -> None: ...
    def complete_view_change_from(self, source: typing.Optional[SemanticZoomLocation], destination: typing.Optional[SemanticZoomLocation], /) -> None: ...
    def complete_view_change_to(self, source: typing.Optional[SemanticZoomLocation], destination: typing.Optional[SemanticZoomLocation], /) -> None: ...
    def initialize_view_change(self) -> None: ...
    def make_visible(self, item: typing.Optional[SemanticZoomLocation], /) -> None: ...
    def start_view_change_from(self, source: typing.Optional[SemanticZoomLocation], destination: typing.Optional[SemanticZoomLocation], /) -> None: ...
    def start_view_change_to(self, source: typing.Optional[SemanticZoomLocation], destination: typing.Optional[SemanticZoomLocation], /) -> None: ...
    @_property
    def is_active_view(self) -> bool: ...
    @is_active_view.setter
    def is_active_view(self, value: bool) -> None: ...
    @_property
    def is_zoomed_in_view(self) -> bool: ...
    @is_zoomed_in_view.setter
    def is_zoomed_in_view(self, value: bool) -> None: ...
    @_property
    def semantic_zoom_owner(self) -> typing.Optional[SemanticZoom]: ...
    @semantic_zoom_owner.setter
    def semantic_zoom_owner(self, value: typing.Optional[SemanticZoom]) -> None: ...

