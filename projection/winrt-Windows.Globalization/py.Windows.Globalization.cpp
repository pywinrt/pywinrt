// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Globalization.h"


namespace py::cpp::Windows::Globalization
{
    // ----- ApplicationLanguages class --------------------

    static PyObject* _new_ApplicationLanguages(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Globalization::ApplicationLanguages>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Globalization::ApplicationLanguages>::type_name);
        return nullptr;
    }

    static PyObject* ApplicationLanguages_GetLanguagesForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.ApplicationLanguages", L"GetLanguagesForUser", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::Globalization::ApplicationLanguages::GetLanguagesForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationLanguages_get_PrimaryLanguageOverride(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.ApplicationLanguages", L"PrimaryLanguageOverride"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::ApplicationLanguages::PrimaryLanguageOverride());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationLanguages_put_PrimaryLanguageOverride(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.ApplicationLanguages", L"PrimaryLanguageOverride"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            winrt::Windows::Globalization::ApplicationLanguages::PrimaryLanguageOverride(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationLanguages_get_Languages(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.ApplicationLanguages", L"Languages"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::ApplicationLanguages::Languages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationLanguages_get_ManifestLanguages(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.ApplicationLanguages", L"ManifestLanguages"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::ApplicationLanguages::ManifestLanguages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ApplicationLanguages[] = {
        { }
    };

    static PyGetSetDef _getset_ApplicationLanguages[] = {
        { }
    };

    static PyType_Slot _type_slots_ApplicationLanguages[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ApplicationLanguages) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ApplicationLanguages) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ApplicationLanguages) },
        { },
    };

    static PyType_Spec type_spec_ApplicationLanguages =
    {
        "winrt._winrt_windows_globalization.ApplicationLanguages",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationLanguages
    };

    static PyGetSetDef getset_ApplicationLanguages_Static[] = {
        { "primary_language_override", reinterpret_cast<getter>(ApplicationLanguages_get_PrimaryLanguageOverride), reinterpret_cast<setter>(ApplicationLanguages_put_PrimaryLanguageOverride), nullptr, nullptr },
        { "languages", reinterpret_cast<getter>(ApplicationLanguages_get_Languages), nullptr, nullptr, nullptr },
        { "manifest_languages", reinterpret_cast<getter>(ApplicationLanguages_get_ManifestLanguages), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ApplicationLanguages_Static[] = {
        { "get_languages_for_user", reinterpret_cast<PyCFunction>(ApplicationLanguages_GetLanguagesForUser), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_ApplicationLanguages_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ApplicationLanguages_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ApplicationLanguages_Static) },
        { }
    };

    static PyType_Spec type_spec_ApplicationLanguages_Static =
    {
        "winrt._winrt_windows_globalization.ApplicationLanguages_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ApplicationLanguages_Static
    };

    // ----- Calendar class --------------------

    static PyObject* _new_Calendar(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                winrt::Windows::Globalization::Calendar instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                winrt::Windows::Globalization::Calendar instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                winrt::Windows::Globalization::Calendar instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Globalization::Calendar instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Calendar(py::wrapper::Windows::Globalization::Calendar* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Calendar_AddDays(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"AddDays", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.AddDays(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_AddEras(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"AddEras", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.AddEras(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_AddHours(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"AddHours", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.AddHours(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_AddMinutes(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"AddMinutes", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.AddMinutes(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_AddMonths(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"AddMonths", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.AddMonths(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_AddNanoseconds(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"AddNanoseconds", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.AddNanoseconds(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_AddPeriods(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"AddPeriods", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.AddPeriods(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_AddSeconds(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"AddSeconds", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.AddSeconds(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_AddWeeks(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"AddWeeks", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.AddWeeks(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_AddYears(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"AddYears", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.AddYears(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_ChangeCalendarSystem(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"ChangeCalendarSystem", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.ChangeCalendarSystem(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_ChangeClock(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"ChangeClock", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.ChangeClock(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_ChangeTimeZone(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"ChangeTimeZone", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.ChangeTimeZone(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_Clone(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"Clone", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.Clone());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_Compare(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"Compare", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Globalization::Calendar>(args, 0);

                return py::convert(self->obj.Compare(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_CompareDateTime(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"CompareDateTime", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

                return py::convert(self->obj.CompareDateTime(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_CopyTo(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"CopyTo", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Globalization::Calendar>(args, 0);

                self->obj.CopyTo(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_DayAsPaddedString(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"DayAsPaddedString", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.DayAsPaddedString(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_DayAsString(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"DayAsString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.DayAsString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_DayOfWeekAsSoloString(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"DayOfWeekAsSoloString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.DayOfWeekAsSoloString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"DayOfWeekAsSoloString", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.DayOfWeekAsSoloString(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_DayOfWeekAsString(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"DayOfWeekAsString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.DayOfWeekAsString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"DayOfWeekAsString", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.DayOfWeekAsString(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_EraAsString(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"EraAsString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.EraAsString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"EraAsString", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.EraAsString(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_GetCalendarSystem(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"GetCalendarSystem", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetCalendarSystem());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_GetClock(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"GetClock", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetClock());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_GetDateTime(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"GetDateTime", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDateTime());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_GetTimeZone(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"GetTimeZone", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetTimeZone());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_HourAsPaddedString(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"HourAsPaddedString", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.HourAsPaddedString(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_HourAsString(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"HourAsString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.HourAsString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_MinuteAsPaddedString(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"MinuteAsPaddedString", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.MinuteAsPaddedString(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_MinuteAsString(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"MinuteAsString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.MinuteAsString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_MonthAsNumericString(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"MonthAsNumericString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.MonthAsNumericString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_MonthAsPaddedNumericString(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"MonthAsPaddedNumericString", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.MonthAsPaddedNumericString(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_MonthAsSoloString(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"MonthAsSoloString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.MonthAsSoloString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"MonthAsSoloString", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.MonthAsSoloString(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_MonthAsString(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"MonthAsString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.MonthAsString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"MonthAsString", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.MonthAsString(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_NanosecondAsPaddedString(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"NanosecondAsPaddedString", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.NanosecondAsPaddedString(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_NanosecondAsString(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"NanosecondAsString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.NanosecondAsString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_PeriodAsString(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"PeriodAsString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.PeriodAsString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"PeriodAsString", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.PeriodAsString(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_SecondAsPaddedString(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"SecondAsPaddedString", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.SecondAsPaddedString(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_SecondAsString(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"SecondAsString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.SecondAsString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_SetDateTime(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"SetDateTime", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

                self->obj.SetDateTime(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_SetToMax(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"SetToMax", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.SetToMax();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_SetToMin(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"SetToMin", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.SetToMin();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_SetToNow(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"SetToNow", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.SetToNow();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_TimeZoneAsString(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"TimeZoneAsString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TimeZoneAsString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"TimeZoneAsString", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.TimeZoneAsString(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_YearAsPaddedString(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"YearAsPaddedString", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.YearAsPaddedString(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_YearAsString(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"YearAsString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.YearAsString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_YearAsTruncatedString(py::wrapper::Windows::Globalization::Calendar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Calendar", L"YearAsTruncatedString", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.YearAsTruncatedString(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Calendar_get_Year(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"Year"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Year());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Calendar_put_Year(py::wrapper::Windows::Globalization::Calendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"Year"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Year(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Calendar_get_Second(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"Second"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Second());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Calendar_put_Second(py::wrapper::Windows::Globalization::Calendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"Second"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Second(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Calendar_get_Period(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"Period"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Period());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Calendar_put_Period(py::wrapper::Windows::Globalization::Calendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"Period"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Period(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Calendar_get_Nanosecond(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"Nanosecond"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Nanosecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Calendar_put_Nanosecond(py::wrapper::Windows::Globalization::Calendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"Nanosecond"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Nanosecond(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Calendar_get_Month(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"Month"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Month());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Calendar_put_Month(py::wrapper::Windows::Globalization::Calendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"Month"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Month(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Calendar_get_Minute(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"Minute"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Minute());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Calendar_put_Minute(py::wrapper::Windows::Globalization::Calendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"Minute"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Minute(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Calendar_get_NumeralSystem(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"NumeralSystem"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NumeralSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Calendar_put_NumeralSystem(py::wrapper::Windows::Globalization::Calendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"NumeralSystem"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.NumeralSystem(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Calendar_get_Era(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"Era"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Era());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Calendar_put_Era(py::wrapper::Windows::Globalization::Calendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"Era"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Era(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Calendar_get_Hour(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"Hour"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Hour());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Calendar_put_Hour(py::wrapper::Windows::Globalization::Calendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"Hour"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Hour(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Calendar_get_Day(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"Day"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Day());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Calendar_put_Day(py::wrapper::Windows::Globalization::Calendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"Day"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Day(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Calendar_get_FirstSecondInThisMinute(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"FirstSecondInThisMinute"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FirstSecondInThisMinute());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Calendar_get_FirstYearInThisEra(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"FirstYearInThisEra"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FirstYearInThisEra());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Calendar_get_IsDaylightSavingTime(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"IsDaylightSavingTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDaylightSavingTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Calendar_get_Languages(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"Languages"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Languages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Calendar_get_LastDayInThisMonth(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"LastDayInThisMonth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LastDayInThisMonth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Calendar_get_LastEra(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"LastEra"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LastEra());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Calendar_get_LastHourInThisPeriod(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"LastHourInThisPeriod"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LastHourInThisPeriod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Calendar_get_LastMinuteInThisHour(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"LastMinuteInThisHour"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LastMinuteInThisHour());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Calendar_get_LastMonthInThisYear(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"LastMonthInThisYear"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LastMonthInThisYear());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Calendar_get_LastSecondInThisMinute(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"LastSecondInThisMinute"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LastSecondInThisMinute());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Calendar_get_LastYearInThisEra(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"LastYearInThisEra"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LastYearInThisEra());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Calendar_get_DayOfWeek(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"DayOfWeek"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DayOfWeek());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Calendar_get_FirstDayInThisMonth(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"FirstDayInThisMonth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FirstDayInThisMonth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Calendar_get_LastPeriodInThisDay(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"LastPeriodInThisDay"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LastPeriodInThisDay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Calendar_get_FirstEra(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"FirstEra"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FirstEra());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Calendar_get_NumberOfDaysInThisMonth(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"NumberOfDaysInThisMonth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NumberOfDaysInThisMonth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Calendar_get_NumberOfEras(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"NumberOfEras"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NumberOfEras());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Calendar_get_NumberOfHoursInThisPeriod(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"NumberOfHoursInThisPeriod"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NumberOfHoursInThisPeriod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Calendar_get_NumberOfMinutesInThisHour(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"NumberOfMinutesInThisHour"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NumberOfMinutesInThisHour());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Calendar_get_FirstHourInThisPeriod(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"FirstHourInThisPeriod"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FirstHourInThisPeriod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Calendar_get_NumberOfMonthsInThisYear(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"NumberOfMonthsInThisYear"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NumberOfMonthsInThisYear());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Calendar_get_NumberOfPeriodsInThisDay(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"NumberOfPeriodsInThisDay"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NumberOfPeriodsInThisDay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Calendar_get_NumberOfSecondsInThisMinute(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"NumberOfSecondsInThisMinute"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NumberOfSecondsInThisMinute());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Calendar_get_NumberOfYearsInThisEra(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"NumberOfYearsInThisEra"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NumberOfYearsInThisEra());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Calendar_get_FirstMinuteInThisHour(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"FirstMinuteInThisHour"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FirstMinuteInThisHour());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Calendar_get_ResolvedLanguage(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"ResolvedLanguage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResolvedLanguage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Calendar_get_FirstMonthInThisYear(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"FirstMonthInThisYear"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FirstMonthInThisYear());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Calendar_get_FirstPeriodInThisDay(py::wrapper::Windows::Globalization::Calendar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Calendar", L"FirstPeriodInThisDay"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FirstPeriodInThisDay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Calendar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::Calendar>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Calendar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::Calendar>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Calendar[] = {
        { "add_days", reinterpret_cast<PyCFunction>(Calendar_AddDays), METH_VARARGS, nullptr },
        { "add_eras", reinterpret_cast<PyCFunction>(Calendar_AddEras), METH_VARARGS, nullptr },
        { "add_hours", reinterpret_cast<PyCFunction>(Calendar_AddHours), METH_VARARGS, nullptr },
        { "add_minutes", reinterpret_cast<PyCFunction>(Calendar_AddMinutes), METH_VARARGS, nullptr },
        { "add_months", reinterpret_cast<PyCFunction>(Calendar_AddMonths), METH_VARARGS, nullptr },
        { "add_nanoseconds", reinterpret_cast<PyCFunction>(Calendar_AddNanoseconds), METH_VARARGS, nullptr },
        { "add_periods", reinterpret_cast<PyCFunction>(Calendar_AddPeriods), METH_VARARGS, nullptr },
        { "add_seconds", reinterpret_cast<PyCFunction>(Calendar_AddSeconds), METH_VARARGS, nullptr },
        { "add_weeks", reinterpret_cast<PyCFunction>(Calendar_AddWeeks), METH_VARARGS, nullptr },
        { "add_years", reinterpret_cast<PyCFunction>(Calendar_AddYears), METH_VARARGS, nullptr },
        { "change_calendar_system", reinterpret_cast<PyCFunction>(Calendar_ChangeCalendarSystem), METH_VARARGS, nullptr },
        { "change_clock", reinterpret_cast<PyCFunction>(Calendar_ChangeClock), METH_VARARGS, nullptr },
        { "change_time_zone", reinterpret_cast<PyCFunction>(Calendar_ChangeTimeZone), METH_VARARGS, nullptr },
        { "clone", reinterpret_cast<PyCFunction>(Calendar_Clone), METH_VARARGS, nullptr },
        { "compare", reinterpret_cast<PyCFunction>(Calendar_Compare), METH_VARARGS, nullptr },
        { "compare_date_time", reinterpret_cast<PyCFunction>(Calendar_CompareDateTime), METH_VARARGS, nullptr },
        { "copy_to", reinterpret_cast<PyCFunction>(Calendar_CopyTo), METH_VARARGS, nullptr },
        { "day_as_padded_string", reinterpret_cast<PyCFunction>(Calendar_DayAsPaddedString), METH_VARARGS, nullptr },
        { "day_as_string", reinterpret_cast<PyCFunction>(Calendar_DayAsString), METH_VARARGS, nullptr },
        { "day_of_week_as_solo_string", reinterpret_cast<PyCFunction>(Calendar_DayOfWeekAsSoloString), METH_VARARGS, nullptr },
        { "day_of_week_as_string", reinterpret_cast<PyCFunction>(Calendar_DayOfWeekAsString), METH_VARARGS, nullptr },
        { "era_as_string", reinterpret_cast<PyCFunction>(Calendar_EraAsString), METH_VARARGS, nullptr },
        { "get_calendar_system", reinterpret_cast<PyCFunction>(Calendar_GetCalendarSystem), METH_VARARGS, nullptr },
        { "get_clock", reinterpret_cast<PyCFunction>(Calendar_GetClock), METH_VARARGS, nullptr },
        { "get_date_time", reinterpret_cast<PyCFunction>(Calendar_GetDateTime), METH_VARARGS, nullptr },
        { "get_time_zone", reinterpret_cast<PyCFunction>(Calendar_GetTimeZone), METH_VARARGS, nullptr },
        { "hour_as_padded_string", reinterpret_cast<PyCFunction>(Calendar_HourAsPaddedString), METH_VARARGS, nullptr },
        { "hour_as_string", reinterpret_cast<PyCFunction>(Calendar_HourAsString), METH_VARARGS, nullptr },
        { "minute_as_padded_string", reinterpret_cast<PyCFunction>(Calendar_MinuteAsPaddedString), METH_VARARGS, nullptr },
        { "minute_as_string", reinterpret_cast<PyCFunction>(Calendar_MinuteAsString), METH_VARARGS, nullptr },
        { "month_as_numeric_string", reinterpret_cast<PyCFunction>(Calendar_MonthAsNumericString), METH_VARARGS, nullptr },
        { "month_as_padded_numeric_string", reinterpret_cast<PyCFunction>(Calendar_MonthAsPaddedNumericString), METH_VARARGS, nullptr },
        { "month_as_solo_string", reinterpret_cast<PyCFunction>(Calendar_MonthAsSoloString), METH_VARARGS, nullptr },
        { "month_as_string", reinterpret_cast<PyCFunction>(Calendar_MonthAsString), METH_VARARGS, nullptr },
        { "nanosecond_as_padded_string", reinterpret_cast<PyCFunction>(Calendar_NanosecondAsPaddedString), METH_VARARGS, nullptr },
        { "nanosecond_as_string", reinterpret_cast<PyCFunction>(Calendar_NanosecondAsString), METH_VARARGS, nullptr },
        { "period_as_string", reinterpret_cast<PyCFunction>(Calendar_PeriodAsString), METH_VARARGS, nullptr },
        { "second_as_padded_string", reinterpret_cast<PyCFunction>(Calendar_SecondAsPaddedString), METH_VARARGS, nullptr },
        { "second_as_string", reinterpret_cast<PyCFunction>(Calendar_SecondAsString), METH_VARARGS, nullptr },
        { "set_date_time", reinterpret_cast<PyCFunction>(Calendar_SetDateTime), METH_VARARGS, nullptr },
        { "set_to_max", reinterpret_cast<PyCFunction>(Calendar_SetToMax), METH_VARARGS, nullptr },
        { "set_to_min", reinterpret_cast<PyCFunction>(Calendar_SetToMin), METH_VARARGS, nullptr },
        { "set_to_now", reinterpret_cast<PyCFunction>(Calendar_SetToNow), METH_VARARGS, nullptr },
        { "time_zone_as_string", reinterpret_cast<PyCFunction>(Calendar_TimeZoneAsString), METH_VARARGS, nullptr },
        { "year_as_padded_string", reinterpret_cast<PyCFunction>(Calendar_YearAsPaddedString), METH_VARARGS, nullptr },
        { "year_as_string", reinterpret_cast<PyCFunction>(Calendar_YearAsString), METH_VARARGS, nullptr },
        { "year_as_truncated_string", reinterpret_cast<PyCFunction>(Calendar_YearAsTruncatedString), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Calendar, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Calendar), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Calendar[] = {
        { "year", reinterpret_cast<getter>(Calendar_get_Year), reinterpret_cast<setter>(Calendar_put_Year), nullptr, nullptr },
        { "second", reinterpret_cast<getter>(Calendar_get_Second), reinterpret_cast<setter>(Calendar_put_Second), nullptr, nullptr },
        { "period", reinterpret_cast<getter>(Calendar_get_Period), reinterpret_cast<setter>(Calendar_put_Period), nullptr, nullptr },
        { "nanosecond", reinterpret_cast<getter>(Calendar_get_Nanosecond), reinterpret_cast<setter>(Calendar_put_Nanosecond), nullptr, nullptr },
        { "month", reinterpret_cast<getter>(Calendar_get_Month), reinterpret_cast<setter>(Calendar_put_Month), nullptr, nullptr },
        { "minute", reinterpret_cast<getter>(Calendar_get_Minute), reinterpret_cast<setter>(Calendar_put_Minute), nullptr, nullptr },
        { "numeral_system", reinterpret_cast<getter>(Calendar_get_NumeralSystem), reinterpret_cast<setter>(Calendar_put_NumeralSystem), nullptr, nullptr },
        { "era", reinterpret_cast<getter>(Calendar_get_Era), reinterpret_cast<setter>(Calendar_put_Era), nullptr, nullptr },
        { "hour", reinterpret_cast<getter>(Calendar_get_Hour), reinterpret_cast<setter>(Calendar_put_Hour), nullptr, nullptr },
        { "day", reinterpret_cast<getter>(Calendar_get_Day), reinterpret_cast<setter>(Calendar_put_Day), nullptr, nullptr },
        { "first_second_in_this_minute", reinterpret_cast<getter>(Calendar_get_FirstSecondInThisMinute), nullptr, nullptr, nullptr },
        { "first_year_in_this_era", reinterpret_cast<getter>(Calendar_get_FirstYearInThisEra), nullptr, nullptr, nullptr },
        { "is_daylight_saving_time", reinterpret_cast<getter>(Calendar_get_IsDaylightSavingTime), nullptr, nullptr, nullptr },
        { "languages", reinterpret_cast<getter>(Calendar_get_Languages), nullptr, nullptr, nullptr },
        { "last_day_in_this_month", reinterpret_cast<getter>(Calendar_get_LastDayInThisMonth), nullptr, nullptr, nullptr },
        { "last_era", reinterpret_cast<getter>(Calendar_get_LastEra), nullptr, nullptr, nullptr },
        { "last_hour_in_this_period", reinterpret_cast<getter>(Calendar_get_LastHourInThisPeriod), nullptr, nullptr, nullptr },
        { "last_minute_in_this_hour", reinterpret_cast<getter>(Calendar_get_LastMinuteInThisHour), nullptr, nullptr, nullptr },
        { "last_month_in_this_year", reinterpret_cast<getter>(Calendar_get_LastMonthInThisYear), nullptr, nullptr, nullptr },
        { "last_second_in_this_minute", reinterpret_cast<getter>(Calendar_get_LastSecondInThisMinute), nullptr, nullptr, nullptr },
        { "last_year_in_this_era", reinterpret_cast<getter>(Calendar_get_LastYearInThisEra), nullptr, nullptr, nullptr },
        { "day_of_week", reinterpret_cast<getter>(Calendar_get_DayOfWeek), nullptr, nullptr, nullptr },
        { "first_day_in_this_month", reinterpret_cast<getter>(Calendar_get_FirstDayInThisMonth), nullptr, nullptr, nullptr },
        { "last_period_in_this_day", reinterpret_cast<getter>(Calendar_get_LastPeriodInThisDay), nullptr, nullptr, nullptr },
        { "first_era", reinterpret_cast<getter>(Calendar_get_FirstEra), nullptr, nullptr, nullptr },
        { "number_of_days_in_this_month", reinterpret_cast<getter>(Calendar_get_NumberOfDaysInThisMonth), nullptr, nullptr, nullptr },
        { "number_of_eras", reinterpret_cast<getter>(Calendar_get_NumberOfEras), nullptr, nullptr, nullptr },
        { "number_of_hours_in_this_period", reinterpret_cast<getter>(Calendar_get_NumberOfHoursInThisPeriod), nullptr, nullptr, nullptr },
        { "number_of_minutes_in_this_hour", reinterpret_cast<getter>(Calendar_get_NumberOfMinutesInThisHour), nullptr, nullptr, nullptr },
        { "first_hour_in_this_period", reinterpret_cast<getter>(Calendar_get_FirstHourInThisPeriod), nullptr, nullptr, nullptr },
        { "number_of_months_in_this_year", reinterpret_cast<getter>(Calendar_get_NumberOfMonthsInThisYear), nullptr, nullptr, nullptr },
        { "number_of_periods_in_this_day", reinterpret_cast<getter>(Calendar_get_NumberOfPeriodsInThisDay), nullptr, nullptr, nullptr },
        { "number_of_seconds_in_this_minute", reinterpret_cast<getter>(Calendar_get_NumberOfSecondsInThisMinute), nullptr, nullptr, nullptr },
        { "number_of_years_in_this_era", reinterpret_cast<getter>(Calendar_get_NumberOfYearsInThisEra), nullptr, nullptr, nullptr },
        { "first_minute_in_this_hour", reinterpret_cast<getter>(Calendar_get_FirstMinuteInThisHour), nullptr, nullptr, nullptr },
        { "resolved_language", reinterpret_cast<getter>(Calendar_get_ResolvedLanguage), nullptr, nullptr, nullptr },
        { "first_month_in_this_year", reinterpret_cast<getter>(Calendar_get_FirstMonthInThisYear), nullptr, nullptr, nullptr },
        { "first_period_in_this_day", reinterpret_cast<getter>(Calendar_get_FirstPeriodInThisDay), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Calendar[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Calendar) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Calendar) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Calendar) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Calendar) },
        { },
    };

    static PyType_Spec type_spec_Calendar =
    {
        "winrt._winrt_windows_globalization.Calendar",
        sizeof(py::wrapper::Windows::Globalization::Calendar),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Calendar
    };

    // ----- CalendarIdentifiers class --------------------

    static PyObject* _new_CalendarIdentifiers(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Globalization::CalendarIdentifiers>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Globalization::CalendarIdentifiers>::type_name);
        return nullptr;
    }

    static PyObject* CalendarIdentifiers_get_Julian(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CalendarIdentifiers", L"Julian"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CalendarIdentifiers::Julian());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarIdentifiers_get_Gregorian(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CalendarIdentifiers", L"Gregorian"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CalendarIdentifiers::Gregorian());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarIdentifiers_get_Hebrew(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CalendarIdentifiers", L"Hebrew"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CalendarIdentifiers::Hebrew());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarIdentifiers_get_Hijri(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CalendarIdentifiers", L"Hijri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CalendarIdentifiers::Hijri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarIdentifiers_get_Japanese(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CalendarIdentifiers", L"Japanese"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CalendarIdentifiers::Japanese());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarIdentifiers_get_Korean(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CalendarIdentifiers", L"Korean"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CalendarIdentifiers::Korean());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarIdentifiers_get_Taiwan(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CalendarIdentifiers", L"Taiwan"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CalendarIdentifiers::Taiwan());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarIdentifiers_get_Thai(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CalendarIdentifiers", L"Thai"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CalendarIdentifiers::Thai());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarIdentifiers_get_UmAlQura(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CalendarIdentifiers", L"UmAlQura"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CalendarIdentifiers::UmAlQura());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarIdentifiers_get_Persian(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CalendarIdentifiers", L"Persian"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CalendarIdentifiers::Persian());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarIdentifiers_get_ChineseLunar(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CalendarIdentifiers", L"ChineseLunar"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CalendarIdentifiers::ChineseLunar());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarIdentifiers_get_VietnameseLunar(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CalendarIdentifiers", L"VietnameseLunar"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CalendarIdentifiers::VietnameseLunar());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarIdentifiers_get_TaiwanLunar(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CalendarIdentifiers", L"TaiwanLunar"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CalendarIdentifiers::TaiwanLunar());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarIdentifiers_get_KoreanLunar(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CalendarIdentifiers", L"KoreanLunar"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CalendarIdentifiers::KoreanLunar());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarIdentifiers_get_JapaneseLunar(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CalendarIdentifiers", L"JapaneseLunar"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CalendarIdentifiers::JapaneseLunar());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CalendarIdentifiers[] = {
        { }
    };

    static PyGetSetDef _getset_CalendarIdentifiers[] = {
        { }
    };

    static PyType_Slot _type_slots_CalendarIdentifiers[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CalendarIdentifiers) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CalendarIdentifiers) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CalendarIdentifiers) },
        { },
    };

    static PyType_Spec type_spec_CalendarIdentifiers =
    {
        "winrt._winrt_windows_globalization.CalendarIdentifiers",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CalendarIdentifiers
    };

    static PyGetSetDef getset_CalendarIdentifiers_Static[] = {
        { "julian", reinterpret_cast<getter>(CalendarIdentifiers_get_Julian), nullptr, nullptr, nullptr },
        { "gregorian", reinterpret_cast<getter>(CalendarIdentifiers_get_Gregorian), nullptr, nullptr, nullptr },
        { "hebrew", reinterpret_cast<getter>(CalendarIdentifiers_get_Hebrew), nullptr, nullptr, nullptr },
        { "hijri", reinterpret_cast<getter>(CalendarIdentifiers_get_Hijri), nullptr, nullptr, nullptr },
        { "japanese", reinterpret_cast<getter>(CalendarIdentifiers_get_Japanese), nullptr, nullptr, nullptr },
        { "korean", reinterpret_cast<getter>(CalendarIdentifiers_get_Korean), nullptr, nullptr, nullptr },
        { "taiwan", reinterpret_cast<getter>(CalendarIdentifiers_get_Taiwan), nullptr, nullptr, nullptr },
        { "thai", reinterpret_cast<getter>(CalendarIdentifiers_get_Thai), nullptr, nullptr, nullptr },
        { "um_al_qura", reinterpret_cast<getter>(CalendarIdentifiers_get_UmAlQura), nullptr, nullptr, nullptr },
        { "persian", reinterpret_cast<getter>(CalendarIdentifiers_get_Persian), nullptr, nullptr, nullptr },
        { "chinese_lunar", reinterpret_cast<getter>(CalendarIdentifiers_get_ChineseLunar), nullptr, nullptr, nullptr },
        { "vietnamese_lunar", reinterpret_cast<getter>(CalendarIdentifiers_get_VietnameseLunar), nullptr, nullptr, nullptr },
        { "taiwan_lunar", reinterpret_cast<getter>(CalendarIdentifiers_get_TaiwanLunar), nullptr, nullptr, nullptr },
        { "korean_lunar", reinterpret_cast<getter>(CalendarIdentifiers_get_KoreanLunar), nullptr, nullptr, nullptr },
        { "japanese_lunar", reinterpret_cast<getter>(CalendarIdentifiers_get_JapaneseLunar), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_CalendarIdentifiers_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CalendarIdentifiers_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CalendarIdentifiers_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CalendarIdentifiers_Static) },
        { }
    };

    static PyType_Spec type_spec_CalendarIdentifiers_Static =
    {
        "winrt._winrt_windows_globalization.CalendarIdentifiers_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CalendarIdentifiers_Static
    };

    // ----- ClockIdentifiers class --------------------

    static PyObject* _new_ClockIdentifiers(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Globalization::ClockIdentifiers>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Globalization::ClockIdentifiers>::type_name);
        return nullptr;
    }

    static PyObject* ClockIdentifiers_get_TwelveHour(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.ClockIdentifiers", L"TwelveHour"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::ClockIdentifiers::TwelveHour());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClockIdentifiers_get_TwentyFourHour(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.ClockIdentifiers", L"TwentyFourHour"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::ClockIdentifiers::TwentyFourHour());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClockIdentifiers[] = {
        { }
    };

    static PyGetSetDef _getset_ClockIdentifiers[] = {
        { }
    };

    static PyType_Slot _type_slots_ClockIdentifiers[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClockIdentifiers) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClockIdentifiers) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClockIdentifiers) },
        { },
    };

    static PyType_Spec type_spec_ClockIdentifiers =
    {
        "winrt._winrt_windows_globalization.ClockIdentifiers",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClockIdentifiers
    };

    static PyGetSetDef getset_ClockIdentifiers_Static[] = {
        { "twelve_hour", reinterpret_cast<getter>(ClockIdentifiers_get_TwelveHour), nullptr, nullptr, nullptr },
        { "twenty_four_hour", reinterpret_cast<getter>(ClockIdentifiers_get_TwentyFourHour), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ClockIdentifiers_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ClockIdentifiers_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ClockIdentifiers_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ClockIdentifiers_Static) },
        { }
    };

    static PyType_Spec type_spec_ClockIdentifiers_Static =
    {
        "winrt._winrt_windows_globalization.ClockIdentifiers_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ClockIdentifiers_Static
    };

    // ----- CurrencyAmount class --------------------

    static PyObject* _new_CurrencyAmount(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Globalization::CurrencyAmount instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CurrencyAmount(py::wrapper::Windows::Globalization::CurrencyAmount* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CurrencyAmount_get_Amount(py::wrapper::Windows::Globalization::CurrencyAmount* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyAmount", L"Amount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Amount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyAmount_get_Currency(py::wrapper::Windows::Globalization::CurrencyAmount* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyAmount", L"Currency"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Currency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CurrencyAmount(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::CurrencyAmount>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CurrencyAmount(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::CurrencyAmount>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CurrencyAmount[] = {
        { "_assign_array_", _assign_array_CurrencyAmount, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CurrencyAmount), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CurrencyAmount[] = {
        { "amount", reinterpret_cast<getter>(CurrencyAmount_get_Amount), nullptr, nullptr, nullptr },
        { "currency", reinterpret_cast<getter>(CurrencyAmount_get_Currency), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CurrencyAmount[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CurrencyAmount) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CurrencyAmount) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CurrencyAmount) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CurrencyAmount) },
        { },
    };

    static PyType_Spec type_spec_CurrencyAmount =
    {
        "winrt._winrt_windows_globalization.CurrencyAmount",
        sizeof(py::wrapper::Windows::Globalization::CurrencyAmount),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CurrencyAmount
    };

    // ----- CurrencyIdentifiers class --------------------

    static PyObject* _new_CurrencyIdentifiers(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Globalization::CurrencyIdentifiers>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Globalization::CurrencyIdentifiers>::type_name);
        return nullptr;
    }

    static PyObject* CurrencyIdentifiers_get_HNL(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"HNL"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::HNL());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_AED(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"AED"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::AED());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_AFN(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"AFN"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::AFN());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_ALL(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"ALL"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::ALL());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_AMD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"AMD"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::AMD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_ANG(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"ANG"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::ANG());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_AOA(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"AOA"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::AOA());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_ARS(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"ARS"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::ARS());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_AUD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"AUD"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::AUD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_AWG(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"AWG"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::AWG());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_AZN(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"AZN"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::AZN());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_BAM(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"BAM"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::BAM());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_BBD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"BBD"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::BBD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_BDT(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"BDT"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::BDT());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_BGN(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"BGN"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::BGN());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_BHD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"BHD"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::BHD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_BIF(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"BIF"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::BIF());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_BMD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"BMD"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::BMD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_BND(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"BND"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::BND());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_BOB(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"BOB"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::BOB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_BRL(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"BRL"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::BRL());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_BSD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"BSD"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::BSD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_BTN(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"BTN"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::BTN());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_BWP(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"BWP"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::BWP());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_BYR(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"BYR"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::BYR());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_BZD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"BZD"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::BZD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_CAD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"CAD"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::CAD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_CDF(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"CDF"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::CDF());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_CHF(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"CHF"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::CHF());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_CLP(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"CLP"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::CLP());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_CNY(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"CNY"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::CNY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_COP(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"COP"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::COP());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_CRC(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"CRC"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::CRC());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_CUP(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"CUP"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::CUP());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_CVE(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"CVE"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::CVE());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_CZK(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"CZK"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::CZK());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_DJF(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"DJF"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::DJF());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_DKK(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"DKK"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::DKK());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_DOP(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"DOP"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::DOP());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_DZD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"DZD"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::DZD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_EGP(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"EGP"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::EGP());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_ERN(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"ERN"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::ERN());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_ETB(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"ETB"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::ETB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_EUR(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"EUR"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::EUR());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_FJD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"FJD"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::FJD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_FKP(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"FKP"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::FKP());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_GBP(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"GBP"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::GBP());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_GEL(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"GEL"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::GEL());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_GHS(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"GHS"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::GHS());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_GIP(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"GIP"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::GIP());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_GMD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"GMD"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::GMD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_GNF(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"GNF"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::GNF());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_GTQ(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"GTQ"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::GTQ());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_GYD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"GYD"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::GYD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_HKD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"HKD"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::HKD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_RON(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"RON"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::RON());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_HRK(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"HRK"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::HRK());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_HTG(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"HTG"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::HTG());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_HUF(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"HUF"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::HUF());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_IDR(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"IDR"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::IDR());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_ILS(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"ILS"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::ILS());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_INR(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"INR"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::INR());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_IQD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"IQD"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::IQD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_IRR(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"IRR"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::IRR());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_ISK(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"ISK"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::ISK());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_JMD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"JMD"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::JMD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_JOD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"JOD"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::JOD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_JPY(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"JPY"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::JPY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_KES(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"KES"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::KES());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_KGS(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"KGS"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::KGS());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_KHR(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"KHR"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::KHR());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_KMF(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"KMF"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::KMF());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_KPW(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"KPW"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::KPW());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_KRW(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"KRW"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::KRW());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_KWD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"KWD"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::KWD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_KYD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"KYD"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::KYD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_KZT(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"KZT"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::KZT());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_LAK(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"LAK"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::LAK());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_LBP(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"LBP"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::LBP());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_LKR(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"LKR"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::LKR());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_LRD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"LRD"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::LRD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_LSL(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"LSL"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::LSL());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_LTL(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"LTL"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::LTL());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_LVL(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"LVL"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::LVL());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_LYD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"LYD"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::LYD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_MAD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"MAD"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::MAD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_MDL(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"MDL"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::MDL());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_MGA(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"MGA"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::MGA());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_MKD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"MKD"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::MKD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_MMK(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"MMK"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::MMK());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_MNT(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"MNT"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::MNT());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_MOP(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"MOP"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::MOP());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_MRO(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"MRO"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::MRO());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_MUR(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"MUR"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::MUR());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_MVR(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"MVR"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::MVR());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_MWK(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"MWK"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::MWK());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_MXN(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"MXN"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::MXN());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_MYR(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"MYR"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::MYR());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_MZN(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"MZN"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::MZN());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_NAD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"NAD"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::NAD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_NGN(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"NGN"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::NGN());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_NIO(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"NIO"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::NIO());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_NOK(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"NOK"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::NOK());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_NPR(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"NPR"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::NPR());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_NZD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"NZD"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::NZD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_OMR(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"OMR"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::OMR());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_PAB(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"PAB"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::PAB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_PEN(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"PEN"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::PEN());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_PGK(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"PGK"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::PGK());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_PHP(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"PHP"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::PHP());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_PKR(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"PKR"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::PKR());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_PLN(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"PLN"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::PLN());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_PYG(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"PYG"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::PYG());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_QAR(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"QAR"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::QAR());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_RSD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"RSD"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::RSD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_RUB(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"RUB"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::RUB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_RWF(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"RWF"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::RWF());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_SAR(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"SAR"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::SAR());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_SBD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"SBD"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::SBD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_SCR(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"SCR"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::SCR());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_SDG(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"SDG"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::SDG());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_SEK(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"SEK"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::SEK());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_SGD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"SGD"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::SGD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_SHP(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"SHP"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::SHP());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_SLL(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"SLL"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::SLL());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_SOS(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"SOS"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::SOS());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_SRD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"SRD"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::SRD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_STD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"STD"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::STD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_SYP(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"SYP"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::SYP());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_SZL(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"SZL"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::SZL());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_THB(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"THB"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::THB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_TJS(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"TJS"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::TJS());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_TMT(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"TMT"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::TMT());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_TND(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"TND"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::TND());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_TOP(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"TOP"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::TOP());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_TRY(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"TRY"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::TRY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_TTD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"TTD"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::TTD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_TWD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"TWD"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::TWD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_TZS(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"TZS"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::TZS());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_UAH(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"UAH"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::UAH());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_UGX(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"UGX"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::UGX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_USD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"USD"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::USD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_UYU(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"UYU"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::UYU());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_UZS(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"UZS"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::UZS());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_VEF(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"VEF"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::VEF());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_VND(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"VND"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::VND());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_VUV(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"VUV"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::VUV());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_WST(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"WST"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::WST());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_XAF(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"XAF"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::XAF());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_XCD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"XCD"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::XCD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_XOF(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"XOF"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::XOF());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_XPF(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"XPF"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::XPF());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_XXX(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"XXX"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::XXX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_YER(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"YER"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::YER());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_ZAR(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"ZAR"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::ZAR());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_ZMW(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"ZMW"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::ZMW());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_ZWL(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"ZWL"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::ZWL());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_BYN(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"BYN"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::BYN());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_SSP(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"SSP"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::SSP());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_STN(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"STN"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::STN());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_VES(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"VES"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::VES());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyIdentifiers_get_MRU(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.CurrencyIdentifiers", L"MRU"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::CurrencyIdentifiers::MRU());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CurrencyIdentifiers[] = {
        { }
    };

    static PyGetSetDef _getset_CurrencyIdentifiers[] = {
        { }
    };

    static PyType_Slot _type_slots_CurrencyIdentifiers[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CurrencyIdentifiers) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CurrencyIdentifiers) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CurrencyIdentifiers) },
        { },
    };

    static PyType_Spec type_spec_CurrencyIdentifiers =
    {
        "winrt._winrt_windows_globalization.CurrencyIdentifiers",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CurrencyIdentifiers
    };

    static PyGetSetDef getset_CurrencyIdentifiers_Static[] = {
        { "h_n_l", reinterpret_cast<getter>(CurrencyIdentifiers_get_HNL), nullptr, nullptr, nullptr },
        { "a_e_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_AED), nullptr, nullptr, nullptr },
        { "a_f_n", reinterpret_cast<getter>(CurrencyIdentifiers_get_AFN), nullptr, nullptr, nullptr },
        { "a_l_l", reinterpret_cast<getter>(CurrencyIdentifiers_get_ALL), nullptr, nullptr, nullptr },
        { "a_m_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_AMD), nullptr, nullptr, nullptr },
        { "a_n_g", reinterpret_cast<getter>(CurrencyIdentifiers_get_ANG), nullptr, nullptr, nullptr },
        { "a_o_a", reinterpret_cast<getter>(CurrencyIdentifiers_get_AOA), nullptr, nullptr, nullptr },
        { "a_r_s", reinterpret_cast<getter>(CurrencyIdentifiers_get_ARS), nullptr, nullptr, nullptr },
        { "a_u_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_AUD), nullptr, nullptr, nullptr },
        { "a_w_g", reinterpret_cast<getter>(CurrencyIdentifiers_get_AWG), nullptr, nullptr, nullptr },
        { "a_z_n", reinterpret_cast<getter>(CurrencyIdentifiers_get_AZN), nullptr, nullptr, nullptr },
        { "b_a_m", reinterpret_cast<getter>(CurrencyIdentifiers_get_BAM), nullptr, nullptr, nullptr },
        { "b_b_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_BBD), nullptr, nullptr, nullptr },
        { "b_d_t", reinterpret_cast<getter>(CurrencyIdentifiers_get_BDT), nullptr, nullptr, nullptr },
        { "b_g_n", reinterpret_cast<getter>(CurrencyIdentifiers_get_BGN), nullptr, nullptr, nullptr },
        { "b_h_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_BHD), nullptr, nullptr, nullptr },
        { "b_i_f", reinterpret_cast<getter>(CurrencyIdentifiers_get_BIF), nullptr, nullptr, nullptr },
        { "b_m_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_BMD), nullptr, nullptr, nullptr },
        { "b_n_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_BND), nullptr, nullptr, nullptr },
        { "b_o_b", reinterpret_cast<getter>(CurrencyIdentifiers_get_BOB), nullptr, nullptr, nullptr },
        { "b_r_l", reinterpret_cast<getter>(CurrencyIdentifiers_get_BRL), nullptr, nullptr, nullptr },
        { "b_s_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_BSD), nullptr, nullptr, nullptr },
        { "b_t_n", reinterpret_cast<getter>(CurrencyIdentifiers_get_BTN), nullptr, nullptr, nullptr },
        { "b_w_p", reinterpret_cast<getter>(CurrencyIdentifiers_get_BWP), nullptr, nullptr, nullptr },
        { "b_y_r", reinterpret_cast<getter>(CurrencyIdentifiers_get_BYR), nullptr, nullptr, nullptr },
        { "b_z_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_BZD), nullptr, nullptr, nullptr },
        { "c_a_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_CAD), nullptr, nullptr, nullptr },
        { "c_d_f", reinterpret_cast<getter>(CurrencyIdentifiers_get_CDF), nullptr, nullptr, nullptr },
        { "c_h_f", reinterpret_cast<getter>(CurrencyIdentifiers_get_CHF), nullptr, nullptr, nullptr },
        { "c_l_p", reinterpret_cast<getter>(CurrencyIdentifiers_get_CLP), nullptr, nullptr, nullptr },
        { "c_n_y", reinterpret_cast<getter>(CurrencyIdentifiers_get_CNY), nullptr, nullptr, nullptr },
        { "c_o_p", reinterpret_cast<getter>(CurrencyIdentifiers_get_COP), nullptr, nullptr, nullptr },
        { "c_r_c", reinterpret_cast<getter>(CurrencyIdentifiers_get_CRC), nullptr, nullptr, nullptr },
        { "c_u_p", reinterpret_cast<getter>(CurrencyIdentifiers_get_CUP), nullptr, nullptr, nullptr },
        { "c_v_e", reinterpret_cast<getter>(CurrencyIdentifiers_get_CVE), nullptr, nullptr, nullptr },
        { "c_z_k", reinterpret_cast<getter>(CurrencyIdentifiers_get_CZK), nullptr, nullptr, nullptr },
        { "d_j_f", reinterpret_cast<getter>(CurrencyIdentifiers_get_DJF), nullptr, nullptr, nullptr },
        { "d_k_k", reinterpret_cast<getter>(CurrencyIdentifiers_get_DKK), nullptr, nullptr, nullptr },
        { "d_o_p", reinterpret_cast<getter>(CurrencyIdentifiers_get_DOP), nullptr, nullptr, nullptr },
        { "d_z_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_DZD), nullptr, nullptr, nullptr },
        { "e_g_p", reinterpret_cast<getter>(CurrencyIdentifiers_get_EGP), nullptr, nullptr, nullptr },
        { "e_r_n", reinterpret_cast<getter>(CurrencyIdentifiers_get_ERN), nullptr, nullptr, nullptr },
        { "e_t_b", reinterpret_cast<getter>(CurrencyIdentifiers_get_ETB), nullptr, nullptr, nullptr },
        { "e_u_r", reinterpret_cast<getter>(CurrencyIdentifiers_get_EUR), nullptr, nullptr, nullptr },
        { "f_j_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_FJD), nullptr, nullptr, nullptr },
        { "f_k_p", reinterpret_cast<getter>(CurrencyIdentifiers_get_FKP), nullptr, nullptr, nullptr },
        { "g_b_p", reinterpret_cast<getter>(CurrencyIdentifiers_get_GBP), nullptr, nullptr, nullptr },
        { "g_e_l", reinterpret_cast<getter>(CurrencyIdentifiers_get_GEL), nullptr, nullptr, nullptr },
        { "g_h_s", reinterpret_cast<getter>(CurrencyIdentifiers_get_GHS), nullptr, nullptr, nullptr },
        { "g_i_p", reinterpret_cast<getter>(CurrencyIdentifiers_get_GIP), nullptr, nullptr, nullptr },
        { "g_m_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_GMD), nullptr, nullptr, nullptr },
        { "g_n_f", reinterpret_cast<getter>(CurrencyIdentifiers_get_GNF), nullptr, nullptr, nullptr },
        { "g_t_q", reinterpret_cast<getter>(CurrencyIdentifiers_get_GTQ), nullptr, nullptr, nullptr },
        { "g_y_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_GYD), nullptr, nullptr, nullptr },
        { "h_k_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_HKD), nullptr, nullptr, nullptr },
        { "r_o_n", reinterpret_cast<getter>(CurrencyIdentifiers_get_RON), nullptr, nullptr, nullptr },
        { "h_r_k", reinterpret_cast<getter>(CurrencyIdentifiers_get_HRK), nullptr, nullptr, nullptr },
        { "h_t_g", reinterpret_cast<getter>(CurrencyIdentifiers_get_HTG), nullptr, nullptr, nullptr },
        { "h_u_f", reinterpret_cast<getter>(CurrencyIdentifiers_get_HUF), nullptr, nullptr, nullptr },
        { "i_d_r", reinterpret_cast<getter>(CurrencyIdentifiers_get_IDR), nullptr, nullptr, nullptr },
        { "i_l_s", reinterpret_cast<getter>(CurrencyIdentifiers_get_ILS), nullptr, nullptr, nullptr },
        { "i_n_r", reinterpret_cast<getter>(CurrencyIdentifiers_get_INR), nullptr, nullptr, nullptr },
        { "i_q_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_IQD), nullptr, nullptr, nullptr },
        { "i_r_r", reinterpret_cast<getter>(CurrencyIdentifiers_get_IRR), nullptr, nullptr, nullptr },
        { "i_s_k", reinterpret_cast<getter>(CurrencyIdentifiers_get_ISK), nullptr, nullptr, nullptr },
        { "j_m_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_JMD), nullptr, nullptr, nullptr },
        { "j_o_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_JOD), nullptr, nullptr, nullptr },
        { "j_p_y", reinterpret_cast<getter>(CurrencyIdentifiers_get_JPY), nullptr, nullptr, nullptr },
        { "k_e_s", reinterpret_cast<getter>(CurrencyIdentifiers_get_KES), nullptr, nullptr, nullptr },
        { "k_g_s", reinterpret_cast<getter>(CurrencyIdentifiers_get_KGS), nullptr, nullptr, nullptr },
        { "k_h_r", reinterpret_cast<getter>(CurrencyIdentifiers_get_KHR), nullptr, nullptr, nullptr },
        { "k_m_f", reinterpret_cast<getter>(CurrencyIdentifiers_get_KMF), nullptr, nullptr, nullptr },
        { "k_p_w", reinterpret_cast<getter>(CurrencyIdentifiers_get_KPW), nullptr, nullptr, nullptr },
        { "k_r_w", reinterpret_cast<getter>(CurrencyIdentifiers_get_KRW), nullptr, nullptr, nullptr },
        { "k_w_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_KWD), nullptr, nullptr, nullptr },
        { "k_y_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_KYD), nullptr, nullptr, nullptr },
        { "k_z_t", reinterpret_cast<getter>(CurrencyIdentifiers_get_KZT), nullptr, nullptr, nullptr },
        { "l_a_k", reinterpret_cast<getter>(CurrencyIdentifiers_get_LAK), nullptr, nullptr, nullptr },
        { "l_b_p", reinterpret_cast<getter>(CurrencyIdentifiers_get_LBP), nullptr, nullptr, nullptr },
        { "l_k_r", reinterpret_cast<getter>(CurrencyIdentifiers_get_LKR), nullptr, nullptr, nullptr },
        { "l_r_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_LRD), nullptr, nullptr, nullptr },
        { "l_s_l", reinterpret_cast<getter>(CurrencyIdentifiers_get_LSL), nullptr, nullptr, nullptr },
        { "l_t_l", reinterpret_cast<getter>(CurrencyIdentifiers_get_LTL), nullptr, nullptr, nullptr },
        { "l_v_l", reinterpret_cast<getter>(CurrencyIdentifiers_get_LVL), nullptr, nullptr, nullptr },
        { "l_y_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_LYD), nullptr, nullptr, nullptr },
        { "m_a_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_MAD), nullptr, nullptr, nullptr },
        { "m_d_l", reinterpret_cast<getter>(CurrencyIdentifiers_get_MDL), nullptr, nullptr, nullptr },
        { "m_g_a", reinterpret_cast<getter>(CurrencyIdentifiers_get_MGA), nullptr, nullptr, nullptr },
        { "m_k_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_MKD), nullptr, nullptr, nullptr },
        { "m_m_k", reinterpret_cast<getter>(CurrencyIdentifiers_get_MMK), nullptr, nullptr, nullptr },
        { "m_n_t", reinterpret_cast<getter>(CurrencyIdentifiers_get_MNT), nullptr, nullptr, nullptr },
        { "m_o_p", reinterpret_cast<getter>(CurrencyIdentifiers_get_MOP), nullptr, nullptr, nullptr },
        { "m_r_o", reinterpret_cast<getter>(CurrencyIdentifiers_get_MRO), nullptr, nullptr, nullptr },
        { "m_u_r", reinterpret_cast<getter>(CurrencyIdentifiers_get_MUR), nullptr, nullptr, nullptr },
        { "m_v_r", reinterpret_cast<getter>(CurrencyIdentifiers_get_MVR), nullptr, nullptr, nullptr },
        { "m_w_k", reinterpret_cast<getter>(CurrencyIdentifiers_get_MWK), nullptr, nullptr, nullptr },
        { "m_x_n", reinterpret_cast<getter>(CurrencyIdentifiers_get_MXN), nullptr, nullptr, nullptr },
        { "m_y_r", reinterpret_cast<getter>(CurrencyIdentifiers_get_MYR), nullptr, nullptr, nullptr },
        { "m_z_n", reinterpret_cast<getter>(CurrencyIdentifiers_get_MZN), nullptr, nullptr, nullptr },
        { "n_a_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_NAD), nullptr, nullptr, nullptr },
        { "n_g_n", reinterpret_cast<getter>(CurrencyIdentifiers_get_NGN), nullptr, nullptr, nullptr },
        { "n_i_o", reinterpret_cast<getter>(CurrencyIdentifiers_get_NIO), nullptr, nullptr, nullptr },
        { "n_o_k", reinterpret_cast<getter>(CurrencyIdentifiers_get_NOK), nullptr, nullptr, nullptr },
        { "n_p_r", reinterpret_cast<getter>(CurrencyIdentifiers_get_NPR), nullptr, nullptr, nullptr },
        { "n_z_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_NZD), nullptr, nullptr, nullptr },
        { "o_m_r", reinterpret_cast<getter>(CurrencyIdentifiers_get_OMR), nullptr, nullptr, nullptr },
        { "p_a_b", reinterpret_cast<getter>(CurrencyIdentifiers_get_PAB), nullptr, nullptr, nullptr },
        { "p_e_n", reinterpret_cast<getter>(CurrencyIdentifiers_get_PEN), nullptr, nullptr, nullptr },
        { "p_g_k", reinterpret_cast<getter>(CurrencyIdentifiers_get_PGK), nullptr, nullptr, nullptr },
        { "p_h_p", reinterpret_cast<getter>(CurrencyIdentifiers_get_PHP), nullptr, nullptr, nullptr },
        { "p_k_r", reinterpret_cast<getter>(CurrencyIdentifiers_get_PKR), nullptr, nullptr, nullptr },
        { "p_l_n", reinterpret_cast<getter>(CurrencyIdentifiers_get_PLN), nullptr, nullptr, nullptr },
        { "p_y_g", reinterpret_cast<getter>(CurrencyIdentifiers_get_PYG), nullptr, nullptr, nullptr },
        { "q_a_r", reinterpret_cast<getter>(CurrencyIdentifiers_get_QAR), nullptr, nullptr, nullptr },
        { "r_s_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_RSD), nullptr, nullptr, nullptr },
        { "r_u_b", reinterpret_cast<getter>(CurrencyIdentifiers_get_RUB), nullptr, nullptr, nullptr },
        { "r_w_f", reinterpret_cast<getter>(CurrencyIdentifiers_get_RWF), nullptr, nullptr, nullptr },
        { "s_a_r", reinterpret_cast<getter>(CurrencyIdentifiers_get_SAR), nullptr, nullptr, nullptr },
        { "s_b_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_SBD), nullptr, nullptr, nullptr },
        { "s_c_r", reinterpret_cast<getter>(CurrencyIdentifiers_get_SCR), nullptr, nullptr, nullptr },
        { "s_d_g", reinterpret_cast<getter>(CurrencyIdentifiers_get_SDG), nullptr, nullptr, nullptr },
        { "s_e_k", reinterpret_cast<getter>(CurrencyIdentifiers_get_SEK), nullptr, nullptr, nullptr },
        { "s_g_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_SGD), nullptr, nullptr, nullptr },
        { "s_h_p", reinterpret_cast<getter>(CurrencyIdentifiers_get_SHP), nullptr, nullptr, nullptr },
        { "s_l_l", reinterpret_cast<getter>(CurrencyIdentifiers_get_SLL), nullptr, nullptr, nullptr },
        { "s_o_s", reinterpret_cast<getter>(CurrencyIdentifiers_get_SOS), nullptr, nullptr, nullptr },
        { "s_r_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_SRD), nullptr, nullptr, nullptr },
        { "s_t_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_STD), nullptr, nullptr, nullptr },
        { "s_y_p", reinterpret_cast<getter>(CurrencyIdentifiers_get_SYP), nullptr, nullptr, nullptr },
        { "s_z_l", reinterpret_cast<getter>(CurrencyIdentifiers_get_SZL), nullptr, nullptr, nullptr },
        { "t_h_b", reinterpret_cast<getter>(CurrencyIdentifiers_get_THB), nullptr, nullptr, nullptr },
        { "t_j_s", reinterpret_cast<getter>(CurrencyIdentifiers_get_TJS), nullptr, nullptr, nullptr },
        { "t_m_t", reinterpret_cast<getter>(CurrencyIdentifiers_get_TMT), nullptr, nullptr, nullptr },
        { "t_n_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_TND), nullptr, nullptr, nullptr },
        { "t_o_p", reinterpret_cast<getter>(CurrencyIdentifiers_get_TOP), nullptr, nullptr, nullptr },
        { "t_r_y", reinterpret_cast<getter>(CurrencyIdentifiers_get_TRY), nullptr, nullptr, nullptr },
        { "t_t_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_TTD), nullptr, nullptr, nullptr },
        { "t_w_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_TWD), nullptr, nullptr, nullptr },
        { "t_z_s", reinterpret_cast<getter>(CurrencyIdentifiers_get_TZS), nullptr, nullptr, nullptr },
        { "u_a_h", reinterpret_cast<getter>(CurrencyIdentifiers_get_UAH), nullptr, nullptr, nullptr },
        { "u_g_x", reinterpret_cast<getter>(CurrencyIdentifiers_get_UGX), nullptr, nullptr, nullptr },
        { "u_s_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_USD), nullptr, nullptr, nullptr },
        { "u_y_u", reinterpret_cast<getter>(CurrencyIdentifiers_get_UYU), nullptr, nullptr, nullptr },
        { "u_z_s", reinterpret_cast<getter>(CurrencyIdentifiers_get_UZS), nullptr, nullptr, nullptr },
        { "v_e_f", reinterpret_cast<getter>(CurrencyIdentifiers_get_VEF), nullptr, nullptr, nullptr },
        { "v_n_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_VND), nullptr, nullptr, nullptr },
        { "v_u_v", reinterpret_cast<getter>(CurrencyIdentifiers_get_VUV), nullptr, nullptr, nullptr },
        { "w_s_t", reinterpret_cast<getter>(CurrencyIdentifiers_get_WST), nullptr, nullptr, nullptr },
        { "x_a_f", reinterpret_cast<getter>(CurrencyIdentifiers_get_XAF), nullptr, nullptr, nullptr },
        { "x_c_d", reinterpret_cast<getter>(CurrencyIdentifiers_get_XCD), nullptr, nullptr, nullptr },
        { "x_o_f", reinterpret_cast<getter>(CurrencyIdentifiers_get_XOF), nullptr, nullptr, nullptr },
        { "x_p_f", reinterpret_cast<getter>(CurrencyIdentifiers_get_XPF), nullptr, nullptr, nullptr },
        { "x_x_x", reinterpret_cast<getter>(CurrencyIdentifiers_get_XXX), nullptr, nullptr, nullptr },
        { "y_e_r", reinterpret_cast<getter>(CurrencyIdentifiers_get_YER), nullptr, nullptr, nullptr },
        { "z_a_r", reinterpret_cast<getter>(CurrencyIdentifiers_get_ZAR), nullptr, nullptr, nullptr },
        { "z_m_w", reinterpret_cast<getter>(CurrencyIdentifiers_get_ZMW), nullptr, nullptr, nullptr },
        { "z_w_l", reinterpret_cast<getter>(CurrencyIdentifiers_get_ZWL), nullptr, nullptr, nullptr },
        { "b_y_n", reinterpret_cast<getter>(CurrencyIdentifiers_get_BYN), nullptr, nullptr, nullptr },
        { "s_s_p", reinterpret_cast<getter>(CurrencyIdentifiers_get_SSP), nullptr, nullptr, nullptr },
        { "s_t_n", reinterpret_cast<getter>(CurrencyIdentifiers_get_STN), nullptr, nullptr, nullptr },
        { "v_e_s", reinterpret_cast<getter>(CurrencyIdentifiers_get_VES), nullptr, nullptr, nullptr },
        { "m_r_u", reinterpret_cast<getter>(CurrencyIdentifiers_get_MRU), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_CurrencyIdentifiers_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CurrencyIdentifiers_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CurrencyIdentifiers_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CurrencyIdentifiers_Static) },
        { }
    };

    static PyType_Spec type_spec_CurrencyIdentifiers_Static =
    {
        "winrt._winrt_windows_globalization.CurrencyIdentifiers_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CurrencyIdentifiers_Static
    };

    // ----- GeographicRegion class --------------------

    static PyObject* _new_GeographicRegion(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Globalization::GeographicRegion instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Globalization::GeographicRegion instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GeographicRegion(py::wrapper::Windows::Globalization::GeographicRegion* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GeographicRegion_IsSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.GeographicRegion", L"IsSupported", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Globalization::GeographicRegion::IsSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeographicRegion_get_Code(py::wrapper::Windows::Globalization::GeographicRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.GeographicRegion", L"Code"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Code());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeographicRegion_get_CodeThreeDigit(py::wrapper::Windows::Globalization::GeographicRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.GeographicRegion", L"CodeThreeDigit"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CodeThreeDigit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeographicRegion_get_CodeThreeLetter(py::wrapper::Windows::Globalization::GeographicRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.GeographicRegion", L"CodeThreeLetter"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CodeThreeLetter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeographicRegion_get_CodeTwoLetter(py::wrapper::Windows::Globalization::GeographicRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.GeographicRegion", L"CodeTwoLetter"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CodeTwoLetter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeographicRegion_get_CurrenciesInUse(py::wrapper::Windows::Globalization::GeographicRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.GeographicRegion", L"CurrenciesInUse"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CurrenciesInUse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeographicRegion_get_DisplayName(py::wrapper::Windows::Globalization::GeographicRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.GeographicRegion", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeographicRegion_get_NativeName(py::wrapper::Windows::Globalization::GeographicRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.GeographicRegion", L"NativeName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NativeName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GeographicRegion(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::GeographicRegion>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GeographicRegion(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::GeographicRegion>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GeographicRegion[] = {
        { "_assign_array_", _assign_array_GeographicRegion, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GeographicRegion), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GeographicRegion[] = {
        { "code", reinterpret_cast<getter>(GeographicRegion_get_Code), nullptr, nullptr, nullptr },
        { "code_three_digit", reinterpret_cast<getter>(GeographicRegion_get_CodeThreeDigit), nullptr, nullptr, nullptr },
        { "code_three_letter", reinterpret_cast<getter>(GeographicRegion_get_CodeThreeLetter), nullptr, nullptr, nullptr },
        { "code_two_letter", reinterpret_cast<getter>(GeographicRegion_get_CodeTwoLetter), nullptr, nullptr, nullptr },
        { "currencies_in_use", reinterpret_cast<getter>(GeographicRegion_get_CurrenciesInUse), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(GeographicRegion_get_DisplayName), nullptr, nullptr, nullptr },
        { "native_name", reinterpret_cast<getter>(GeographicRegion_get_NativeName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GeographicRegion[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GeographicRegion) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GeographicRegion) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GeographicRegion) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GeographicRegion) },
        { },
    };

    static PyType_Spec type_spec_GeographicRegion =
    {
        "winrt._winrt_windows_globalization.GeographicRegion",
        sizeof(py::wrapper::Windows::Globalization::GeographicRegion),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GeographicRegion
    };

    static PyGetSetDef getset_GeographicRegion_Static[] = {
        { }
    };

    static PyMethodDef methods_GeographicRegion_Static[] = {
        { "is_supported", reinterpret_cast<PyCFunction>(GeographicRegion_IsSupported), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_GeographicRegion_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GeographicRegion_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GeographicRegion_Static) },
        { }
    };

    static PyType_Spec type_spec_GeographicRegion_Static =
    {
        "winrt._winrt_windows_globalization.GeographicRegion_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GeographicRegion_Static
    };

    // ----- JapanesePhoneme class --------------------

    static PyObject* _new_JapanesePhoneme(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Globalization::JapanesePhoneme>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Globalization::JapanesePhoneme>::type_name);
        return nullptr;
    }

    static void _dealloc_JapanesePhoneme(py::wrapper::Windows::Globalization::JapanesePhoneme* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* JapanesePhoneme_get_DisplayText(py::wrapper::Windows::Globalization::JapanesePhoneme* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.JapanesePhoneme", L"DisplayText"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JapanesePhoneme_get_IsPhraseStart(py::wrapper::Windows::Globalization::JapanesePhoneme* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.JapanesePhoneme", L"IsPhraseStart"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPhraseStart());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JapanesePhoneme_get_YomiText(py::wrapper::Windows::Globalization::JapanesePhoneme* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.JapanesePhoneme", L"YomiText"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.YomiText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_JapanesePhoneme(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::JapanesePhoneme>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_JapanesePhoneme(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::JapanesePhoneme>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_JapanesePhoneme[] = {
        { "_assign_array_", _assign_array_JapanesePhoneme, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_JapanesePhoneme), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_JapanesePhoneme[] = {
        { "display_text", reinterpret_cast<getter>(JapanesePhoneme_get_DisplayText), nullptr, nullptr, nullptr },
        { "is_phrase_start", reinterpret_cast<getter>(JapanesePhoneme_get_IsPhraseStart), nullptr, nullptr, nullptr },
        { "yomi_text", reinterpret_cast<getter>(JapanesePhoneme_get_YomiText), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_JapanesePhoneme[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_JapanesePhoneme) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_JapanesePhoneme) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_JapanesePhoneme) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_JapanesePhoneme) },
        { },
    };

    static PyType_Spec type_spec_JapanesePhoneme =
    {
        "winrt._winrt_windows_globalization.JapanesePhoneme",
        sizeof(py::wrapper::Windows::Globalization::JapanesePhoneme),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_JapanesePhoneme
    };

    // ----- JapanesePhoneticAnalyzer class --------------------

    static PyObject* _new_JapanesePhoneticAnalyzer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Globalization::JapanesePhoneticAnalyzer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Globalization::JapanesePhoneticAnalyzer>::type_name);
        return nullptr;
    }

    static PyObject* JapanesePhoneticAnalyzer_GetWords(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.JapanesePhoneticAnalyzer", L"GetWords", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Globalization::JapanesePhoneticAnalyzer::GetWords(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.JapanesePhoneticAnalyzer", L"GetWords", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(winrt::Windows::Globalization::JapanesePhoneticAnalyzer::GetWords(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_JapanesePhoneticAnalyzer[] = {
        { }
    };

    static PyGetSetDef _getset_JapanesePhoneticAnalyzer[] = {
        { }
    };

    static PyType_Slot _type_slots_JapanesePhoneticAnalyzer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_JapanesePhoneticAnalyzer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_JapanesePhoneticAnalyzer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_JapanesePhoneticAnalyzer) },
        { },
    };

    static PyType_Spec type_spec_JapanesePhoneticAnalyzer =
    {
        "winrt._winrt_windows_globalization.JapanesePhoneticAnalyzer",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_JapanesePhoneticAnalyzer
    };

    static PyGetSetDef getset_JapanesePhoneticAnalyzer_Static[] = {
        { }
    };

    static PyMethodDef methods_JapanesePhoneticAnalyzer_Static[] = {
        { "get_words", reinterpret_cast<PyCFunction>(JapanesePhoneticAnalyzer_GetWords), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_JapanesePhoneticAnalyzer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_JapanesePhoneticAnalyzer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_JapanesePhoneticAnalyzer_Static) },
        { }
    };

    static PyType_Spec type_spec_JapanesePhoneticAnalyzer_Static =
    {
        "winrt._winrt_windows_globalization.JapanesePhoneticAnalyzer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_JapanesePhoneticAnalyzer_Static
    };

    // ----- Language class --------------------

    static PyObject* _new_Language(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Globalization::Language instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Language(py::wrapper::Windows::Globalization::Language* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Language_GetExtensionSubtags(py::wrapper::Windows::Globalization::Language* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Language", L"GetExtensionSubtags", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetExtensionSubtags(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Language_GetMuiCompatibleLanguageListFromLanguageTags(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Language", L"GetMuiCompatibleLanguageListFromLanguageTags", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(winrt::Windows::Globalization::Language::GetMuiCompatibleLanguageListFromLanguageTags(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Language_IsWellFormed(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Language", L"IsWellFormed", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Globalization::Language::IsWellFormed(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Language_TrySetInputMethodLanguageTag(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.Language", L"TrySetInputMethodLanguageTag", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Globalization::Language::TrySetInputMethodLanguageTag(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Language_get_DisplayName(py::wrapper::Windows::Globalization::Language* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Language", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Language_get_LanguageTag(py::wrapper::Windows::Globalization::Language* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Language", L"LanguageTag"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LanguageTag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Language_get_NativeName(py::wrapper::Windows::Globalization::Language* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Language", L"NativeName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NativeName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Language_get_Script(py::wrapper::Windows::Globalization::Language* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Language", L"Script"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Script());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Language_get_LayoutDirection(py::wrapper::Windows::Globalization::Language* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Language", L"LayoutDirection"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LayoutDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Language_get_AbbreviatedName(py::wrapper::Windows::Globalization::Language* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Language", L"AbbreviatedName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AbbreviatedName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Language_get_CurrentInputMethodLanguageTag(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.Language", L"CurrentInputMethodLanguageTag"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::Language::CurrentInputMethodLanguageTag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Language(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::Language>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Language(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::Language>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Language[] = {
        { "get_extension_subtags", reinterpret_cast<PyCFunction>(Language_GetExtensionSubtags), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Language, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Language), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Language[] = {
        { "display_name", reinterpret_cast<getter>(Language_get_DisplayName), nullptr, nullptr, nullptr },
        { "language_tag", reinterpret_cast<getter>(Language_get_LanguageTag), nullptr, nullptr, nullptr },
        { "native_name", reinterpret_cast<getter>(Language_get_NativeName), nullptr, nullptr, nullptr },
        { "script", reinterpret_cast<getter>(Language_get_Script), nullptr, nullptr, nullptr },
        { "layout_direction", reinterpret_cast<getter>(Language_get_LayoutDirection), nullptr, nullptr, nullptr },
        { "abbreviated_name", reinterpret_cast<getter>(Language_get_AbbreviatedName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Language[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Language) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Language) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Language) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Language) },
        { },
    };

    static PyType_Spec type_spec_Language =
    {
        "winrt._winrt_windows_globalization.Language",
        sizeof(py::wrapper::Windows::Globalization::Language),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Language
    };

    static PyGetSetDef getset_Language_Static[] = {
        { "current_input_method_language_tag", reinterpret_cast<getter>(Language_get_CurrentInputMethodLanguageTag), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Language_Static[] = {
        { "get_mui_compatible_language_list_from_language_tags", reinterpret_cast<PyCFunction>(Language_GetMuiCompatibleLanguageListFromLanguageTags), METH_VARARGS, nullptr },
        { "is_well_formed", reinterpret_cast<PyCFunction>(Language_IsWellFormed), METH_VARARGS, nullptr },
        { "try_set_input_method_language_tag", reinterpret_cast<PyCFunction>(Language_TrySetInputMethodLanguageTag), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_Language_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Language_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Language_Static) },
        { }
    };

    static PyType_Spec type_spec_Language_Static =
    {
        "winrt._winrt_windows_globalization.Language_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Language_Static
    };

    // ----- NumeralSystemIdentifiers class --------------------

    static PyObject* _new_NumeralSystemIdentifiers(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Globalization::NumeralSystemIdentifiers>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Globalization::NumeralSystemIdentifiers>::type_name);
        return nullptr;
    }

    static PyObject* NumeralSystemIdentifiers_get_FullWide(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"FullWide"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::FullWide());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_Arab(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"Arab"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::Arab());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_ArabExt(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"ArabExt"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::ArabExt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_Bali(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"Bali"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::Bali());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_Beng(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"Beng"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::Beng());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_Cham(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"Cham"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::Cham());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_Deva(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"Deva"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::Deva());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_MymrShan(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"MymrShan"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::MymrShan());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_Gujr(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"Gujr"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::Gujr());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_Guru(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"Guru"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::Guru());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_HaniDec(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"HaniDec"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::HaniDec());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_Java(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"Java"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::Java());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_Kali(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"Kali"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::Kali());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_Khmr(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"Khmr"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::Khmr());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_Knda(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"Knda"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::Knda());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_Lana(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"Lana"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::Lana());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_LanaTham(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"LanaTham"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::LanaTham());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_Laoo(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"Laoo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::Laoo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_Latn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"Latn"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::Latn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_Lepc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"Lepc"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::Lepc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_Limb(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"Limb"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::Limb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_Mlym(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"Mlym"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::Mlym());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_Mong(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"Mong"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::Mong());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_Mtei(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"Mtei"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::Mtei());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_Mymr(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"Mymr"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::Mymr());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_Nkoo(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"Nkoo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::Nkoo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_Olck(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"Olck"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::Olck());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_Orya(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"Orya"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::Orya());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_Saur(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"Saur"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::Saur());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_Sund(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"Sund"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::Sund());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_Talu(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"Talu"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::Talu());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_TamlDec(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"TamlDec"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::TamlDec());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_Telu(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"Telu"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::Telu());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_Thai(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"Thai"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::Thai());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_Tibt(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"Tibt"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::Tibt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_Vaii(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"Vaii"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::Vaii());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_MathBold(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"MathBold"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::MathBold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_MathDbl(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"MathDbl"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::MathDbl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_MathMono(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"MathMono"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::MathMono());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_MathSanb(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"MathSanb"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::MathSanb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_MathSans(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"MathSans"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::MathSans());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_Osma(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"Osma"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::Osma());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_ZmthBold(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"ZmthBold"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::ZmthBold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_ZmthDbl(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"ZmthDbl"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::ZmthDbl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_ZmthMono(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"ZmthMono"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::ZmthMono());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_ZmthSanb(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"ZmthSanb"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::ZmthSanb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_ZmthSans(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"ZmthSans"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::ZmthSans());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemIdentifiers_get_Brah(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumeralSystemIdentifiers", L"Brah"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Globalization::NumeralSystemIdentifiers::Brah());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NumeralSystemIdentifiers[] = {
        { }
    };

    static PyGetSetDef _getset_NumeralSystemIdentifiers[] = {
        { }
    };

    static PyType_Slot _type_slots_NumeralSystemIdentifiers[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NumeralSystemIdentifiers) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NumeralSystemIdentifiers) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NumeralSystemIdentifiers) },
        { },
    };

    static PyType_Spec type_spec_NumeralSystemIdentifiers =
    {
        "winrt._winrt_windows_globalization.NumeralSystemIdentifiers",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NumeralSystemIdentifiers
    };

    static PyGetSetDef getset_NumeralSystemIdentifiers_Static[] = {
        { "full_wide", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_FullWide), nullptr, nullptr, nullptr },
        { "arab", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_Arab), nullptr, nullptr, nullptr },
        { "arab_ext", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_ArabExt), nullptr, nullptr, nullptr },
        { "bali", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_Bali), nullptr, nullptr, nullptr },
        { "beng", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_Beng), nullptr, nullptr, nullptr },
        { "cham", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_Cham), nullptr, nullptr, nullptr },
        { "deva", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_Deva), nullptr, nullptr, nullptr },
        { "mymr_shan", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_MymrShan), nullptr, nullptr, nullptr },
        { "gujr", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_Gujr), nullptr, nullptr, nullptr },
        { "guru", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_Guru), nullptr, nullptr, nullptr },
        { "hani_dec", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_HaniDec), nullptr, nullptr, nullptr },
        { "java", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_Java), nullptr, nullptr, nullptr },
        { "kali", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_Kali), nullptr, nullptr, nullptr },
        { "khmr", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_Khmr), nullptr, nullptr, nullptr },
        { "knda", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_Knda), nullptr, nullptr, nullptr },
        { "lana", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_Lana), nullptr, nullptr, nullptr },
        { "lana_tham", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_LanaTham), nullptr, nullptr, nullptr },
        { "laoo", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_Laoo), nullptr, nullptr, nullptr },
        { "latn", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_Latn), nullptr, nullptr, nullptr },
        { "lepc", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_Lepc), nullptr, nullptr, nullptr },
        { "limb", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_Limb), nullptr, nullptr, nullptr },
        { "mlym", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_Mlym), nullptr, nullptr, nullptr },
        { "mong", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_Mong), nullptr, nullptr, nullptr },
        { "mtei", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_Mtei), nullptr, nullptr, nullptr },
        { "mymr", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_Mymr), nullptr, nullptr, nullptr },
        { "nkoo", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_Nkoo), nullptr, nullptr, nullptr },
        { "olck", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_Olck), nullptr, nullptr, nullptr },
        { "orya", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_Orya), nullptr, nullptr, nullptr },
        { "saur", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_Saur), nullptr, nullptr, nullptr },
        { "sund", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_Sund), nullptr, nullptr, nullptr },
        { "talu", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_Talu), nullptr, nullptr, nullptr },
        { "taml_dec", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_TamlDec), nullptr, nullptr, nullptr },
        { "telu", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_Telu), nullptr, nullptr, nullptr },
        { "thai", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_Thai), nullptr, nullptr, nullptr },
        { "tibt", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_Tibt), nullptr, nullptr, nullptr },
        { "vaii", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_Vaii), nullptr, nullptr, nullptr },
        { "math_bold", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_MathBold), nullptr, nullptr, nullptr },
        { "math_dbl", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_MathDbl), nullptr, nullptr, nullptr },
        { "math_mono", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_MathMono), nullptr, nullptr, nullptr },
        { "math_sanb", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_MathSanb), nullptr, nullptr, nullptr },
        { "math_sans", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_MathSans), nullptr, nullptr, nullptr },
        { "osma", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_Osma), nullptr, nullptr, nullptr },
        { "zmth_bold", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_ZmthBold), nullptr, nullptr, nullptr },
        { "zmth_dbl", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_ZmthDbl), nullptr, nullptr, nullptr },
        { "zmth_mono", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_ZmthMono), nullptr, nullptr, nullptr },
        { "zmth_sanb", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_ZmthSanb), nullptr, nullptr, nullptr },
        { "zmth_sans", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_ZmthSans), nullptr, nullptr, nullptr },
        { "brah", reinterpret_cast<getter>(NumeralSystemIdentifiers_get_Brah), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_NumeralSystemIdentifiers_Static[] = {
        { }
    };

    static PyType_Slot type_slots_NumeralSystemIdentifiers_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NumeralSystemIdentifiers_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NumeralSystemIdentifiers_Static) },
        { }
    };

    static PyType_Spec type_spec_NumeralSystemIdentifiers_Static =
    {
        "winrt._winrt_windows_globalization.NumeralSystemIdentifiers_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_NumeralSystemIdentifiers_Static
    };

    // ----- Windows.Globalization Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Globalization");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_globalization",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Globalization

PyMODINIT_FUNC PyInit__winrt_windows_globalization(void) noexcept
{
    using namespace py::cpp::Windows::Globalization;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ApplicationLanguages_Static{PyType_FromSpec(&type_spec_ApplicationLanguages_Static)};
    if (!type_ApplicationLanguages_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ApplicationLanguages, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ApplicationLanguages_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Calendar, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_CalendarIdentifiers_Static{PyType_FromSpec(&type_spec_CalendarIdentifiers_Static)};
    if (!type_CalendarIdentifiers_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CalendarIdentifiers, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CalendarIdentifiers_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ClockIdentifiers_Static{PyType_FromSpec(&type_spec_ClockIdentifiers_Static)};
    if (!type_ClockIdentifiers_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ClockIdentifiers, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ClockIdentifiers_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CurrencyAmount, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_CurrencyIdentifiers_Static{PyType_FromSpec(&type_spec_CurrencyIdentifiers_Static)};
    if (!type_CurrencyIdentifiers_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CurrencyIdentifiers, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CurrencyIdentifiers_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_GeographicRegion_Static{PyType_FromSpec(&type_spec_GeographicRegion_Static)};
    if (!type_GeographicRegion_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GeographicRegion, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GeographicRegion_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_JapanesePhoneme, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_JapanesePhoneticAnalyzer_Static{PyType_FromSpec(&type_spec_JapanesePhoneticAnalyzer_Static)};
    if (!type_JapanesePhoneticAnalyzer_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_JapanesePhoneticAnalyzer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_JapanesePhoneticAnalyzer_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_Language_Static{PyType_FromSpec(&type_spec_Language_Static)};
    if (!type_Language_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Language, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Language_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_NumeralSystemIdentifiers_Static{PyType_FromSpec(&type_spec_NumeralSystemIdentifiers_Static)};
    if (!type_NumeralSystemIdentifiers_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_NumeralSystemIdentifiers, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_NumeralSystemIdentifiers_Static.get())) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
