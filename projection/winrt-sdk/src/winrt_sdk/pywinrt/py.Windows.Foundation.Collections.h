// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.1

#pragma once

#include "pybase.h"
static_assert(winrt::check_version(PYWINRT_VERSION, "3.2.1"), "Mismatched Py/WinRT headers.");
#include <winrt/Windows.Foundation.h>

#include <winrt/Windows.Foundation.Collections.h>

namespace py::proj::Windows::Foundation::Collections
{
    struct IIterable
    {
        virtual ~IIterable() {};
        virtual PyObject* First(PyObject*) noexcept = 0;
        virtual PyObject* dunder_iter() noexcept = 0;
    };

    struct IIterator
    {
        virtual ~IIterator() {};
        virtual PyObject* GetMany(PyObject*) noexcept = 0;
        virtual PyObject* MoveNext(PyObject*) noexcept = 0;
        virtual PyObject* get_Current() noexcept = 0;
        virtual PyObject* get_HasCurrent() noexcept = 0;
        virtual PyObject* dunder_iternext() noexcept = 0;
    };

    struct IKeyValuePair
    {
        virtual ~IKeyValuePair() {};
        virtual PyObject* get_Key() noexcept = 0;
        virtual PyObject* get_Value() noexcept = 0;
    };

    struct IMapChangedEventArgs
    {
        virtual ~IMapChangedEventArgs() {};
        virtual PyObject* get_CollectionChange() noexcept = 0;
        virtual PyObject* get_Key() noexcept = 0;
    };

    struct IMapView
    {
        virtual ~IMapView() {};
        virtual PyObject* First(PyObject*) noexcept = 0;
        virtual PyObject* HasKey(PyObject*) noexcept = 0;
        virtual PyObject* Lookup(PyObject*) noexcept = 0;
        virtual PyObject* Split(PyObject*) noexcept = 0;
        virtual PyObject* get_Size() noexcept = 0;
        virtual PyObject* dunder_iter() noexcept = 0;
        virtual int map_contains(PyObject* key) noexcept = 0;
        virtual Py_ssize_t map_length() noexcept = 0;
        virtual PyObject* map_subscript(PyObject* key) noexcept = 0;
    };

    struct IMap
    {
        virtual ~IMap() {};
        virtual PyObject* Clear(PyObject*) noexcept = 0;
        virtual PyObject* First(PyObject*) noexcept = 0;
        virtual PyObject* GetView(PyObject*) noexcept = 0;
        virtual PyObject* HasKey(PyObject*) noexcept = 0;
        virtual PyObject* Insert(PyObject*) noexcept = 0;
        virtual PyObject* Lookup(PyObject*) noexcept = 0;
        virtual PyObject* Remove(PyObject*) noexcept = 0;
        virtual PyObject* get_Size() noexcept = 0;
        virtual PyObject* dunder_iter() noexcept = 0;
        virtual int map_contains(PyObject* key) noexcept = 0;
        virtual Py_ssize_t map_length() noexcept = 0;
        virtual PyObject* map_subscript(PyObject* key) noexcept = 0;
        virtual int map_assign(PyObject* key, PyObject* value) noexcept = 0;
    };

    struct IObservableMap
    {
        virtual ~IObservableMap() {};
        virtual PyObject* Clear(PyObject*) noexcept = 0;
        virtual PyObject* First(PyObject*) noexcept = 0;
        virtual PyObject* GetView(PyObject*) noexcept = 0;
        virtual PyObject* HasKey(PyObject*) noexcept = 0;
        virtual PyObject* Insert(PyObject*) noexcept = 0;
        virtual PyObject* Lookup(PyObject*) noexcept = 0;
        virtual PyObject* Remove(PyObject*) noexcept = 0;
        virtual PyObject* get_Size() noexcept = 0;
        virtual PyObject* add_MapChanged(PyObject*) noexcept = 0;
        virtual PyObject* remove_MapChanged(PyObject*) noexcept = 0;
        virtual PyObject* dunder_iter() noexcept = 0;
        virtual int map_contains(PyObject* key) noexcept = 0;
        virtual Py_ssize_t map_length() noexcept = 0;
        virtual PyObject* map_subscript(PyObject* key) noexcept = 0;
        virtual int map_assign(PyObject* key, PyObject* value) noexcept = 0;
    };

    struct IObservableVector
    {
        virtual ~IObservableVector() {};
        virtual PyObject* Append(PyObject*) noexcept = 0;
        virtual PyObject* Clear(PyObject*) noexcept = 0;
        virtual PyObject* First(PyObject*) noexcept = 0;
        virtual PyObject* GetAt(PyObject*) noexcept = 0;
        virtual PyObject* GetMany(PyObject*) noexcept = 0;
        virtual PyObject* GetView(PyObject*) noexcept = 0;
        virtual PyObject* IndexOf(PyObject*) noexcept = 0;
        virtual PyObject* InsertAt(PyObject*) noexcept = 0;
        virtual PyObject* RemoveAt(PyObject*) noexcept = 0;
        virtual PyObject* RemoveAtEnd(PyObject*) noexcept = 0;
        virtual PyObject* ReplaceAll(PyObject*) noexcept = 0;
        virtual PyObject* SetAt(PyObject*) noexcept = 0;
        virtual PyObject* get_Size() noexcept = 0;
        virtual PyObject* add_VectorChanged(PyObject*) noexcept = 0;
        virtual PyObject* remove_VectorChanged(PyObject*) noexcept = 0;
        virtual PyObject* dunder_iter() noexcept = 0;
        virtual Py_ssize_t seq_length() noexcept = 0;
        virtual PyObject* seq_item(Py_ssize_t i) noexcept = 0;
        virtual PyObject* seq_subscript(PyObject* slice) noexcept = 0;
        virtual int seq_assign(Py_ssize_t i, PyObject* value) noexcept = 0;
    };

    struct IVectorView
    {
        virtual ~IVectorView() {};
        virtual PyObject* First(PyObject*) noexcept = 0;
        virtual PyObject* GetAt(PyObject*) noexcept = 0;
        virtual PyObject* GetMany(PyObject*) noexcept = 0;
        virtual PyObject* IndexOf(PyObject*) noexcept = 0;
        virtual PyObject* get_Size() noexcept = 0;
        virtual PyObject* dunder_iter() noexcept = 0;
        virtual Py_ssize_t seq_length() noexcept = 0;
        virtual PyObject* seq_item(Py_ssize_t i) noexcept = 0;
        virtual PyObject* seq_subscript(PyObject* slice) noexcept = 0;
    };

    struct IVector
    {
        virtual ~IVector() {};
        virtual PyObject* Append(PyObject*) noexcept = 0;
        virtual PyObject* Clear(PyObject*) noexcept = 0;
        virtual PyObject* First(PyObject*) noexcept = 0;
        virtual PyObject* GetAt(PyObject*) noexcept = 0;
        virtual PyObject* GetMany(PyObject*) noexcept = 0;
        virtual PyObject* GetView(PyObject*) noexcept = 0;
        virtual PyObject* IndexOf(PyObject*) noexcept = 0;
        virtual PyObject* InsertAt(PyObject*) noexcept = 0;
        virtual PyObject* RemoveAt(PyObject*) noexcept = 0;
        virtual PyObject* RemoveAtEnd(PyObject*) noexcept = 0;
        virtual PyObject* ReplaceAll(PyObject*) noexcept = 0;
        virtual PyObject* SetAt(PyObject*) noexcept = 0;
        virtual PyObject* get_Size() noexcept = 0;
        virtual PyObject* dunder_iter() noexcept = 0;
        virtual Py_ssize_t seq_length() noexcept = 0;
        virtual PyObject* seq_item(Py_ssize_t i) noexcept = 0;
        virtual PyObject* seq_subscript(PyObject* slice) noexcept = 0;
        virtual int seq_assign(Py_ssize_t i, PyObject* value) noexcept = 0;
    };
}

namespace py
{
    template<>
    inline constexpr const char* buffer_format<winrt::Windows::Foundation::Collections::CollectionChange> = "i";


    template<>
    struct py_type<winrt::Windows::Foundation::Collections::CollectionChange>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation.collections.CollectionChange";
        static constexpr const char* module_name = "winrt.windows.foundation.collections";
        static constexpr const char* type_name = "CollectionChange";
    };

    template<>
    struct py_type<winrt::Windows::Foundation::Collections::PropertySet>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation.collections.PropertySet";
        static constexpr const char* module_name = "winrt.windows.foundation.collections";
        static constexpr const char* type_name = "PropertySet";
    };

    template<>
    struct py_type<winrt::Windows::Foundation::Collections::StringMap>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation.collections.StringMap";
        static constexpr const char* module_name = "winrt.windows.foundation.collections";
        static constexpr const char* type_name = "StringMap";
    };

    template<>
    struct py_type<winrt::Windows::Foundation::Collections::ValueSet>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation.collections.ValueSet";
        static constexpr const char* module_name = "winrt.windows.foundation.collections";
        static constexpr const char* type_name = "ValueSet";
    };

    template<>
    struct py_type<py::proj::Windows::Foundation::Collections::IIterable>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation.collections._IIterable";
        static constexpr const char* module_name = "winrt.windows.foundation.collections";
        static constexpr const char* type_name = "_IIterable";
    };

    template<>
    struct py_type<py::proj::Windows::Foundation::Collections::IIterator>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation.collections._IIterator";
        static constexpr const char* module_name = "winrt.windows.foundation.collections";
        static constexpr const char* type_name = "_IIterator";
    };

    template<>
    struct py_type<py::proj::Windows::Foundation::Collections::IKeyValuePair>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation.collections._IKeyValuePair";
        static constexpr const char* module_name = "winrt.windows.foundation.collections";
        static constexpr const char* type_name = "_IKeyValuePair";
    };

    template<>
    struct py_type<py::proj::Windows::Foundation::Collections::IMapChangedEventArgs>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation.collections._IMapChangedEventArgs";
        static constexpr const char* module_name = "winrt.windows.foundation.collections";
        static constexpr const char* type_name = "_IMapChangedEventArgs";
    };

    template<>
    struct py_type<py::proj::Windows::Foundation::Collections::IMapView>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation.collections._IMapView";
        static constexpr const char* module_name = "winrt.windows.foundation.collections";
        static constexpr const char* type_name = "_IMapView";
    };

    template<>
    struct py_type<py::proj::Windows::Foundation::Collections::IMap>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation.collections._IMap";
        static constexpr const char* module_name = "winrt.windows.foundation.collections";
        static constexpr const char* type_name = "_IMap";
    };

    template<>
    struct py_type<py::proj::Windows::Foundation::Collections::IObservableMap>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation.collections._IObservableMap";
        static constexpr const char* module_name = "winrt.windows.foundation.collections";
        static constexpr const char* type_name = "_IObservableMap";
    };

    template<>
    struct py_type<py::proj::Windows::Foundation::Collections::IObservableVector>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation.collections._IObservableVector";
        static constexpr const char* module_name = "winrt.windows.foundation.collections";
        static constexpr const char* type_name = "_IObservableVector";
    };

    template<>
    struct py_type<winrt::Windows::Foundation::Collections::IPropertySet>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation.collections._IPropertySet";
        static constexpr const char* module_name = "winrt.windows.foundation.collections";
        static constexpr const char* type_name = "_IPropertySet";
    };

    template<>
    struct py_type<winrt::Windows::Foundation::Collections::IVectorChangedEventArgs>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation.collections._IVectorChangedEventArgs";
        static constexpr const char* module_name = "winrt.windows.foundation.collections";
        static constexpr const char* type_name = "_IVectorChangedEventArgs";
    };

    template<>
    struct py_type<py::proj::Windows::Foundation::Collections::IVectorView>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation.collections._IVectorView";
        static constexpr const char* module_name = "winrt.windows.foundation.collections";
        static constexpr const char* type_name = "_IVectorView";
    };

    template<>
    struct py_type<py::proj::Windows::Foundation::Collections::IVector>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation.collections._IVector";
        static constexpr const char* module_name = "winrt.windows.foundation.collections";
        static constexpr const char* type_name = "_IVector";
    };
}

#if __has_include("py.Windows.Foundation.h")
#include "py.Windows.Foundation.h"
#endif

namespace py::impl::Windows::Foundation::Collections
{
    template <typename K, typename V>
    struct MapChangedEventHandler
    {
        static winrt::Windows::Foundation::Collections::MapChangedEventHandler<K, V> get(PyObject* callable)
        {
            py::delegate_callable _delegate{ callable };

            return [delegate = std::move(_delegate)](winrt::Windows::Foundation::Collections::IObservableMap<K, V> const& param0, winrt::Windows::Foundation::Collections::IMapChangedEventArgs<K> const& param1)
            {
                auto gil = py::ensure_gil();

                try
                {
                    py::pyobj_handle py_param0{py::convert(param0)};
                    if (!py_param0)
                    {
                        throw python_exception();
                    }

                    py::pyobj_handle py_param1{py::convert(param1)};
                    if (!py_param1)
                    {
                        throw python_exception();
                    }

                    py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                    if (!args)
                    {
                        throw python_exception();
                    }

                    py::pyobj_handle return_value{PyObject_CallObject(delegate.callable(), args.get())};
                    if (!return_value)
                    {
                        throw python_exception();
                    }
                }
                catch (python_exception)
                {
                    py::write_unraisable_and_throw();
                }
            };
        };
    };

    template <typename T>
    struct VectorChangedEventHandler
    {
        static winrt::Windows::Foundation::Collections::VectorChangedEventHandler<T> get(PyObject* callable)
        {
            py::delegate_callable _delegate{ callable };

            return [delegate = std::move(_delegate)](winrt::Windows::Foundation::Collections::IObservableVector<T> const& param0, winrt::Windows::Foundation::Collections::IVectorChangedEventArgs const& param1)
            {
                auto gil = py::ensure_gil();

                try
                {
                    py::pyobj_handle py_param0{py::convert(param0)};
                    if (!py_param0)
                    {
                        throw python_exception();
                    }

                    py::pyobj_handle py_param1{py::convert(param1)};
                    if (!py_param1)
                    {
                        throw python_exception();
                    }

                    py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                    if (!args)
                    {
                        throw python_exception();
                    }

                    py::pyobj_handle return_value{PyObject_CallObject(delegate.callable(), args.get())};
                    if (!return_value)
                    {
                        throw python_exception();
                    }
                }
                catch (python_exception)
                {
                    py::write_unraisable_and_throw();
                }
            };
        };
    };

    template<typename T>
    struct IIterable : public py::proj::Windows::Foundation::Collections::IIterable
    {
        IIterable(winrt::Windows::Foundation::Collections::IIterable<T> o) : _obj(o) {}
        PyObject* First(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IIterable`1", L"First", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.First();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* dunder_iter() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = py::release_gil();
                    return _obj.First();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        winrt::Windows::Foundation::Collections::IIterable<T> _obj{ nullptr };
    };

    template<typename T>
    struct IIterator : public py::proj::Windows::Foundation::Collections::IIterator
    {
        IIterator(winrt::Windows::Foundation::Collections::IIterator<T> o) : _obj(o) {}
        PyObject* GetMany(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 1)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IIterator`1", L"GetMany", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    auto param0 = py::convert_to<py::pybuf_view<T, true>>(args, 0);

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetMany(param0);
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* MoveNext(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IIterator`1", L"MoveNext", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.MoveNext();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* get_Current() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.Current();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        PyObject* get_HasCurrent() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.HasCurrent();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        PyObject* dunder_iternext() noexcept override
        {
            try
            {
                if (_obj.HasCurrent())
                {
                    return py::convert([&]()
                    {
                        auto _gil = py::release_gil();
                        auto cur = _obj.Current();
                        _obj.MoveNext();
                        return cur;
                    }());
                }
                else
                {
                    return nullptr;
                }
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        winrt::Windows::Foundation::Collections::IIterator<T> _obj{ nullptr };
    };

    template<typename K, typename V>
    struct IKeyValuePair : public py::proj::Windows::Foundation::Collections::IKeyValuePair
    {
        IKeyValuePair(winrt::Windows::Foundation::Collections::IKeyValuePair<K, V> o) : _obj(o) {}
        PyObject* get_Key() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.Key();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        PyObject* get_Value() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.Value();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        winrt::Windows::Foundation::Collections::IKeyValuePair<K, V> _obj{ nullptr };
    };

    template<typename K>
    struct IMapChangedEventArgs : public py::proj::Windows::Foundation::Collections::IMapChangedEventArgs
    {
        IMapChangedEventArgs(winrt::Windows::Foundation::Collections::IMapChangedEventArgs<K> o) : _obj(o) {}
        PyObject* get_CollectionChange() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.CollectionChange();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        PyObject* get_Key() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.Key();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        winrt::Windows::Foundation::Collections::IMapChangedEventArgs<K> _obj{ nullptr };
    };

    template<typename K, typename V>
    struct IMapView : public py::proj::Windows::Foundation::Collections::IMapView
    {
        IMapView(winrt::Windows::Foundation::Collections::IMapView<K, V> o) : _obj(o) {}
        PyObject* First(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IIterable`1", L"First", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.First();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* HasKey(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 1)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IMapView`2", L"HasKey", 1);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(1);
                        return nullptr;
                    }

                    auto param0 = py::convert_to<K>(args, 0);

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.HasKey(param0);
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* Lookup(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 1)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IMapView`2", L"Lookup", 1);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(1);
                        return nullptr;
                    }

                    auto param0 = py::convert_to<K>(args, 0);

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.Lookup(param0);
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* Split(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IMapView`2", L"Split", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::Windows::Foundation::Collections::IMapView<K, V> param0{nullptr};
                    winrt::Windows::Foundation::Collections::IMapView<K, V> param1{nullptr};

                    {
                        auto _gil = release_gil();
                        _obj.Split(param0, param1);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }
                    py::pyobj_handle out1{ py::convert(param1) };
                    if (!out1)
                    {
                        return nullptr;
                    }

                    return PyTuple_Pack(2, out0.get(), out1.get());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* get_Size() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.Size();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        PyObject* dunder_iter() noexcept override
        {
            try
            {
                py::pyobj_handle iter{py::convert([&]()
                {
                    auto _gil = py::release_gil();
                    return _obj.First();
                }())};

                if (!iter)
                {
                    return nullptr;
                }

                return py::wrap_mapping_iter(iter.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        int map_contains(PyObject* key) noexcept override
        {
            try
            {
                auto _key = py::convert_to<K>(key);
                {
                    auto _gil = py::release_gil();
                    return static_cast<int>(_obj.HasKey(_key));
                }
            }
            catch (...)
            {
                py::to_PyErr();
                return -1;
            }
        }
        Py_ssize_t map_length() noexcept override
        {
            try
            {
                auto _gil = py::release_gil();
                return static_cast<Py_ssize_t>(_obj.Size());
            }
            catch (...)
            {
                py::to_PyErr();
                return -1;
            }
        }
        PyObject* map_subscript(PyObject* key) noexcept override
        {
            try
            {
                auto _key = py::convert_to<K>(key);
                auto value = [&]()
                {
                    auto _gil = py::release_gil();
                    return _obj.TryLookup(_key);
                }();

                if (!value)
                {
                    if constexpr (std::is_base_of_v<winrt::Windows::Foundation::IUnknown, decltype(value)>)
                    {
                        auto has_key = [&]()
                        {
                            auto _gil = py::release_gil();
                            return _obj.HasKey(_key);
                        }();

                        if (has_key)
                        {
                            Py_RETURN_NONE;
                        }
                    }

                    PyErr_SetObject(PyExc_KeyError, key);
                    return nullptr;
                }

                return py::convert(value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        winrt::Windows::Foundation::Collections::IMapView<K, V> _obj{ nullptr };
    };

    template<typename K, typename V>
    struct IMap : public py::proj::Windows::Foundation::Collections::IMap
    {
        IMap(winrt::Windows::Foundation::Collections::IMap<K, V> o) : _obj(o) {}
        PyObject* Clear(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IMap`2", L"Clear", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    {
                        auto _gil = release_gil();
                        _obj.Clear();
                    }

                    Py_RETURN_NONE;
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* First(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IIterable`1", L"First", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.First();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetView(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IMap`2", L"GetView", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetView();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* HasKey(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 1)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IMap`2", L"HasKey", 1);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(1);
                        return nullptr;
                    }

                    auto param0 = py::convert_to<K>(args, 0);

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.HasKey(param0);
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* Insert(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 2)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IMap`2", L"Insert", 2);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(2);
                        return nullptr;
                    }

                    auto param0 = py::convert_to<K>(args, 0);
                    auto param1 = py::convert_to<V>(args, 1);

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.Insert(param0, param1);
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* Lookup(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 1)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IMap`2", L"Lookup", 1);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(1);
                        return nullptr;
                    }

                    auto param0 = py::convert_to<K>(args, 0);

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.Lookup(param0);
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* Remove(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 1)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IMap`2", L"Remove", 1);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(1);
                        return nullptr;
                    }

                    auto param0 = py::convert_to<K>(args, 0);

                    {
                        auto _gil = release_gil();
                        _obj.Remove(param0);
                    }

                    Py_RETURN_NONE;
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* get_Size() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.Size();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        PyObject* dunder_iter() noexcept override
        {
            try
            {
                py::pyobj_handle iter{py::convert([&]()
                {
                    auto _gil = py::release_gil();
                    return _obj.First();
                }())};

                if (!iter)
                {
                    return nullptr;
                }

                return py::wrap_mapping_iter(iter.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        int map_contains(PyObject* key) noexcept override
        {
            try
            {
                auto _key = py::convert_to<K>(key);
                {
                    auto _gil = py::release_gil();
                    return static_cast<int>(_obj.HasKey(_key));
                }
            }
            catch (...)
            {
                py::to_PyErr();
                return -1;
            }
        }
        Py_ssize_t map_length() noexcept override
        {
            try
            {
                auto _gil = py::release_gil();
                return static_cast<Py_ssize_t>(_obj.Size());
            }
            catch (...)
            {
                py::to_PyErr();
                return -1;
            }
        }
        PyObject* map_subscript(PyObject* key) noexcept override
        {
            try
            {
                auto _key = py::convert_to<K>(key);
                auto value = [&]()
                {
                    auto _gil = py::release_gil();
                    return _obj.TryLookup(_key);
                }();

                if (!value)
                {
                    if constexpr (std::is_base_of_v<winrt::Windows::Foundation::IUnknown, decltype(value)>)
                    {
                        auto has_key = [&]()
                        {
                            auto _gil = py::release_gil();
                            return _obj.HasKey(_key);
                        }();

                        if (has_key)
                        {
                            Py_RETURN_NONE;
                        }
                    }

                    PyErr_SetObject(PyExc_KeyError, key);
                    return nullptr;
                }

                return py::convert(value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        int map_assign(PyObject* key, PyObject* value) noexcept override
        {
            try
            {
                auto _key = py::convert_to<K>(key);

                if (!value)
                {
                    bool did_remove;
                    {
                        auto _gil = py::release_gil();
                        did_remove = _obj.TryRemove(_key);
                    }
                    if (!did_remove)
                    {
                        PyErr_SetObject(PyExc_KeyError, key);
                        return -1;
                    }

                    return 0;
                }

                auto _value = py::convert_to<V>(value);
                {
                    auto _gil = py::release_gil();
                    _obj.Insert(_key, _value);
                }

                return 0;
            }
            catch (...)
            {
                py::to_PyErr();
                return -1;
            }
        }

        winrt::Windows::Foundation::Collections::IMap<K, V> _obj{ nullptr };
    };

    template<typename K, typename V>
    struct IObservableMap : public py::proj::Windows::Foundation::Collections::IObservableMap
    {
        IObservableMap(winrt::Windows::Foundation::Collections::IObservableMap<K, V> o) : _obj(o) {}
        PyObject* Clear(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IMap`2", L"Clear", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    {
                        auto _gil = release_gil();
                        _obj.Clear();
                    }

                    Py_RETURN_NONE;
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* First(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IIterable`1", L"First", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.First();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetView(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IMap`2", L"GetView", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetView();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* HasKey(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 1)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IMap`2", L"HasKey", 1);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(1);
                        return nullptr;
                    }

                    auto param0 = py::convert_to<K>(args, 0);

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.HasKey(param0);
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* Insert(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 2)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IMap`2", L"Insert", 2);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(2);
                        return nullptr;
                    }

                    auto param0 = py::convert_to<K>(args, 0);
                    auto param1 = py::convert_to<V>(args, 1);

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.Insert(param0, param1);
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* Lookup(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 1)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IMap`2", L"Lookup", 1);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(1);
                        return nullptr;
                    }

                    auto param0 = py::convert_to<K>(args, 0);

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.Lookup(param0);
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* Remove(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 1)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IMap`2", L"Remove", 1);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(1);
                        return nullptr;
                    }

                    auto param0 = py::convert_to<K>(args, 0);

                    {
                        auto _gil = release_gil();
                        _obj.Remove(param0);
                    }

                    Py_RETURN_NONE;
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* get_Size() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.Size();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        PyObject* add_MapChanged(PyObject* arg) noexcept override
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::MapChangedEventHandler<K, V>>(arg);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.MapChanged(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        PyObject* remove_MapChanged(PyObject* arg) noexcept override
        {
            try
            {
                auto param0 = py::convert_to<winrt::event_token>(arg);

                {
                    auto _gil = release_gil();
                    _obj.MapChanged(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        PyObject* dunder_iter() noexcept override
        {
            try
            {
                py::pyobj_handle iter{py::convert([&]()
                {
                    auto _gil = py::release_gil();
                    return _obj.First();
                }())};

                if (!iter)
                {
                    return nullptr;
                }

                return py::wrap_mapping_iter(iter.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        int map_contains(PyObject* key) noexcept override
        {
            try
            {
                auto _key = py::convert_to<K>(key);
                {
                    auto _gil = py::release_gil();
                    return static_cast<int>(_obj.HasKey(_key));
                }
            }
            catch (...)
            {
                py::to_PyErr();
                return -1;
            }
        }
        Py_ssize_t map_length() noexcept override
        {
            try
            {
                auto _gil = py::release_gil();
                return static_cast<Py_ssize_t>(_obj.Size());
            }
            catch (...)
            {
                py::to_PyErr();
                return -1;
            }
        }
        PyObject* map_subscript(PyObject* key) noexcept override
        {
            try
            {
                auto _key = py::convert_to<K>(key);
                auto value = [&]()
                {
                    auto _gil = py::release_gil();
                    return _obj.TryLookup(_key);
                }();

                if (!value)
                {
                    if constexpr (std::is_base_of_v<winrt::Windows::Foundation::IUnknown, decltype(value)>)
                    {
                        auto has_key = [&]()
                        {
                            auto _gil = py::release_gil();
                            return _obj.HasKey(_key);
                        }();

                        if (has_key)
                        {
                            Py_RETURN_NONE;
                        }
                    }

                    PyErr_SetObject(PyExc_KeyError, key);
                    return nullptr;
                }

                return py::convert(value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        int map_assign(PyObject* key, PyObject* value) noexcept override
        {
            try
            {
                auto _key = py::convert_to<K>(key);

                if (!value)
                {
                    bool did_remove;
                    {
                        auto _gil = py::release_gil();
                        did_remove = _obj.TryRemove(_key);
                    }
                    if (!did_remove)
                    {
                        PyErr_SetObject(PyExc_KeyError, key);
                        return -1;
                    }

                    return 0;
                }

                auto _value = py::convert_to<V>(value);
                {
                    auto _gil = py::release_gil();
                    _obj.Insert(_key, _value);
                }

                return 0;
            }
            catch (...)
            {
                py::to_PyErr();
                return -1;
            }
        }

        winrt::Windows::Foundation::Collections::IObservableMap<K, V> _obj{ nullptr };
    };

    template<typename T>
    struct IObservableVector : public py::proj::Windows::Foundation::Collections::IObservableVector
    {
        IObservableVector(winrt::Windows::Foundation::Collections::IObservableVector<T> o) : _obj(o) {}
        PyObject* Append(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 1)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"Append", 1);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(1);
                        return nullptr;
                    }

                    auto param0 = py::convert_to<T>(args, 0);

                    {
                        auto _gil = release_gil();
                        _obj.Append(param0);
                    }

                    Py_RETURN_NONE;
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* Clear(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"Clear", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    {
                        auto _gil = release_gil();
                        _obj.Clear();
                    }

                    Py_RETURN_NONE;
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* First(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IIterable`1", L"First", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.First();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetAt(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 1)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"GetAt", 1);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(1);
                        return nullptr;
                    }

                    auto param0 = py::convert_to<uint32_t>(args, 0);

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetAt(param0);
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetMany(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 2)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"GetMany", 1);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(1);
                        return nullptr;
                    }

                    auto param0 = py::convert_to<uint32_t>(args, 0);
                    auto param1 = py::convert_to<py::pybuf_view<T, true>>(args, 1);

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetMany(param0, param1);
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetView(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"GetView", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetView();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* IndexOf(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 1)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"IndexOf", 1);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(1);
                        return nullptr;
                    }

                    auto param0 = py::convert_to<T>(args, 0);
                    uint32_t param1{};

                    auto return_value = [&]()
                    {
                        auto _gil = release_gil();
                        return _obj.IndexOf(param0, param1);
                    }();

                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value)
                    {
                        return nullptr;
                    }
                    py::pyobj_handle out1{ py::convert(param1) };
                    if (!out1)
                    {
                        return nullptr;
                    }

                    return PyTuple_Pack(2, out_return_value.get(), out1.get());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* InsertAt(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 2)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"InsertAt", 2);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(2);
                        return nullptr;
                    }

                    auto param0 = py::convert_to<uint32_t>(args, 0);
                    auto param1 = py::convert_to<T>(args, 1);

                    {
                        auto _gil = release_gil();
                        _obj.InsertAt(param0, param1);
                    }

                    Py_RETURN_NONE;
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* RemoveAt(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 1)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"RemoveAt", 1);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(1);
                        return nullptr;
                    }

                    auto param0 = py::convert_to<uint32_t>(args, 0);

                    {
                        auto _gil = release_gil();
                        _obj.RemoveAt(param0);
                    }

                    Py_RETURN_NONE;
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* RemoveAtEnd(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"RemoveAtEnd", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    {
                        auto _gil = release_gil();
                        _obj.RemoveAtEnd();
                    }

                    Py_RETURN_NONE;
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* ReplaceAll(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 1)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"ReplaceAll", 1);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(1);
                        return nullptr;
                    }

                    auto param0 = py::convert_to<py::pybuf_view<T, false>>(args, 0);

                    {
                        auto _gil = release_gil();
                        _obj.ReplaceAll(param0);
                    }

                    Py_RETURN_NONE;
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* SetAt(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 2)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"SetAt", 2);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(2);
                        return nullptr;
                    }

                    auto param0 = py::convert_to<uint32_t>(args, 0);
                    auto param1 = py::convert_to<T>(args, 1);

                    {
                        auto _gil = release_gil();
                        _obj.SetAt(param0, param1);
                    }

                    Py_RETURN_NONE;
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* get_Size() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.Size();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        PyObject* add_VectorChanged(PyObject* arg) noexcept override
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::VectorChangedEventHandler<T>>(arg);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.VectorChanged(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        PyObject* remove_VectorChanged(PyObject* arg) noexcept override
        {
            try
            {
                auto param0 = py::convert_to<winrt::event_token>(arg);

                {
                    auto _gil = release_gil();
                    _obj.VectorChanged(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        PyObject* dunder_iter() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = py::release_gil();
                    return _obj.First();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        Py_ssize_t seq_length() noexcept override
        {
            try
            {
                auto _gil = py::release_gil();
                return static_cast<Py_ssize_t>(_obj.Size());
            }
            catch (...)
            {
                py::to_PyErr();
                return -1;
            }
        }
        PyObject* seq_item(Py_ssize_t i) noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = py::release_gil();
                    return _obj.GetAt(static_cast<uint32_t>(i));
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        PyObject* seq_subscript(PyObject* slice) noexcept override
        {
            try
            {
                if (PyIndex_Check(slice))
                {
                    pyobj_handle index{PyNumber_Index(slice)};

                    if (!index)
                    {
                        return nullptr;
                    }

                    auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                    if (i == -1 && PyErr_Occurred())
                    {
                        return nullptr;
                    }

                    return seq_item(i);
                }

                if (!PySlice_Check(slice))
                {
                    PyErr_Format(PyExc_TypeError, "indices must be integers, not '%s'", Py_TYPE(slice)->tp_name);
                }

                Py_ssize_t start, stop, step, length;

                auto size = [&]()
                {
                    auto _gil = py::release_gil();
                    return _obj.Size();
                }();
                if (PySlice_GetIndicesEx(slice, size, &start, &stop, &step, &length) < 0)
                {
                    return nullptr;
                }

                if (step != 1)
                {
                    PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                    return nullptr;
                }

                winrt::com_array<T> items(static_cast<uint32_t>(length), empty_instance<T>::get());

                auto count = [&]()
                {
                    auto _gil = py::release_gil();
                    return _obj.GetMany(static_cast<uint32_t>(start), items);
                }();

                if (count != static_cast<uint32_t>(length))
                {
                    PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                    return nullptr;
                }

                return convert(items);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        int seq_assign(Py_ssize_t i, PyObject* value) noexcept override
        {
            try
            {
                if (!value)
                {
                    auto _gil = py::release_gil();
                    _obj.RemoveAt(static_cast<uint32_t>(i));
                }
                else
                {
                    auto _value = py::convert_to<T>(value);
                    {
                        auto _gil = py::release_gil();
                        _obj.SetAt(static_cast<uint32_t>(i), _value);
                    }
                }

                return 0;
            }
            catch (...)
            {
                py::to_PyErr();
                return -1;
            }
        }

        winrt::Windows::Foundation::Collections::IObservableVector<T> _obj{ nullptr };
    };

    template<typename T>
    struct IVectorView : public py::proj::Windows::Foundation::Collections::IVectorView
    {
        IVectorView(winrt::Windows::Foundation::Collections::IVectorView<T> o) : _obj(o) {}
        PyObject* First(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IIterable`1", L"First", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.First();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetAt(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 1)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVectorView`1", L"GetAt", 1);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(1);
                        return nullptr;
                    }

                    auto param0 = py::convert_to<uint32_t>(args, 0);

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetAt(param0);
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetMany(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 2)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVectorView`1", L"GetMany", 1);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(1);
                        return nullptr;
                    }

                    auto param0 = py::convert_to<uint32_t>(args, 0);
                    auto param1 = py::convert_to<py::pybuf_view<T, true>>(args, 1);

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetMany(param0, param1);
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* IndexOf(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 1)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVectorView`1", L"IndexOf", 1);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(1);
                        return nullptr;
                    }

                    auto param0 = py::convert_to<T>(args, 0);
                    uint32_t param1{};

                    auto return_value = [&]()
                    {
                        auto _gil = release_gil();
                        return _obj.IndexOf(param0, param1);
                    }();

                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value)
                    {
                        return nullptr;
                    }
                    py::pyobj_handle out1{ py::convert(param1) };
                    if (!out1)
                    {
                        return nullptr;
                    }

                    return PyTuple_Pack(2, out_return_value.get(), out1.get());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* get_Size() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.Size();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        PyObject* dunder_iter() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = py::release_gil();
                    return _obj.First();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        Py_ssize_t seq_length() noexcept override
        {
            try
            {
                auto _gil = py::release_gil();
                return static_cast<Py_ssize_t>(_obj.Size());
            }
            catch (...)
            {
                py::to_PyErr();
                return -1;
            }
        }
        PyObject* seq_item(Py_ssize_t i) noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = py::release_gil();
                    return _obj.GetAt(static_cast<uint32_t>(i));
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        PyObject* seq_subscript(PyObject* slice) noexcept override
        {
            try
            {
                if (PyIndex_Check(slice))
                {
                    pyobj_handle index{PyNumber_Index(slice)};

                    if (!index)
                    {
                        return nullptr;
                    }

                    auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                    if (i == -1 && PyErr_Occurred())
                    {
                        return nullptr;
                    }

                    return seq_item(i);
                }

                if (!PySlice_Check(slice))
                {
                    PyErr_Format(PyExc_TypeError, "indices must be integers, not '%s'", Py_TYPE(slice)->tp_name);
                }

                Py_ssize_t start, stop, step, length;

                auto size = [&]()
                {
                    auto _gil = py::release_gil();
                    return _obj.Size();
                }();
                if (PySlice_GetIndicesEx(slice, size, &start, &stop, &step, &length) < 0)
                {
                    return nullptr;
                }

                if (step != 1)
                {
                    PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                    return nullptr;
                }

                winrt::com_array<T> items(static_cast<uint32_t>(length), empty_instance<T>::get());

                auto count = [&]()
                {
                    auto _gil = py::release_gil();
                    return _obj.GetMany(static_cast<uint32_t>(start), items);
                }();

                if (count != static_cast<uint32_t>(length))
                {
                    PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                    return nullptr;
                }

                return convert(items);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        winrt::Windows::Foundation::Collections::IVectorView<T> _obj{ nullptr };
    };

    template<typename T>
    struct IVector : public py::proj::Windows::Foundation::Collections::IVector
    {
        IVector(winrt::Windows::Foundation::Collections::IVector<T> o) : _obj(o) {}
        PyObject* Append(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 1)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"Append", 1);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(1);
                        return nullptr;
                    }

                    auto param0 = py::convert_to<T>(args, 0);

                    {
                        auto _gil = release_gil();
                        _obj.Append(param0);
                    }

                    Py_RETURN_NONE;
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* Clear(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"Clear", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    {
                        auto _gil = release_gil();
                        _obj.Clear();
                    }

                    Py_RETURN_NONE;
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* First(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IIterable`1", L"First", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.First();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetAt(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 1)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"GetAt", 1);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(1);
                        return nullptr;
                    }

                    auto param0 = py::convert_to<uint32_t>(args, 0);

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetAt(param0);
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetMany(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 2)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"GetMany", 1);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(1);
                        return nullptr;
                    }

                    auto param0 = py::convert_to<uint32_t>(args, 0);
                    auto param1 = py::convert_to<py::pybuf_view<T, true>>(args, 1);

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetMany(param0, param1);
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetView(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"GetView", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetView();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* IndexOf(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 1)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"IndexOf", 1);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(1);
                        return nullptr;
                    }

                    auto param0 = py::convert_to<T>(args, 0);
                    uint32_t param1{};

                    auto return_value = [&]()
                    {
                        auto _gil = release_gil();
                        return _obj.IndexOf(param0, param1);
                    }();

                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value)
                    {
                        return nullptr;
                    }
                    py::pyobj_handle out1{ py::convert(param1) };
                    if (!out1)
                    {
                        return nullptr;
                    }

                    return PyTuple_Pack(2, out_return_value.get(), out1.get());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* InsertAt(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 2)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"InsertAt", 2);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(2);
                        return nullptr;
                    }

                    auto param0 = py::convert_to<uint32_t>(args, 0);
                    auto param1 = py::convert_to<T>(args, 1);

                    {
                        auto _gil = release_gil();
                        _obj.InsertAt(param0, param1);
                    }

                    Py_RETURN_NONE;
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* RemoveAt(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 1)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"RemoveAt", 1);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(1);
                        return nullptr;
                    }

                    auto param0 = py::convert_to<uint32_t>(args, 0);

                    {
                        auto _gil = release_gil();
                        _obj.RemoveAt(param0);
                    }

                    Py_RETURN_NONE;
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* RemoveAtEnd(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"RemoveAtEnd", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    {
                        auto _gil = release_gil();
                        _obj.RemoveAtEnd();
                    }

                    Py_RETURN_NONE;
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* ReplaceAll(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 1)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"ReplaceAll", 1);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(1);
                        return nullptr;
                    }

                    auto param0 = py::convert_to<py::pybuf_view<T, false>>(args, 0);

                    {
                        auto _gil = release_gil();
                        _obj.ReplaceAll(param0);
                    }

                    Py_RETURN_NONE;
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* SetAt(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 2)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"SetAt", 2);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(2);
                        return nullptr;
                    }

                    auto param0 = py::convert_to<uint32_t>(args, 0);
                    auto param1 = py::convert_to<T>(args, 1);

                    {
                        auto _gil = release_gil();
                        _obj.SetAt(param0, param1);
                    }

                    Py_RETURN_NONE;
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* get_Size() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.Size();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        PyObject* dunder_iter() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = py::release_gil();
                    return _obj.First();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        Py_ssize_t seq_length() noexcept override
        {
            try
            {
                auto _gil = py::release_gil();
                return static_cast<Py_ssize_t>(_obj.Size());
            }
            catch (...)
            {
                py::to_PyErr();
                return -1;
            }
        }
        PyObject* seq_item(Py_ssize_t i) noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = py::release_gil();
                    return _obj.GetAt(static_cast<uint32_t>(i));
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        PyObject* seq_subscript(PyObject* slice) noexcept override
        {
            try
            {
                if (PyIndex_Check(slice))
                {
                    pyobj_handle index{PyNumber_Index(slice)};

                    if (!index)
                    {
                        return nullptr;
                    }

                    auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                    if (i == -1 && PyErr_Occurred())
                    {
                        return nullptr;
                    }

                    return seq_item(i);
                }

                if (!PySlice_Check(slice))
                {
                    PyErr_Format(PyExc_TypeError, "indices must be integers, not '%s'", Py_TYPE(slice)->tp_name);
                }

                Py_ssize_t start, stop, step, length;

                auto size = [&]()
                {
                    auto _gil = py::release_gil();
                    return _obj.Size();
                }();
                if (PySlice_GetIndicesEx(slice, size, &start, &stop, &step, &length) < 0)
                {
                    return nullptr;
                }

                if (step != 1)
                {
                    PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                    return nullptr;
                }

                winrt::com_array<T> items(static_cast<uint32_t>(length), empty_instance<T>::get());

                auto count = [&]()
                {
                    auto _gil = py::release_gil();
                    return _obj.GetMany(static_cast<uint32_t>(start), items);
                }();

                if (count != static_cast<uint32_t>(length))
                {
                    PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                    return nullptr;
                }

                return convert(items);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        int seq_assign(Py_ssize_t i, PyObject* value) noexcept override
        {
            try
            {
                if (!value)
                {
                    auto _gil = py::release_gil();
                    _obj.RemoveAt(static_cast<uint32_t>(i));
                }
                else
                {
                    auto _value = py::convert_to<T>(value);
                    {
                        auto _gil = py::release_gil();
                        _obj.SetAt(static_cast<uint32_t>(i), _value);
                    }
                }

                return 0;
            }
            catch (...)
            {
                py::to_PyErr();
                return -1;
            }
        }

        winrt::Windows::Foundation::Collections::IVector<T> _obj{ nullptr };
    };
}

namespace py::wrapper::Windows::Foundation::Collections
{
    using PropertySet = py::winrt_wrapper<winrt::Windows::Foundation::Collections::PropertySet>;
    using StringMap = py::winrt_wrapper<winrt::Windows::Foundation::Collections::StringMap>;
    using ValueSet = py::winrt_wrapper<winrt::Windows::Foundation::Collections::ValueSet>;
    using IIterable = py::winrt_pinterface_wrapper<py::proj::Windows::Foundation::Collections::IIterable>;
    using IIterator = py::winrt_pinterface_wrapper<py::proj::Windows::Foundation::Collections::IIterator>;
    using IKeyValuePair = py::winrt_pinterface_wrapper<py::proj::Windows::Foundation::Collections::IKeyValuePair>;
    using IMapChangedEventArgs = py::winrt_pinterface_wrapper<py::proj::Windows::Foundation::Collections::IMapChangedEventArgs>;
    using IMapView = py::winrt_pinterface_wrapper<py::proj::Windows::Foundation::Collections::IMapView>;
    using IMap = py::winrt_pinterface_wrapper<py::proj::Windows::Foundation::Collections::IMap>;
    using IObservableMap = py::winrt_pinterface_wrapper<py::proj::Windows::Foundation::Collections::IObservableMap>;
    using IObservableVector = py::winrt_pinterface_wrapper<py::proj::Windows::Foundation::Collections::IObservableVector>;
    using IPropertySet = py::winrt_wrapper<winrt::Windows::Foundation::Collections::IPropertySet>;
    using IVectorChangedEventArgs = py::winrt_wrapper<winrt::Windows::Foundation::Collections::IVectorChangedEventArgs>;
    using IVectorView = py::winrt_pinterface_wrapper<py::proj::Windows::Foundation::Collections::IVectorView>;
    using IVector = py::winrt_pinterface_wrapper<py::proj::Windows::Foundation::Collections::IVector>;
}

namespace py
{
    template <typename T>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IIterable<T>>
    {
        using abstract = py::proj::Windows::Foundation::Collections::IIterable;
        using concrete = py::impl::Windows::Foundation::Collections::IIterable<T>;
    };

    template <typename T>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IIterator<T>>
    {
        using abstract = py::proj::Windows::Foundation::Collections::IIterator;
        using concrete = py::impl::Windows::Foundation::Collections::IIterator<T>;
    };

    template <typename K, typename V>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IKeyValuePair<K, V>>
    {
        using abstract = py::proj::Windows::Foundation::Collections::IKeyValuePair;
        using concrete = py::impl::Windows::Foundation::Collections::IKeyValuePair<K, V>;
    };

    template <typename K>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IMapChangedEventArgs<K>>
    {
        using abstract = py::proj::Windows::Foundation::Collections::IMapChangedEventArgs;
        using concrete = py::impl::Windows::Foundation::Collections::IMapChangedEventArgs<K>;
    };

    template <typename K, typename V>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IMapView<K, V>>
    {
        using abstract = py::proj::Windows::Foundation::Collections::IMapView;
        using concrete = py::impl::Windows::Foundation::Collections::IMapView<K, V>;
    };

    template <typename K, typename V>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IMap<K, V>>
    {
        using abstract = py::proj::Windows::Foundation::Collections::IMap;
        using concrete = py::impl::Windows::Foundation::Collections::IMap<K, V>;
    };

    template <typename K, typename V>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IObservableMap<K, V>>
    {
        using abstract = py::proj::Windows::Foundation::Collections::IObservableMap;
        using concrete = py::impl::Windows::Foundation::Collections::IObservableMap<K, V>;
    };

    template <typename T>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IObservableVector<T>>
    {
        using abstract = py::proj::Windows::Foundation::Collections::IObservableVector;
        using concrete = py::impl::Windows::Foundation::Collections::IObservableVector<T>;
    };

    template <typename T>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IVectorView<T>>
    {
        using abstract = py::proj::Windows::Foundation::Collections::IVectorView;
        using concrete = py::impl::Windows::Foundation::Collections::IVectorView<T>;
    };

    template <typename T>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IVector<T>>
    {
        using abstract = py::proj::Windows::Foundation::Collections::IVector;
        using concrete = py::impl::Windows::Foundation::Collections::IVector<T>;
    };

    template <typename K, typename V>
    struct delegate_python_type<winrt::Windows::Foundation::Collections::MapChangedEventHandler<K, V>>
    {
        using type = py::impl::Windows::Foundation::Collections::MapChangedEventHandler<K, V>;
    };

    template <typename T>
    struct delegate_python_type<winrt::Windows::Foundation::Collections::VectorChangedEventHandler<T>>
    {
        using type = py::impl::Windows::Foundation::Collections::VectorChangedEventHandler<T>;
    };

}
