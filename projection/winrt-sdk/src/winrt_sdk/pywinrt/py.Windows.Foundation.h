// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.1

#pragma once

#include "pybase.h"
static_assert(winrt::check_version(PYWINRT_VERSION, "3.2.1"), "Mismatched Py/WinRT headers.");
#include <winrt/Windows.Foundation.Collections.h>

#include <winrt/Windows.Foundation.h>

namespace py::proj::Windows::Foundation
{
    struct IAsyncActionWithProgress
    {
        virtual ~IAsyncActionWithProgress() {};
        virtual PyObject* Cancel(PyObject*) noexcept = 0;
        virtual PyObject* Close(PyObject*) noexcept = 0;
        virtual PyObject* GetResults(PyObject*) noexcept = 0;
        virtual PyObject* get_Progress() noexcept = 0;
        virtual int put_Progress(PyObject*) noexcept = 0;
        virtual PyObject* get_Completed() noexcept = 0;
        virtual int put_Completed(PyObject*) noexcept = 0;
        virtual PyObject* get_ErrorCode() noexcept = 0;
        virtual PyObject* get_Id() noexcept = 0;
        virtual PyObject* get_Status() noexcept = 0;
        virtual PyObject* async_get() noexcept = 0;
        virtual PyObject* async_wait(PyObject* arg) noexcept = 0;
    };

    struct IAsyncOperationWithProgress
    {
        virtual ~IAsyncOperationWithProgress() {};
        virtual PyObject* Cancel(PyObject*) noexcept = 0;
        virtual PyObject* Close(PyObject*) noexcept = 0;
        virtual PyObject* GetResults(PyObject*) noexcept = 0;
        virtual PyObject* get_Progress() noexcept = 0;
        virtual int put_Progress(PyObject*) noexcept = 0;
        virtual PyObject* get_Completed() noexcept = 0;
        virtual int put_Completed(PyObject*) noexcept = 0;
        virtual PyObject* get_ErrorCode() noexcept = 0;
        virtual PyObject* get_Id() noexcept = 0;
        virtual PyObject* get_Status() noexcept = 0;
        virtual PyObject* async_get() noexcept = 0;
        virtual PyObject* async_wait(PyObject* arg) noexcept = 0;
    };

    struct IAsyncOperation
    {
        virtual ~IAsyncOperation() {};
        virtual PyObject* Cancel(PyObject*) noexcept = 0;
        virtual PyObject* Close(PyObject*) noexcept = 0;
        virtual PyObject* GetResults(PyObject*) noexcept = 0;
        virtual PyObject* get_Completed() noexcept = 0;
        virtual int put_Completed(PyObject*) noexcept = 0;
        virtual PyObject* get_ErrorCode() noexcept = 0;
        virtual PyObject* get_Id() noexcept = 0;
        virtual PyObject* get_Status() noexcept = 0;
        virtual PyObject* async_get() noexcept = 0;
        virtual PyObject* async_wait(PyObject* arg) noexcept = 0;
    };

    struct IReferenceArray
    {
        virtual ~IReferenceArray() {};
        virtual PyObject* GetBoolean(PyObject*) noexcept = 0;
        virtual PyObject* GetBooleanArray(PyObject*) noexcept = 0;
        virtual PyObject* GetChar16(PyObject*) noexcept = 0;
        virtual PyObject* GetChar16Array(PyObject*) noexcept = 0;
        virtual PyObject* GetDateTime(PyObject*) noexcept = 0;
        virtual PyObject* GetDateTimeArray(PyObject*) noexcept = 0;
        virtual PyObject* GetDouble(PyObject*) noexcept = 0;
        virtual PyObject* GetDoubleArray(PyObject*) noexcept = 0;
        virtual PyObject* GetGuid(PyObject*) noexcept = 0;
        virtual PyObject* GetGuidArray(PyObject*) noexcept = 0;
        virtual PyObject* GetInspectableArray(PyObject*) noexcept = 0;
        virtual PyObject* GetInt16(PyObject*) noexcept = 0;
        virtual PyObject* GetInt16Array(PyObject*) noexcept = 0;
        virtual PyObject* GetInt32(PyObject*) noexcept = 0;
        virtual PyObject* GetInt32Array(PyObject*) noexcept = 0;
        virtual PyObject* GetInt64(PyObject*) noexcept = 0;
        virtual PyObject* GetInt64Array(PyObject*) noexcept = 0;
        virtual PyObject* GetPoint(PyObject*) noexcept = 0;
        virtual PyObject* GetPointArray(PyObject*) noexcept = 0;
        virtual PyObject* GetRect(PyObject*) noexcept = 0;
        virtual PyObject* GetRectArray(PyObject*) noexcept = 0;
        virtual PyObject* GetSingle(PyObject*) noexcept = 0;
        virtual PyObject* GetSingleArray(PyObject*) noexcept = 0;
        virtual PyObject* GetSize(PyObject*) noexcept = 0;
        virtual PyObject* GetSizeArray(PyObject*) noexcept = 0;
        virtual PyObject* GetString(PyObject*) noexcept = 0;
        virtual PyObject* GetStringArray(PyObject*) noexcept = 0;
        virtual PyObject* GetTimeSpan(PyObject*) noexcept = 0;
        virtual PyObject* GetTimeSpanArray(PyObject*) noexcept = 0;
        virtual PyObject* GetUInt16(PyObject*) noexcept = 0;
        virtual PyObject* GetUInt16Array(PyObject*) noexcept = 0;
        virtual PyObject* GetUInt32(PyObject*) noexcept = 0;
        virtual PyObject* GetUInt32Array(PyObject*) noexcept = 0;
        virtual PyObject* GetUInt64(PyObject*) noexcept = 0;
        virtual PyObject* GetUInt64Array(PyObject*) noexcept = 0;
        virtual PyObject* GetUInt8(PyObject*) noexcept = 0;
        virtual PyObject* GetUInt8Array(PyObject*) noexcept = 0;
        virtual PyObject* get_Value() noexcept = 0;
        virtual PyObject* get_IsNumericScalar() noexcept = 0;
        virtual PyObject* get_Type() noexcept = 0;
    };

    struct IReference
    {
        virtual ~IReference() {};
        virtual PyObject* GetBoolean(PyObject*) noexcept = 0;
        virtual PyObject* GetBooleanArray(PyObject*) noexcept = 0;
        virtual PyObject* GetChar16(PyObject*) noexcept = 0;
        virtual PyObject* GetChar16Array(PyObject*) noexcept = 0;
        virtual PyObject* GetDateTime(PyObject*) noexcept = 0;
        virtual PyObject* GetDateTimeArray(PyObject*) noexcept = 0;
        virtual PyObject* GetDouble(PyObject*) noexcept = 0;
        virtual PyObject* GetDoubleArray(PyObject*) noexcept = 0;
        virtual PyObject* GetGuid(PyObject*) noexcept = 0;
        virtual PyObject* GetGuidArray(PyObject*) noexcept = 0;
        virtual PyObject* GetInspectableArray(PyObject*) noexcept = 0;
        virtual PyObject* GetInt16(PyObject*) noexcept = 0;
        virtual PyObject* GetInt16Array(PyObject*) noexcept = 0;
        virtual PyObject* GetInt32(PyObject*) noexcept = 0;
        virtual PyObject* GetInt32Array(PyObject*) noexcept = 0;
        virtual PyObject* GetInt64(PyObject*) noexcept = 0;
        virtual PyObject* GetInt64Array(PyObject*) noexcept = 0;
        virtual PyObject* GetPoint(PyObject*) noexcept = 0;
        virtual PyObject* GetPointArray(PyObject*) noexcept = 0;
        virtual PyObject* GetRect(PyObject*) noexcept = 0;
        virtual PyObject* GetRectArray(PyObject*) noexcept = 0;
        virtual PyObject* GetSingle(PyObject*) noexcept = 0;
        virtual PyObject* GetSingleArray(PyObject*) noexcept = 0;
        virtual PyObject* GetSize(PyObject*) noexcept = 0;
        virtual PyObject* GetSizeArray(PyObject*) noexcept = 0;
        virtual PyObject* GetString(PyObject*) noexcept = 0;
        virtual PyObject* GetStringArray(PyObject*) noexcept = 0;
        virtual PyObject* GetTimeSpan(PyObject*) noexcept = 0;
        virtual PyObject* GetTimeSpanArray(PyObject*) noexcept = 0;
        virtual PyObject* GetUInt16(PyObject*) noexcept = 0;
        virtual PyObject* GetUInt16Array(PyObject*) noexcept = 0;
        virtual PyObject* GetUInt32(PyObject*) noexcept = 0;
        virtual PyObject* GetUInt32Array(PyObject*) noexcept = 0;
        virtual PyObject* GetUInt64(PyObject*) noexcept = 0;
        virtual PyObject* GetUInt64Array(PyObject*) noexcept = 0;
        virtual PyObject* GetUInt8(PyObject*) noexcept = 0;
        virtual PyObject* GetUInt8Array(PyObject*) noexcept = 0;
        virtual PyObject* get_Value() noexcept = 0;
        virtual PyObject* get_IsNumericScalar() noexcept = 0;
        virtual PyObject* get_Type() noexcept = 0;
    };
}

namespace py
{
    template<>
    inline constexpr const char* buffer_format<winrt::Windows::Foundation::AsyncStatus> = "i";

    template<>
    inline constexpr const char* buffer_format<winrt::Windows::Foundation::PropertyType> = "i";

    template<>
    inline constexpr const char* buffer_format<winrt::event_token> = "T{q:value:}";

    template<>
    inline constexpr const char* buffer_format<winrt::hresult> = "T{i:value:}";

    template<>
    inline constexpr const char* buffer_format<winrt::Windows::Foundation::Point> = "T{f:x:f:y:}";

    template<>
    inline constexpr const char* buffer_format<winrt::Windows::Foundation::Rect> = "T{f:x:f:y:f:width:f:height:}";

    template<>
    inline constexpr const char* buffer_format<winrt::Windows::Foundation::Size> = "T{f:width:f:height:}";


    template<>
    struct py_type<winrt::Windows::Foundation::AsyncStatus>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation.AsyncStatus";
        static constexpr const char* module_name = "winrt.windows.foundation";
        static constexpr const char* type_name = "AsyncStatus";
    };

    template<>
    struct py_type<winrt::Windows::Foundation::PropertyType>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation.PropertyType";
        static constexpr const char* module_name = "winrt.windows.foundation";
        static constexpr const char* type_name = "PropertyType";
    };

    template<>
    struct py_type<winrt::Windows::Foundation::Deferral>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation.Deferral";
        static constexpr const char* module_name = "winrt.windows.foundation";
        static constexpr const char* type_name = "Deferral";
    };

    template<>
    struct py_type<winrt::Windows::Foundation::GuidHelper>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation.GuidHelper";
        static constexpr const char* module_name = "winrt.windows.foundation";
        static constexpr const char* type_name = "GuidHelper";
    };

    template<>
    struct py_type<winrt::Windows::Foundation::MemoryBuffer>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation.MemoryBuffer";
        static constexpr const char* module_name = "winrt.windows.foundation";
        static constexpr const char* type_name = "MemoryBuffer";
    };

    template<>
    struct py_type<winrt::Windows::Foundation::PropertyValue>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation.PropertyValue";
        static constexpr const char* module_name = "winrt.windows.foundation";
        static constexpr const char* type_name = "PropertyValue";
    };

    template<>
    struct py_type<winrt::Windows::Foundation::Uri>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation.Uri";
        static constexpr const char* module_name = "winrt.windows.foundation";
        static constexpr const char* type_name = "Uri";
    };

    template<>
    struct py_type<winrt::Windows::Foundation::WwwFormUrlDecoder>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation.WwwFormUrlDecoder";
        static constexpr const char* module_name = "winrt.windows.foundation";
        static constexpr const char* type_name = "WwwFormUrlDecoder";
    };

    template<>
    struct py_type<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation.WwwFormUrlDecoderEntry";
        static constexpr const char* module_name = "winrt.windows.foundation";
        static constexpr const char* type_name = "WwwFormUrlDecoderEntry";
    };

    template<>
    struct py_type<winrt::Windows::Foundation::IAsyncAction>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation._IAsyncAction";
        static constexpr const char* module_name = "winrt.windows.foundation";
        static constexpr const char* type_name = "_IAsyncAction";
    };

    template<>
    struct py_type<py::proj::Windows::Foundation::IAsyncActionWithProgress>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation._IAsyncActionWithProgress";
        static constexpr const char* module_name = "winrt.windows.foundation";
        static constexpr const char* type_name = "_IAsyncActionWithProgress";
    };

    template<>
    struct py_type<winrt::Windows::Foundation::IAsyncInfo>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation._IAsyncInfo";
        static constexpr const char* module_name = "winrt.windows.foundation";
        static constexpr const char* type_name = "_IAsyncInfo";
    };

    template<>
    struct py_type<py::proj::Windows::Foundation::IAsyncOperationWithProgress>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation._IAsyncOperationWithProgress";
        static constexpr const char* module_name = "winrt.windows.foundation";
        static constexpr const char* type_name = "_IAsyncOperationWithProgress";
    };

    template<>
    struct py_type<py::proj::Windows::Foundation::IAsyncOperation>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation._IAsyncOperation";
        static constexpr const char* module_name = "winrt.windows.foundation";
        static constexpr const char* type_name = "_IAsyncOperation";
    };

    template<>
    struct py_type<winrt::Windows::Foundation::IClosable>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation._IClosable";
        static constexpr const char* module_name = "winrt.windows.foundation";
        static constexpr const char* type_name = "_IClosable";
    };

    template<>
    struct py_type<winrt::Windows::Foundation::IGetActivationFactory>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation._IGetActivationFactory";
        static constexpr const char* module_name = "winrt.windows.foundation";
        static constexpr const char* type_name = "_IGetActivationFactory";
    };

    template<>
    struct py_type<winrt::Windows::Foundation::IMemoryBuffer>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation._IMemoryBuffer";
        static constexpr const char* module_name = "winrt.windows.foundation";
        static constexpr const char* type_name = "_IMemoryBuffer";
    };

    template<>
    struct py_type<winrt::Windows::Foundation::IMemoryBufferReference>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation._IMemoryBufferReference";
        static constexpr const char* module_name = "winrt.windows.foundation";
        static constexpr const char* type_name = "_IMemoryBufferReference";
    };

    template<>
    struct py_type<winrt::Windows::Foundation::IPropertyValue>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation._IPropertyValue";
        static constexpr const char* module_name = "winrt.windows.foundation";
        static constexpr const char* type_name = "_IPropertyValue";
    };

    template<>
    struct py_type<py::proj::Windows::Foundation::IReferenceArray>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation._IReferenceArray";
        static constexpr const char* module_name = "winrt.windows.foundation";
        static constexpr const char* type_name = "_IReferenceArray";
    };

    template<>
    struct py_type<py::proj::Windows::Foundation::IReference>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation._IReference";
        static constexpr const char* module_name = "winrt.windows.foundation";
        static constexpr const char* type_name = "_IReference";
    };

    template<>
    struct py_type<winrt::Windows::Foundation::IStringable>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation._IStringable";
        static constexpr const char* module_name = "winrt.windows.foundation";
        static constexpr const char* type_name = "_IStringable";
    };

    template<>
    struct py_type<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>
    {
        static constexpr std::string_view qualified_name = "winrt.windows.foundation._IWwwFormUrlDecoderEntry";
        static constexpr const char* module_name = "winrt.windows.foundation";
        static constexpr const char* type_name = "_IWwwFormUrlDecoderEntry";
    };

    template<>
    struct py_type<winrt::Windows::Foundation::DateTime>
    {
        static constexpr std::string_view from_tuple = "winrt._winrt_windows_foundation.DateTime_from_tuple";
        static constexpr std::string_view qualified_name = "winrt.windows.foundation.DateTime";
        static constexpr const char* module_name = "winrt.windows.foundation";
        static constexpr const char* type_name = "DateTime";
    };

    template<>
    struct py_type<winrt::event_token>
    {
        static constexpr std::string_view from_tuple = "winrt._winrt_windows_foundation.EventRegistrationToken_from_tuple";
        static constexpr std::string_view qualified_name = "winrt.windows.foundation.EventRegistrationToken";
        static constexpr const char* module_name = "winrt.windows.foundation";
        static constexpr const char* type_name = "EventRegistrationToken";
    };

    template<>
    struct py_type<winrt::hresult>
    {
        static constexpr std::string_view from_tuple = "winrt._winrt_windows_foundation.HResult_from_tuple";
        static constexpr std::string_view qualified_name = "winrt.windows.foundation.HResult";
        static constexpr const char* module_name = "winrt.windows.foundation";
        static constexpr const char* type_name = "HResult";
    };

    template<>
    struct py_type<winrt::Windows::Foundation::Point>
    {
        static constexpr std::string_view from_tuple = "winrt._winrt_windows_foundation.Point_from_tuple";
        static constexpr std::string_view qualified_name = "winrt.windows.foundation.Point";
        static constexpr const char* module_name = "winrt.windows.foundation";
        static constexpr const char* type_name = "Point";
    };

    template<>
    struct py_type<winrt::Windows::Foundation::Rect>
    {
        static constexpr std::string_view from_tuple = "winrt._winrt_windows_foundation.Rect_from_tuple";
        static constexpr std::string_view qualified_name = "winrt.windows.foundation.Rect";
        static constexpr const char* module_name = "winrt.windows.foundation";
        static constexpr const char* type_name = "Rect";
    };

    template<>
    struct py_type<winrt::Windows::Foundation::Size>
    {
        static constexpr std::string_view from_tuple = "winrt._winrt_windows_foundation.Size_from_tuple";
        static constexpr std::string_view qualified_name = "winrt.windows.foundation.Size";
        static constexpr const char* module_name = "winrt.windows.foundation";
        static constexpr const char* type_name = "Size";
    };

    template<>
    struct py_type<winrt::Windows::Foundation::TimeSpan>
    {
        static constexpr std::string_view from_tuple = "winrt._winrt_windows_foundation.TimeSpan_from_tuple";
        static constexpr std::string_view qualified_name = "winrt.windows.foundation.TimeSpan";
        static constexpr const char* module_name = "winrt.windows.foundation";
        static constexpr const char* type_name = "TimeSpan";
    };
}

#if __has_include("py.Windows.Foundation.Collections.h")
#include "py.Windows.Foundation.Collections.h"
#endif

namespace py::impl::Windows::Foundation
{
    struct AsyncActionCompletedHandler
    {
        static winrt::Windows::Foundation::AsyncActionCompletedHandler get(PyObject* callable)
        {
            py::delegate_callable _delegate{ callable };

            return [delegate = std::move(_delegate)](winrt::Windows::Foundation::IAsyncAction const& param0, winrt::Windows::Foundation::AsyncStatus param1)
            {
                auto gil = py::ensure_gil();

                try
                {
                    py::pyobj_handle py_param0{py::convert(param0)};
                    if (!py_param0)
                    {
                        throw python_exception();
                    }

                    py::pyobj_handle py_param1{py::convert(param1)};
                    if (!py_param1)
                    {
                        throw python_exception();
                    }

                    py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                    if (!args)
                    {
                        throw python_exception();
                    }

                    py::pyobj_handle return_value{PyObject_CallObject(delegate.callable(), args.get())};
                    if (!return_value)
                    {
                        throw python_exception();
                    }
                }
                catch (python_exception)
                {
                    py::write_unraisable_and_throw();
                }
            };
        };
    };

    template <typename TProgress>
    struct AsyncActionProgressHandler
    {
        static winrt::Windows::Foundation::AsyncActionProgressHandler<TProgress> get(PyObject* callable)
        {
            py::delegate_callable _delegate{ callable };

            return [delegate = std::move(_delegate)](winrt::Windows::Foundation::IAsyncActionWithProgress<TProgress> const& param0, winrt::impl::param_type<TProgress> const& param1)
            {
                auto gil = py::ensure_gil();

                try
                {
                    py::pyobj_handle py_param0{py::convert(param0)};
                    if (!py_param0)
                    {
                        throw python_exception();
                    }

                    py::pyobj_handle py_param1{py::convert(param1)};
                    if (!py_param1)
                    {
                        throw python_exception();
                    }

                    py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                    if (!args)
                    {
                        throw python_exception();
                    }

                    py::pyobj_handle return_value{PyObject_CallObject(delegate.callable(), args.get())};
                    if (!return_value)
                    {
                        throw python_exception();
                    }
                }
                catch (python_exception)
                {
                    py::write_unraisable_and_throw();
                }
            };
        };
    };

    template <typename TProgress>
    struct AsyncActionWithProgressCompletedHandler
    {
        static winrt::Windows::Foundation::AsyncActionWithProgressCompletedHandler<TProgress> get(PyObject* callable)
        {
            py::delegate_callable _delegate{ callable };

            return [delegate = std::move(_delegate)](winrt::Windows::Foundation::IAsyncActionWithProgress<TProgress> const& param0, winrt::Windows::Foundation::AsyncStatus param1)
            {
                auto gil = py::ensure_gil();

                try
                {
                    py::pyobj_handle py_param0{py::convert(param0)};
                    if (!py_param0)
                    {
                        throw python_exception();
                    }

                    py::pyobj_handle py_param1{py::convert(param1)};
                    if (!py_param1)
                    {
                        throw python_exception();
                    }

                    py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                    if (!args)
                    {
                        throw python_exception();
                    }

                    py::pyobj_handle return_value{PyObject_CallObject(delegate.callable(), args.get())};
                    if (!return_value)
                    {
                        throw python_exception();
                    }
                }
                catch (python_exception)
                {
                    py::write_unraisable_and_throw();
                }
            };
        };
    };

    template <typename TResult>
    struct AsyncOperationCompletedHandler
    {
        static winrt::Windows::Foundation::AsyncOperationCompletedHandler<TResult> get(PyObject* callable)
        {
            py::delegate_callable _delegate{ callable };

            return [delegate = std::move(_delegate)](winrt::Windows::Foundation::IAsyncOperation<TResult> const& param0, winrt::Windows::Foundation::AsyncStatus param1)
            {
                auto gil = py::ensure_gil();

                try
                {
                    py::pyobj_handle py_param0{py::convert(param0)};
                    if (!py_param0)
                    {
                        throw python_exception();
                    }

                    py::pyobj_handle py_param1{py::convert(param1)};
                    if (!py_param1)
                    {
                        throw python_exception();
                    }

                    py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                    if (!args)
                    {
                        throw python_exception();
                    }

                    py::pyobj_handle return_value{PyObject_CallObject(delegate.callable(), args.get())};
                    if (!return_value)
                    {
                        throw python_exception();
                    }
                }
                catch (python_exception)
                {
                    py::write_unraisable_and_throw();
                }
            };
        };
    };

    template <typename TResult, typename TProgress>
    struct AsyncOperationProgressHandler
    {
        static winrt::Windows::Foundation::AsyncOperationProgressHandler<TResult, TProgress> get(PyObject* callable)
        {
            py::delegate_callable _delegate{ callable };

            return [delegate = std::move(_delegate)](winrt::Windows::Foundation::IAsyncOperationWithProgress<TResult, TProgress> const& param0, winrt::impl::param_type<TProgress> const& param1)
            {
                auto gil = py::ensure_gil();

                try
                {
                    py::pyobj_handle py_param0{py::convert(param0)};
                    if (!py_param0)
                    {
                        throw python_exception();
                    }

                    py::pyobj_handle py_param1{py::convert(param1)};
                    if (!py_param1)
                    {
                        throw python_exception();
                    }

                    py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                    if (!args)
                    {
                        throw python_exception();
                    }

                    py::pyobj_handle return_value{PyObject_CallObject(delegate.callable(), args.get())};
                    if (!return_value)
                    {
                        throw python_exception();
                    }
                }
                catch (python_exception)
                {
                    py::write_unraisable_and_throw();
                }
            };
        };
    };

    template <typename TResult, typename TProgress>
    struct AsyncOperationWithProgressCompletedHandler
    {
        static winrt::Windows::Foundation::AsyncOperationWithProgressCompletedHandler<TResult, TProgress> get(PyObject* callable)
        {
            py::delegate_callable _delegate{ callable };

            return [delegate = std::move(_delegate)](winrt::Windows::Foundation::IAsyncOperationWithProgress<TResult, TProgress> const& param0, winrt::Windows::Foundation::AsyncStatus param1)
            {
                auto gil = py::ensure_gil();

                try
                {
                    py::pyobj_handle py_param0{py::convert(param0)};
                    if (!py_param0)
                    {
                        throw python_exception();
                    }

                    py::pyobj_handle py_param1{py::convert(param1)};
                    if (!py_param1)
                    {
                        throw python_exception();
                    }

                    py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                    if (!args)
                    {
                        throw python_exception();
                    }

                    py::pyobj_handle return_value{PyObject_CallObject(delegate.callable(), args.get())};
                    if (!return_value)
                    {
                        throw python_exception();
                    }
                }
                catch (python_exception)
                {
                    py::write_unraisable_and_throw();
                }
            };
        };
    };

    struct DeferralCompletedHandler
    {
        static winrt::Windows::Foundation::DeferralCompletedHandler get(PyObject* callable)
        {
            py::delegate_callable _delegate{ callable };

            return [delegate = std::move(_delegate)]()
            {
                auto gil = py::ensure_gil();

                try
                {
                    py::pyobj_handle return_value{PyObject_CallNoArgs(delegate.callable())};
                    if (!return_value)
                    {
                        throw python_exception();
                    }
                }
                catch (python_exception)
                {
                    py::write_unraisable_and_throw();
                }
            };
        };
    };

    template <typename T>
    struct EventHandler
    {
        static winrt::Windows::Foundation::EventHandler<T> get(PyObject* callable)
        {
            py::delegate_callable _delegate{ callable };

            return [delegate = std::move(_delegate)](winrt::Windows::Foundation::IInspectable const& param0, winrt::impl::param_type<T> const& param1)
            {
                auto gil = py::ensure_gil();

                try
                {
                    py::pyobj_handle py_param0{py::convert(param0)};
                    if (!py_param0)
                    {
                        throw python_exception();
                    }

                    py::pyobj_handle py_param1{py::convert(param1)};
                    if (!py_param1)
                    {
                        throw python_exception();
                    }

                    py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                    if (!args)
                    {
                        throw python_exception();
                    }

                    py::pyobj_handle return_value{PyObject_CallObject(delegate.callable(), args.get())};
                    if (!return_value)
                    {
                        throw python_exception();
                    }
                }
                catch (python_exception)
                {
                    py::write_unraisable_and_throw();
                }
            };
        };
    };

    template <typename TSender, typename TResult>
    struct TypedEventHandler
    {
        static winrt::Windows::Foundation::TypedEventHandler<TSender, TResult> get(PyObject* callable)
        {
            py::delegate_callable _delegate{ callable };

            return [delegate = std::move(_delegate)](winrt::impl::param_type<TSender> const& param0, winrt::impl::param_type<TResult> const& param1)
            {
                auto gil = py::ensure_gil();

                try
                {
                    py::pyobj_handle py_param0{py::convert(param0)};
                    if (!py_param0)
                    {
                        throw python_exception();
                    }

                    py::pyobj_handle py_param1{py::convert(param1)};
                    if (!py_param1)
                    {
                        throw python_exception();
                    }

                    py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                    if (!args)
                    {
                        throw python_exception();
                    }

                    py::pyobj_handle return_value{PyObject_CallObject(delegate.callable(), args.get())};
                    if (!return_value)
                    {
                        throw python_exception();
                    }
                }
                catch (python_exception)
                {
                    py::write_unraisable_and_throw();
                }
            };
        };
    };

    template<typename TProgress>
    struct IAsyncActionWithProgress : public py::proj::Windows::Foundation::IAsyncActionWithProgress
    {
        IAsyncActionWithProgress(winrt::Windows::Foundation::IAsyncActionWithProgress<TProgress> o) : _obj(o) {}
        PyObject* Cancel(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IAsyncInfo", L"Cancel", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    {
                        auto _gil = release_gil();
                        _obj.Cancel();
                    }

                    Py_RETURN_NONE;
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* Close(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IAsyncInfo", L"Close", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    {
                        auto _gil = release_gil();
                        _obj.Close();
                    }

                    Py_RETURN_NONE;
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetResults(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IAsyncActionWithProgress`1", L"GetResults", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    {
                        auto _gil = release_gil();
                        _obj.GetResults();
                    }

                    Py_RETURN_NONE;
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* get_Progress() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.Progress();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        int put_Progress(PyObject* arg) noexcept override
        {
            if (!arg)
            {
                PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
                return -1;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncActionProgressHandler<TProgress>>(arg);

                {
                    auto _gil = release_gil();
                    _obj.Progress(param0);
                }

                return 0;
            }
            catch (...)
            {
                py::to_PyErr();
                return -1;
            }
        }
        PyObject* get_Completed() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.Completed();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        int put_Completed(PyObject* arg) noexcept override
        {
            if (!arg)
            {
                PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
                return -1;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncActionWithProgressCompletedHandler<TProgress>>(arg);

                {
                    auto _gil = release_gil();
                    _obj.Completed(param0);
                }

                return 0;
            }
            catch (...)
            {
                py::to_PyErr();
                return -1;
            }
        }
        PyObject* get_ErrorCode() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.ErrorCode();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        PyObject* get_Id() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.Id();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        PyObject* get_Status() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.Status();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        PyObject* async_get() noexcept override
        {
            if (winrt::impl::is_sta_thread())
            {
                PyErr_SetString(PyExc_RuntimeError, "Cannot call blocking method from single-threaded apartment.");
                return nullptr;
            }

            try
            {
                auto _gil = py::release_gil();
                _obj.get();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }

            Py_RETURN_NONE;
        }

        PyObject* async_wait(PyObject* arg) noexcept override
        {
            if (winrt::impl::is_sta_thread())
            {
                PyErr_SetString(PyExc_RuntimeError, "Cannot call blocking method from single-threaded apartment.");
                return nullptr;
            }

            auto timeout = PyFloat_AsDouble(arg);
            if (timeout == -1.0 && PyErr_Occurred())
            {
                return nullptr;
            }

            try
            {
                return py::convert([&]()
                {
                    auto _gil = py::release_gil();
                    auto duration = std::chrono::duration_cast<winrt::Windows::Foundation::TimeSpan>(std::chrono::duration<double>(timeout));
                    return _obj.wait_for(duration);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        winrt::Windows::Foundation::IAsyncActionWithProgress<TProgress> _obj{ nullptr };
    };

    template<typename TResult, typename TProgress>
    struct IAsyncOperationWithProgress : public py::proj::Windows::Foundation::IAsyncOperationWithProgress
    {
        IAsyncOperationWithProgress(winrt::Windows::Foundation::IAsyncOperationWithProgress<TResult, TProgress> o) : _obj(o) {}
        PyObject* Cancel(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IAsyncInfo", L"Cancel", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    {
                        auto _gil = release_gil();
                        _obj.Cancel();
                    }

                    Py_RETURN_NONE;
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* Close(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IAsyncInfo", L"Close", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    {
                        auto _gil = release_gil();
                        _obj.Close();
                    }

                    Py_RETURN_NONE;
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetResults(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IAsyncOperationWithProgress`2", L"GetResults", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetResults();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* get_Progress() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.Progress();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        int put_Progress(PyObject* arg) noexcept override
        {
            if (!arg)
            {
                PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
                return -1;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncOperationProgressHandler<TResult, TProgress>>(arg);

                {
                    auto _gil = release_gil();
                    _obj.Progress(param0);
                }

                return 0;
            }
            catch (...)
            {
                py::to_PyErr();
                return -1;
            }
        }
        PyObject* get_Completed() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.Completed();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        int put_Completed(PyObject* arg) noexcept override
        {
            if (!arg)
            {
                PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
                return -1;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncOperationWithProgressCompletedHandler<TResult, TProgress>>(arg);

                {
                    auto _gil = release_gil();
                    _obj.Completed(param0);
                }

                return 0;
            }
            catch (...)
            {
                py::to_PyErr();
                return -1;
            }
        }
        PyObject* get_ErrorCode() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.ErrorCode();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        PyObject* get_Id() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.Id();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        PyObject* get_Status() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.Status();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        PyObject* async_get() noexcept override
        {
            if (winrt::impl::is_sta_thread())
            {
                PyErr_SetString(PyExc_RuntimeError, "Cannot call blocking method from single-threaded apartment.");
                return nullptr;
            }

            try
            {
                return py::convert([&]()
                {
                    auto _gil = py::release_gil();
                    return _obj.get();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        PyObject* async_wait(PyObject* arg) noexcept override
        {
            if (winrt::impl::is_sta_thread())
            {
                PyErr_SetString(PyExc_RuntimeError, "Cannot call blocking method from single-threaded apartment.");
                return nullptr;
            }

            auto timeout = PyFloat_AsDouble(arg);
            if (timeout == -1.0 && PyErr_Occurred())
            {
                return nullptr;
            }

            try
            {
                return py::convert([&]()
                {
                    auto _gil = py::release_gil();
                    auto duration = std::chrono::duration_cast<winrt::Windows::Foundation::TimeSpan>(std::chrono::duration<double>(timeout));
                    return _obj.wait_for(duration);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        winrt::Windows::Foundation::IAsyncOperationWithProgress<TResult, TProgress> _obj{ nullptr };
    };

    template<typename TResult>
    struct IAsyncOperation : public py::proj::Windows::Foundation::IAsyncOperation
    {
        IAsyncOperation(winrt::Windows::Foundation::IAsyncOperation<TResult> o) : _obj(o) {}
        PyObject* Cancel(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IAsyncInfo", L"Cancel", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    {
                        auto _gil = release_gil();
                        _obj.Cancel();
                    }

                    Py_RETURN_NONE;
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* Close(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IAsyncInfo", L"Close", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    {
                        auto _gil = release_gil();
                        _obj.Close();
                    }

                    Py_RETURN_NONE;
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetResults(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IAsyncOperation`1", L"GetResults", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetResults();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* get_Completed() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.Completed();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        int put_Completed(PyObject* arg) noexcept override
        {
            if (!arg)
            {
                PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
                return -1;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncOperationCompletedHandler<TResult>>(arg);

                {
                    auto _gil = release_gil();
                    _obj.Completed(param0);
                }

                return 0;
            }
            catch (...)
            {
                py::to_PyErr();
                return -1;
            }
        }
        PyObject* get_ErrorCode() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.ErrorCode();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        PyObject* get_Id() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.Id();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        PyObject* get_Status() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.Status();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        PyObject* async_get() noexcept override
        {
            if (winrt::impl::is_sta_thread())
            {
                PyErr_SetString(PyExc_RuntimeError, "Cannot call blocking method from single-threaded apartment.");
                return nullptr;
            }

            try
            {
                return py::convert([&]()
                {
                    auto _gil = py::release_gil();
                    return _obj.get();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        PyObject* async_wait(PyObject* arg) noexcept override
        {
            if (winrt::impl::is_sta_thread())
            {
                PyErr_SetString(PyExc_RuntimeError, "Cannot call blocking method from single-threaded apartment.");
                return nullptr;
            }

            auto timeout = PyFloat_AsDouble(arg);
            if (timeout == -1.0 && PyErr_Occurred())
            {
                return nullptr;
            }

            try
            {
                return py::convert([&]()
                {
                    auto _gil = py::release_gil();
                    auto duration = std::chrono::duration_cast<winrt::Windows::Foundation::TimeSpan>(std::chrono::duration<double>(timeout));
                    return _obj.wait_for(duration);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        winrt::Windows::Foundation::IAsyncOperation<TResult> _obj{ nullptr };
    };

    template<typename T>
    struct IReferenceArray : public py::proj::Windows::Foundation::IReferenceArray
    {
        IReferenceArray(winrt::Windows::Foundation::IReferenceArray<T> o) : _obj(o) {}
        PyObject* GetBoolean(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetBoolean", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetBoolean();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetBooleanArray(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetBooleanArray", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<bool> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetBooleanArray(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetChar16(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetChar16", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetChar16();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetChar16Array(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetChar16Array", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<char16_t> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetChar16Array(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetDateTime(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetDateTime", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetDateTime();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetDateTimeArray(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetDateTimeArray", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<winrt::Windows::Foundation::DateTime> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetDateTimeArray(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetDouble(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetDouble", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetDouble();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetDoubleArray(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetDoubleArray", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<double> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetDoubleArray(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetGuid(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetGuid", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetGuid();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetGuidArray(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetGuidArray", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<winrt::guid> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetGuidArray(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetInspectableArray(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInspectableArray", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<winrt::Windows::Foundation::IInspectable> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetInspectableArray(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetInt16(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInt16", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetInt16();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetInt16Array(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInt16Array", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<int16_t> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetInt16Array(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetInt32(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInt32", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetInt32();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetInt32Array(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInt32Array", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<int32_t> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetInt32Array(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetInt64(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInt64", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetInt64();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetInt64Array(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInt64Array", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<int64_t> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetInt64Array(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetPoint(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetPoint", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetPoint();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetPointArray(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetPointArray", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<winrt::Windows::Foundation::Point> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetPointArray(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetRect(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetRect", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetRect();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetRectArray(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetRectArray", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<winrt::Windows::Foundation::Rect> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetRectArray(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetSingle(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetSingle", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetSingle();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetSingleArray(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetSingleArray", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<float> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetSingleArray(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetSize(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetSize", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetSize();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetSizeArray(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetSizeArray", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<winrt::Windows::Foundation::Size> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetSizeArray(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetString(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetString", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetString();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetStringArray(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetStringArray", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<winrt::hstring> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetStringArray(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetTimeSpan(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetTimeSpan", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetTimeSpan();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetTimeSpanArray(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetTimeSpanArray", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<winrt::Windows::Foundation::TimeSpan> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetTimeSpanArray(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetUInt16(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt16", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetUInt16();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetUInt16Array(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt16Array", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<uint16_t> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetUInt16Array(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetUInt32(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt32", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetUInt32();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetUInt32Array(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt32Array", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<uint32_t> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetUInt32Array(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetUInt64(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt64", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetUInt64();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetUInt64Array(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt64Array", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<uint64_t> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetUInt64Array(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetUInt8(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt8", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetUInt8();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetUInt8Array(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt8Array", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<uint8_t> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetUInt8Array(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* get_Value() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.Value();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        PyObject* get_IsNumericScalar() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.IsNumericScalar();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        PyObject* get_Type() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.Type();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        winrt::Windows::Foundation::IReferenceArray<T> _obj{ nullptr };
    };

    template<typename T>
    struct IReference : public py::proj::Windows::Foundation::IReference
    {
        IReference(winrt::Windows::Foundation::IReference<T> o) : _obj(o) {}
        PyObject* GetBoolean(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetBoolean", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetBoolean();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetBooleanArray(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetBooleanArray", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<bool> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetBooleanArray(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetChar16(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetChar16", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetChar16();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetChar16Array(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetChar16Array", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<char16_t> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetChar16Array(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetDateTime(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetDateTime", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetDateTime();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetDateTimeArray(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetDateTimeArray", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<winrt::Windows::Foundation::DateTime> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetDateTimeArray(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetDouble(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetDouble", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetDouble();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetDoubleArray(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetDoubleArray", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<double> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetDoubleArray(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetGuid(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetGuid", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetGuid();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetGuidArray(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetGuidArray", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<winrt::guid> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetGuidArray(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetInspectableArray(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInspectableArray", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<winrt::Windows::Foundation::IInspectable> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetInspectableArray(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetInt16(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInt16", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetInt16();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetInt16Array(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInt16Array", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<int16_t> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetInt16Array(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetInt32(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInt32", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetInt32();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetInt32Array(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInt32Array", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<int32_t> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetInt32Array(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetInt64(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInt64", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetInt64();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetInt64Array(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInt64Array", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<int64_t> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetInt64Array(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetPoint(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetPoint", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetPoint();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetPointArray(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetPointArray", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<winrt::Windows::Foundation::Point> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetPointArray(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetRect(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetRect", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetRect();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetRectArray(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetRectArray", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<winrt::Windows::Foundation::Rect> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetRectArray(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetSingle(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetSingle", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetSingle();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetSingleArray(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetSingleArray", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<float> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetSingleArray(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetSize(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetSize", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetSize();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetSizeArray(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetSizeArray", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<winrt::Windows::Foundation::Size> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetSizeArray(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetString(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetString", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetString();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetStringArray(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetStringArray", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<winrt::hstring> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetStringArray(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetTimeSpan(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetTimeSpan", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetTimeSpan();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetTimeSpanArray(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetTimeSpanArray", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<winrt::Windows::Foundation::TimeSpan> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetTimeSpanArray(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetUInt16(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt16", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetUInt16();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetUInt16Array(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt16Array", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<uint16_t> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetUInt16Array(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetUInt32(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt32", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetUInt32();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetUInt32Array(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt32Array", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<uint32_t> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetUInt32Array(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetUInt64(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt64", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetUInt64();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetUInt64Array(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt64Array", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<uint64_t> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetUInt64Array(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetUInt8(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt8", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    return py::convert([&]()
                    {
                        auto _gil = release_gil();
                        return _obj.GetUInt8();
                    }());
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* GetUInt8Array(PyObject* args) noexcept override
        {
            auto arg_count = PyTuple_GET_SIZE(args);

            if (arg_count == 0)
            {
                try
                {
                    static std::optional<bool> is_overload_present{};

                    if (!is_overload_present.has_value())
                    {
                        is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt8Array", 0);
                    }

                    if (!is_overload_present.value())
                    {
                        py::set_arg_count_version_error(0);
                        return nullptr;
                    }

                    winrt::com_array<uint8_t> param0{};

                    {
                        auto _gil = release_gil();
                        _obj.GetUInt8Array(param0);
                    }

                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0)
                    {
                        return nullptr;
                    }

                    return out0.detach();
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
            else
            {
                py::set_invalid_arg_count_error(arg_count);
                return nullptr;
            }
        }
        PyObject* get_Value() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.Value();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        PyObject* get_IsNumericScalar() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.IsNumericScalar();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        PyObject* get_Type() noexcept override
        {
            try
            {
                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return _obj.Type();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        winrt::Windows::Foundation::IReference<T> _obj{ nullptr };
    };
}

namespace py::wrapper::Windows::Foundation
{
    using Deferral = py::winrt_wrapper<winrt::Windows::Foundation::Deferral>;
    using GuidHelper = py::winrt_wrapper<winrt::Windows::Foundation::GuidHelper>;
    using MemoryBuffer = py::winrt_wrapper<winrt::Windows::Foundation::MemoryBuffer>;
    using PropertyValue = py::winrt_wrapper<winrt::Windows::Foundation::PropertyValue>;
    using Uri = py::winrt_wrapper<winrt::Windows::Foundation::Uri>;
    using WwwFormUrlDecoder = py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoder>;
    using WwwFormUrlDecoderEntry = py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>;
    using IAsyncAction = py::winrt_wrapper<winrt::Windows::Foundation::IAsyncAction>;
    using IAsyncActionWithProgress = py::winrt_pinterface_wrapper<py::proj::Windows::Foundation::IAsyncActionWithProgress>;
    using IAsyncInfo = py::winrt_wrapper<winrt::Windows::Foundation::IAsyncInfo>;
    using IAsyncOperationWithProgress = py::winrt_pinterface_wrapper<py::proj::Windows::Foundation::IAsyncOperationWithProgress>;
    using IAsyncOperation = py::winrt_pinterface_wrapper<py::proj::Windows::Foundation::IAsyncOperation>;
    using IClosable = py::winrt_wrapper<winrt::Windows::Foundation::IClosable>;
    using IGetActivationFactory = py::winrt_wrapper<winrt::Windows::Foundation::IGetActivationFactory>;
    using IMemoryBuffer = py::winrt_wrapper<winrt::Windows::Foundation::IMemoryBuffer>;
    using IMemoryBufferReference = py::winrt_wrapper<winrt::Windows::Foundation::IMemoryBufferReference>;
    using IPropertyValue = py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>;
    using IReferenceArray = py::winrt_pinterface_wrapper<py::proj::Windows::Foundation::IReferenceArray>;
    using IReference = py::winrt_pinterface_wrapper<py::proj::Windows::Foundation::IReference>;
    using IStringable = py::winrt_wrapper<winrt::Windows::Foundation::IStringable>;
    using IWwwFormUrlDecoderEntry = py::winrt_wrapper<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>;
    using EventRegistrationToken = py::winrt_struct_wrapper<winrt::event_token>;
    using HResult = py::winrt_struct_wrapper<winrt::hresult>;
    using Point = py::winrt_struct_wrapper<winrt::Windows::Foundation::Point>;
    using Rect = py::winrt_struct_wrapper<winrt::Windows::Foundation::Rect>;
    using Size = py::winrt_struct_wrapper<winrt::Windows::Foundation::Size>;
}

namespace py
{
    template <typename TProgress>
    struct pinterface_python_type<winrt::Windows::Foundation::IAsyncActionWithProgress<TProgress>>
    {
        using abstract = py::proj::Windows::Foundation::IAsyncActionWithProgress;
        using concrete = py::impl::Windows::Foundation::IAsyncActionWithProgress<TProgress>;
    };

    template <typename TResult, typename TProgress>
    struct pinterface_python_type<winrt::Windows::Foundation::IAsyncOperationWithProgress<TResult, TProgress>>
    {
        using abstract = py::proj::Windows::Foundation::IAsyncOperationWithProgress;
        using concrete = py::impl::Windows::Foundation::IAsyncOperationWithProgress<TResult, TProgress>;
    };

    template <typename TResult>
    struct pinterface_python_type<winrt::Windows::Foundation::IAsyncOperation<TResult>>
    {
        using abstract = py::proj::Windows::Foundation::IAsyncOperation;
        using concrete = py::impl::Windows::Foundation::IAsyncOperation<TResult>;
    };

    template <typename T>
    struct pinterface_python_type<winrt::Windows::Foundation::IReferenceArray<T>>
    {
        using abstract = py::proj::Windows::Foundation::IReferenceArray;
        using concrete = py::impl::Windows::Foundation::IReferenceArray<T>;
    };

    template <typename T>
    struct pinterface_python_type<winrt::Windows::Foundation::IReference<T>>
    {
        using abstract = py::proj::Windows::Foundation::IReference;
        using concrete = py::impl::Windows::Foundation::IReference<T>;
    };

    template <>
    struct delegate_python_type<winrt::Windows::Foundation::AsyncActionCompletedHandler>
    {
        using type = py::impl::Windows::Foundation::AsyncActionCompletedHandler;
    };

    template <typename TProgress>
    struct delegate_python_type<winrt::Windows::Foundation::AsyncActionProgressHandler<TProgress>>
    {
        using type = py::impl::Windows::Foundation::AsyncActionProgressHandler<TProgress>;
    };

    template <typename TProgress>
    struct delegate_python_type<winrt::Windows::Foundation::AsyncActionWithProgressCompletedHandler<TProgress>>
    {
        using type = py::impl::Windows::Foundation::AsyncActionWithProgressCompletedHandler<TProgress>;
    };

    template <typename TResult>
    struct delegate_python_type<winrt::Windows::Foundation::AsyncOperationCompletedHandler<TResult>>
    {
        using type = py::impl::Windows::Foundation::AsyncOperationCompletedHandler<TResult>;
    };

    template <typename TResult, typename TProgress>
    struct delegate_python_type<winrt::Windows::Foundation::AsyncOperationProgressHandler<TResult, TProgress>>
    {
        using type = py::impl::Windows::Foundation::AsyncOperationProgressHandler<TResult, TProgress>;
    };

    template <typename TResult, typename TProgress>
    struct delegate_python_type<winrt::Windows::Foundation::AsyncOperationWithProgressCompletedHandler<TResult, TProgress>>
    {
        using type = py::impl::Windows::Foundation::AsyncOperationWithProgressCompletedHandler<TResult, TProgress>;
    };

    template <>
    struct delegate_python_type<winrt::Windows::Foundation::DeferralCompletedHandler>
    {
        using type = py::impl::Windows::Foundation::DeferralCompletedHandler;
    };

    template <typename T>
    struct delegate_python_type<winrt::Windows::Foundation::EventHandler<T>>
    {
        using type = py::impl::Windows::Foundation::EventHandler<T>;
    };

    template <typename TSender, typename TResult>
    struct delegate_python_type<winrt::Windows::Foundation::TypedEventHandler<TSender, TResult>>
    {
        using type = py::impl::Windows::Foundation::TypedEventHandler<TSender, TResult>;
    };

}
