// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

#include "py.Windows.UI.Composition.Scenes.h"


namespace py::cpp::Windows::UI::Composition::Scenes
{
    // ----- SceneBoundingBox class --------------------

    static PyObject* _new_SceneBoundingBox(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneBoundingBox>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneBoundingBox>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneBoundingBox(py::wrapper::Windows::UI::Composition::Scenes::SceneBoundingBox* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneBoundingBox_get_Center(py::wrapper::Windows::UI::Composition::Scenes::SceneBoundingBox* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneBoundingBox", L"Center"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Center());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneBoundingBox_get_Extents(py::wrapper::Windows::UI::Composition::Scenes::SceneBoundingBox* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneBoundingBox", L"Extents"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Extents());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneBoundingBox_get_Max(py::wrapper::Windows::UI::Composition::Scenes::SceneBoundingBox* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneBoundingBox", L"Max"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneBoundingBox_get_Min(py::wrapper::Windows::UI::Composition::Scenes::SceneBoundingBox* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneBoundingBox", L"Min"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneBoundingBox_get_Size(py::wrapper::Windows::UI::Composition::Scenes::SceneBoundingBox* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneBoundingBox", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SceneBoundingBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::SceneBoundingBox>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneBoundingBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::SceneBoundingBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneBoundingBox[] = {
        { "_assign_array_", _assign_array_SceneBoundingBox, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneBoundingBox), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneBoundingBox[] = {
        { "center", reinterpret_cast<getter>(SceneBoundingBox_get_Center), nullptr, nullptr, nullptr },
        { "extents", reinterpret_cast<getter>(SceneBoundingBox_get_Extents), nullptr, nullptr, nullptr },
        { "max", reinterpret_cast<getter>(SceneBoundingBox_get_Max), nullptr, nullptr, nullptr },
        { "min", reinterpret_cast<getter>(SceneBoundingBox_get_Min), nullptr, nullptr, nullptr },
        { "size", reinterpret_cast<getter>(SceneBoundingBox_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SceneBoundingBox[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneBoundingBox) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneBoundingBox) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneBoundingBox) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneBoundingBox) },
        { },
    };

    static PyType_Spec type_spec_SceneBoundingBox =
    {
        "winrt._winrt_windows_ui_composition_scenes.SceneBoundingBox",
        sizeof(py::wrapper::Windows::UI::Composition::Scenes::SceneBoundingBox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneBoundingBox
    };

    // ----- SceneComponent class --------------------

    static PyObject* _new_SceneComponent(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneComponent>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneComponent>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneComponent(py::wrapper::Windows::UI::Composition::Scenes::SceneComponent* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneComponent_get_ComponentType(py::wrapper::Windows::UI::Composition::Scenes::SceneComponent* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneComponent", L"ComponentType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ComponentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SceneComponent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::SceneComponent>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneComponent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::SceneComponent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneComponent[] = {
        { "_assign_array_", _assign_array_SceneComponent, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneComponent), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneComponent[] = {
        { "component_type", reinterpret_cast<getter>(SceneComponent_get_ComponentType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SceneComponent[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneComponent) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneComponent) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneComponent) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneComponent) },
        { },
    };

    static PyType_Spec type_spec_SceneComponent =
    {
        "winrt._winrt_windows_ui_composition_scenes.SceneComponent",
        sizeof(py::wrapper::Windows::UI::Composition::Scenes::SceneComponent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneComponent
    };

    // ----- SceneComponentCollection class --------------------

    static PyObject* _new_SceneComponentCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneComponentCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneComponentCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneComponentCollection(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneComponentCollection_Append(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneComponentCollection", L"Append", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneComponent>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneComponentCollection_Clear(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneComponentCollection", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneComponentCollection_First(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneComponentCollection", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneComponentCollection_GetAt(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneComponentCollection", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneComponentCollection_GetMany(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneComponentCollection", L"GetMany", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Composition::Scenes::SceneComponent, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneComponentCollection_GetView(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneComponentCollection", L"GetView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneComponentCollection_IndexOf(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneComponentCollection", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneComponent>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneComponentCollection_InsertAt(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneComponentCollection", L"InsertAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneComponent>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneComponentCollection_RemoveAt(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneComponentCollection", L"RemoveAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneComponentCollection_RemoveAtEnd(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneComponentCollection", L"RemoveAtEnd", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneComponentCollection_ReplaceAll(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneComponentCollection", L"ReplaceAll", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Composition::Scenes::SceneComponent, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneComponentCollection_SetAt(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneComponentCollection", L"SetAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneComponent>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneComponentCollection_get_Size(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneComponentCollection", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SceneComponentCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::SceneComponentCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneComponentCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::SceneComponentCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_SceneComponentCollection(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_SceneComponentCollection(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_SceneComponentCollection(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_SceneComponentCollection(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_SceneComponentCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(
                    PyExc_NotImplementedError,
                    "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::UI::Composition::Scenes::SceneComponent> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::UI::Composition::Scenes::SceneComponent>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(
                    PyExc_RuntimeError,
                    "returned count %d did not match requested length %zd",
                    count,
                    length);
                return nullptr;
            }

            return convert(items);}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_SceneComponentCollection(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneComponent>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_SceneComponentCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(SceneComponentCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(SceneComponentCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(SceneComponentCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(SceneComponentCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(SceneComponentCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(SceneComponentCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(SceneComponentCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(SceneComponentCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(SceneComponentCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(SceneComponentCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(SceneComponentCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(SceneComponentCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SceneComponentCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneComponentCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneComponentCollection[] = {
        { "size", reinterpret_cast<getter>(SceneComponentCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SceneComponentCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneComponentCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneComponentCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneComponentCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneComponentCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_SceneComponentCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_SceneComponentCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_SceneComponentCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_SceneComponentCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_SceneComponentCollection) },
        { },
    };

    static PyType_Spec type_spec_SceneComponentCollection =
    {
        "winrt._winrt_windows_ui_composition_scenes.SceneComponentCollection",
        sizeof(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneComponentCollection
    };

    // ----- SceneMaterial class --------------------

    static PyObject* _new_SceneMaterial(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneMaterial>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneMaterial>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneMaterial(py::wrapper::Windows::UI::Composition::Scenes::SceneMaterial* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SceneMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::SceneMaterial>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::SceneMaterial>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneMaterial[] = {
        { "_assign_array_", _assign_array_SceneMaterial, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneMaterial), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneMaterial[] = {
        { }
    };

    static PyType_Slot _type_slots_SceneMaterial[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneMaterial) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneMaterial) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneMaterial) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneMaterial) },
        { },
    };

    static PyType_Spec type_spec_SceneMaterial =
    {
        "winrt._winrt_windows_ui_composition_scenes.SceneMaterial",
        sizeof(py::wrapper::Windows::UI::Composition::Scenes::SceneMaterial),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneMaterial
    };

    // ----- SceneMaterialInput class --------------------

    static PyObject* _new_SceneMaterialInput(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneMaterialInput>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneMaterialInput>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneMaterialInput(py::wrapper::Windows::UI::Composition::Scenes::SceneMaterialInput* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SceneMaterialInput(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::SceneMaterialInput>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneMaterialInput(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::SceneMaterialInput>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneMaterialInput[] = {
        { "_assign_array_", _assign_array_SceneMaterialInput, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneMaterialInput), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneMaterialInput[] = {
        { }
    };

    static PyType_Slot _type_slots_SceneMaterialInput[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneMaterialInput) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneMaterialInput) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneMaterialInput) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneMaterialInput) },
        { },
    };

    static PyType_Spec type_spec_SceneMaterialInput =
    {
        "winrt._winrt_windows_ui_composition_scenes.SceneMaterialInput",
        sizeof(py::wrapper::Windows::UI::Composition::Scenes::SceneMaterialInput),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneMaterialInput
    };

    // ----- SceneMesh class --------------------

    static PyObject* _new_SceneMesh(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneMesh>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneMesh>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneMesh(py::wrapper::Windows::UI::Composition::Scenes::SceneMesh* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneMesh_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneMesh", L"Create", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Compositor>(args, 0);

                return py::convert(winrt::Windows::UI::Composition::Scenes::SceneMesh::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneMesh_FillMeshAttribute(py::wrapper::Windows::UI::Composition::Scenes::SceneMesh* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneMesh", L"FillMeshAttribute", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneAttributeSemantic>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::DirectX::DirectXPixelFormat>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::MemoryBuffer>(args, 2);

                self->obj.FillMeshAttribute(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneMesh_get_PrimitiveTopology(py::wrapper::Windows::UI::Composition::Scenes::SceneMesh* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMesh", L"PrimitiveTopology"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PrimitiveTopology());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneMesh_put_PrimitiveTopology(py::wrapper::Windows::UI::Composition::Scenes::SceneMesh* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMesh", L"PrimitiveTopology"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::DirectXPrimitiveTopology>(arg);

            self->obj.PrimitiveTopology(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneMesh_get_Bounds(py::wrapper::Windows::UI::Composition::Scenes::SceneMesh* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMesh", L"Bounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Bounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SceneMesh(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::SceneMesh>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneMesh(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::SceneMesh>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneMesh[] = {
        { "fill_mesh_attribute", reinterpret_cast<PyCFunction>(SceneMesh_FillMeshAttribute), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SceneMesh, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneMesh), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneMesh[] = {
        { "primitive_topology", reinterpret_cast<getter>(SceneMesh_get_PrimitiveTopology), reinterpret_cast<setter>(SceneMesh_put_PrimitiveTopology), nullptr, nullptr },
        { "bounds", reinterpret_cast<getter>(SceneMesh_get_Bounds), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SceneMesh[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneMesh) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneMesh) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneMesh) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneMesh) },
        { },
    };

    static PyType_Spec type_spec_SceneMesh =
    {
        "winrt._winrt_windows_ui_composition_scenes.SceneMesh",
        sizeof(py::wrapper::Windows::UI::Composition::Scenes::SceneMesh),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneMesh
    };

    static PyGetSetDef getset_SceneMesh_Static[] = {
        { }
    };

    static PyMethodDef methods_SceneMesh_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(SceneMesh_Create), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_SceneMesh_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SceneMesh_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SceneMesh_Static) },
        { }
    };

    static PyType_Spec type_spec_SceneMesh_Static =
    {
        "winrt._winrt_windows_ui_composition_scenes.SceneMesh_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SceneMesh_Static
    };

    // ----- SceneMeshMaterialAttributeMap class --------------------

    static PyObject* _new_SceneMeshMaterialAttributeMap(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneMeshMaterialAttributeMap(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneMeshMaterialAttributeMap_Clear(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneMeshMaterialAttributeMap", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneMeshMaterialAttributeMap_First(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneMeshMaterialAttributeMap", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneMeshMaterialAttributeMap_GetView(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneMeshMaterialAttributeMap", L"GetView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneMeshMaterialAttributeMap_HasKey(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneMeshMaterialAttributeMap", L"HasKey", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneMeshMaterialAttributeMap_Insert(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneMeshMaterialAttributeMap", L"Insert", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneAttributeSemantic>(args, 1);

                return py::convert(self->obj.Insert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneMeshMaterialAttributeMap_Lookup(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneMeshMaterialAttributeMap", L"Lookup", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneMeshMaterialAttributeMap_Remove(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneMeshMaterialAttributeMap", L"Remove", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneMeshMaterialAttributeMap_get_Size(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMeshMaterialAttributeMap", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SceneMeshMaterialAttributeMap(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneMeshMaterialAttributeMap(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_SceneMeshMaterialAttributeMap(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap* self) noexcept
    {
        try
        {
            py::pyobj_handle iter{py::convert(self->obj.First())};

            if (!iter)
            {
                return nullptr;
            }

            return py::wrap_mapping_iter(iter.get());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_contains_SceneMeshMaterialAttributeMap(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap* self, PyObject* key) noexcept
    {
        try
        {
            return static_cast<int>(self->obj.HasKey(py::convert_to<winrt::hstring>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static Py_ssize_t _map_length_SceneMeshMaterialAttributeMap(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_SceneMeshMaterialAttributeMap(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap* self, PyObject* key) noexcept
    {
        try
        {
            auto value = self->obj.TryLookup(py::convert_to<winrt::hstring>(key));

            if (!value) {
                PyErr_SetObject(PyExc_KeyError, key);
                return nullptr;
            }

            return py::convert(value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_SceneMeshMaterialAttributeMap(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);

            if (value == nullptr) {
                if (!self->obj.TryRemove(_key)) {
                    PyErr_SetObject(PyExc_KeyError, key);
                    return -1;
                }

                return 0;
            }

            self->obj.Insert(_key, py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneAttributeSemantic>(value));

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_SceneMeshMaterialAttributeMap[] = {
        { "clear", reinterpret_cast<PyCFunction>(SceneMeshMaterialAttributeMap_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(SceneMeshMaterialAttributeMap_First), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(SceneMeshMaterialAttributeMap_GetView), METH_VARARGS, nullptr },
        { "has_key", reinterpret_cast<PyCFunction>(SceneMeshMaterialAttributeMap_HasKey), METH_VARARGS, nullptr },
        { "insert", reinterpret_cast<PyCFunction>(SceneMeshMaterialAttributeMap_Insert), METH_VARARGS, nullptr },
        { "lookup", reinterpret_cast<PyCFunction>(SceneMeshMaterialAttributeMap_Lookup), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(SceneMeshMaterialAttributeMap_Remove), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SceneMeshMaterialAttributeMap, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneMeshMaterialAttributeMap), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneMeshMaterialAttributeMap[] = {
        { "size", reinterpret_cast<getter>(SceneMeshMaterialAttributeMap_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SceneMeshMaterialAttributeMap[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneMeshMaterialAttributeMap) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneMeshMaterialAttributeMap) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneMeshMaterialAttributeMap) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneMeshMaterialAttributeMap) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_SceneMeshMaterialAttributeMap) },
        { Py_sq_contains, reinterpret_cast<void*>(_map_contains_SceneMeshMaterialAttributeMap) },
        { Py_mp_length, reinterpret_cast<void*>(_map_length_SceneMeshMaterialAttributeMap) },
        { Py_mp_subscript, reinterpret_cast<void*>(_map_subscript_SceneMeshMaterialAttributeMap) },
        { Py_mp_ass_subscript, reinterpret_cast<void*>(_map_assign_SceneMeshMaterialAttributeMap) },
        { },
    };

    static PyType_Spec type_spec_SceneMeshMaterialAttributeMap =
    {
        "winrt._winrt_windows_ui_composition_scenes.SceneMeshMaterialAttributeMap",
        sizeof(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneMeshMaterialAttributeMap
    };

    // ----- SceneMeshRendererComponent class --------------------

    static PyObject* _new_SceneMeshRendererComponent(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneMeshRendererComponent>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneMeshRendererComponent>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneMeshRendererComponent(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshRendererComponent* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneMeshRendererComponent_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneMeshRendererComponent", L"Create", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Compositor>(args, 0);

                return py::convert(winrt::Windows::UI::Composition::Scenes::SceneMeshRendererComponent::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneMeshRendererComponent_get_Mesh(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshRendererComponent* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMeshRendererComponent", L"Mesh"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Mesh());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneMeshRendererComponent_put_Mesh(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshRendererComponent* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMeshRendererComponent", L"Mesh"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneMesh>(arg);

            self->obj.Mesh(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneMeshRendererComponent_get_Material(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshRendererComponent* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMeshRendererComponent", L"Material"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Material());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneMeshRendererComponent_put_Material(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshRendererComponent* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMeshRendererComponent", L"Material"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneMaterial>(arg);

            self->obj.Material(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneMeshRendererComponent_get_UVMappings(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshRendererComponent* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMeshRendererComponent", L"UVMappings"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UVMappings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SceneMeshRendererComponent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::SceneMeshRendererComponent>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneMeshRendererComponent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::SceneMeshRendererComponent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneMeshRendererComponent[] = {
        { "_assign_array_", _assign_array_SceneMeshRendererComponent, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneMeshRendererComponent), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneMeshRendererComponent[] = {
        { "mesh", reinterpret_cast<getter>(SceneMeshRendererComponent_get_Mesh), reinterpret_cast<setter>(SceneMeshRendererComponent_put_Mesh), nullptr, nullptr },
        { "material", reinterpret_cast<getter>(SceneMeshRendererComponent_get_Material), reinterpret_cast<setter>(SceneMeshRendererComponent_put_Material), nullptr, nullptr },
        { "u_v_mappings", reinterpret_cast<getter>(SceneMeshRendererComponent_get_UVMappings), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SceneMeshRendererComponent[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneMeshRendererComponent) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneMeshRendererComponent) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneMeshRendererComponent) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneMeshRendererComponent) },
        { },
    };

    static PyType_Spec type_spec_SceneMeshRendererComponent =
    {
        "winrt._winrt_windows_ui_composition_scenes.SceneMeshRendererComponent",
        sizeof(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshRendererComponent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneMeshRendererComponent
    };

    static PyGetSetDef getset_SceneMeshRendererComponent_Static[] = {
        { }
    };

    static PyMethodDef methods_SceneMeshRendererComponent_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(SceneMeshRendererComponent_Create), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_SceneMeshRendererComponent_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SceneMeshRendererComponent_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SceneMeshRendererComponent_Static) },
        { }
    };

    static PyType_Spec type_spec_SceneMeshRendererComponent_Static =
    {
        "winrt._winrt_windows_ui_composition_scenes.SceneMeshRendererComponent_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SceneMeshRendererComponent_Static
    };

    // ----- SceneMetallicRoughnessMaterial class --------------------

    static PyObject* _new_SceneMetallicRoughnessMaterial(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneMetallicRoughnessMaterial(py::wrapper::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneMetallicRoughnessMaterial_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneMetallicRoughnessMaterial", L"Create", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Compositor>(args, 0);

                return py::convert(winrt::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneMetallicRoughnessMaterial_get_RoughnessFactor(py::wrapper::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMetallicRoughnessMaterial", L"RoughnessFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RoughnessFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneMetallicRoughnessMaterial_put_RoughnessFactor(py::wrapper::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMetallicRoughnessMaterial", L"RoughnessFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.RoughnessFactor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneMetallicRoughnessMaterial_get_MetallicRoughnessInput(py::wrapper::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMetallicRoughnessMaterial", L"MetallicRoughnessInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MetallicRoughnessInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneMetallicRoughnessMaterial_put_MetallicRoughnessInput(py::wrapper::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMetallicRoughnessMaterial", L"MetallicRoughnessInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneMaterialInput>(arg);

            self->obj.MetallicRoughnessInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneMetallicRoughnessMaterial_get_MetallicFactor(py::wrapper::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMetallicRoughnessMaterial", L"MetallicFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MetallicFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneMetallicRoughnessMaterial_put_MetallicFactor(py::wrapper::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMetallicRoughnessMaterial", L"MetallicFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.MetallicFactor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneMetallicRoughnessMaterial_get_BaseColorInput(py::wrapper::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMetallicRoughnessMaterial", L"BaseColorInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BaseColorInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneMetallicRoughnessMaterial_put_BaseColorInput(py::wrapper::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMetallicRoughnessMaterial", L"BaseColorInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneMaterialInput>(arg);

            self->obj.BaseColorInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneMetallicRoughnessMaterial_get_BaseColorFactor(py::wrapper::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMetallicRoughnessMaterial", L"BaseColorFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BaseColorFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneMetallicRoughnessMaterial_put_BaseColorFactor(py::wrapper::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMetallicRoughnessMaterial", L"BaseColorFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float4>(arg);

            self->obj.BaseColorFactor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_SceneMetallicRoughnessMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneMetallicRoughnessMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneMetallicRoughnessMaterial[] = {
        { "_assign_array_", _assign_array_SceneMetallicRoughnessMaterial, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneMetallicRoughnessMaterial), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneMetallicRoughnessMaterial[] = {
        { "roughness_factor", reinterpret_cast<getter>(SceneMetallicRoughnessMaterial_get_RoughnessFactor), reinterpret_cast<setter>(SceneMetallicRoughnessMaterial_put_RoughnessFactor), nullptr, nullptr },
        { "metallic_roughness_input", reinterpret_cast<getter>(SceneMetallicRoughnessMaterial_get_MetallicRoughnessInput), reinterpret_cast<setter>(SceneMetallicRoughnessMaterial_put_MetallicRoughnessInput), nullptr, nullptr },
        { "metallic_factor", reinterpret_cast<getter>(SceneMetallicRoughnessMaterial_get_MetallicFactor), reinterpret_cast<setter>(SceneMetallicRoughnessMaterial_put_MetallicFactor), nullptr, nullptr },
        { "base_color_input", reinterpret_cast<getter>(SceneMetallicRoughnessMaterial_get_BaseColorInput), reinterpret_cast<setter>(SceneMetallicRoughnessMaterial_put_BaseColorInput), nullptr, nullptr },
        { "base_color_factor", reinterpret_cast<getter>(SceneMetallicRoughnessMaterial_get_BaseColorFactor), reinterpret_cast<setter>(SceneMetallicRoughnessMaterial_put_BaseColorFactor), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SceneMetallicRoughnessMaterial[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneMetallicRoughnessMaterial) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneMetallicRoughnessMaterial) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneMetallicRoughnessMaterial) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneMetallicRoughnessMaterial) },
        { },
    };

    static PyType_Spec type_spec_SceneMetallicRoughnessMaterial =
    {
        "winrt._winrt_windows_ui_composition_scenes.SceneMetallicRoughnessMaterial",
        sizeof(py::wrapper::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneMetallicRoughnessMaterial
    };

    static PyGetSetDef getset_SceneMetallicRoughnessMaterial_Static[] = {
        { }
    };

    static PyMethodDef methods_SceneMetallicRoughnessMaterial_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(SceneMetallicRoughnessMaterial_Create), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_SceneMetallicRoughnessMaterial_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SceneMetallicRoughnessMaterial_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SceneMetallicRoughnessMaterial_Static) },
        { }
    };

    static PyType_Spec type_spec_SceneMetallicRoughnessMaterial_Static =
    {
        "winrt._winrt_windows_ui_composition_scenes.SceneMetallicRoughnessMaterial_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SceneMetallicRoughnessMaterial_Static
    };

    // ----- SceneModelTransform class --------------------

    static PyObject* _new_SceneModelTransform(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneModelTransform>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneModelTransform>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneModelTransform(py::wrapper::Windows::UI::Composition::Scenes::SceneModelTransform* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneModelTransform_get_Translation(py::wrapper::Windows::UI::Composition::Scenes::SceneModelTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneModelTransform", L"Translation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Translation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneModelTransform_put_Translation(py::wrapper::Windows::UI::Composition::Scenes::SceneModelTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneModelTransform", L"Translation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.Translation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneModelTransform_get_Scale(py::wrapper::Windows::UI::Composition::Scenes::SceneModelTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneModelTransform", L"Scale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Scale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneModelTransform_put_Scale(py::wrapper::Windows::UI::Composition::Scenes::SceneModelTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneModelTransform", L"Scale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.Scale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneModelTransform_get_RotationAxis(py::wrapper::Windows::UI::Composition::Scenes::SceneModelTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneModelTransform", L"RotationAxis"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RotationAxis());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneModelTransform_put_RotationAxis(py::wrapper::Windows::UI::Composition::Scenes::SceneModelTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneModelTransform", L"RotationAxis"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.RotationAxis(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneModelTransform_get_RotationAngleInDegrees(py::wrapper::Windows::UI::Composition::Scenes::SceneModelTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneModelTransform", L"RotationAngleInDegrees"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RotationAngleInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneModelTransform_put_RotationAngleInDegrees(py::wrapper::Windows::UI::Composition::Scenes::SceneModelTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneModelTransform", L"RotationAngleInDegrees"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.RotationAngleInDegrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneModelTransform_get_RotationAngle(py::wrapper::Windows::UI::Composition::Scenes::SceneModelTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneModelTransform", L"RotationAngle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RotationAngle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneModelTransform_put_RotationAngle(py::wrapper::Windows::UI::Composition::Scenes::SceneModelTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneModelTransform", L"RotationAngle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.RotationAngle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneModelTransform_get_Orientation(py::wrapper::Windows::UI::Composition::Scenes::SceneModelTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneModelTransform", L"Orientation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneModelTransform_put_Orientation(py::wrapper::Windows::UI::Composition::Scenes::SceneModelTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneModelTransform", L"Orientation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(arg);

            self->obj.Orientation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_SceneModelTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::SceneModelTransform>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneModelTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::SceneModelTransform>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneModelTransform[] = {
        { "_assign_array_", _assign_array_SceneModelTransform, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneModelTransform), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneModelTransform[] = {
        { "translation", reinterpret_cast<getter>(SceneModelTransform_get_Translation), reinterpret_cast<setter>(SceneModelTransform_put_Translation), nullptr, nullptr },
        { "scale", reinterpret_cast<getter>(SceneModelTransform_get_Scale), reinterpret_cast<setter>(SceneModelTransform_put_Scale), nullptr, nullptr },
        { "rotation_axis", reinterpret_cast<getter>(SceneModelTransform_get_RotationAxis), reinterpret_cast<setter>(SceneModelTransform_put_RotationAxis), nullptr, nullptr },
        { "rotation_angle_in_degrees", reinterpret_cast<getter>(SceneModelTransform_get_RotationAngleInDegrees), reinterpret_cast<setter>(SceneModelTransform_put_RotationAngleInDegrees), nullptr, nullptr },
        { "rotation_angle", reinterpret_cast<getter>(SceneModelTransform_get_RotationAngle), reinterpret_cast<setter>(SceneModelTransform_put_RotationAngle), nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(SceneModelTransform_get_Orientation), reinterpret_cast<setter>(SceneModelTransform_put_Orientation), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SceneModelTransform[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneModelTransform) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneModelTransform) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneModelTransform) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneModelTransform) },
        { },
    };

    static PyType_Spec type_spec_SceneModelTransform =
    {
        "winrt._winrt_windows_ui_composition_scenes.SceneModelTransform",
        sizeof(py::wrapper::Windows::UI::Composition::Scenes::SceneModelTransform),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneModelTransform
    };

    // ----- SceneNode class --------------------

    static PyObject* _new_SceneNode(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneNode>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneNode>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneNode(py::wrapper::Windows::UI::Composition::Scenes::SceneNode* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneNode_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneNode", L"Create", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Compositor>(args, 0);

                return py::convert(winrt::Windows::UI::Composition::Scenes::SceneNode::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneNode_FindFirstComponentOfType(py::wrapper::Windows::UI::Composition::Scenes::SceneNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneNode", L"FindFirstComponentOfType", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneComponentType>(args, 0);

                return py::convert(self->obj.FindFirstComponentOfType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneNode_get_Children(py::wrapper::Windows::UI::Composition::Scenes::SceneNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneNode", L"Children"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Children());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneNode_get_Components(py::wrapper::Windows::UI::Composition::Scenes::SceneNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneNode", L"Components"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Components());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneNode_get_Parent(py::wrapper::Windows::UI::Composition::Scenes::SceneNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneNode", L"Parent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Parent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneNode_get_Transform(py::wrapper::Windows::UI::Composition::Scenes::SceneNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneNode", L"Transform"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Transform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SceneNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::SceneNode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::SceneNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneNode[] = {
        { "find_first_component_of_type", reinterpret_cast<PyCFunction>(SceneNode_FindFirstComponentOfType), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SceneNode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneNode), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneNode[] = {
        { "children", reinterpret_cast<getter>(SceneNode_get_Children), nullptr, nullptr, nullptr },
        { "components", reinterpret_cast<getter>(SceneNode_get_Components), nullptr, nullptr, nullptr },
        { "parent", reinterpret_cast<getter>(SceneNode_get_Parent), nullptr, nullptr, nullptr },
        { "transform", reinterpret_cast<getter>(SceneNode_get_Transform), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SceneNode[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneNode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneNode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneNode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneNode) },
        { },
    };

    static PyType_Spec type_spec_SceneNode =
    {
        "winrt._winrt_windows_ui_composition_scenes.SceneNode",
        sizeof(py::wrapper::Windows::UI::Composition::Scenes::SceneNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneNode
    };

    static PyGetSetDef getset_SceneNode_Static[] = {
        { }
    };

    static PyMethodDef methods_SceneNode_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(SceneNode_Create), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_SceneNode_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SceneNode_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SceneNode_Static) },
        { }
    };

    static PyType_Spec type_spec_SceneNode_Static =
    {
        "winrt._winrt_windows_ui_composition_scenes.SceneNode_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SceneNode_Static
    };

    // ----- SceneNodeCollection class --------------------

    static PyObject* _new_SceneNodeCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneNodeCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneNodeCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneNodeCollection(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneNodeCollection_Append(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneNodeCollection", L"Append", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneNode>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneNodeCollection_Clear(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneNodeCollection", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneNodeCollection_First(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneNodeCollection", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneNodeCollection_GetAt(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneNodeCollection", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneNodeCollection_GetMany(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneNodeCollection", L"GetMany", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Composition::Scenes::SceneNode, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneNodeCollection_GetView(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneNodeCollection", L"GetView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneNodeCollection_IndexOf(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneNodeCollection", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneNode>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneNodeCollection_InsertAt(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneNodeCollection", L"InsertAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneNode>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneNodeCollection_RemoveAt(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneNodeCollection", L"RemoveAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneNodeCollection_RemoveAtEnd(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneNodeCollection", L"RemoveAtEnd", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneNodeCollection_ReplaceAll(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneNodeCollection", L"ReplaceAll", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Composition::Scenes::SceneNode, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneNodeCollection_SetAt(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneNodeCollection", L"SetAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneNode>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneNodeCollection_get_Size(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneNodeCollection", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SceneNodeCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::SceneNodeCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneNodeCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::SceneNodeCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_SceneNodeCollection(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_SceneNodeCollection(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_SceneNodeCollection(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_SceneNodeCollection(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_SceneNodeCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(
                    PyExc_NotImplementedError,
                    "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::UI::Composition::Scenes::SceneNode> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::UI::Composition::Scenes::SceneNode>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(
                    PyExc_RuntimeError,
                    "returned count %d did not match requested length %zd",
                    count,
                    length);
                return nullptr;
            }

            return convert(items);}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_SceneNodeCollection(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneNode>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_SceneNodeCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(SceneNodeCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(SceneNodeCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(SceneNodeCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(SceneNodeCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(SceneNodeCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(SceneNodeCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(SceneNodeCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(SceneNodeCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(SceneNodeCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(SceneNodeCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(SceneNodeCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(SceneNodeCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SceneNodeCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneNodeCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneNodeCollection[] = {
        { "size", reinterpret_cast<getter>(SceneNodeCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SceneNodeCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneNodeCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneNodeCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneNodeCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneNodeCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_SceneNodeCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_SceneNodeCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_SceneNodeCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_SceneNodeCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_SceneNodeCollection) },
        { },
    };

    static PyType_Spec type_spec_SceneNodeCollection =
    {
        "winrt._winrt_windows_ui_composition_scenes.SceneNodeCollection",
        sizeof(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneNodeCollection
    };

    // ----- SceneObject class --------------------

    static PyObject* _new_SceneObject(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneObject>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneObject>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneObject(py::wrapper::Windows::UI::Composition::Scenes::SceneObject* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SceneObject(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::SceneObject>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneObject(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::SceneObject>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneObject[] = {
        { "_assign_array_", _assign_array_SceneObject, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneObject), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneObject[] = {
        { }
    };

    static PyType_Slot _type_slots_SceneObject[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneObject) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneObject) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneObject) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneObject) },
        { },
    };

    static PyType_Spec type_spec_SceneObject =
    {
        "winrt._winrt_windows_ui_composition_scenes.SceneObject",
        sizeof(py::wrapper::Windows::UI::Composition::Scenes::SceneObject),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneObject
    };

    // ----- ScenePbrMaterial class --------------------

    static PyObject* _new_ScenePbrMaterial(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::ScenePbrMaterial>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::ScenePbrMaterial>::type_name);
        return nullptr;
    }

    static void _dealloc_ScenePbrMaterial(py::wrapper::Windows::UI::Composition::Scenes::ScenePbrMaterial* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScenePbrMaterial_get_OcclusionStrength(py::wrapper::Windows::UI::Composition::Scenes::ScenePbrMaterial* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"OcclusionStrength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OcclusionStrength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScenePbrMaterial_put_OcclusionStrength(py::wrapper::Windows::UI::Composition::Scenes::ScenePbrMaterial* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"OcclusionStrength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.OcclusionStrength(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScenePbrMaterial_get_OcclusionInput(py::wrapper::Windows::UI::Composition::Scenes::ScenePbrMaterial* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"OcclusionInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OcclusionInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScenePbrMaterial_put_OcclusionInput(py::wrapper::Windows::UI::Composition::Scenes::ScenePbrMaterial* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"OcclusionInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneMaterialInput>(arg);

            self->obj.OcclusionInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScenePbrMaterial_get_NormalScale(py::wrapper::Windows::UI::Composition::Scenes::ScenePbrMaterial* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"NormalScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NormalScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScenePbrMaterial_put_NormalScale(py::wrapper::Windows::UI::Composition::Scenes::ScenePbrMaterial* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"NormalScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.NormalScale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScenePbrMaterial_get_NormalInput(py::wrapper::Windows::UI::Composition::Scenes::ScenePbrMaterial* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"NormalInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NormalInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScenePbrMaterial_put_NormalInput(py::wrapper::Windows::UI::Composition::Scenes::ScenePbrMaterial* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"NormalInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneMaterialInput>(arg);

            self->obj.NormalInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScenePbrMaterial_get_IsDoubleSided(py::wrapper::Windows::UI::Composition::Scenes::ScenePbrMaterial* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"IsDoubleSided"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDoubleSided());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScenePbrMaterial_put_IsDoubleSided(py::wrapper::Windows::UI::Composition::Scenes::ScenePbrMaterial* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"IsDoubleSided"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDoubleSided(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScenePbrMaterial_get_EmissiveInput(py::wrapper::Windows::UI::Composition::Scenes::ScenePbrMaterial* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"EmissiveInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmissiveInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScenePbrMaterial_put_EmissiveInput(py::wrapper::Windows::UI::Composition::Scenes::ScenePbrMaterial* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"EmissiveInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneMaterialInput>(arg);

            self->obj.EmissiveInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScenePbrMaterial_get_EmissiveFactor(py::wrapper::Windows::UI::Composition::Scenes::ScenePbrMaterial* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"EmissiveFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmissiveFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScenePbrMaterial_put_EmissiveFactor(py::wrapper::Windows::UI::Composition::Scenes::ScenePbrMaterial* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"EmissiveFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.EmissiveFactor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScenePbrMaterial_get_AlphaMode(py::wrapper::Windows::UI::Composition::Scenes::ScenePbrMaterial* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"AlphaMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AlphaMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScenePbrMaterial_put_AlphaMode(py::wrapper::Windows::UI::Composition::Scenes::ScenePbrMaterial* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"AlphaMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneAlphaMode>(arg);

            self->obj.AlphaMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScenePbrMaterial_get_AlphaCutoff(py::wrapper::Windows::UI::Composition::Scenes::ScenePbrMaterial* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"AlphaCutoff"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AlphaCutoff());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScenePbrMaterial_put_AlphaCutoff(py::wrapper::Windows::UI::Composition::Scenes::ScenePbrMaterial* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"AlphaCutoff"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.AlphaCutoff(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ScenePbrMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::ScenePbrMaterial>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScenePbrMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::ScenePbrMaterial>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScenePbrMaterial[] = {
        { "_assign_array_", _assign_array_ScenePbrMaterial, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScenePbrMaterial), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScenePbrMaterial[] = {
        { "occlusion_strength", reinterpret_cast<getter>(ScenePbrMaterial_get_OcclusionStrength), reinterpret_cast<setter>(ScenePbrMaterial_put_OcclusionStrength), nullptr, nullptr },
        { "occlusion_input", reinterpret_cast<getter>(ScenePbrMaterial_get_OcclusionInput), reinterpret_cast<setter>(ScenePbrMaterial_put_OcclusionInput), nullptr, nullptr },
        { "normal_scale", reinterpret_cast<getter>(ScenePbrMaterial_get_NormalScale), reinterpret_cast<setter>(ScenePbrMaterial_put_NormalScale), nullptr, nullptr },
        { "normal_input", reinterpret_cast<getter>(ScenePbrMaterial_get_NormalInput), reinterpret_cast<setter>(ScenePbrMaterial_put_NormalInput), nullptr, nullptr },
        { "is_double_sided", reinterpret_cast<getter>(ScenePbrMaterial_get_IsDoubleSided), reinterpret_cast<setter>(ScenePbrMaterial_put_IsDoubleSided), nullptr, nullptr },
        { "emissive_input", reinterpret_cast<getter>(ScenePbrMaterial_get_EmissiveInput), reinterpret_cast<setter>(ScenePbrMaterial_put_EmissiveInput), nullptr, nullptr },
        { "emissive_factor", reinterpret_cast<getter>(ScenePbrMaterial_get_EmissiveFactor), reinterpret_cast<setter>(ScenePbrMaterial_put_EmissiveFactor), nullptr, nullptr },
        { "alpha_mode", reinterpret_cast<getter>(ScenePbrMaterial_get_AlphaMode), reinterpret_cast<setter>(ScenePbrMaterial_put_AlphaMode), nullptr, nullptr },
        { "alpha_cutoff", reinterpret_cast<getter>(ScenePbrMaterial_get_AlphaCutoff), reinterpret_cast<setter>(ScenePbrMaterial_put_AlphaCutoff), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScenePbrMaterial[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScenePbrMaterial) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScenePbrMaterial) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScenePbrMaterial) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScenePbrMaterial) },
        { },
    };

    static PyType_Spec type_spec_ScenePbrMaterial =
    {
        "winrt._winrt_windows_ui_composition_scenes.ScenePbrMaterial",
        sizeof(py::wrapper::Windows::UI::Composition::Scenes::ScenePbrMaterial),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScenePbrMaterial
    };

    // ----- SceneRendererComponent class --------------------

    static PyObject* _new_SceneRendererComponent(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneRendererComponent>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneRendererComponent>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneRendererComponent(py::wrapper::Windows::UI::Composition::Scenes::SceneRendererComponent* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SceneRendererComponent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::SceneRendererComponent>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneRendererComponent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::SceneRendererComponent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneRendererComponent[] = {
        { "_assign_array_", _assign_array_SceneRendererComponent, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneRendererComponent), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneRendererComponent[] = {
        { }
    };

    static PyType_Slot _type_slots_SceneRendererComponent[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneRendererComponent) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneRendererComponent) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneRendererComponent) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneRendererComponent) },
        { },
    };

    static PyType_Spec type_spec_SceneRendererComponent =
    {
        "winrt._winrt_windows_ui_composition_scenes.SceneRendererComponent",
        sizeof(py::wrapper::Windows::UI::Composition::Scenes::SceneRendererComponent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneRendererComponent
    };

    // ----- SceneSurfaceMaterialInput class --------------------

    static PyObject* _new_SceneSurfaceMaterialInput(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneSurfaceMaterialInput>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneSurfaceMaterialInput>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneSurfaceMaterialInput(py::wrapper::Windows::UI::Composition::Scenes::SceneSurfaceMaterialInput* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneSurfaceMaterialInput_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneSurfaceMaterialInput", L"Create", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Compositor>(args, 0);

                return py::convert(winrt::Windows::UI::Composition::Scenes::SceneSurfaceMaterialInput::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneSurfaceMaterialInput_get_WrappingVMode(py::wrapper::Windows::UI::Composition::Scenes::SceneSurfaceMaterialInput* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneSurfaceMaterialInput", L"WrappingVMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WrappingVMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneSurfaceMaterialInput_put_WrappingVMode(py::wrapper::Windows::UI::Composition::Scenes::SceneSurfaceMaterialInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneSurfaceMaterialInput", L"WrappingVMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneWrappingMode>(arg);

            self->obj.WrappingVMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneSurfaceMaterialInput_get_WrappingUMode(py::wrapper::Windows::UI::Composition::Scenes::SceneSurfaceMaterialInput* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneSurfaceMaterialInput", L"WrappingUMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WrappingUMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneSurfaceMaterialInput_put_WrappingUMode(py::wrapper::Windows::UI::Composition::Scenes::SceneSurfaceMaterialInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneSurfaceMaterialInput", L"WrappingUMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneWrappingMode>(arg);

            self->obj.WrappingUMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneSurfaceMaterialInput_get_Surface(py::wrapper::Windows::UI::Composition::Scenes::SceneSurfaceMaterialInput* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneSurfaceMaterialInput", L"Surface"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Surface());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneSurfaceMaterialInput_put_Surface(py::wrapper::Windows::UI::Composition::Scenes::SceneSurfaceMaterialInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneSurfaceMaterialInput", L"Surface"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Composition::ICompositionSurface>(arg);

            self->obj.Surface(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneSurfaceMaterialInput_get_BitmapInterpolationMode(py::wrapper::Windows::UI::Composition::Scenes::SceneSurfaceMaterialInput* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneSurfaceMaterialInput", L"BitmapInterpolationMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BitmapInterpolationMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneSurfaceMaterialInput_put_BitmapInterpolationMode(py::wrapper::Windows::UI::Composition::Scenes::SceneSurfaceMaterialInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneSurfaceMaterialInput", L"BitmapInterpolationMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Composition::CompositionBitmapInterpolationMode>(arg);

            self->obj.BitmapInterpolationMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_SceneSurfaceMaterialInput(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::SceneSurfaceMaterialInput>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneSurfaceMaterialInput(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::SceneSurfaceMaterialInput>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneSurfaceMaterialInput[] = {
        { "_assign_array_", _assign_array_SceneSurfaceMaterialInput, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneSurfaceMaterialInput), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneSurfaceMaterialInput[] = {
        { "wrapping_v_mode", reinterpret_cast<getter>(SceneSurfaceMaterialInput_get_WrappingVMode), reinterpret_cast<setter>(SceneSurfaceMaterialInput_put_WrappingVMode), nullptr, nullptr },
        { "wrapping_u_mode", reinterpret_cast<getter>(SceneSurfaceMaterialInput_get_WrappingUMode), reinterpret_cast<setter>(SceneSurfaceMaterialInput_put_WrappingUMode), nullptr, nullptr },
        { "surface", reinterpret_cast<getter>(SceneSurfaceMaterialInput_get_Surface), reinterpret_cast<setter>(SceneSurfaceMaterialInput_put_Surface), nullptr, nullptr },
        { "bitmap_interpolation_mode", reinterpret_cast<getter>(SceneSurfaceMaterialInput_get_BitmapInterpolationMode), reinterpret_cast<setter>(SceneSurfaceMaterialInput_put_BitmapInterpolationMode), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SceneSurfaceMaterialInput[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneSurfaceMaterialInput) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneSurfaceMaterialInput) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneSurfaceMaterialInput) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneSurfaceMaterialInput) },
        { },
    };

    static PyType_Spec type_spec_SceneSurfaceMaterialInput =
    {
        "winrt._winrt_windows_ui_composition_scenes.SceneSurfaceMaterialInput",
        sizeof(py::wrapper::Windows::UI::Composition::Scenes::SceneSurfaceMaterialInput),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneSurfaceMaterialInput
    };

    static PyGetSetDef getset_SceneSurfaceMaterialInput_Static[] = {
        { }
    };

    static PyMethodDef methods_SceneSurfaceMaterialInput_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(SceneSurfaceMaterialInput_Create), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_SceneSurfaceMaterialInput_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SceneSurfaceMaterialInput_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SceneSurfaceMaterialInput_Static) },
        { }
    };

    static PyType_Spec type_spec_SceneSurfaceMaterialInput_Static =
    {
        "winrt._winrt_windows_ui_composition_scenes.SceneSurfaceMaterialInput_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SceneSurfaceMaterialInput_Static
    };

    // ----- SceneVisual class --------------------

    static PyObject* _new_SceneVisual(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneVisual>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneVisual>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneVisual(py::wrapper::Windows::UI::Composition::Scenes::SceneVisual* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneVisual_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneVisual", L"Create", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Compositor>(args, 0);

                return py::convert(winrt::Windows::UI::Composition::Scenes::SceneVisual::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneVisual_get_Root(py::wrapper::Windows::UI::Composition::Scenes::SceneVisual* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneVisual", L"Root"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Root());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneVisual_put_Root(py::wrapper::Windows::UI::Composition::Scenes::SceneVisual* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneVisual", L"Root"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneNode>(arg);

            self->obj.Root(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_SceneVisual(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::SceneVisual>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneVisual(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::SceneVisual>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneVisual[] = {
        { "_assign_array_", _assign_array_SceneVisual, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneVisual), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneVisual[] = {
        { "root", reinterpret_cast<getter>(SceneVisual_get_Root), reinterpret_cast<setter>(SceneVisual_put_Root), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SceneVisual[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneVisual) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneVisual) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneVisual) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneVisual) },
        { },
    };

    static PyType_Spec type_spec_SceneVisual =
    {
        "winrt._winrt_windows_ui_composition_scenes.SceneVisual",
        sizeof(py::wrapper::Windows::UI::Composition::Scenes::SceneVisual),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneVisual
    };

    static PyGetSetDef getset_SceneVisual_Static[] = {
        { }
    };

    static PyMethodDef methods_SceneVisual_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(SceneVisual_Create), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_SceneVisual_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SceneVisual_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SceneVisual_Static) },
        { }
    };

    static PyType_Spec type_spec_SceneVisual_Static =
    {
        "winrt._winrt_windows_ui_composition_scenes.SceneVisual_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SceneVisual_Static
    };

    // ----- Windows.UI.Composition.Scenes Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::UI::Composition::Scenes");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_ui_composition_scenes",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::UI::Composition::Scenes

PyMODINIT_FUNC PyInit__winrt_windows_ui_composition_scenes(void) noexcept
{
    using namespace py::cpp::Windows::UI::Composition::Scenes;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SceneBoundingBox, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SceneComponent, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SceneComponentCollection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SceneMaterial, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SceneMaterialInput, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SceneMesh_Static{PyType_FromSpec(&type_spec_SceneMesh_Static)};
    if (!type_SceneMesh_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SceneMesh, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SceneMesh_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SceneMeshMaterialAttributeMap, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SceneMeshRendererComponent_Static{PyType_FromSpec(&type_spec_SceneMeshRendererComponent_Static)};
    if (!type_SceneMeshRendererComponent_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SceneMeshRendererComponent, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SceneMeshRendererComponent_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SceneMetallicRoughnessMaterial_Static{PyType_FromSpec(&type_spec_SceneMetallicRoughnessMaterial_Static)};
    if (!type_SceneMetallicRoughnessMaterial_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SceneMetallicRoughnessMaterial, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SceneMetallicRoughnessMaterial_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SceneModelTransform, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SceneNode_Static{PyType_FromSpec(&type_spec_SceneNode_Static)};
    if (!type_SceneNode_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SceneNode, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SceneNode_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SceneNodeCollection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SceneObject, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ScenePbrMaterial, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SceneRendererComponent, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SceneSurfaceMaterialInput_Static{PyType_FromSpec(&type_spec_SceneSurfaceMaterialInput_Static)};
    if (!type_SceneSurfaceMaterialInput_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SceneSurfaceMaterialInput, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SceneSurfaceMaterialInput_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SceneVisual_Static{PyType_FromSpec(&type_spec_SceneVisual_Static)};
    if (!type_SceneVisual_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SceneVisual, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SceneVisual_Static.get())) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
