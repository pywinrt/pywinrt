// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.1.0

#include "py.Windows.Security.Cryptography.Certificates.h"

namespace py::cpp::Windows::Security::Cryptography::Certificates
{
    // ----- Certificate class --------------------

    static PyObject* _new_Certificate(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                winrt::Windows::Security::Cryptography::Certificates::Certificate instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Certificate(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Certificate_BuildChainAsync(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"BuildChainAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Security::Cryptography::Certificates::Certificate>>(args, 0);

                return py::convert(self->obj.BuildChainAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"BuildChainAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Security::Cryptography::Certificates::Certificate>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::ChainBuildingParameters>(args, 1);

                return py::convert(self->obj.BuildChainAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Certificate_GetCertificateBlob(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"GetCertificateBlob", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetCertificateBlob());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Certificate_GetHashValue(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"GetHashValue", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetHashValue());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"GetHashValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetHashValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Certificate_get_FriendlyName(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"FriendlyName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Certificate_put_FriendlyName(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"FriendlyName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FriendlyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Certificate_get_EnhancedKeyUsages(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"EnhancedKeyUsages"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EnhancedKeyUsages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_HasPrivateKey(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"HasPrivateKey"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HasPrivateKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_IsStronglyProtected(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"IsStronglyProtected"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsStronglyProtected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_Issuer(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"Issuer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Issuer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_SerialNumber(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"SerialNumber"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SerialNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_Subject(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"Subject"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Subject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_ValidFrom(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"ValidFrom"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ValidFrom());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_ValidTo(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"ValidTo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ValidTo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_IsSecurityDeviceBound(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"IsSecurityDeviceBound"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSecurityDeviceBound());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_KeyAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"KeyAlgorithmName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyAlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_KeyUsages(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"KeyUsages"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyUsages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_SignatureAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"SignatureAlgorithmName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SignatureAlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_SignatureHashAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"SignatureHashAlgorithmName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SignatureHashAlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_SubjectAlternativeName(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"SubjectAlternativeName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SubjectAlternativeName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_IsPerUser(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"IsPerUser"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPerUser());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_KeyStorageProviderName(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"KeyStorageProviderName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyStorageProviderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_StoreName(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.Certificate", L"StoreName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StoreName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Certificate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::Certificate>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Certificate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::Certificate>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Certificate[] = {
        { "build_chain_async", reinterpret_cast<PyCFunction>(Certificate_BuildChainAsync), METH_VARARGS, nullptr },
        { "get_certificate_blob", reinterpret_cast<PyCFunction>(Certificate_GetCertificateBlob), METH_VARARGS, nullptr },
        { "get_hash_value", reinterpret_cast<PyCFunction>(Certificate_GetHashValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Certificate, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Certificate), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Certificate[] = {
        { "friendly_name", reinterpret_cast<getter>(Certificate_get_FriendlyName), reinterpret_cast<setter>(Certificate_put_FriendlyName), nullptr, nullptr },
        { "enhanced_key_usages", reinterpret_cast<getter>(Certificate_get_EnhancedKeyUsages), nullptr, nullptr, nullptr },
        { "has_private_key", reinterpret_cast<getter>(Certificate_get_HasPrivateKey), nullptr, nullptr, nullptr },
        { "is_strongly_protected", reinterpret_cast<getter>(Certificate_get_IsStronglyProtected), nullptr, nullptr, nullptr },
        { "issuer", reinterpret_cast<getter>(Certificate_get_Issuer), nullptr, nullptr, nullptr },
        { "serial_number", reinterpret_cast<getter>(Certificate_get_SerialNumber), nullptr, nullptr, nullptr },
        { "subject", reinterpret_cast<getter>(Certificate_get_Subject), nullptr, nullptr, nullptr },
        { "valid_from", reinterpret_cast<getter>(Certificate_get_ValidFrom), nullptr, nullptr, nullptr },
        { "valid_to", reinterpret_cast<getter>(Certificate_get_ValidTo), nullptr, nullptr, nullptr },
        { "is_security_device_bound", reinterpret_cast<getter>(Certificate_get_IsSecurityDeviceBound), nullptr, nullptr, nullptr },
        { "key_algorithm_name", reinterpret_cast<getter>(Certificate_get_KeyAlgorithmName), nullptr, nullptr, nullptr },
        { "key_usages", reinterpret_cast<getter>(Certificate_get_KeyUsages), nullptr, nullptr, nullptr },
        { "signature_algorithm_name", reinterpret_cast<getter>(Certificate_get_SignatureAlgorithmName), nullptr, nullptr, nullptr },
        { "signature_hash_algorithm_name", reinterpret_cast<getter>(Certificate_get_SignatureHashAlgorithmName), nullptr, nullptr, nullptr },
        { "subject_alternative_name", reinterpret_cast<getter>(Certificate_get_SubjectAlternativeName), nullptr, nullptr, nullptr },
        { "is_per_user", reinterpret_cast<getter>(Certificate_get_IsPerUser), nullptr, nullptr, nullptr },
        { "key_storage_provider_name", reinterpret_cast<getter>(Certificate_get_KeyStorageProviderName), nullptr, nullptr, nullptr },
        { "store_name", reinterpret_cast<getter>(Certificate_get_StoreName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Certificate[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Certificate) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Certificate) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Certificate) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Certificate) },
        { }
    };

    static PyType_Spec type_spec_Certificate = {
        "winrt._winrt_windows_security_cryptography_certificates.Certificate",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Certificate};

    // ----- CertificateChain class --------------------

    static PyObject* _new_CertificateChain(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Cryptography::Certificates::CertificateChain>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Cryptography::Certificates::CertificateChain>::type_name);
        return nullptr;
    }

    static void _dealloc_CertificateChain(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateChain* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CertificateChain_GetCertificates(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateChain* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CertificateChain", L"GetCertificates", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.GetCertificates(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateChain_Validate(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateChain* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CertificateChain", L"Validate", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.Validate());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CertificateChain", L"Validate", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::ChainValidationParameters>(args, 0);

                return py::convert(self->obj.Validate(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_CertificateChain(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::CertificateChain>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CertificateChain(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CertificateChain>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CertificateChain[] = {
        { "get_certificates", reinterpret_cast<PyCFunction>(CertificateChain_GetCertificates), METH_VARARGS, nullptr },
        { "validate", reinterpret_cast<PyCFunction>(CertificateChain_Validate), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CertificateChain, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CertificateChain), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CertificateChain[] = {
        { }
    };

    static PyType_Slot _type_slots_CertificateChain[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CertificateChain) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CertificateChain) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CertificateChain) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CertificateChain) },
        { }
    };

    static PyType_Spec type_spec_CertificateChain = {
        "winrt._winrt_windows_security_cryptography_certificates.CertificateChain",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateChain),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CertificateChain};

    // ----- CertificateEnrollmentManager class --------------------

    static PyObject* _new_CertificateEnrollmentManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager>::type_name);
        return nullptr;
    }

    static PyObject* CertificateEnrollmentManager_CreateRequestAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CertificateEnrollmentManager", L"CreateRequestAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::CertificateRequestProperties>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager::CreateRequestAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateEnrollmentManager_ImportPfxDataAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CertificateEnrollmentManager", L"ImportPfxDataAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::PfxImportParameters>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager::ImportPfxDataAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 6)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CertificateEnrollmentManager", L"ImportPfxDataAsync", 6))
                {
                    py::set_arg_count_version_error(6);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::ExportOption>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::KeyProtectionLevel>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::InstallOptions>(args, 4);
                auto param5 = py::convert_to<winrt::hstring>(args, 5);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager::ImportPfxDataAsync(param0, param1, param2, param3, param4, param5));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 7)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CertificateEnrollmentManager", L"ImportPfxDataAsync", 7))
                {
                    py::set_arg_count_version_error(7);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::ExportOption>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::KeyProtectionLevel>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::InstallOptions>(args, 4);
                auto param5 = py::convert_to<winrt::hstring>(args, 5);
                auto param6 = py::convert_to<winrt::hstring>(args, 6);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager::ImportPfxDataAsync(param0, param1, param2, param3, param4, param5, param6));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateEnrollmentManager_InstallCertificateAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CertificateEnrollmentManager", L"InstallCertificateAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::InstallOptions>(args, 1);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager::InstallCertificateAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateEnrollmentManager_get_UserCertificateEnrollmentManager(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateEnrollmentManager", L"UserCertificateEnrollmentManager"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager::UserCertificateEnrollmentManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CertificateEnrollmentManager[] = {
        { }
    };

    static PyGetSetDef _getset_CertificateEnrollmentManager[] = {
        { }
    };

    static PyType_Slot _type_slots_CertificateEnrollmentManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CertificateEnrollmentManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CertificateEnrollmentManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CertificateEnrollmentManager) },
        { }
    };

    static PyType_Spec type_spec_CertificateEnrollmentManager = {
        "winrt._winrt_windows_security_cryptography_certificates.CertificateEnrollmentManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CertificateEnrollmentManager};

    static PyGetSetDef getset_CertificateEnrollmentManager_Static[] = {
        { "user_certificate_enrollment_manager", reinterpret_cast<getter>(CertificateEnrollmentManager_get_UserCertificateEnrollmentManager), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_CertificateEnrollmentManager_Static[] = {
        { "create_request_async", reinterpret_cast<PyCFunction>(CertificateEnrollmentManager_CreateRequestAsync), METH_VARARGS, nullptr },
        { "import_pfx_data_async", reinterpret_cast<PyCFunction>(CertificateEnrollmentManager_ImportPfxDataAsync), METH_VARARGS, nullptr },
        { "install_certificate_async", reinterpret_cast<PyCFunction>(CertificateEnrollmentManager_InstallCertificateAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_CertificateEnrollmentManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CertificateEnrollmentManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CertificateEnrollmentManager_Static) },
        { }
    };

    static PyType_Spec type_spec_CertificateEnrollmentManager_Static =
    {
        "winrt._winrt_windows_security_cryptography_certificates.CertificateEnrollmentManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CertificateEnrollmentManager_Static
    };

    // ----- CertificateExtension class --------------------

    static PyObject* _new_CertificateExtension(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::CertificateExtension instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CertificateExtension(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CertificateExtension_EncodeValue(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CertificateExtension", L"EncodeValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.EncodeValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateExtension_get_Value(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateExtension", L"Value"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateExtension_put_Value(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateExtension", L"Value"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateExtension_get_ObjectId(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateExtension", L"ObjectId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ObjectId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateExtension_put_ObjectId(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateExtension", L"ObjectId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ObjectId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateExtension_get_IsCritical(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateExtension", L"IsCritical"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCritical());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateExtension_put_IsCritical(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateExtension", L"IsCritical"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCritical(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CertificateExtension(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::CertificateExtension>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CertificateExtension(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CertificateExtension>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CertificateExtension[] = {
        { "encode_value", reinterpret_cast<PyCFunction>(CertificateExtension_EncodeValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CertificateExtension, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CertificateExtension), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CertificateExtension[] = {
        { "value", reinterpret_cast<getter>(CertificateExtension_get_Value), reinterpret_cast<setter>(CertificateExtension_put_Value), nullptr, nullptr },
        { "object_id", reinterpret_cast<getter>(CertificateExtension_get_ObjectId), reinterpret_cast<setter>(CertificateExtension_put_ObjectId), nullptr, nullptr },
        { "is_critical", reinterpret_cast<getter>(CertificateExtension_get_IsCritical), reinterpret_cast<setter>(CertificateExtension_put_IsCritical), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CertificateExtension[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CertificateExtension) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CertificateExtension) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CertificateExtension) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CertificateExtension) },
        { }
    };

    static PyType_Spec type_spec_CertificateExtension = {
        "winrt._winrt_windows_security_cryptography_certificates.CertificateExtension",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CertificateExtension};

    // ----- CertificateKeyUsages class --------------------

    static PyObject* _new_CertificateKeyUsages(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::CertificateKeyUsages instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CertificateKeyUsages(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CertificateKeyUsages_get_NonRepudiation(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateKeyUsages", L"NonRepudiation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NonRepudiation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateKeyUsages_put_NonRepudiation(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateKeyUsages", L"NonRepudiation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.NonRepudiation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateKeyUsages_get_KeyEncipherment(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateKeyUsages", L"KeyEncipherment"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyEncipherment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateKeyUsages_put_KeyEncipherment(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateKeyUsages", L"KeyEncipherment"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.KeyEncipherment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateKeyUsages_get_KeyCertificateSign(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateKeyUsages", L"KeyCertificateSign"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyCertificateSign());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateKeyUsages_put_KeyCertificateSign(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateKeyUsages", L"KeyCertificateSign"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.KeyCertificateSign(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateKeyUsages_get_KeyAgreement(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateKeyUsages", L"KeyAgreement"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyAgreement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateKeyUsages_put_KeyAgreement(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateKeyUsages", L"KeyAgreement"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.KeyAgreement(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateKeyUsages_get_EncipherOnly(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateKeyUsages", L"EncipherOnly"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EncipherOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateKeyUsages_put_EncipherOnly(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateKeyUsages", L"EncipherOnly"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.EncipherOnly(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateKeyUsages_get_DigitalSignature(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateKeyUsages", L"DigitalSignature"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DigitalSignature());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateKeyUsages_put_DigitalSignature(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateKeyUsages", L"DigitalSignature"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.DigitalSignature(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateKeyUsages_get_DataEncipherment(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateKeyUsages", L"DataEncipherment"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DataEncipherment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateKeyUsages_put_DataEncipherment(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateKeyUsages", L"DataEncipherment"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.DataEncipherment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateKeyUsages_get_CrlSign(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateKeyUsages", L"CrlSign"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CrlSign());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateKeyUsages_put_CrlSign(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateKeyUsages", L"CrlSign"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CrlSign(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CertificateKeyUsages(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::CertificateKeyUsages>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CertificateKeyUsages(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CertificateKeyUsages>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CertificateKeyUsages[] = {
        { "_assign_array_", _assign_array_CertificateKeyUsages, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CertificateKeyUsages), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CertificateKeyUsages[] = {
        { "non_repudiation", reinterpret_cast<getter>(CertificateKeyUsages_get_NonRepudiation), reinterpret_cast<setter>(CertificateKeyUsages_put_NonRepudiation), nullptr, nullptr },
        { "key_encipherment", reinterpret_cast<getter>(CertificateKeyUsages_get_KeyEncipherment), reinterpret_cast<setter>(CertificateKeyUsages_put_KeyEncipherment), nullptr, nullptr },
        { "key_certificate_sign", reinterpret_cast<getter>(CertificateKeyUsages_get_KeyCertificateSign), reinterpret_cast<setter>(CertificateKeyUsages_put_KeyCertificateSign), nullptr, nullptr },
        { "key_agreement", reinterpret_cast<getter>(CertificateKeyUsages_get_KeyAgreement), reinterpret_cast<setter>(CertificateKeyUsages_put_KeyAgreement), nullptr, nullptr },
        { "encipher_only", reinterpret_cast<getter>(CertificateKeyUsages_get_EncipherOnly), reinterpret_cast<setter>(CertificateKeyUsages_put_EncipherOnly), nullptr, nullptr },
        { "digital_signature", reinterpret_cast<getter>(CertificateKeyUsages_get_DigitalSignature), reinterpret_cast<setter>(CertificateKeyUsages_put_DigitalSignature), nullptr, nullptr },
        { "data_encipherment", reinterpret_cast<getter>(CertificateKeyUsages_get_DataEncipherment), reinterpret_cast<setter>(CertificateKeyUsages_put_DataEncipherment), nullptr, nullptr },
        { "crl_sign", reinterpret_cast<getter>(CertificateKeyUsages_get_CrlSign), reinterpret_cast<setter>(CertificateKeyUsages_put_CrlSign), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CertificateKeyUsages[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CertificateKeyUsages) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CertificateKeyUsages) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CertificateKeyUsages) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CertificateKeyUsages) },
        { }
    };

    static PyType_Spec type_spec_CertificateKeyUsages = {
        "winrt._winrt_windows_security_cryptography_certificates.CertificateKeyUsages",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CertificateKeyUsages};

    // ----- CertificateQuery class --------------------

    static PyObject* _new_CertificateQuery(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::CertificateQuery instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CertificateQuery(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CertificateQuery_get_Thumbprint(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateQuery", L"Thumbprint"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Thumbprint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateQuery_put_Thumbprint(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateQuery", L"Thumbprint"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(arg);

            self->obj.Thumbprint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateQuery_get_IssuerName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateQuery", L"IssuerName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IssuerName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateQuery_put_IssuerName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateQuery", L"IssuerName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.IssuerName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateQuery_get_HardwareOnly(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateQuery", L"HardwareOnly"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HardwareOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateQuery_put_HardwareOnly(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateQuery", L"HardwareOnly"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.HardwareOnly(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateQuery_get_FriendlyName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateQuery", L"FriendlyName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateQuery_put_FriendlyName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateQuery", L"FriendlyName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FriendlyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateQuery_get_EnhancedKeyUsages(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateQuery", L"EnhancedKeyUsages"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EnhancedKeyUsages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CertificateQuery_get_StoreName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateQuery", L"StoreName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StoreName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateQuery_put_StoreName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateQuery", L"StoreName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.StoreName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateQuery_get_IncludeExpiredCertificates(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateQuery", L"IncludeExpiredCertificates"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IncludeExpiredCertificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateQuery_put_IncludeExpiredCertificates(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateQuery", L"IncludeExpiredCertificates"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IncludeExpiredCertificates(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateQuery_get_IncludeDuplicates(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateQuery", L"IncludeDuplicates"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IncludeDuplicates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateQuery_put_IncludeDuplicates(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateQuery", L"IncludeDuplicates"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IncludeDuplicates(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CertificateQuery(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::CertificateQuery>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CertificateQuery(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CertificateQuery>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CertificateQuery[] = {
        { "_assign_array_", _assign_array_CertificateQuery, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CertificateQuery), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CertificateQuery[] = {
        { "thumbprint", reinterpret_cast<getter>(CertificateQuery_get_Thumbprint), reinterpret_cast<setter>(CertificateQuery_put_Thumbprint), nullptr, nullptr },
        { "issuer_name", reinterpret_cast<getter>(CertificateQuery_get_IssuerName), reinterpret_cast<setter>(CertificateQuery_put_IssuerName), nullptr, nullptr },
        { "hardware_only", reinterpret_cast<getter>(CertificateQuery_get_HardwareOnly), reinterpret_cast<setter>(CertificateQuery_put_HardwareOnly), nullptr, nullptr },
        { "friendly_name", reinterpret_cast<getter>(CertificateQuery_get_FriendlyName), reinterpret_cast<setter>(CertificateQuery_put_FriendlyName), nullptr, nullptr },
        { "enhanced_key_usages", reinterpret_cast<getter>(CertificateQuery_get_EnhancedKeyUsages), nullptr, nullptr, nullptr },
        { "store_name", reinterpret_cast<getter>(CertificateQuery_get_StoreName), reinterpret_cast<setter>(CertificateQuery_put_StoreName), nullptr, nullptr },
        { "include_expired_certificates", reinterpret_cast<getter>(CertificateQuery_get_IncludeExpiredCertificates), reinterpret_cast<setter>(CertificateQuery_put_IncludeExpiredCertificates), nullptr, nullptr },
        { "include_duplicates", reinterpret_cast<getter>(CertificateQuery_get_IncludeDuplicates), reinterpret_cast<setter>(CertificateQuery_put_IncludeDuplicates), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CertificateQuery[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CertificateQuery) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CertificateQuery) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CertificateQuery) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CertificateQuery) },
        { }
    };

    static PyType_Spec type_spec_CertificateQuery = {
        "winrt._winrt_windows_security_cryptography_certificates.CertificateQuery",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CertificateQuery};

    // ----- CertificateRequestProperties class --------------------

    static PyObject* _new_CertificateRequestProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::CertificateRequestProperties instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CertificateRequestProperties(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CertificateRequestProperties_get_Subject(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"Subject"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Subject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_Subject(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"Subject"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subject(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_KeyUsages(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"KeyUsages"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyUsages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_KeyUsages(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"KeyUsages"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::EnrollKeyUsages>(arg);

            self->obj.KeyUsages(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_KeyStorageProviderName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"KeyStorageProviderName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyStorageProviderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_KeyStorageProviderName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"KeyStorageProviderName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.KeyStorageProviderName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_KeySize(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"KeySize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeySize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_KeySize(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"KeySize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.KeySize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_Exportable(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"Exportable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Exportable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_Exportable(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"Exportable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::ExportOption>(arg);

            self->obj.Exportable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_KeyProtectionLevel(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"KeyProtectionLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyProtectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_KeyProtectionLevel(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"KeyProtectionLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::KeyProtectionLevel>(arg);

            self->obj.KeyProtectionLevel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_KeyAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"KeyAlgorithmName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyAlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_KeyAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"KeyAlgorithmName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.KeyAlgorithmName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_HashAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"HashAlgorithmName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HashAlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_HashAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"HashAlgorithmName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.HashAlgorithmName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_FriendlyName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"FriendlyName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_FriendlyName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"FriendlyName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FriendlyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_AttestationCredentialCertificate(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"AttestationCredentialCertificate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AttestationCredentialCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_AttestationCredentialCertificate(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"AttestationCredentialCertificate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(arg);

            self->obj.AttestationCredentialCertificate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_SigningCertificate(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"SigningCertificate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SigningCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_SigningCertificate(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"SigningCertificate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(arg);

            self->obj.SigningCertificate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_SmartcardReaderName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"SmartcardReaderName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SmartcardReaderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_SmartcardReaderName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"SmartcardReaderName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SmartcardReaderName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_UseExistingKey(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"UseExistingKey"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UseExistingKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_UseExistingKey(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"UseExistingKey"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.UseExistingKey(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_CurveParameters(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"CurveParameters"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CurveParameters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_CurveParameters(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"CurveParameters"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(arg);

            self->obj.CurveParameters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_CurveName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"CurveName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CurveName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_CurveName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"CurveName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CurveName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_ContainerNamePrefix(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"ContainerNamePrefix"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContainerNamePrefix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_ContainerNamePrefix(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"ContainerNamePrefix"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContainerNamePrefix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_ContainerName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"ContainerName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContainerName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_ContainerName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"ContainerName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContainerName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_Extensions(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"Extensions"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Extensions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CertificateRequestProperties_get_SubjectAlternativeName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"SubjectAlternativeName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SubjectAlternativeName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CertificateRequestProperties_get_SuppressedDefaults(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateRequestProperties", L"SuppressedDefaults"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SuppressedDefaults());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CertificateRequestProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::CertificateRequestProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CertificateRequestProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CertificateRequestProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CertificateRequestProperties[] = {
        { "_assign_array_", _assign_array_CertificateRequestProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CertificateRequestProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CertificateRequestProperties[] = {
        { "subject", reinterpret_cast<getter>(CertificateRequestProperties_get_Subject), reinterpret_cast<setter>(CertificateRequestProperties_put_Subject), nullptr, nullptr },
        { "key_usages", reinterpret_cast<getter>(CertificateRequestProperties_get_KeyUsages), reinterpret_cast<setter>(CertificateRequestProperties_put_KeyUsages), nullptr, nullptr },
        { "key_storage_provider_name", reinterpret_cast<getter>(CertificateRequestProperties_get_KeyStorageProviderName), reinterpret_cast<setter>(CertificateRequestProperties_put_KeyStorageProviderName), nullptr, nullptr },
        { "key_size", reinterpret_cast<getter>(CertificateRequestProperties_get_KeySize), reinterpret_cast<setter>(CertificateRequestProperties_put_KeySize), nullptr, nullptr },
        { "exportable", reinterpret_cast<getter>(CertificateRequestProperties_get_Exportable), reinterpret_cast<setter>(CertificateRequestProperties_put_Exportable), nullptr, nullptr },
        { "key_protection_level", reinterpret_cast<getter>(CertificateRequestProperties_get_KeyProtectionLevel), reinterpret_cast<setter>(CertificateRequestProperties_put_KeyProtectionLevel), nullptr, nullptr },
        { "key_algorithm_name", reinterpret_cast<getter>(CertificateRequestProperties_get_KeyAlgorithmName), reinterpret_cast<setter>(CertificateRequestProperties_put_KeyAlgorithmName), nullptr, nullptr },
        { "hash_algorithm_name", reinterpret_cast<getter>(CertificateRequestProperties_get_HashAlgorithmName), reinterpret_cast<setter>(CertificateRequestProperties_put_HashAlgorithmName), nullptr, nullptr },
        { "friendly_name", reinterpret_cast<getter>(CertificateRequestProperties_get_FriendlyName), reinterpret_cast<setter>(CertificateRequestProperties_put_FriendlyName), nullptr, nullptr },
        { "attestation_credential_certificate", reinterpret_cast<getter>(CertificateRequestProperties_get_AttestationCredentialCertificate), reinterpret_cast<setter>(CertificateRequestProperties_put_AttestationCredentialCertificate), nullptr, nullptr },
        { "signing_certificate", reinterpret_cast<getter>(CertificateRequestProperties_get_SigningCertificate), reinterpret_cast<setter>(CertificateRequestProperties_put_SigningCertificate), nullptr, nullptr },
        { "smartcard_reader_name", reinterpret_cast<getter>(CertificateRequestProperties_get_SmartcardReaderName), reinterpret_cast<setter>(CertificateRequestProperties_put_SmartcardReaderName), nullptr, nullptr },
        { "use_existing_key", reinterpret_cast<getter>(CertificateRequestProperties_get_UseExistingKey), reinterpret_cast<setter>(CertificateRequestProperties_put_UseExistingKey), nullptr, nullptr },
        { "curve_parameters", reinterpret_cast<getter>(CertificateRequestProperties_get_CurveParameters), reinterpret_cast<setter>(CertificateRequestProperties_put_CurveParameters), nullptr, nullptr },
        { "curve_name", reinterpret_cast<getter>(CertificateRequestProperties_get_CurveName), reinterpret_cast<setter>(CertificateRequestProperties_put_CurveName), nullptr, nullptr },
        { "container_name_prefix", reinterpret_cast<getter>(CertificateRequestProperties_get_ContainerNamePrefix), reinterpret_cast<setter>(CertificateRequestProperties_put_ContainerNamePrefix), nullptr, nullptr },
        { "container_name", reinterpret_cast<getter>(CertificateRequestProperties_get_ContainerName), reinterpret_cast<setter>(CertificateRequestProperties_put_ContainerName), nullptr, nullptr },
        { "extensions", reinterpret_cast<getter>(CertificateRequestProperties_get_Extensions), nullptr, nullptr, nullptr },
        { "subject_alternative_name", reinterpret_cast<getter>(CertificateRequestProperties_get_SubjectAlternativeName), nullptr, nullptr, nullptr },
        { "suppressed_defaults", reinterpret_cast<getter>(CertificateRequestProperties_get_SuppressedDefaults), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CertificateRequestProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CertificateRequestProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CertificateRequestProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CertificateRequestProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CertificateRequestProperties) },
        { }
    };

    static PyType_Spec type_spec_CertificateRequestProperties = {
        "winrt._winrt_windows_security_cryptography_certificates.CertificateRequestProperties",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CertificateRequestProperties};

    // ----- CertificateStore class --------------------

    static PyObject* _new_CertificateStore(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Cryptography::Certificates::CertificateStore>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Cryptography::Certificates::CertificateStore>::type_name);
        return nullptr;
    }

    static void _dealloc_CertificateStore(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateStore* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CertificateStore_Add(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CertificateStore", L"Add", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(args, 0);

                self->obj.Add(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateStore_Delete(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CertificateStore", L"Delete", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(args, 0);

                self->obj.Delete(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateStore_get_Name(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateStore* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateStore", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CertificateStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::CertificateStore>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CertificateStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CertificateStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CertificateStore[] = {
        { "add", reinterpret_cast<PyCFunction>(CertificateStore_Add), METH_VARARGS, nullptr },
        { "delete", reinterpret_cast<PyCFunction>(CertificateStore_Delete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CertificateStore, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CertificateStore), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CertificateStore[] = {
        { "name", reinterpret_cast<getter>(CertificateStore_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CertificateStore[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CertificateStore) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CertificateStore) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CertificateStore) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CertificateStore) },
        { }
    };

    static PyType_Spec type_spec_CertificateStore = {
        "winrt._winrt_windows_security_cryptography_certificates.CertificateStore",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CertificateStore};

    // ----- CertificateStores class --------------------

    static PyObject* _new_CertificateStores(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Cryptography::Certificates::CertificateStores>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Cryptography::Certificates::CertificateStores>::type_name);
        return nullptr;
    }

    static PyObject* CertificateStores_FindAllAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CertificateStores", L"FindAllAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateStores::FindAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CertificateStores", L"FindAllAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::CertificateQuery>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateStores::FindAllAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateStores_GetStoreByName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CertificateStores", L"GetStoreByName", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateStores::GetStoreByName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateStores_GetUserStoreByName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CertificateStores", L"GetUserStoreByName", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateStores::GetUserStoreByName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateStores_get_IntermediateCertificationAuthorities(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateStores", L"IntermediateCertificationAuthorities"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateStores::IntermediateCertificationAuthorities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CertificateStores_get_TrustedRootCertificationAuthorities(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CertificateStores", L"TrustedRootCertificationAuthorities"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateStores::TrustedRootCertificationAuthorities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CertificateStores[] = {
        { }
    };

    static PyGetSetDef _getset_CertificateStores[] = {
        { }
    };

    static PyType_Slot _type_slots_CertificateStores[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CertificateStores) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CertificateStores) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CertificateStores) },
        { }
    };

    static PyType_Spec type_spec_CertificateStores = {
        "winrt._winrt_windows_security_cryptography_certificates.CertificateStores",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CertificateStores};

    static PyGetSetDef getset_CertificateStores_Static[] = {
        { "intermediate_certification_authorities", reinterpret_cast<getter>(CertificateStores_get_IntermediateCertificationAuthorities), nullptr, nullptr, nullptr },
        { "trusted_root_certification_authorities", reinterpret_cast<getter>(CertificateStores_get_TrustedRootCertificationAuthorities), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_CertificateStores_Static[] = {
        { "find_all_async", reinterpret_cast<PyCFunction>(CertificateStores_FindAllAsync), METH_VARARGS, nullptr },
        { "get_store_by_name", reinterpret_cast<PyCFunction>(CertificateStores_GetStoreByName), METH_VARARGS, nullptr },
        { "get_user_store_by_name", reinterpret_cast<PyCFunction>(CertificateStores_GetUserStoreByName), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_CertificateStores_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CertificateStores_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CertificateStores_Static) },
        { }
    };

    static PyType_Spec type_spec_CertificateStores_Static =
    {
        "winrt._winrt_windows_security_cryptography_certificates.CertificateStores_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CertificateStores_Static
    };

    // ----- ChainBuildingParameters class --------------------

    static PyObject* _new_ChainBuildingParameters(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::ChainBuildingParameters instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChainBuildingParameters(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChainBuildingParameters_get_ValidationTimestamp(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.ChainBuildingParameters", L"ValidationTimestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ValidationTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChainBuildingParameters_put_ValidationTimestamp(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.ChainBuildingParameters", L"ValidationTimestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.ValidationTimestamp(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChainBuildingParameters_get_RevocationCheckEnabled(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.ChainBuildingParameters", L"RevocationCheckEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RevocationCheckEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChainBuildingParameters_put_RevocationCheckEnabled(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.ChainBuildingParameters", L"RevocationCheckEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.RevocationCheckEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChainBuildingParameters_get_NetworkRetrievalEnabled(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.ChainBuildingParameters", L"NetworkRetrievalEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NetworkRetrievalEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChainBuildingParameters_put_NetworkRetrievalEnabled(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.ChainBuildingParameters", L"NetworkRetrievalEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.NetworkRetrievalEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChainBuildingParameters_get_CurrentTimeValidationEnabled(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.ChainBuildingParameters", L"CurrentTimeValidationEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CurrentTimeValidationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChainBuildingParameters_put_CurrentTimeValidationEnabled(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.ChainBuildingParameters", L"CurrentTimeValidationEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CurrentTimeValidationEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChainBuildingParameters_get_AuthorityInformationAccessEnabled(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.ChainBuildingParameters", L"AuthorityInformationAccessEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AuthorityInformationAccessEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChainBuildingParameters_put_AuthorityInformationAccessEnabled(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.ChainBuildingParameters", L"AuthorityInformationAccessEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AuthorityInformationAccessEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChainBuildingParameters_get_EnhancedKeyUsages(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.ChainBuildingParameters", L"EnhancedKeyUsages"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EnhancedKeyUsages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChainBuildingParameters_get_ExclusiveTrustRoots(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.ChainBuildingParameters", L"ExclusiveTrustRoots"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExclusiveTrustRoots());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChainBuildingParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::ChainBuildingParameters>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChainBuildingParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::ChainBuildingParameters>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChainBuildingParameters[] = {
        { "_assign_array_", _assign_array_ChainBuildingParameters, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChainBuildingParameters), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChainBuildingParameters[] = {
        { "validation_timestamp", reinterpret_cast<getter>(ChainBuildingParameters_get_ValidationTimestamp), reinterpret_cast<setter>(ChainBuildingParameters_put_ValidationTimestamp), nullptr, nullptr },
        { "revocation_check_enabled", reinterpret_cast<getter>(ChainBuildingParameters_get_RevocationCheckEnabled), reinterpret_cast<setter>(ChainBuildingParameters_put_RevocationCheckEnabled), nullptr, nullptr },
        { "network_retrieval_enabled", reinterpret_cast<getter>(ChainBuildingParameters_get_NetworkRetrievalEnabled), reinterpret_cast<setter>(ChainBuildingParameters_put_NetworkRetrievalEnabled), nullptr, nullptr },
        { "current_time_validation_enabled", reinterpret_cast<getter>(ChainBuildingParameters_get_CurrentTimeValidationEnabled), reinterpret_cast<setter>(ChainBuildingParameters_put_CurrentTimeValidationEnabled), nullptr, nullptr },
        { "authority_information_access_enabled", reinterpret_cast<getter>(ChainBuildingParameters_get_AuthorityInformationAccessEnabled), reinterpret_cast<setter>(ChainBuildingParameters_put_AuthorityInformationAccessEnabled), nullptr, nullptr },
        { "enhanced_key_usages", reinterpret_cast<getter>(ChainBuildingParameters_get_EnhancedKeyUsages), nullptr, nullptr, nullptr },
        { "exclusive_trust_roots", reinterpret_cast<getter>(ChainBuildingParameters_get_ExclusiveTrustRoots), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChainBuildingParameters[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChainBuildingParameters) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChainBuildingParameters) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChainBuildingParameters) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChainBuildingParameters) },
        { }
    };

    static PyType_Spec type_spec_ChainBuildingParameters = {
        "winrt._winrt_windows_security_cryptography_certificates.ChainBuildingParameters",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChainBuildingParameters};

    // ----- ChainValidationParameters class --------------------

    static PyObject* _new_ChainValidationParameters(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::ChainValidationParameters instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChainValidationParameters(py::wrapper::Windows::Security::Cryptography::Certificates::ChainValidationParameters* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChainValidationParameters_get_ServerDnsName(py::wrapper::Windows::Security::Cryptography::Certificates::ChainValidationParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.ChainValidationParameters", L"ServerDnsName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerDnsName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChainValidationParameters_put_ServerDnsName(py::wrapper::Windows::Security::Cryptography::Certificates::ChainValidationParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.ChainValidationParameters", L"ServerDnsName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(arg);

            self->obj.ServerDnsName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChainValidationParameters_get_CertificateChainPolicy(py::wrapper::Windows::Security::Cryptography::Certificates::ChainValidationParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.ChainValidationParameters", L"CertificateChainPolicy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CertificateChainPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChainValidationParameters_put_CertificateChainPolicy(py::wrapper::Windows::Security::Cryptography::Certificates::ChainValidationParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.ChainValidationParameters", L"CertificateChainPolicy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::CertificateChainPolicy>(arg);

            self->obj.CertificateChainPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ChainValidationParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::ChainValidationParameters>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChainValidationParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::ChainValidationParameters>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChainValidationParameters[] = {
        { "_assign_array_", _assign_array_ChainValidationParameters, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChainValidationParameters), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChainValidationParameters[] = {
        { "server_dns_name", reinterpret_cast<getter>(ChainValidationParameters_get_ServerDnsName), reinterpret_cast<setter>(ChainValidationParameters_put_ServerDnsName), nullptr, nullptr },
        { "certificate_chain_policy", reinterpret_cast<getter>(ChainValidationParameters_get_CertificateChainPolicy), reinterpret_cast<setter>(ChainValidationParameters_put_CertificateChainPolicy), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChainValidationParameters[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChainValidationParameters) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChainValidationParameters) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChainValidationParameters) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChainValidationParameters) },
        { }
    };

    static PyType_Spec type_spec_ChainValidationParameters = {
        "winrt._winrt_windows_security_cryptography_certificates.ChainValidationParameters",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::ChainValidationParameters),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChainValidationParameters};

    // ----- CmsAttachedSignature class --------------------

    static PyObject* _new_CmsAttachedSignature(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                winrt::Windows::Security::Cryptography::Certificates::CmsAttachedSignature instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CmsAttachedSignature(py::wrapper::Windows::Security::Cryptography::Certificates::CmsAttachedSignature* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CmsAttachedSignature_GenerateSignatureAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CmsAttachedSignature", L"GenerateSignatureAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Security::Cryptography::Certificates::CmsSignerInfo>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Security::Cryptography::Certificates::Certificate>>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CmsAttachedSignature::GenerateSignatureAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CmsAttachedSignature_VerifySignature(py::wrapper::Windows::Security::Cryptography::Certificates::CmsAttachedSignature* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CmsAttachedSignature", L"VerifySignature", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.VerifySignature());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CmsAttachedSignature_get_Certificates(py::wrapper::Windows::Security::Cryptography::Certificates::CmsAttachedSignature* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CmsAttachedSignature", L"Certificates"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Certificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CmsAttachedSignature_get_Content(py::wrapper::Windows::Security::Cryptography::Certificates::CmsAttachedSignature* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CmsAttachedSignature", L"Content"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CmsAttachedSignature_get_Signers(py::wrapper::Windows::Security::Cryptography::Certificates::CmsAttachedSignature* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CmsAttachedSignature", L"Signers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Signers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CmsAttachedSignature(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::CmsAttachedSignature>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CmsAttachedSignature(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CmsAttachedSignature>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CmsAttachedSignature[] = {
        { "verify_signature", reinterpret_cast<PyCFunction>(CmsAttachedSignature_VerifySignature), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CmsAttachedSignature, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CmsAttachedSignature), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CmsAttachedSignature[] = {
        { "certificates", reinterpret_cast<getter>(CmsAttachedSignature_get_Certificates), nullptr, nullptr, nullptr },
        { "content", reinterpret_cast<getter>(CmsAttachedSignature_get_Content), nullptr, nullptr, nullptr },
        { "signers", reinterpret_cast<getter>(CmsAttachedSignature_get_Signers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CmsAttachedSignature[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CmsAttachedSignature) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CmsAttachedSignature) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CmsAttachedSignature) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CmsAttachedSignature) },
        { }
    };

    static PyType_Spec type_spec_CmsAttachedSignature = {
        "winrt._winrt_windows_security_cryptography_certificates.CmsAttachedSignature",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CmsAttachedSignature),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CmsAttachedSignature};

    static PyGetSetDef getset_CmsAttachedSignature_Static[] = {
        { }
    };

    static PyMethodDef methods_CmsAttachedSignature_Static[] = {
        { "generate_signature_async", reinterpret_cast<PyCFunction>(CmsAttachedSignature_GenerateSignatureAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_CmsAttachedSignature_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CmsAttachedSignature_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CmsAttachedSignature_Static) },
        { }
    };

    static PyType_Spec type_spec_CmsAttachedSignature_Static =
    {
        "winrt._winrt_windows_security_cryptography_certificates.CmsAttachedSignature_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CmsAttachedSignature_Static
    };

    // ----- CmsDetachedSignature class --------------------

    static PyObject* _new_CmsDetachedSignature(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                winrt::Windows::Security::Cryptography::Certificates::CmsDetachedSignature instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CmsDetachedSignature(py::wrapper::Windows::Security::Cryptography::Certificates::CmsDetachedSignature* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CmsDetachedSignature_GenerateSignatureAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CmsDetachedSignature", L"GenerateSignatureAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Security::Cryptography::Certificates::CmsSignerInfo>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Security::Cryptography::Certificates::Certificate>>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CmsDetachedSignature::GenerateSignatureAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CmsDetachedSignature_VerifySignatureAsync(py::wrapper::Windows::Security::Cryptography::Certificates::CmsDetachedSignature* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.CmsDetachedSignature", L"VerifySignatureAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                return py::convert(self->obj.VerifySignatureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CmsDetachedSignature_get_Certificates(py::wrapper::Windows::Security::Cryptography::Certificates::CmsDetachedSignature* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CmsDetachedSignature", L"Certificates"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Certificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CmsDetachedSignature_get_Signers(py::wrapper::Windows::Security::Cryptography::Certificates::CmsDetachedSignature* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CmsDetachedSignature", L"Signers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Signers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CmsDetachedSignature(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::CmsDetachedSignature>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CmsDetachedSignature(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CmsDetachedSignature>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CmsDetachedSignature[] = {
        { "verify_signature_async", reinterpret_cast<PyCFunction>(CmsDetachedSignature_VerifySignatureAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CmsDetachedSignature, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CmsDetachedSignature), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CmsDetachedSignature[] = {
        { "certificates", reinterpret_cast<getter>(CmsDetachedSignature_get_Certificates), nullptr, nullptr, nullptr },
        { "signers", reinterpret_cast<getter>(CmsDetachedSignature_get_Signers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CmsDetachedSignature[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CmsDetachedSignature) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CmsDetachedSignature) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CmsDetachedSignature) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CmsDetachedSignature) },
        { }
    };

    static PyType_Spec type_spec_CmsDetachedSignature = {
        "winrt._winrt_windows_security_cryptography_certificates.CmsDetachedSignature",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CmsDetachedSignature),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CmsDetachedSignature};

    static PyGetSetDef getset_CmsDetachedSignature_Static[] = {
        { }
    };

    static PyMethodDef methods_CmsDetachedSignature_Static[] = {
        { "generate_signature_async", reinterpret_cast<PyCFunction>(CmsDetachedSignature_GenerateSignatureAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_CmsDetachedSignature_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CmsDetachedSignature_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CmsDetachedSignature_Static) },
        { }
    };

    static PyType_Spec type_spec_CmsDetachedSignature_Static =
    {
        "winrt._winrt_windows_security_cryptography_certificates.CmsDetachedSignature_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CmsDetachedSignature_Static
    };

    // ----- CmsSignerInfo class --------------------

    static PyObject* _new_CmsSignerInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::CmsSignerInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CmsSignerInfo(py::wrapper::Windows::Security::Cryptography::Certificates::CmsSignerInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CmsSignerInfo_get_HashAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::CmsSignerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CmsSignerInfo", L"HashAlgorithmName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HashAlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CmsSignerInfo_put_HashAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::CmsSignerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CmsSignerInfo", L"HashAlgorithmName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.HashAlgorithmName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CmsSignerInfo_get_Certificate(py::wrapper::Windows::Security::Cryptography::Certificates::CmsSignerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CmsSignerInfo", L"Certificate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Certificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CmsSignerInfo_put_Certificate(py::wrapper::Windows::Security::Cryptography::Certificates::CmsSignerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CmsSignerInfo", L"Certificate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(arg);

            self->obj.Certificate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CmsSignerInfo_get_TimestampInfo(py::wrapper::Windows::Security::Cryptography::Certificates::CmsSignerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CmsSignerInfo", L"TimestampInfo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TimestampInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CmsSignerInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::CmsSignerInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CmsSignerInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CmsSignerInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CmsSignerInfo[] = {
        { "_assign_array_", _assign_array_CmsSignerInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CmsSignerInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CmsSignerInfo[] = {
        { "hash_algorithm_name", reinterpret_cast<getter>(CmsSignerInfo_get_HashAlgorithmName), reinterpret_cast<setter>(CmsSignerInfo_put_HashAlgorithmName), nullptr, nullptr },
        { "certificate", reinterpret_cast<getter>(CmsSignerInfo_get_Certificate), reinterpret_cast<setter>(CmsSignerInfo_put_Certificate), nullptr, nullptr },
        { "timestamp_info", reinterpret_cast<getter>(CmsSignerInfo_get_TimestampInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CmsSignerInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CmsSignerInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CmsSignerInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CmsSignerInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CmsSignerInfo) },
        { }
    };

    static PyType_Spec type_spec_CmsSignerInfo = {
        "winrt._winrt_windows_security_cryptography_certificates.CmsSignerInfo",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CmsSignerInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CmsSignerInfo};

    // ----- CmsTimestampInfo class --------------------

    static PyObject* _new_CmsTimestampInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Cryptography::Certificates::CmsTimestampInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Cryptography::Certificates::CmsTimestampInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_CmsTimestampInfo(py::wrapper::Windows::Security::Cryptography::Certificates::CmsTimestampInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CmsTimestampInfo_get_Certificates(py::wrapper::Windows::Security::Cryptography::Certificates::CmsTimestampInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CmsTimestampInfo", L"Certificates"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Certificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CmsTimestampInfo_get_SigningCertificate(py::wrapper::Windows::Security::Cryptography::Certificates::CmsTimestampInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CmsTimestampInfo", L"SigningCertificate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SigningCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CmsTimestampInfo_get_Timestamp(py::wrapper::Windows::Security::Cryptography::Certificates::CmsTimestampInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.CmsTimestampInfo", L"Timestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CmsTimestampInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::CmsTimestampInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CmsTimestampInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CmsTimestampInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CmsTimestampInfo[] = {
        { "_assign_array_", _assign_array_CmsTimestampInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CmsTimestampInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CmsTimestampInfo[] = {
        { "certificates", reinterpret_cast<getter>(CmsTimestampInfo_get_Certificates), nullptr, nullptr, nullptr },
        { "signing_certificate", reinterpret_cast<getter>(CmsTimestampInfo_get_SigningCertificate), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(CmsTimestampInfo_get_Timestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CmsTimestampInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CmsTimestampInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CmsTimestampInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CmsTimestampInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CmsTimestampInfo) },
        { }
    };

    static PyType_Spec type_spec_CmsTimestampInfo = {
        "winrt._winrt_windows_security_cryptography_certificates.CmsTimestampInfo",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CmsTimestampInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CmsTimestampInfo};

    // ----- KeyAlgorithmNames class --------------------

    static PyObject* _new_KeyAlgorithmNames(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames>::type_name);
        return nullptr;
    }

    static PyObject* KeyAlgorithmNames_get_Dsa(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.KeyAlgorithmNames", L"Dsa"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Dsa());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Ecdh256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.KeyAlgorithmNames", L"Ecdh256"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Ecdh256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Ecdh384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.KeyAlgorithmNames", L"Ecdh384"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Ecdh384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Ecdh521(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.KeyAlgorithmNames", L"Ecdh521"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Ecdh521());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Ecdsa256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.KeyAlgorithmNames", L"Ecdsa256"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Ecdsa256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Ecdsa384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.KeyAlgorithmNames", L"Ecdsa384"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Ecdsa384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Ecdsa521(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.KeyAlgorithmNames", L"Ecdsa521"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Ecdsa521());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Rsa(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.KeyAlgorithmNames", L"Rsa"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Rsa());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Ecdh(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.KeyAlgorithmNames", L"Ecdh"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Ecdh());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Ecdsa(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.KeyAlgorithmNames", L"Ecdsa"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Ecdsa());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyAlgorithmNames[] = {
        { }
    };

    static PyGetSetDef _getset_KeyAlgorithmNames[] = {
        { }
    };

    static PyType_Slot _type_slots_KeyAlgorithmNames[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_KeyAlgorithmNames) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KeyAlgorithmNames) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KeyAlgorithmNames) },
        { }
    };

    static PyType_Spec type_spec_KeyAlgorithmNames = {
        "winrt._winrt_windows_security_cryptography_certificates.KeyAlgorithmNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyAlgorithmNames};

    static PyGetSetDef getset_KeyAlgorithmNames_Static[] = {
        { "dsa", reinterpret_cast<getter>(KeyAlgorithmNames_get_Dsa), nullptr, nullptr, nullptr },
        { "ecdh256", reinterpret_cast<getter>(KeyAlgorithmNames_get_Ecdh256), nullptr, nullptr, nullptr },
        { "ecdh384", reinterpret_cast<getter>(KeyAlgorithmNames_get_Ecdh384), nullptr, nullptr, nullptr },
        { "ecdh521", reinterpret_cast<getter>(KeyAlgorithmNames_get_Ecdh521), nullptr, nullptr, nullptr },
        { "ecdsa256", reinterpret_cast<getter>(KeyAlgorithmNames_get_Ecdsa256), nullptr, nullptr, nullptr },
        { "ecdsa384", reinterpret_cast<getter>(KeyAlgorithmNames_get_Ecdsa384), nullptr, nullptr, nullptr },
        { "ecdsa521", reinterpret_cast<getter>(KeyAlgorithmNames_get_Ecdsa521), nullptr, nullptr, nullptr },
        { "rsa", reinterpret_cast<getter>(KeyAlgorithmNames_get_Rsa), nullptr, nullptr, nullptr },
        { "ecdh", reinterpret_cast<getter>(KeyAlgorithmNames_get_Ecdh), nullptr, nullptr, nullptr },
        { "ecdsa", reinterpret_cast<getter>(KeyAlgorithmNames_get_Ecdsa), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_KeyAlgorithmNames_Static[] = {
        { }
    };

    static PyType_Slot type_slots_KeyAlgorithmNames_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KeyAlgorithmNames_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_KeyAlgorithmNames_Static) },
        { }
    };

    static PyType_Spec type_spec_KeyAlgorithmNames_Static =
    {
        "winrt._winrt_windows_security_cryptography_certificates.KeyAlgorithmNames_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KeyAlgorithmNames_Static
    };

    // ----- KeyAttestationHelper class --------------------

    static PyObject* _new_KeyAttestationHelper(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Cryptography::Certificates::KeyAttestationHelper>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Cryptography::Certificates::KeyAttestationHelper>::type_name);
        return nullptr;
    }

    static PyObject* KeyAttestationHelper_DecryptTpmAttestationCredentialAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.KeyAttestationHelper", L"DecryptTpmAttestationCredentialAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAttestationHelper::DecryptTpmAttestationCredentialAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.KeyAttestationHelper", L"DecryptTpmAttestationCredentialAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAttestationHelper::DecryptTpmAttestationCredentialAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyAttestationHelper_GetTpmAttestationCredentialId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.KeyAttestationHelper", L"GetTpmAttestationCredentialId", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAttestationHelper::GetTpmAttestationCredentialId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyAttestationHelper[] = {
        { }
    };

    static PyGetSetDef _getset_KeyAttestationHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_KeyAttestationHelper[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_KeyAttestationHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KeyAttestationHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KeyAttestationHelper) },
        { }
    };

    static PyType_Spec type_spec_KeyAttestationHelper = {
        "winrt._winrt_windows_security_cryptography_certificates.KeyAttestationHelper",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyAttestationHelper};

    static PyGetSetDef getset_KeyAttestationHelper_Static[] = {
        { }
    };

    static PyMethodDef methods_KeyAttestationHelper_Static[] = {
        { "decrypt_tpm_attestation_credential_async", reinterpret_cast<PyCFunction>(KeyAttestationHelper_DecryptTpmAttestationCredentialAsync), METH_VARARGS, nullptr },
        { "get_tpm_attestation_credential_id", reinterpret_cast<PyCFunction>(KeyAttestationHelper_GetTpmAttestationCredentialId), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_KeyAttestationHelper_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KeyAttestationHelper_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_KeyAttestationHelper_Static) },
        { }
    };

    static PyType_Spec type_spec_KeyAttestationHelper_Static =
    {
        "winrt._winrt_windows_security_cryptography_certificates.KeyAttestationHelper_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KeyAttestationHelper_Static
    };

    // ----- KeyStorageProviderNames class --------------------

    static PyObject* _new_KeyStorageProviderNames(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Cryptography::Certificates::KeyStorageProviderNames>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Cryptography::Certificates::KeyStorageProviderNames>::type_name);
        return nullptr;
    }

    static PyObject* KeyStorageProviderNames_get_PlatformKeyStorageProvider(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.KeyStorageProviderNames", L"PlatformKeyStorageProvider"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyStorageProviderNames::PlatformKeyStorageProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyStorageProviderNames_get_SmartcardKeyStorageProvider(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.KeyStorageProviderNames", L"SmartcardKeyStorageProvider"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyStorageProviderNames::SmartcardKeyStorageProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyStorageProviderNames_get_SoftwareKeyStorageProvider(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.KeyStorageProviderNames", L"SoftwareKeyStorageProvider"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyStorageProviderNames::SoftwareKeyStorageProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyStorageProviderNames_get_PassportKeyStorageProvider(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.KeyStorageProviderNames", L"PassportKeyStorageProvider"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyStorageProviderNames::PassportKeyStorageProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyStorageProviderNames[] = {
        { }
    };

    static PyGetSetDef _getset_KeyStorageProviderNames[] = {
        { }
    };

    static PyType_Slot _type_slots_KeyStorageProviderNames[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_KeyStorageProviderNames) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KeyStorageProviderNames) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KeyStorageProviderNames) },
        { }
    };

    static PyType_Spec type_spec_KeyStorageProviderNames = {
        "winrt._winrt_windows_security_cryptography_certificates.KeyStorageProviderNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyStorageProviderNames};

    static PyGetSetDef getset_KeyStorageProviderNames_Static[] = {
        { "platform_key_storage_provider", reinterpret_cast<getter>(KeyStorageProviderNames_get_PlatformKeyStorageProvider), nullptr, nullptr, nullptr },
        { "smartcard_key_storage_provider", reinterpret_cast<getter>(KeyStorageProviderNames_get_SmartcardKeyStorageProvider), nullptr, nullptr, nullptr },
        { "software_key_storage_provider", reinterpret_cast<getter>(KeyStorageProviderNames_get_SoftwareKeyStorageProvider), nullptr, nullptr, nullptr },
        { "passport_key_storage_provider", reinterpret_cast<getter>(KeyStorageProviderNames_get_PassportKeyStorageProvider), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_KeyStorageProviderNames_Static[] = {
        { }
    };

    static PyType_Slot type_slots_KeyStorageProviderNames_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KeyStorageProviderNames_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_KeyStorageProviderNames_Static) },
        { }
    };

    static PyType_Spec type_spec_KeyStorageProviderNames_Static =
    {
        "winrt._winrt_windows_security_cryptography_certificates.KeyStorageProviderNames_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KeyStorageProviderNames_Static
    };

    // ----- PfxImportParameters class --------------------

    static PyObject* _new_PfxImportParameters(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::PfxImportParameters instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PfxImportParameters(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PfxImportParameters_get_ReaderName(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.PfxImportParameters", L"ReaderName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReaderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PfxImportParameters_put_ReaderName(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.PfxImportParameters", L"ReaderName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ReaderName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PfxImportParameters_get_KeyStorageProviderName(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.PfxImportParameters", L"KeyStorageProviderName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyStorageProviderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PfxImportParameters_put_KeyStorageProviderName(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.PfxImportParameters", L"KeyStorageProviderName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.KeyStorageProviderName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PfxImportParameters_get_KeyProtectionLevel(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.PfxImportParameters", L"KeyProtectionLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyProtectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PfxImportParameters_put_KeyProtectionLevel(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.PfxImportParameters", L"KeyProtectionLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::KeyProtectionLevel>(arg);

            self->obj.KeyProtectionLevel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PfxImportParameters_get_InstallOptions(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.PfxImportParameters", L"InstallOptions"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InstallOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PfxImportParameters_put_InstallOptions(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.PfxImportParameters", L"InstallOptions"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::InstallOptions>(arg);

            self->obj.InstallOptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PfxImportParameters_get_FriendlyName(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.PfxImportParameters", L"FriendlyName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PfxImportParameters_put_FriendlyName(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.PfxImportParameters", L"FriendlyName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FriendlyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PfxImportParameters_get_Exportable(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.PfxImportParameters", L"Exportable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Exportable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PfxImportParameters_put_Exportable(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.PfxImportParameters", L"Exportable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::ExportOption>(arg);

            self->obj.Exportable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PfxImportParameters_get_ContainerNamePrefix(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.PfxImportParameters", L"ContainerNamePrefix"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContainerNamePrefix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PfxImportParameters_put_ContainerNamePrefix(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.PfxImportParameters", L"ContainerNamePrefix"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContainerNamePrefix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PfxImportParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::PfxImportParameters>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PfxImportParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::PfxImportParameters>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PfxImportParameters[] = {
        { "_assign_array_", _assign_array_PfxImportParameters, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PfxImportParameters), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PfxImportParameters[] = {
        { "reader_name", reinterpret_cast<getter>(PfxImportParameters_get_ReaderName), reinterpret_cast<setter>(PfxImportParameters_put_ReaderName), nullptr, nullptr },
        { "key_storage_provider_name", reinterpret_cast<getter>(PfxImportParameters_get_KeyStorageProviderName), reinterpret_cast<setter>(PfxImportParameters_put_KeyStorageProviderName), nullptr, nullptr },
        { "key_protection_level", reinterpret_cast<getter>(PfxImportParameters_get_KeyProtectionLevel), reinterpret_cast<setter>(PfxImportParameters_put_KeyProtectionLevel), nullptr, nullptr },
        { "install_options", reinterpret_cast<getter>(PfxImportParameters_get_InstallOptions), reinterpret_cast<setter>(PfxImportParameters_put_InstallOptions), nullptr, nullptr },
        { "friendly_name", reinterpret_cast<getter>(PfxImportParameters_get_FriendlyName), reinterpret_cast<setter>(PfxImportParameters_put_FriendlyName), nullptr, nullptr },
        { "exportable", reinterpret_cast<getter>(PfxImportParameters_get_Exportable), reinterpret_cast<setter>(PfxImportParameters_put_Exportable), nullptr, nullptr },
        { "container_name_prefix", reinterpret_cast<getter>(PfxImportParameters_get_ContainerNamePrefix), reinterpret_cast<setter>(PfxImportParameters_put_ContainerNamePrefix), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PfxImportParameters[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PfxImportParameters) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PfxImportParameters) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PfxImportParameters) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PfxImportParameters) },
        { }
    };

    static PyType_Spec type_spec_PfxImportParameters = {
        "winrt._winrt_windows_security_cryptography_certificates.PfxImportParameters",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PfxImportParameters};

    // ----- StandardCertificateStoreNames class --------------------

    static PyObject* _new_StandardCertificateStoreNames(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Cryptography::Certificates::StandardCertificateStoreNames>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Cryptography::Certificates::StandardCertificateStoreNames>::type_name);
        return nullptr;
    }

    static PyObject* StandardCertificateStoreNames_get_IntermediateCertificationAuthorities(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.StandardCertificateStoreNames", L"IntermediateCertificationAuthorities"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Certificates::StandardCertificateStoreNames::IntermediateCertificationAuthorities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StandardCertificateStoreNames_get_Personal(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.StandardCertificateStoreNames", L"Personal"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Certificates::StandardCertificateStoreNames::Personal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StandardCertificateStoreNames_get_TrustedRootCertificationAuthorities(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.StandardCertificateStoreNames", L"TrustedRootCertificationAuthorities"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Certificates::StandardCertificateStoreNames::TrustedRootCertificationAuthorities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StandardCertificateStoreNames[] = {
        { }
    };

    static PyGetSetDef _getset_StandardCertificateStoreNames[] = {
        { }
    };

    static PyType_Slot _type_slots_StandardCertificateStoreNames[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StandardCertificateStoreNames) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StandardCertificateStoreNames) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StandardCertificateStoreNames) },
        { }
    };

    static PyType_Spec type_spec_StandardCertificateStoreNames = {
        "winrt._winrt_windows_security_cryptography_certificates.StandardCertificateStoreNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StandardCertificateStoreNames};

    static PyGetSetDef getset_StandardCertificateStoreNames_Static[] = {
        { "intermediate_certification_authorities", reinterpret_cast<getter>(StandardCertificateStoreNames_get_IntermediateCertificationAuthorities), nullptr, nullptr, nullptr },
        { "personal", reinterpret_cast<getter>(StandardCertificateStoreNames_get_Personal), nullptr, nullptr, nullptr },
        { "trusted_root_certification_authorities", reinterpret_cast<getter>(StandardCertificateStoreNames_get_TrustedRootCertificationAuthorities), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_StandardCertificateStoreNames_Static[] = {
        { }
    };

    static PyType_Slot type_slots_StandardCertificateStoreNames_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_StandardCertificateStoreNames_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_StandardCertificateStoreNames_Static) },
        { }
    };

    static PyType_Spec type_spec_StandardCertificateStoreNames_Static =
    {
        "winrt._winrt_windows_security_cryptography_certificates.StandardCertificateStoreNames_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_StandardCertificateStoreNames_Static
    };

    // ----- SubjectAlternativeNameInfo class --------------------

    static PyObject* _new_SubjectAlternativeNameInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SubjectAlternativeNameInfo(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SubjectAlternativeNameInfo_get_DistinguishedName(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo", L"DistinguishedName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DistinguishedName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_DnsName(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo", L"DnsName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DnsName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_EmailName(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo", L"EmailName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EmailName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_IPAddress(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo", L"IPAddress"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IPAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_PrincipalName(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo", L"PrincipalName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PrincipalName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_Url(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo", L"Url"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Url());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_DistinguishedNames(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo", L"DistinguishedNames"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DistinguishedNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_DnsNames(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo", L"DnsNames"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DnsNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_EmailNames(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo", L"EmailNames"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EmailNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_Extension(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo", L"Extension"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Extension());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_IPAddresses(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo", L"IPAddresses"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IPAddresses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_PrincipalNames(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo", L"PrincipalNames"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PrincipalNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_Urls(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo", L"Urls"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Urls());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SubjectAlternativeNameInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SubjectAlternativeNameInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SubjectAlternativeNameInfo[] = {
        { "_assign_array_", _assign_array_SubjectAlternativeNameInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SubjectAlternativeNameInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SubjectAlternativeNameInfo[] = {
        { "distinguished_name", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_DistinguishedName), nullptr, nullptr, nullptr },
        { "dns_name", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_DnsName), nullptr, nullptr, nullptr },
        { "email_name", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_EmailName), nullptr, nullptr, nullptr },
        { "ip_address", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_IPAddress), nullptr, nullptr, nullptr },
        { "principal_name", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_PrincipalName), nullptr, nullptr, nullptr },
        { "url", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_Url), nullptr, nullptr, nullptr },
        { "distinguished_names", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_DistinguishedNames), nullptr, nullptr, nullptr },
        { "dns_names", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_DnsNames), nullptr, nullptr, nullptr },
        { "email_names", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_EmailNames), nullptr, nullptr, nullptr },
        { "extension", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_Extension), nullptr, nullptr, nullptr },
        { "ip_addresses", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_IPAddresses), nullptr, nullptr, nullptr },
        { "principal_names", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_PrincipalNames), nullptr, nullptr, nullptr },
        { "urls", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_Urls), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SubjectAlternativeNameInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SubjectAlternativeNameInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SubjectAlternativeNameInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SubjectAlternativeNameInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SubjectAlternativeNameInfo) },
        { }
    };

    static PyType_Spec type_spec_SubjectAlternativeNameInfo = {
        "winrt._winrt_windows_security_cryptography_certificates.SubjectAlternativeNameInfo",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SubjectAlternativeNameInfo};

    // ----- UserCertificateEnrollmentManager class --------------------

    static PyObject* _new_UserCertificateEnrollmentManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager>::type_name);
        return nullptr;
    }

    static void _dealloc_UserCertificateEnrollmentManager(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UserCertificateEnrollmentManager_CreateRequestAsync(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.UserCertificateEnrollmentManager", L"CreateRequestAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::CertificateRequestProperties>(args, 0);

                return py::convert(self->obj.CreateRequestAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserCertificateEnrollmentManager_ImportPfxDataAsync(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.UserCertificateEnrollmentManager", L"ImportPfxDataAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::PfxImportParameters>(args, 2);

                return py::convert(self->obj.ImportPfxDataAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 6)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.UserCertificateEnrollmentManager", L"ImportPfxDataAsync", 6))
                {
                    py::set_arg_count_version_error(6);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::ExportOption>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::KeyProtectionLevel>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::InstallOptions>(args, 4);
                auto param5 = py::convert_to<winrt::hstring>(args, 5);

                return py::convert(self->obj.ImportPfxDataAsync(param0, param1, param2, param3, param4, param5));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 7)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.UserCertificateEnrollmentManager", L"ImportPfxDataAsync", 7))
                {
                    py::set_arg_count_version_error(7);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::ExportOption>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::KeyProtectionLevel>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::InstallOptions>(args, 4);
                auto param5 = py::convert_to<winrt::hstring>(args, 5);
                auto param6 = py::convert_to<winrt::hstring>(args, 6);

                return py::convert(self->obj.ImportPfxDataAsync(param0, param1, param2, param3, param4, param5, param6));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserCertificateEnrollmentManager_InstallCertificateAsync(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.UserCertificateEnrollmentManager", L"InstallCertificateAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::InstallOptions>(args, 1);

                return py::convert(self->obj.InstallCertificateAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_UserCertificateEnrollmentManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UserCertificateEnrollmentManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserCertificateEnrollmentManager[] = {
        { "create_request_async", reinterpret_cast<PyCFunction>(UserCertificateEnrollmentManager_CreateRequestAsync), METH_VARARGS, nullptr },
        { "import_pfx_data_async", reinterpret_cast<PyCFunction>(UserCertificateEnrollmentManager_ImportPfxDataAsync), METH_VARARGS, nullptr },
        { "install_certificate_async", reinterpret_cast<PyCFunction>(UserCertificateEnrollmentManager_InstallCertificateAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_UserCertificateEnrollmentManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UserCertificateEnrollmentManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UserCertificateEnrollmentManager[] = {
        { }
    };

    static PyType_Slot _type_slots_UserCertificateEnrollmentManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_UserCertificateEnrollmentManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UserCertificateEnrollmentManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UserCertificateEnrollmentManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UserCertificateEnrollmentManager) },
        { }
    };

    static PyType_Spec type_spec_UserCertificateEnrollmentManager = {
        "winrt._winrt_windows_security_cryptography_certificates.UserCertificateEnrollmentManager",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserCertificateEnrollmentManager};

    // ----- UserCertificateStore class --------------------

    static PyObject* _new_UserCertificateStore(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Cryptography::Certificates::UserCertificateStore>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Cryptography::Certificates::UserCertificateStore>::type_name);
        return nullptr;
    }

    static void _dealloc_UserCertificateStore(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateStore* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UserCertificateStore_RequestAddAsync(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.UserCertificateStore", L"RequestAddAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(args, 0);

                return py::convert(self->obj.RequestAddAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserCertificateStore_RequestDeleteAsync(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Certificates.UserCertificateStore", L"RequestDeleteAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(args, 0);

                return py::convert(self->obj.RequestDeleteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserCertificateStore_get_Name(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateStore* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Certificates.UserCertificateStore", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UserCertificateStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Certificates::UserCertificateStore>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UserCertificateStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::UserCertificateStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserCertificateStore[] = {
        { "request_add_async", reinterpret_cast<PyCFunction>(UserCertificateStore_RequestAddAsync), METH_VARARGS, nullptr },
        { "request_delete_async", reinterpret_cast<PyCFunction>(UserCertificateStore_RequestDeleteAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_UserCertificateStore, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UserCertificateStore), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UserCertificateStore[] = {
        { "name", reinterpret_cast<getter>(UserCertificateStore_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UserCertificateStore[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_UserCertificateStore) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UserCertificateStore) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UserCertificateStore) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UserCertificateStore) },
        { }
    };

    static PyType_Spec type_spec_UserCertificateStore = {
        "winrt._winrt_windows_security_cryptography_certificates.UserCertificateStore",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserCertificateStore};

    // ----- Windows.Security.Cryptography.Certificates Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Security.Cryptography.Certificates");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_security_cryptography_certificates",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Security::Cryptography::Certificates

PyMODINIT_FUNC PyInit__winrt_windows_security_cryptography_certificates(void) noexcept
{
    using namespace py::cpp::Windows::Security::Cryptography::Certificates;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Certificate, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CertificateChain, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_CertificateEnrollmentManager_Static{PyType_FromSpec(&type_spec_CertificateEnrollmentManager_Static)};
    if (!type_CertificateEnrollmentManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CertificateEnrollmentManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CertificateEnrollmentManager_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CertificateExtension, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CertificateKeyUsages, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CertificateQuery, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CertificateRequestProperties, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CertificateStore, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_CertificateStores_Static{PyType_FromSpec(&type_spec_CertificateStores_Static)};
    if (!type_CertificateStores_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CertificateStores, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CertificateStores_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ChainBuildingParameters, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ChainValidationParameters, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_CmsAttachedSignature_Static{PyType_FromSpec(&type_spec_CmsAttachedSignature_Static)};
    if (!type_CmsAttachedSignature_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CmsAttachedSignature, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CmsAttachedSignature_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_CmsDetachedSignature_Static{PyType_FromSpec(&type_spec_CmsDetachedSignature_Static)};
    if (!type_CmsDetachedSignature_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CmsDetachedSignature, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CmsDetachedSignature_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CmsSignerInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CmsTimestampInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_KeyAlgorithmNames_Static{PyType_FromSpec(&type_spec_KeyAlgorithmNames_Static)};
    if (!type_KeyAlgorithmNames_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_KeyAlgorithmNames, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KeyAlgorithmNames_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_KeyAttestationHelper_Static{PyType_FromSpec(&type_spec_KeyAttestationHelper_Static)};
    if (!type_KeyAttestationHelper_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_KeyAttestationHelper, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KeyAttestationHelper_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_KeyStorageProviderNames_Static{PyType_FromSpec(&type_spec_KeyStorageProviderNames_Static)};
    if (!type_KeyStorageProviderNames_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_KeyStorageProviderNames, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KeyStorageProviderNames_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PfxImportParameters, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_StandardCertificateStoreNames_Static{PyType_FromSpec(&type_spec_StandardCertificateStoreNames_Static)};
    if (!type_StandardCertificateStoreNames_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StandardCertificateStoreNames, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_StandardCertificateStoreNames_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SubjectAlternativeNameInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UserCertificateEnrollmentManager, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UserCertificateStore, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
