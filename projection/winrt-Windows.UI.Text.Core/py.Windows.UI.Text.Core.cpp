// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.1

#include "py.Windows.UI.Text.Core.h"


namespace py::cpp::Windows::UI::Text::Core
{
    // ----- CoreTextCompositionCompletedEventArgs class --------------------

    static PyObject* _new_CoreTextCompositionCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::Core::CoreTextCompositionCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::Core::CoreTextCompositionCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreTextCompositionCompletedEventArgs(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextCompositionCompletedEventArgs_GetDeferral(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionCompletedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextCompositionCompletedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextCompositionCompletedEventArgs_get_CompositionSegments(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextCompositionCompletedEventArgs", L"CompositionSegments"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CompositionSegments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextCompositionCompletedEventArgs_get_IsCanceled(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextCompositionCompletedEventArgs", L"IsCanceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCanceled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextCompositionCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextCompositionCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextCompositionCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextCompositionCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextCompositionCompletedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreTextCompositionCompletedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreTextCompositionCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextCompositionCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreTextCompositionCompletedEventArgs[] = {
        { "composition_segments", reinterpret_cast<getter>(CoreTextCompositionCompletedEventArgs_get_CompositionSegments), nullptr, nullptr, nullptr },
        { "is_canceled", reinterpret_cast<getter>(CoreTextCompositionCompletedEventArgs_get_IsCanceled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreTextCompositionCompletedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextCompositionCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextCompositionCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextCompositionCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextCompositionCompletedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreTextCompositionCompletedEventArgs =
    {
        "winrt._winrt_windows_ui_text_core.CoreTextCompositionCompletedEventArgs",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextCompositionCompletedEventArgs
    };

    // ----- CoreTextCompositionSegment class --------------------

    static PyObject* _new_CoreTextCompositionSegment(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::Core::CoreTextCompositionSegment>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::Core::CoreTextCompositionSegment>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreTextCompositionSegment(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionSegment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextCompositionSegment_get_PreconversionString(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionSegment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextCompositionSegment", L"PreconversionString"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreconversionString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextCompositionSegment_get_Range(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionSegment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextCompositionSegment", L"Range"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Range());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextCompositionSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextCompositionSegment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextCompositionSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextCompositionSegment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextCompositionSegment[] = {
        { "_assign_array_", _assign_array_CoreTextCompositionSegment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextCompositionSegment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreTextCompositionSegment[] = {
        { "preconversion_string", reinterpret_cast<getter>(CoreTextCompositionSegment_get_PreconversionString), nullptr, nullptr, nullptr },
        { "range", reinterpret_cast<getter>(CoreTextCompositionSegment_get_Range), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreTextCompositionSegment[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextCompositionSegment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextCompositionSegment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextCompositionSegment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextCompositionSegment) },
        { },
    };

    static PyType_Spec type_spec_CoreTextCompositionSegment =
    {
        "winrt._winrt_windows_ui_text_core.CoreTextCompositionSegment",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionSegment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextCompositionSegment
    };

    // ----- CoreTextCompositionStartedEventArgs class --------------------

    static PyObject* _new_CoreTextCompositionStartedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::Core::CoreTextCompositionStartedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::Core::CoreTextCompositionStartedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreTextCompositionStartedEventArgs(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionStartedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextCompositionStartedEventArgs_GetDeferral(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionStartedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextCompositionStartedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextCompositionStartedEventArgs_get_IsCanceled(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionStartedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextCompositionStartedEventArgs", L"IsCanceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCanceled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextCompositionStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextCompositionStartedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextCompositionStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextCompositionStartedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextCompositionStartedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreTextCompositionStartedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreTextCompositionStartedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextCompositionStartedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreTextCompositionStartedEventArgs[] = {
        { "is_canceled", reinterpret_cast<getter>(CoreTextCompositionStartedEventArgs_get_IsCanceled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreTextCompositionStartedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextCompositionStartedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextCompositionStartedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextCompositionStartedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextCompositionStartedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreTextCompositionStartedEventArgs =
    {
        "winrt._winrt_windows_ui_text_core.CoreTextCompositionStartedEventArgs",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionStartedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextCompositionStartedEventArgs
    };

    // ----- CoreTextEditContext class --------------------

    static PyObject* _new_CoreTextEditContext(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::Core::CoreTextEditContext>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::Core::CoreTextEditContext>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreTextEditContext(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextEditContext_NotifyFocusEnter(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"NotifyFocusEnter", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.NotifyFocusEnter();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_NotifyFocusLeave(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"NotifyFocusLeave", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.NotifyFocusLeave();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_NotifyLayoutChanged(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"NotifyLayoutChanged", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.NotifyLayoutChanged();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_NotifySelectionChanged(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"NotifySelectionChanged", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::Core::CoreTextRange>(args, 0);

                self->obj.NotifySelectionChanged(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_NotifyTextChanged(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"NotifyTextChanged", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::Core::CoreTextRange>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Text::Core::CoreTextRange>(args, 2);

                self->obj.NotifyTextChanged(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_get_Name(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextEditContext_put_Name(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreTextEditContext_get_IsReadOnly(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"IsReadOnly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextEditContext_put_IsReadOnly(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"IsReadOnly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsReadOnly(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreTextEditContext_get_InputScope(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"InputScope"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InputScope());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextEditContext_put_InputScope(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"InputScope"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::Core::CoreTextInputScope>(arg);

            self->obj.InputScope(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreTextEditContext_get_InputPaneDisplayPolicy(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"InputPaneDisplayPolicy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InputPaneDisplayPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextEditContext_put_InputPaneDisplayPolicy(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"InputPaneDisplayPolicy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::Core::CoreTextInputPaneDisplayPolicy>(arg);

            self->obj.InputPaneDisplayPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreTextEditContext_add_CompositionCompleted(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"CompositionCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Text::Core::CoreTextEditContext, winrt::Windows::UI::Text::Core::CoreTextCompositionCompletedEventArgs>>(arg);

            return py::convert(self->obj.CompositionCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_remove_CompositionCompleted(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"CompositionCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CompositionCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_add_CompositionStarted(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"CompositionStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Text::Core::CoreTextEditContext, winrt::Windows::UI::Text::Core::CoreTextCompositionStartedEventArgs>>(arg);

            return py::convert(self->obj.CompositionStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_remove_CompositionStarted(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"CompositionStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CompositionStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_add_FocusRemoved(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"FocusRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Text::Core::CoreTextEditContext, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.FocusRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_remove_FocusRemoved(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"FocusRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FocusRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_add_FormatUpdating(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"FormatUpdating"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Text::Core::CoreTextEditContext, winrt::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs>>(arg);

            return py::convert(self->obj.FormatUpdating(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_remove_FormatUpdating(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"FormatUpdating"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FormatUpdating(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_add_LayoutRequested(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"LayoutRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Text::Core::CoreTextEditContext, winrt::Windows::UI::Text::Core::CoreTextLayoutRequestedEventArgs>>(arg);

            return py::convert(self->obj.LayoutRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_remove_LayoutRequested(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"LayoutRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LayoutRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_add_SelectionRequested(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"SelectionRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Text::Core::CoreTextEditContext, winrt::Windows::UI::Text::Core::CoreTextSelectionRequestedEventArgs>>(arg);

            return py::convert(self->obj.SelectionRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_remove_SelectionRequested(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"SelectionRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SelectionRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_add_SelectionUpdating(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"SelectionUpdating"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Text::Core::CoreTextEditContext, winrt::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs>>(arg);

            return py::convert(self->obj.SelectionUpdating(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_remove_SelectionUpdating(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"SelectionUpdating"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SelectionUpdating(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_add_TextRequested(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"TextRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Text::Core::CoreTextEditContext, winrt::Windows::UI::Text::Core::CoreTextTextRequestedEventArgs>>(arg);

            return py::convert(self->obj.TextRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_remove_TextRequested(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"TextRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TextRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_add_TextUpdating(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"TextUpdating"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Text::Core::CoreTextEditContext, winrt::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs>>(arg);

            return py::convert(self->obj.TextUpdating(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_remove_TextUpdating(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"TextUpdating"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TextUpdating(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_add_NotifyFocusLeaveCompleted(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"NotifyFocusLeaveCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Text::Core::CoreTextEditContext, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.NotifyFocusLeaveCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_remove_NotifyFocusLeaveCompleted(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"NotifyFocusLeaveCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NotifyFocusLeaveCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextEditContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextEditContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextEditContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextEditContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextEditContext[] = {
        { "notify_focus_enter", reinterpret_cast<PyCFunction>(CoreTextEditContext_NotifyFocusEnter), METH_VARARGS, nullptr },
        { "notify_focus_leave", reinterpret_cast<PyCFunction>(CoreTextEditContext_NotifyFocusLeave), METH_VARARGS, nullptr },
        { "notify_layout_changed", reinterpret_cast<PyCFunction>(CoreTextEditContext_NotifyLayoutChanged), METH_VARARGS, nullptr },
        { "notify_selection_changed", reinterpret_cast<PyCFunction>(CoreTextEditContext_NotifySelectionChanged), METH_VARARGS, nullptr },
        { "notify_text_changed", reinterpret_cast<PyCFunction>(CoreTextEditContext_NotifyTextChanged), METH_VARARGS, nullptr },
        { "add_composition_completed", reinterpret_cast<PyCFunction>(CoreTextEditContext_add_CompositionCompleted), METH_O, nullptr },
        { "remove_composition_completed", reinterpret_cast<PyCFunction>(CoreTextEditContext_remove_CompositionCompleted), METH_O, nullptr },
        { "add_composition_started", reinterpret_cast<PyCFunction>(CoreTextEditContext_add_CompositionStarted), METH_O, nullptr },
        { "remove_composition_started", reinterpret_cast<PyCFunction>(CoreTextEditContext_remove_CompositionStarted), METH_O, nullptr },
        { "add_focus_removed", reinterpret_cast<PyCFunction>(CoreTextEditContext_add_FocusRemoved), METH_O, nullptr },
        { "remove_focus_removed", reinterpret_cast<PyCFunction>(CoreTextEditContext_remove_FocusRemoved), METH_O, nullptr },
        { "add_format_updating", reinterpret_cast<PyCFunction>(CoreTextEditContext_add_FormatUpdating), METH_O, nullptr },
        { "remove_format_updating", reinterpret_cast<PyCFunction>(CoreTextEditContext_remove_FormatUpdating), METH_O, nullptr },
        { "add_layout_requested", reinterpret_cast<PyCFunction>(CoreTextEditContext_add_LayoutRequested), METH_O, nullptr },
        { "remove_layout_requested", reinterpret_cast<PyCFunction>(CoreTextEditContext_remove_LayoutRequested), METH_O, nullptr },
        { "add_selection_requested", reinterpret_cast<PyCFunction>(CoreTextEditContext_add_SelectionRequested), METH_O, nullptr },
        { "remove_selection_requested", reinterpret_cast<PyCFunction>(CoreTextEditContext_remove_SelectionRequested), METH_O, nullptr },
        { "add_selection_updating", reinterpret_cast<PyCFunction>(CoreTextEditContext_add_SelectionUpdating), METH_O, nullptr },
        { "remove_selection_updating", reinterpret_cast<PyCFunction>(CoreTextEditContext_remove_SelectionUpdating), METH_O, nullptr },
        { "add_text_requested", reinterpret_cast<PyCFunction>(CoreTextEditContext_add_TextRequested), METH_O, nullptr },
        { "remove_text_requested", reinterpret_cast<PyCFunction>(CoreTextEditContext_remove_TextRequested), METH_O, nullptr },
        { "add_text_updating", reinterpret_cast<PyCFunction>(CoreTextEditContext_add_TextUpdating), METH_O, nullptr },
        { "remove_text_updating", reinterpret_cast<PyCFunction>(CoreTextEditContext_remove_TextUpdating), METH_O, nullptr },
        { "add_notify_focus_leave_completed", reinterpret_cast<PyCFunction>(CoreTextEditContext_add_NotifyFocusLeaveCompleted), METH_O, nullptr },
        { "remove_notify_focus_leave_completed", reinterpret_cast<PyCFunction>(CoreTextEditContext_remove_NotifyFocusLeaveCompleted), METH_O, nullptr },
        { "_assign_array_", _assign_array_CoreTextEditContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextEditContext), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreTextEditContext[] = {
        { "name", reinterpret_cast<getter>(CoreTextEditContext_get_Name), reinterpret_cast<setter>(CoreTextEditContext_put_Name), nullptr, nullptr },
        { "is_read_only", reinterpret_cast<getter>(CoreTextEditContext_get_IsReadOnly), reinterpret_cast<setter>(CoreTextEditContext_put_IsReadOnly), nullptr, nullptr },
        { "input_scope", reinterpret_cast<getter>(CoreTextEditContext_get_InputScope), reinterpret_cast<setter>(CoreTextEditContext_put_InputScope), nullptr, nullptr },
        { "input_pane_display_policy", reinterpret_cast<getter>(CoreTextEditContext_get_InputPaneDisplayPolicy), reinterpret_cast<setter>(CoreTextEditContext_put_InputPaneDisplayPolicy), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreTextEditContext[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextEditContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextEditContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextEditContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextEditContext) },
        { },
    };

    static PyType_Spec type_spec_CoreTextEditContext =
    {
        "winrt._winrt_windows_ui_text_core.CoreTextEditContext",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextEditContext
    };

    // ----- CoreTextFormatUpdatingEventArgs class --------------------

    static PyObject* _new_CoreTextFormatUpdatingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreTextFormatUpdatingEventArgs(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextFormatUpdatingEventArgs_GetDeferral(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextFormatUpdatingEventArgs_get_Result(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs", L"Result"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Result());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextFormatUpdatingEventArgs_put_Result(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs", L"Result"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::Core::CoreTextFormatUpdatingResult>(arg);

            self->obj.Result(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreTextFormatUpdatingEventArgs_get_BackgroundColor(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs", L"BackgroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextFormatUpdatingEventArgs_get_IsCanceled(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs", L"IsCanceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCanceled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextFormatUpdatingEventArgs_get_Range(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs", L"Range"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Range());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextFormatUpdatingEventArgs_get_Reason(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs", L"Reason"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextFormatUpdatingEventArgs_get_TextColor(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs", L"TextColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TextColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextFormatUpdatingEventArgs_get_UnderlineColor(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs", L"UnderlineColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UnderlineColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextFormatUpdatingEventArgs_get_UnderlineType(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs", L"UnderlineType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UnderlineType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextFormatUpdatingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextFormatUpdatingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextFormatUpdatingEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreTextFormatUpdatingEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreTextFormatUpdatingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextFormatUpdatingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreTextFormatUpdatingEventArgs[] = {
        { "result", reinterpret_cast<getter>(CoreTextFormatUpdatingEventArgs_get_Result), reinterpret_cast<setter>(CoreTextFormatUpdatingEventArgs_put_Result), nullptr, nullptr },
        { "background_color", reinterpret_cast<getter>(CoreTextFormatUpdatingEventArgs_get_BackgroundColor), nullptr, nullptr, nullptr },
        { "is_canceled", reinterpret_cast<getter>(CoreTextFormatUpdatingEventArgs_get_IsCanceled), nullptr, nullptr, nullptr },
        { "range", reinterpret_cast<getter>(CoreTextFormatUpdatingEventArgs_get_Range), nullptr, nullptr, nullptr },
        { "reason", reinterpret_cast<getter>(CoreTextFormatUpdatingEventArgs_get_Reason), nullptr, nullptr, nullptr },
        { "text_color", reinterpret_cast<getter>(CoreTextFormatUpdatingEventArgs_get_TextColor), nullptr, nullptr, nullptr },
        { "underline_color", reinterpret_cast<getter>(CoreTextFormatUpdatingEventArgs_get_UnderlineColor), nullptr, nullptr, nullptr },
        { "underline_type", reinterpret_cast<getter>(CoreTextFormatUpdatingEventArgs_get_UnderlineType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreTextFormatUpdatingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextFormatUpdatingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextFormatUpdatingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextFormatUpdatingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextFormatUpdatingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreTextFormatUpdatingEventArgs =
    {
        "winrt._winrt_windows_ui_text_core.CoreTextFormatUpdatingEventArgs",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextFormatUpdatingEventArgs
    };

    // ----- CoreTextLayoutBounds class --------------------

    static PyObject* _new_CoreTextLayoutBounds(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::Core::CoreTextLayoutBounds>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::Core::CoreTextLayoutBounds>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreTextLayoutBounds(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutBounds* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextLayoutBounds_get_TextBounds(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutBounds* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextLayoutBounds", L"TextBounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TextBounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextLayoutBounds_put_TextBounds(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutBounds* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextLayoutBounds", L"TextBounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            self->obj.TextBounds(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreTextLayoutBounds_get_ControlBounds(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutBounds* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextLayoutBounds", L"ControlBounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ControlBounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextLayoutBounds_put_ControlBounds(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutBounds* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextLayoutBounds", L"ControlBounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            self->obj.ControlBounds(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CoreTextLayoutBounds(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextLayoutBounds>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextLayoutBounds(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextLayoutBounds>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextLayoutBounds[] = {
        { "_assign_array_", _assign_array_CoreTextLayoutBounds, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextLayoutBounds), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreTextLayoutBounds[] = {
        { "text_bounds", reinterpret_cast<getter>(CoreTextLayoutBounds_get_TextBounds), reinterpret_cast<setter>(CoreTextLayoutBounds_put_TextBounds), nullptr, nullptr },
        { "control_bounds", reinterpret_cast<getter>(CoreTextLayoutBounds_get_ControlBounds), reinterpret_cast<setter>(CoreTextLayoutBounds_put_ControlBounds), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreTextLayoutBounds[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextLayoutBounds) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextLayoutBounds) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextLayoutBounds) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextLayoutBounds) },
        { },
    };

    static PyType_Spec type_spec_CoreTextLayoutBounds =
    {
        "winrt._winrt_windows_ui_text_core.CoreTextLayoutBounds",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutBounds),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextLayoutBounds
    };

    // ----- CoreTextLayoutRequest class --------------------

    static PyObject* _new_CoreTextLayoutRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::Core::CoreTextLayoutRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::Core::CoreTextLayoutRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreTextLayoutRequest(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextLayoutRequest_GetDeferral(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextLayoutRequest", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextLayoutRequest_get_IsCanceled(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextLayoutRequest", L"IsCanceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCanceled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextLayoutRequest_get_LayoutBounds(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextLayoutRequest", L"LayoutBounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LayoutBounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextLayoutRequest_get_Range(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextLayoutRequest", L"Range"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Range());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextLayoutRequest_get_LayoutBoundsVisualPixels(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextLayoutRequest", L"LayoutBoundsVisualPixels"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LayoutBoundsVisualPixels());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextLayoutRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextLayoutRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextLayoutRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextLayoutRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextLayoutRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreTextLayoutRequest_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreTextLayoutRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextLayoutRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreTextLayoutRequest[] = {
        { "is_canceled", reinterpret_cast<getter>(CoreTextLayoutRequest_get_IsCanceled), nullptr, nullptr, nullptr },
        { "layout_bounds", reinterpret_cast<getter>(CoreTextLayoutRequest_get_LayoutBounds), nullptr, nullptr, nullptr },
        { "range", reinterpret_cast<getter>(CoreTextLayoutRequest_get_Range), nullptr, nullptr, nullptr },
        { "layout_bounds_visual_pixels", reinterpret_cast<getter>(CoreTextLayoutRequest_get_LayoutBoundsVisualPixels), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreTextLayoutRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextLayoutRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextLayoutRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextLayoutRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextLayoutRequest) },
        { },
    };

    static PyType_Spec type_spec_CoreTextLayoutRequest =
    {
        "winrt._winrt_windows_ui_text_core.CoreTextLayoutRequest",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextLayoutRequest
    };

    // ----- CoreTextLayoutRequestedEventArgs class --------------------

    static PyObject* _new_CoreTextLayoutRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::Core::CoreTextLayoutRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::Core::CoreTextLayoutRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreTextLayoutRequestedEventArgs(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextLayoutRequestedEventArgs_get_Request(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextLayoutRequestedEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextLayoutRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextLayoutRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextLayoutRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextLayoutRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextLayoutRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_CoreTextLayoutRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextLayoutRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreTextLayoutRequestedEventArgs[] = {
        { "request", reinterpret_cast<getter>(CoreTextLayoutRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreTextLayoutRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextLayoutRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextLayoutRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextLayoutRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextLayoutRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreTextLayoutRequestedEventArgs =
    {
        "winrt._winrt_windows_ui_text_core.CoreTextLayoutRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextLayoutRequestedEventArgs
    };

    // ----- CoreTextSelectionRequest class --------------------

    static PyObject* _new_CoreTextSelectionRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::Core::CoreTextSelectionRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::Core::CoreTextSelectionRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreTextSelectionRequest(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextSelectionRequest_GetDeferral(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextSelectionRequest", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextSelectionRequest_get_Selection(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextSelectionRequest", L"Selection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Selection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextSelectionRequest_put_Selection(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextSelectionRequest", L"Selection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::Core::CoreTextRange>(arg);

            self->obj.Selection(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreTextSelectionRequest_get_IsCanceled(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextSelectionRequest", L"IsCanceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCanceled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextSelectionRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextSelectionRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextSelectionRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextSelectionRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextSelectionRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreTextSelectionRequest_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreTextSelectionRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextSelectionRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreTextSelectionRequest[] = {
        { "selection", reinterpret_cast<getter>(CoreTextSelectionRequest_get_Selection), reinterpret_cast<setter>(CoreTextSelectionRequest_put_Selection), nullptr, nullptr },
        { "is_canceled", reinterpret_cast<getter>(CoreTextSelectionRequest_get_IsCanceled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreTextSelectionRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextSelectionRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextSelectionRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextSelectionRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextSelectionRequest) },
        { },
    };

    static PyType_Spec type_spec_CoreTextSelectionRequest =
    {
        "winrt._winrt_windows_ui_text_core.CoreTextSelectionRequest",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextSelectionRequest
    };

    // ----- CoreTextSelectionRequestedEventArgs class --------------------

    static PyObject* _new_CoreTextSelectionRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::Core::CoreTextSelectionRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::Core::CoreTextSelectionRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreTextSelectionRequestedEventArgs(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextSelectionRequestedEventArgs_get_Request(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextSelectionRequestedEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextSelectionRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextSelectionRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextSelectionRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextSelectionRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextSelectionRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_CoreTextSelectionRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextSelectionRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreTextSelectionRequestedEventArgs[] = {
        { "request", reinterpret_cast<getter>(CoreTextSelectionRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreTextSelectionRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextSelectionRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextSelectionRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextSelectionRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextSelectionRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreTextSelectionRequestedEventArgs =
    {
        "winrt._winrt_windows_ui_text_core.CoreTextSelectionRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextSelectionRequestedEventArgs
    };

    // ----- CoreTextSelectionUpdatingEventArgs class --------------------

    static PyObject* _new_CoreTextSelectionUpdatingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreTextSelectionUpdatingEventArgs(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextSelectionUpdatingEventArgs_GetDeferral(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextSelectionUpdatingEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextSelectionUpdatingEventArgs_get_Result(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextSelectionUpdatingEventArgs", L"Result"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Result());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextSelectionUpdatingEventArgs_put_Result(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextSelectionUpdatingEventArgs", L"Result"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::Core::CoreTextSelectionUpdatingResult>(arg);

            self->obj.Result(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreTextSelectionUpdatingEventArgs_get_IsCanceled(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextSelectionUpdatingEventArgs", L"IsCanceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCanceled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextSelectionUpdatingEventArgs_get_Selection(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextSelectionUpdatingEventArgs", L"Selection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Selection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextSelectionUpdatingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextSelectionUpdatingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextSelectionUpdatingEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreTextSelectionUpdatingEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreTextSelectionUpdatingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextSelectionUpdatingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreTextSelectionUpdatingEventArgs[] = {
        { "result", reinterpret_cast<getter>(CoreTextSelectionUpdatingEventArgs_get_Result), reinterpret_cast<setter>(CoreTextSelectionUpdatingEventArgs_put_Result), nullptr, nullptr },
        { "is_canceled", reinterpret_cast<getter>(CoreTextSelectionUpdatingEventArgs_get_IsCanceled), nullptr, nullptr, nullptr },
        { "selection", reinterpret_cast<getter>(CoreTextSelectionUpdatingEventArgs_get_Selection), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreTextSelectionUpdatingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextSelectionUpdatingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextSelectionUpdatingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextSelectionUpdatingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextSelectionUpdatingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreTextSelectionUpdatingEventArgs =
    {
        "winrt._winrt_windows_ui_text_core.CoreTextSelectionUpdatingEventArgs",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextSelectionUpdatingEventArgs
    };

    // ----- CoreTextServicesConstants class --------------------

    static PyObject* _new_CoreTextServicesConstants(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::Core::CoreTextServicesConstants>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::Core::CoreTextServicesConstants>::type_name);
        return nullptr;
    }

    static PyObject* CoreTextServicesConstants_get_HiddenCharacter(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextServicesConstants", L"HiddenCharacter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Text::Core::CoreTextServicesConstants::HiddenCharacter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextServicesConstants[] = {
        { }
    };

    static PyGetSetDef _getset_CoreTextServicesConstants[] = {
        { }
    };

    static PyType_Slot _type_slots_CoreTextServicesConstants[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextServicesConstants) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextServicesConstants) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextServicesConstants) },
        { },
    };

    static PyType_Spec type_spec_CoreTextServicesConstants =
    {
        "winrt._winrt_windows_ui_text_core.CoreTextServicesConstants",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextServicesConstants
    };

    static PyGetSetDef getset_CoreTextServicesConstants_Static[] = {
        { "hidden_character", reinterpret_cast<getter>(CoreTextServicesConstants_get_HiddenCharacter), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_CoreTextServicesConstants_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CoreTextServicesConstants_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CoreTextServicesConstants_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CoreTextServicesConstants_Static) },
        { }
    };

    static PyType_Spec type_spec_CoreTextServicesConstants_Static =
    {
        "winrt._winrt_windows_ui_text_core.CoreTextServicesConstants_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CoreTextServicesConstants_Static
    };

    // ----- CoreTextServicesManager class --------------------

    static PyObject* _new_CoreTextServicesManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::Core::CoreTextServicesManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::Core::CoreTextServicesManager>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreTextServicesManager(py::wrapper::Windows::UI::Text::Core::CoreTextServicesManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextServicesManager_CreateEditContext(py::wrapper::Windows::UI::Text::Core::CoreTextServicesManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextServicesManager", L"CreateEditContext", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateEditContext());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextServicesManager_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextServicesManager", L"GetForCurrentView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::Text::Core::CoreTextServicesManager::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextServicesManager_get_InputLanguage(py::wrapper::Windows::UI::Text::Core::CoreTextServicesManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextServicesManager", L"InputLanguage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InputLanguage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextServicesManager_add_InputLanguageChanged(py::wrapper::Windows::UI::Text::Core::CoreTextServicesManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextServicesManager", L"InputLanguageChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Text::Core::CoreTextServicesManager, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.InputLanguageChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextServicesManager_remove_InputLanguageChanged(py::wrapper::Windows::UI::Text::Core::CoreTextServicesManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextServicesManager", L"InputLanguageChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.InputLanguageChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextServicesManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextServicesManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextServicesManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextServicesManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextServicesManager[] = {
        { "create_edit_context", reinterpret_cast<PyCFunction>(CoreTextServicesManager_CreateEditContext), METH_VARARGS, nullptr },
        { "add_input_language_changed", reinterpret_cast<PyCFunction>(CoreTextServicesManager_add_InputLanguageChanged), METH_O, nullptr },
        { "remove_input_language_changed", reinterpret_cast<PyCFunction>(CoreTextServicesManager_remove_InputLanguageChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_CoreTextServicesManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextServicesManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreTextServicesManager[] = {
        { "input_language", reinterpret_cast<getter>(CoreTextServicesManager_get_InputLanguage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreTextServicesManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextServicesManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextServicesManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextServicesManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextServicesManager) },
        { },
    };

    static PyType_Spec type_spec_CoreTextServicesManager =
    {
        "winrt._winrt_windows_ui_text_core.CoreTextServicesManager",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextServicesManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextServicesManager
    };

    static PyGetSetDef getset_CoreTextServicesManager_Static[] = {
        { }
    };

    static PyMethodDef methods_CoreTextServicesManager_Static[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(CoreTextServicesManager_GetForCurrentView), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_CoreTextServicesManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CoreTextServicesManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CoreTextServicesManager_Static) },
        { }
    };

    static PyType_Spec type_spec_CoreTextServicesManager_Static =
    {
        "winrt._winrt_windows_ui_text_core.CoreTextServicesManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CoreTextServicesManager_Static
    };

    // ----- CoreTextTextRequest class --------------------

    static PyObject* _new_CoreTextTextRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::Core::CoreTextTextRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::Core::CoreTextTextRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreTextTextRequest(py::wrapper::Windows::UI::Text::Core::CoreTextTextRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextTextRequest_GetDeferral(py::wrapper::Windows::UI::Text::Core::CoreTextTextRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextTextRequest", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextTextRequest_get_Text(py::wrapper::Windows::UI::Text::Core::CoreTextTextRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextRequest", L"Text"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextTextRequest_put_Text(py::wrapper::Windows::UI::Text::Core::CoreTextTextRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextRequest", L"Text"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreTextTextRequest_get_IsCanceled(py::wrapper::Windows::UI::Text::Core::CoreTextTextRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextRequest", L"IsCanceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCanceled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextTextRequest_get_Range(py::wrapper::Windows::UI::Text::Core::CoreTextTextRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextRequest", L"Range"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Range());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextTextRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextTextRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextTextRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextTextRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextTextRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreTextTextRequest_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreTextTextRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextTextRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreTextTextRequest[] = {
        { "text", reinterpret_cast<getter>(CoreTextTextRequest_get_Text), reinterpret_cast<setter>(CoreTextTextRequest_put_Text), nullptr, nullptr },
        { "is_canceled", reinterpret_cast<getter>(CoreTextTextRequest_get_IsCanceled), nullptr, nullptr, nullptr },
        { "range", reinterpret_cast<getter>(CoreTextTextRequest_get_Range), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreTextTextRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextTextRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextTextRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextTextRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextTextRequest) },
        { },
    };

    static PyType_Spec type_spec_CoreTextTextRequest =
    {
        "winrt._winrt_windows_ui_text_core.CoreTextTextRequest",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextTextRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextTextRequest
    };

    // ----- CoreTextTextRequestedEventArgs class --------------------

    static PyObject* _new_CoreTextTextRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::Core::CoreTextTextRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::Core::CoreTextTextRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreTextTextRequestedEventArgs(py::wrapper::Windows::UI::Text::Core::CoreTextTextRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextTextRequestedEventArgs_get_Request(py::wrapper::Windows::UI::Text::Core::CoreTextTextRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextRequestedEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextTextRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextTextRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextTextRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextTextRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextTextRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_CoreTextTextRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextTextRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreTextTextRequestedEventArgs[] = {
        { "request", reinterpret_cast<getter>(CoreTextTextRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreTextTextRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextTextRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextTextRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextTextRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextTextRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreTextTextRequestedEventArgs =
    {
        "winrt._winrt_windows_ui_text_core.CoreTextTextRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextTextRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextTextRequestedEventArgs
    };

    // ----- CoreTextTextUpdatingEventArgs class --------------------

    static PyObject* _new_CoreTextTextUpdatingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreTextTextUpdatingEventArgs(py::wrapper::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextTextUpdatingEventArgs_GetDeferral(py::wrapper::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextTextUpdatingEventArgs_get_Result(py::wrapper::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs", L"Result"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Result());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextTextUpdatingEventArgs_put_Result(py::wrapper::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs", L"Result"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::Core::CoreTextTextUpdatingResult>(arg);

            self->obj.Result(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreTextTextUpdatingEventArgs_get_InputLanguage(py::wrapper::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs", L"InputLanguage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InputLanguage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextTextUpdatingEventArgs_get_IsCanceled(py::wrapper::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs", L"IsCanceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCanceled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextTextUpdatingEventArgs_get_NewSelection(py::wrapper::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs", L"NewSelection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NewSelection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextTextUpdatingEventArgs_get_Range(py::wrapper::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs", L"Range"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Range());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextTextUpdatingEventArgs_get_Text(py::wrapper::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs", L"Text"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextTextUpdatingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextTextUpdatingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextTextUpdatingEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreTextTextUpdatingEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreTextTextUpdatingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextTextUpdatingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreTextTextUpdatingEventArgs[] = {
        { "result", reinterpret_cast<getter>(CoreTextTextUpdatingEventArgs_get_Result), reinterpret_cast<setter>(CoreTextTextUpdatingEventArgs_put_Result), nullptr, nullptr },
        { "input_language", reinterpret_cast<getter>(CoreTextTextUpdatingEventArgs_get_InputLanguage), nullptr, nullptr, nullptr },
        { "is_canceled", reinterpret_cast<getter>(CoreTextTextUpdatingEventArgs_get_IsCanceled), nullptr, nullptr, nullptr },
        { "new_selection", reinterpret_cast<getter>(CoreTextTextUpdatingEventArgs_get_NewSelection), nullptr, nullptr, nullptr },
        { "range", reinterpret_cast<getter>(CoreTextTextUpdatingEventArgs_get_Range), nullptr, nullptr, nullptr },
        { "text", reinterpret_cast<getter>(CoreTextTextUpdatingEventArgs_get_Text), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreTextTextUpdatingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextTextUpdatingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextTextUpdatingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextTextUpdatingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextTextUpdatingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreTextTextUpdatingEventArgs =
    {
        "winrt._winrt_windows_ui_text_core.CoreTextTextUpdatingEventArgs",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextTextUpdatingEventArgs
    };

    // ----- CoreTextRange struct --------------------

    winrt_struct_wrapper<winrt::Windows::UI::Text::Core::CoreTextRange>* _new_CoreTextRange(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::UI::Text::Core::CoreTextRange>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_CoreTextRange(winrt_struct_wrapper<winrt::Windows::UI::Text::Core::CoreTextRange>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        int32_t _StartCaretPosition{};
        int32_t _EndCaretPosition{};

        static const char* kwlist[] = {"start_caret_position", "end_caret_position", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ii", const_cast<char**>(kwlist), &_StartCaretPosition, &_EndCaretPosition))
        {
            return -1;
        }

        try
        {
            self->obj = {_StartCaretPosition, _EndCaretPosition};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_CoreTextRange(py::wrapper::Windows::UI::Text::Core::CoreTextRange* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CoreTextRange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextRange>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_CoreTextRange[] = {
        { "_assign_array_", _assign_array_CoreTextRange, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* CoreTextRange_get_StartCaretPosition(py::wrapper::Windows::UI::Text::Core::CoreTextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartCaretPosition);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextRange_set_StartCaretPosition(py::wrapper::Windows::UI::Text::Core::CoreTextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.StartCaretPosition = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreTextRange_get_EndCaretPosition(py::wrapper::Windows::UI::Text::Core::CoreTextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndCaretPosition);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextRange_set_EndCaretPosition(py::wrapper::Windows::UI::Text::Core::CoreTextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.EndCaretPosition = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_CoreTextRange[] = {
        { "start_caret_position", reinterpret_cast<getter>(CoreTextRange_get_StartCaretPosition), reinterpret_cast<setter>(CoreTextRange_set_StartCaretPosition), nullptr, nullptr },
        { "end_caret_position", reinterpret_cast<getter>(CoreTextRange_get_EndCaretPosition), reinterpret_cast<setter>(CoreTextRange_set_EndCaretPosition), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreTextRange[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextRange) },
        { Py_tp_init, reinterpret_cast<void*>(_init_CoreTextRange) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextRange) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextRange) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextRange) },
        { },
    };

    static PyType_Spec type_spec_CoreTextRange =
    {
        "winrt._winrt_windows_ui_text_core.CoreTextRange",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextRange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextRange
    };

    // ----- Windows.UI.Text.Core Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::UI::Text::Core");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_ui_text_core",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::UI::Text::Core

PyMODINIT_FUNC PyInit__winrt_windows_ui_text_core(void) noexcept
{
    using namespace py::cpp::Windows::UI::Text::Core;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreTextCompositionCompletedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreTextCompositionSegment, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreTextCompositionStartedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreTextEditContext, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreTextFormatUpdatingEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreTextLayoutBounds, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreTextLayoutRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreTextLayoutRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreTextSelectionRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreTextSelectionRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreTextSelectionUpdatingEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_CoreTextServicesConstants_Static{PyType_FromSpec(&type_spec_CoreTextServicesConstants_Static)};
    if (!type_CoreTextServicesConstants_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreTextServicesConstants, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CoreTextServicesConstants_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_CoreTextServicesManager_Static{PyType_FromSpec(&type_spec_CoreTextServicesManager_Static)};
    if (!type_CoreTextServicesManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreTextServicesManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CoreTextServicesManager_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreTextTextRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreTextTextRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreTextTextUpdatingEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreTextRange, nullptr, nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
