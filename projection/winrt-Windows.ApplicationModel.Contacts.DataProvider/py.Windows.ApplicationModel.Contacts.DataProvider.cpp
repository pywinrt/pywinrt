// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

#include "py.Windows.ApplicationModel.Contacts.DataProvider.h"


namespace py::cpp::Windows::ApplicationModel::Contacts::DataProvider
{
    // ----- ContactDataProviderConnection class --------------------

    static PyObject* _new_ContactDataProviderConnection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactDataProviderConnection(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactDataProviderConnection_Start(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactDataProviderConnection", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactDataProviderConnection_add_ServerSearchReadBatchRequested(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactDataProviderConnection", L"ServerSearchReadBatchRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection, winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequestEventArgs>>(arg);

            return py::convert(self->obj.ServerSearchReadBatchRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactDataProviderConnection_remove_ServerSearchReadBatchRequested(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactDataProviderConnection", L"ServerSearchReadBatchRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ServerSearchReadBatchRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactDataProviderConnection_add_SyncRequested(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactDataProviderConnection", L"SyncRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection, winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequestEventArgs>>(arg);

            return py::convert(self->obj.SyncRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactDataProviderConnection_remove_SyncRequested(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactDataProviderConnection", L"SyncRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SyncRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactDataProviderConnection_add_CreateOrUpdateContactRequested(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactDataProviderConnection", L"CreateOrUpdateContactRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection, winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequestEventArgs>>(arg);

            return py::convert(self->obj.CreateOrUpdateContactRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactDataProviderConnection_remove_CreateOrUpdateContactRequested(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactDataProviderConnection", L"CreateOrUpdateContactRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CreateOrUpdateContactRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactDataProviderConnection_add_DeleteContactRequested(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactDataProviderConnection", L"DeleteContactRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection, winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequestEventArgs>>(arg);

            return py::convert(self->obj.DeleteContactRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactDataProviderConnection_remove_DeleteContactRequested(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactDataProviderConnection", L"DeleteContactRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DeleteContactRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactDataProviderConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactDataProviderConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactDataProviderConnection[] = {
        { "start", reinterpret_cast<PyCFunction>(ContactDataProviderConnection_Start), METH_VARARGS, nullptr },
        { "add_server_search_read_batch_requested", reinterpret_cast<PyCFunction>(ContactDataProviderConnection_add_ServerSearchReadBatchRequested), METH_O, nullptr },
        { "remove_server_search_read_batch_requested", reinterpret_cast<PyCFunction>(ContactDataProviderConnection_remove_ServerSearchReadBatchRequested), METH_O, nullptr },
        { "add_sync_requested", reinterpret_cast<PyCFunction>(ContactDataProviderConnection_add_SyncRequested), METH_O, nullptr },
        { "remove_sync_requested", reinterpret_cast<PyCFunction>(ContactDataProviderConnection_remove_SyncRequested), METH_O, nullptr },
        { "add_create_or_update_contact_requested", reinterpret_cast<PyCFunction>(ContactDataProviderConnection_add_CreateOrUpdateContactRequested), METH_O, nullptr },
        { "remove_create_or_update_contact_requested", reinterpret_cast<PyCFunction>(ContactDataProviderConnection_remove_CreateOrUpdateContactRequested), METH_O, nullptr },
        { "add_delete_contact_requested", reinterpret_cast<PyCFunction>(ContactDataProviderConnection_add_DeleteContactRequested), METH_O, nullptr },
        { "remove_delete_contact_requested", reinterpret_cast<PyCFunction>(ContactDataProviderConnection_remove_DeleteContactRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_ContactDataProviderConnection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactDataProviderConnection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactDataProviderConnection[] = {
        { }
    };

    static PyType_Slot _type_slots_ContactDataProviderConnection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactDataProviderConnection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactDataProviderConnection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactDataProviderConnection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactDataProviderConnection) },
        { },
    };

    static PyType_Spec type_spec_ContactDataProviderConnection =
    {
        "winrt._winrt_windows_applicationmodel_contacts_dataprovider.ContactDataProviderConnection",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactDataProviderConnection
    };

    // ----- ContactDataProviderTriggerDetails class --------------------

    static PyObject* _new_ContactDataProviderTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactDataProviderTriggerDetails(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactDataProviderTriggerDetails_get_Connection(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactDataProviderTriggerDetails", L"Connection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Connection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactDataProviderTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactDataProviderTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactDataProviderTriggerDetails[] = {
        { "_assign_array_", _assign_array_ContactDataProviderTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactDataProviderTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactDataProviderTriggerDetails[] = {
        { "connection", reinterpret_cast<getter>(ContactDataProviderTriggerDetails_get_Connection), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactDataProviderTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactDataProviderTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactDataProviderTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactDataProviderTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactDataProviderTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_ContactDataProviderTriggerDetails =
    {
        "winrt._winrt_windows_applicationmodel_contacts_dataprovider.ContactDataProviderTriggerDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactDataProviderTriggerDetails
    };

    // ----- ContactListCreateOrUpdateContactRequest class --------------------

    static PyObject* _new_ContactListCreateOrUpdateContactRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactListCreateOrUpdateContactRequest(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactListCreateOrUpdateContactRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListCreateOrUpdateContactRequest", L"ReportCompletedAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                return py::convert(self->obj.ReportCompletedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactListCreateOrUpdateContactRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListCreateOrUpdateContactRequest", L"ReportFailedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportFailedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactListCreateOrUpdateContactRequest_get_Contact(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListCreateOrUpdateContactRequest", L"Contact"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactListCreateOrUpdateContactRequest_get_ContactListId(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListCreateOrUpdateContactRequest", L"ContactListId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContactListId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactListCreateOrUpdateContactRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactListCreateOrUpdateContactRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactListCreateOrUpdateContactRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(ContactListCreateOrUpdateContactRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(ContactListCreateOrUpdateContactRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactListCreateOrUpdateContactRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactListCreateOrUpdateContactRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactListCreateOrUpdateContactRequest[] = {
        { "contact", reinterpret_cast<getter>(ContactListCreateOrUpdateContactRequest_get_Contact), nullptr, nullptr, nullptr },
        { "contact_list_id", reinterpret_cast<getter>(ContactListCreateOrUpdateContactRequest_get_ContactListId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactListCreateOrUpdateContactRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactListCreateOrUpdateContactRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactListCreateOrUpdateContactRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactListCreateOrUpdateContactRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactListCreateOrUpdateContactRequest) },
        { },
    };

    static PyType_Spec type_spec_ContactListCreateOrUpdateContactRequest =
    {
        "winrt._winrt_windows_applicationmodel_contacts_dataprovider.ContactListCreateOrUpdateContactRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactListCreateOrUpdateContactRequest
    };

    // ----- ContactListCreateOrUpdateContactRequestEventArgs class --------------------

    static PyObject* _new_ContactListCreateOrUpdateContactRequestEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequestEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequestEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactListCreateOrUpdateContactRequestEventArgs(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactListCreateOrUpdateContactRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListCreateOrUpdateContactRequestEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactListCreateOrUpdateContactRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequestEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListCreateOrUpdateContactRequestEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactListCreateOrUpdateContactRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactListCreateOrUpdateContactRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactListCreateOrUpdateContactRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(ContactListCreateOrUpdateContactRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactListCreateOrUpdateContactRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactListCreateOrUpdateContactRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactListCreateOrUpdateContactRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(ContactListCreateOrUpdateContactRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactListCreateOrUpdateContactRequestEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactListCreateOrUpdateContactRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactListCreateOrUpdateContactRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactListCreateOrUpdateContactRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactListCreateOrUpdateContactRequestEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ContactListCreateOrUpdateContactRequestEventArgs =
    {
        "winrt._winrt_windows_applicationmodel_contacts_dataprovider.ContactListCreateOrUpdateContactRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactListCreateOrUpdateContactRequestEventArgs
    };

    // ----- ContactListDeleteContactRequest class --------------------

    static PyObject* _new_ContactListDeleteContactRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactListDeleteContactRequest(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactListDeleteContactRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListDeleteContactRequest", L"ReportCompletedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportCompletedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactListDeleteContactRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListDeleteContactRequest", L"ReportFailedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportFailedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactListDeleteContactRequest_get_ContactId(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListDeleteContactRequest", L"ContactId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContactId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactListDeleteContactRequest_get_ContactListId(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListDeleteContactRequest", L"ContactListId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContactListId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactListDeleteContactRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactListDeleteContactRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactListDeleteContactRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(ContactListDeleteContactRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(ContactListDeleteContactRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactListDeleteContactRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactListDeleteContactRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactListDeleteContactRequest[] = {
        { "contact_id", reinterpret_cast<getter>(ContactListDeleteContactRequest_get_ContactId), nullptr, nullptr, nullptr },
        { "contact_list_id", reinterpret_cast<getter>(ContactListDeleteContactRequest_get_ContactListId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactListDeleteContactRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactListDeleteContactRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactListDeleteContactRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactListDeleteContactRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactListDeleteContactRequest) },
        { },
    };

    static PyType_Spec type_spec_ContactListDeleteContactRequest =
    {
        "winrt._winrt_windows_applicationmodel_contacts_dataprovider.ContactListDeleteContactRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactListDeleteContactRequest
    };

    // ----- ContactListDeleteContactRequestEventArgs class --------------------

    static PyObject* _new_ContactListDeleteContactRequestEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequestEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequestEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactListDeleteContactRequestEventArgs(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactListDeleteContactRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListDeleteContactRequestEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactListDeleteContactRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequestEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListDeleteContactRequestEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactListDeleteContactRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactListDeleteContactRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactListDeleteContactRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(ContactListDeleteContactRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactListDeleteContactRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactListDeleteContactRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactListDeleteContactRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(ContactListDeleteContactRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactListDeleteContactRequestEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactListDeleteContactRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactListDeleteContactRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactListDeleteContactRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactListDeleteContactRequestEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ContactListDeleteContactRequestEventArgs =
    {
        "winrt._winrt_windows_applicationmodel_contacts_dataprovider.ContactListDeleteContactRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactListDeleteContactRequestEventArgs
    };

    // ----- ContactListServerSearchReadBatchRequest class --------------------

    static PyObject* _new_ContactListServerSearchReadBatchRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactListServerSearchReadBatchRequest(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactListServerSearchReadBatchRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListServerSearchReadBatchRequest", L"ReportCompletedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportCompletedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactListServerSearchReadBatchRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListServerSearchReadBatchRequest", L"ReportFailedAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactBatchStatus>(args, 0);

                return py::convert(self->obj.ReportFailedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactListServerSearchReadBatchRequest_SaveContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListServerSearchReadBatchRequest", L"SaveContactAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                return py::convert(self->obj.SaveContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactListServerSearchReadBatchRequest_get_ContactListId(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListServerSearchReadBatchRequest", L"ContactListId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContactListId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactListServerSearchReadBatchRequest_get_Options(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListServerSearchReadBatchRequest", L"Options"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Options());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactListServerSearchReadBatchRequest_get_SessionId(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListServerSearchReadBatchRequest", L"SessionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SessionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactListServerSearchReadBatchRequest_get_SuggestedBatchSize(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListServerSearchReadBatchRequest", L"SuggestedBatchSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SuggestedBatchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactListServerSearchReadBatchRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactListServerSearchReadBatchRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactListServerSearchReadBatchRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(ContactListServerSearchReadBatchRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(ContactListServerSearchReadBatchRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "save_contact_async", reinterpret_cast<PyCFunction>(ContactListServerSearchReadBatchRequest_SaveContactAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactListServerSearchReadBatchRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactListServerSearchReadBatchRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactListServerSearchReadBatchRequest[] = {
        { "contact_list_id", reinterpret_cast<getter>(ContactListServerSearchReadBatchRequest_get_ContactListId), nullptr, nullptr, nullptr },
        { "options", reinterpret_cast<getter>(ContactListServerSearchReadBatchRequest_get_Options), nullptr, nullptr, nullptr },
        { "session_id", reinterpret_cast<getter>(ContactListServerSearchReadBatchRequest_get_SessionId), nullptr, nullptr, nullptr },
        { "suggested_batch_size", reinterpret_cast<getter>(ContactListServerSearchReadBatchRequest_get_SuggestedBatchSize), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactListServerSearchReadBatchRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactListServerSearchReadBatchRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactListServerSearchReadBatchRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactListServerSearchReadBatchRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactListServerSearchReadBatchRequest) },
        { },
    };

    static PyType_Spec type_spec_ContactListServerSearchReadBatchRequest =
    {
        "winrt._winrt_windows_applicationmodel_contacts_dataprovider.ContactListServerSearchReadBatchRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactListServerSearchReadBatchRequest
    };

    // ----- ContactListServerSearchReadBatchRequestEventArgs class --------------------

    static PyObject* _new_ContactListServerSearchReadBatchRequestEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequestEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequestEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactListServerSearchReadBatchRequestEventArgs(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactListServerSearchReadBatchRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListServerSearchReadBatchRequestEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactListServerSearchReadBatchRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequestEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListServerSearchReadBatchRequestEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactListServerSearchReadBatchRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactListServerSearchReadBatchRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactListServerSearchReadBatchRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(ContactListServerSearchReadBatchRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactListServerSearchReadBatchRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactListServerSearchReadBatchRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactListServerSearchReadBatchRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(ContactListServerSearchReadBatchRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactListServerSearchReadBatchRequestEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactListServerSearchReadBatchRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactListServerSearchReadBatchRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactListServerSearchReadBatchRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactListServerSearchReadBatchRequestEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ContactListServerSearchReadBatchRequestEventArgs =
    {
        "winrt._winrt_windows_applicationmodel_contacts_dataprovider.ContactListServerSearchReadBatchRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactListServerSearchReadBatchRequestEventArgs
    };

    // ----- ContactListSyncManagerSyncRequest class --------------------

    static PyObject* _new_ContactListSyncManagerSyncRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactListSyncManagerSyncRequest(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactListSyncManagerSyncRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListSyncManagerSyncRequest", L"ReportCompletedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportCompletedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactListSyncManagerSyncRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListSyncManagerSyncRequest", L"ReportFailedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportFailedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactListSyncManagerSyncRequest_get_ContactListId(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListSyncManagerSyncRequest", L"ContactListId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContactListId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactListSyncManagerSyncRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactListSyncManagerSyncRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactListSyncManagerSyncRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(ContactListSyncManagerSyncRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(ContactListSyncManagerSyncRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactListSyncManagerSyncRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactListSyncManagerSyncRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactListSyncManagerSyncRequest[] = {
        { "contact_list_id", reinterpret_cast<getter>(ContactListSyncManagerSyncRequest_get_ContactListId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactListSyncManagerSyncRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactListSyncManagerSyncRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactListSyncManagerSyncRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactListSyncManagerSyncRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactListSyncManagerSyncRequest) },
        { },
    };

    static PyType_Spec type_spec_ContactListSyncManagerSyncRequest =
    {
        "winrt._winrt_windows_applicationmodel_contacts_dataprovider.ContactListSyncManagerSyncRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactListSyncManagerSyncRequest
    };

    // ----- ContactListSyncManagerSyncRequestEventArgs class --------------------

    static PyObject* _new_ContactListSyncManagerSyncRequestEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequestEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequestEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactListSyncManagerSyncRequestEventArgs(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactListSyncManagerSyncRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListSyncManagerSyncRequestEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactListSyncManagerSyncRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequestEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListSyncManagerSyncRequestEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactListSyncManagerSyncRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactListSyncManagerSyncRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactListSyncManagerSyncRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(ContactListSyncManagerSyncRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactListSyncManagerSyncRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactListSyncManagerSyncRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactListSyncManagerSyncRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(ContactListSyncManagerSyncRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactListSyncManagerSyncRequestEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactListSyncManagerSyncRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactListSyncManagerSyncRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactListSyncManagerSyncRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactListSyncManagerSyncRequestEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ContactListSyncManagerSyncRequestEventArgs =
    {
        "winrt._winrt_windows_applicationmodel_contacts_dataprovider.ContactListSyncManagerSyncRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactListSyncManagerSyncRequestEventArgs
    };

    // ----- Windows.ApplicationModel.Contacts.DataProvider Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::ApplicationModel::Contacts::DataProvider");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_applicationmodel_contacts_dataprovider",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::ApplicationModel::Contacts::DataProvider

PyMODINIT_FUNC PyInit__winrt_windows_applicationmodel_contacts_dataprovider(void) noexcept
{
    using namespace py::cpp::Windows::ApplicationModel::Contacts::DataProvider;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactDataProviderConnection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactDataProviderTriggerDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactListCreateOrUpdateContactRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactListCreateOrUpdateContactRequestEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactListDeleteContactRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactListDeleteContactRequestEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactListServerSearchReadBatchRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactListServerSearchReadBatchRequestEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactListSyncManagerSyncRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactListSyncManagerSyncRequestEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
