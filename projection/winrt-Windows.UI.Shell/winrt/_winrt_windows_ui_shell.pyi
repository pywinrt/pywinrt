# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.applicationmodel.core
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.graphics.imaging
import winrt.windows.storage.streams
import winrt.windows.ui
import winrt.windows.ui.startscreen

from winrt.windows.ui.shell import SecurityAppKind, SecurityAppState, SecurityAppSubstatus, ShareWindowCommand

Self = typing.TypeVar('Self')

@typing.final
class AdaptiveCardBuilder_Static(type):
    def create_adaptive_card_from_json(cls, value: str, /) -> typing.Optional[IAdaptiveCard]: ...

@typing.final
class AdaptiveCardBuilder(winrt.system.Object, metaclass=AdaptiveCardBuilder_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AdaptiveCardBuilder: ...

@typing.final
class FocusSession(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FocusSession: ...
    def end(self) -> None: ...
    @_property
    def id(self) -> str: ...

@typing.final
class FocusSessionManager_Static(type):
    def get_default(cls) -> typing.Optional[FocusSessionManager]: ...
    @_property
    def is_supported(cls) -> bool: ...

@typing.final
class FocusSessionManager(winrt.system.Object, metaclass=FocusSessionManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FocusSessionManager: ...
    def deactivate_focus(self) -> None: ...
    def get_session(self, id: str, /) -> typing.Optional[FocusSession]: ...
    @typing.overload
    def try_start_focus_session(self) -> typing.Optional[FocusSession]: ...
    @typing.overload
    def try_start_focus_session(self, end_time: datetime.datetime, /) -> typing.Optional[FocusSession]: ...
    def add_is_focus_active_changed(self, handler: winrt.windows.foundation.TypedEventHandler[FocusSessionManager, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_is_focus_active_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def is_focus_active(self) -> bool: ...

@typing.final
class SecurityAppManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SecurityAppManager: ...
    def __new__(cls: typing.Type[SecurityAppManager]) -> SecurityAppManager:...
    def register(self, kind: SecurityAppKind, display_name: str, details_uri: typing.Optional[winrt.windows.foundation.Uri], register_per_user: bool, /) -> _uuid.UUID: ...
    def unregister(self, kind: SecurityAppKind, guid_registration: _uuid.UUID, /) -> None: ...
    def update_state(self, kind: SecurityAppKind, guid_registration: _uuid.UUID, state: SecurityAppState, substatus: SecurityAppSubstatus, details_uri: typing.Optional[winrt.windows.foundation.Uri], /) -> None: ...

@typing.final
class ShareWindowCommandEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ShareWindowCommandEventArgs: ...
    @_property
    def command(self) -> ShareWindowCommand: ...
    @command.setter
    def command(self, value: ShareWindowCommand) -> None: ...
    @_property
    def window_id(self) -> winrt.windows.ui.WindowId: ...

@typing.final
class ShareWindowCommandSource_Static(type):
    def get_for_current_view(cls) -> typing.Optional[ShareWindowCommandSource]: ...

@typing.final
class ShareWindowCommandSource(winrt.system.Object, metaclass=ShareWindowCommandSource_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ShareWindowCommandSource: ...
    def report_command_changed(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_command_invoked(self, handler: winrt.windows.foundation.TypedEventHandler[ShareWindowCommandSource, ShareWindowCommandEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_command_invoked(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_command_requested(self, handler: winrt.windows.foundation.TypedEventHandler[ShareWindowCommandSource, ShareWindowCommandEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_command_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

@typing.final
class TaskbarManager_Static(type):
    def get_default(cls) -> typing.Optional[TaskbarManager]: ...

@typing.final
class TaskbarManager(winrt.system.Object, metaclass=TaskbarManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TaskbarManager: ...
    def is_app_list_entry_pinned_async(self, app_list_entry: typing.Optional[winrt.windows.applicationmodel.core.AppListEntry], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def is_current_app_pinned_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def is_secondary_tile_pinned_async(self, tile_id: str, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def request_pin_app_list_entry_async(self, app_list_entry: typing.Optional[winrt.windows.applicationmodel.core.AppListEntry], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def request_pin_current_app_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def request_pin_secondary_tile_async(self, secondary_tile: typing.Optional[winrt.windows.ui.startscreen.SecondaryTile], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def try_unpin_secondary_tile_async(self, tile_id: str, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @_property
    def is_pinning_allowed(self) -> bool: ...
    @_property
    def is_supported(self) -> bool: ...

@typing.final
class WindowTab(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WindowTab: ...
    def __new__(cls: typing.Type[WindowTab]) -> WindowTab:...
    def report_thumbnail_available(self) -> None: ...
    @_property
    def treat_as_secondary_tile_id(self) -> str: ...
    @treat_as_secondary_tile_id.setter
    def treat_as_secondary_tile_id(self, value: str) -> None: ...
    @_property
    def title(self) -> str: ...
    @title.setter
    def title(self, value: str) -> None: ...
    @_property
    def tag(self) -> typing.Optional[winrt.system.Object]: ...
    @tag.setter
    def tag(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def icon(self) -> typing.Optional[WindowTabIcon]: ...
    @icon.setter
    def icon(self, value: typing.Optional[WindowTabIcon]) -> None: ...
    @_property
    def group(self) -> typing.Optional[WindowTabGroup]: ...
    @group.setter
    def group(self, value: typing.Optional[WindowTabGroup]) -> None: ...

@typing.final
class WindowTabCloseRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WindowTabCloseRequestedEventArgs: ...
    @_property
    def tab(self) -> typing.Optional[WindowTab]: ...

@typing.final
class WindowTabCollection(winrt.system.Object, winrt._winrt.MutableSequence[WindowTab]):
    def __len__(self) -> int: ...
    def __iter__(self) -> winrt.windows.foundation.collections.IIterator[WindowTab]: ...
    @typing.overload
    def __getitem__(self, index: typing.SupportsIndex) -> WindowTab: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[WindowTab]: ...
    @typing.overload
    def __delitem__(self, index: typing.SupportsIndex) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: typing.SupportsIndex, value: WindowTab) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[WindowTab]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WindowTabCollection: ...
    def append(self, value: typing.Optional[WindowTab], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[WindowTab]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[WindowTab]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[WindowTab], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[WindowTab]]: ...
    def index_of(self, value: typing.Optional[WindowTab], /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[WindowTab], /) -> None: ...
    def move_tab(self, tab: typing.Optional[WindowTab], index: winrt.system.UInt32, /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[WindowTab], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[WindowTab], /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class WindowTabGroup(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WindowTabGroup: ...
    def __new__(cls: typing.Type[WindowTabGroup]) -> WindowTabGroup:...
    @_property
    def title(self) -> str: ...
    @title.setter
    def title(self, value: str) -> None: ...
    @_property
    def icon(self) -> typing.Optional[WindowTabIcon]: ...
    @icon.setter
    def icon(self, value: typing.Optional[WindowTabIcon]) -> None: ...

@typing.final
class WindowTabIcon_Static(type):
    @typing.overload
    def create_from_font_glyph(cls, glyph: str, font_family: str, /) -> typing.Optional[WindowTabIcon]: ...
    @typing.overload
    def create_from_font_glyph(cls, glyph: str, font_family: str, font_uri: typing.Optional[winrt.windows.foundation.Uri], /) -> typing.Optional[WindowTabIcon]: ...
    def create_from_image(cls, image: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference], /) -> typing.Optional[WindowTabIcon]: ...

@typing.final
class WindowTabIcon(winrt.system.Object, metaclass=WindowTabIcon_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WindowTabIcon: ...

@typing.final
class WindowTabManager_Static(type):
    def get_for_window(cls, id: winrt.windows.ui.WindowId, /) -> typing.Optional[WindowTabManager]: ...
    def is_supported(cls) -> bool: ...
    def is_tab_tear_out_supported(cls) -> bool: ...

@typing.final
class WindowTabManager(winrt.system.Object, metaclass=WindowTabManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WindowTabManager: ...
    def set_active_tab(self, tab: typing.Optional[WindowTab], /) -> None: ...
    def add_tab_close_requested(self, handler: winrt.windows.foundation.TypedEventHandler[WindowTabManager, WindowTabCloseRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_tab_close_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_tab_switch_requested(self, handler: winrt.windows.foundation.TypedEventHandler[WindowTabManager, WindowTabSwitchRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_tab_switch_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_tab_tear_out_requested(self, handler: winrt.windows.foundation.TypedEventHandler[WindowTabManager, WindowTabTearOutRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_tab_tear_out_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_tab_thumbnail_requested(self, handler: winrt.windows.foundation.TypedEventHandler[WindowTabManager, WindowTabThumbnailRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_tab_thumbnail_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def tabs(self) -> typing.Optional[WindowTabCollection]: ...

@typing.final
class WindowTabSwitchRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WindowTabSwitchRequestedEventArgs: ...
    @_property
    def tab(self) -> typing.Optional[WindowTab]: ...

@typing.final
class WindowTabTearOutRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WindowTabTearOutRequestedEventArgs: ...
    def get_deferral(self) -> typing.Optional[winrt.windows.foundation.Deferral]: ...
    @_property
    def window_id(self) -> winrt.system.UInt64: ...
    @window_id.setter
    def window_id(self, value: winrt.system.UInt64) -> None: ...
    @_property
    def tab(self) -> typing.Optional[WindowTab]: ...

@typing.final
class WindowTabThumbnailRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WindowTabThumbnailRequestedEventArgs: ...
    def get_deferral(self) -> typing.Optional[winrt.windows.foundation.Deferral]: ...
    @_property
    def image(self) -> typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference]: ...
    @image.setter
    def image(self, value: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference]) -> None: ...
    @_property
    def is_composited_on_window(self) -> bool: ...
    @_property
    def requested_size(self) -> winrt.windows.graphics.imaging.BitmapSize: ...
    @_property
    def tab(self) -> typing.Optional[WindowTab]: ...

@typing.final
class IAdaptiveCard(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IAdaptiveCard: ...
    def to_json(self) -> str: ...

@typing.final
class IAdaptiveCardBuilderStatics(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IAdaptiveCardBuilderStatics: ...
    def create_adaptive_card_from_json(self, value: str, /) -> typing.Optional[IAdaptiveCard]: ...

