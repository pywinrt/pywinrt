// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

#include "py.Windows.UI.Shell.h"


namespace py::cpp::Windows::UI::Shell
{
    // ----- AdaptiveCardBuilder class --------------------

    static PyObject* _new_AdaptiveCardBuilder(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Shell::AdaptiveCardBuilder>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Shell::AdaptiveCardBuilder>::type_name);
        return nullptr;
    }

    static PyObject* AdaptiveCardBuilder_CreateAdaptiveCardFromJson(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.AdaptiveCardBuilder", L"CreateAdaptiveCardFromJson", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::UI::Shell::AdaptiveCardBuilder::CreateAdaptiveCardFromJson(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveCardBuilder[] = {
        { }
    };

    static PyGetSetDef _getset_AdaptiveCardBuilder[] = {
        { }
    };

    static PyType_Slot _type_slots_AdaptiveCardBuilder[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AdaptiveCardBuilder) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AdaptiveCardBuilder) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AdaptiveCardBuilder) },
        { },
    };

    static PyType_Spec type_spec_AdaptiveCardBuilder =
    {
        "winrt._winrt_windows_ui_shell.AdaptiveCardBuilder",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveCardBuilder
    };

    static PyGetSetDef getset_AdaptiveCardBuilder_Static[] = {
        { }
    };

    static PyMethodDef methods_AdaptiveCardBuilder_Static[] = {
        { "create_adaptive_card_from_json", reinterpret_cast<PyCFunction>(AdaptiveCardBuilder_CreateAdaptiveCardFromJson), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AdaptiveCardBuilder_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AdaptiveCardBuilder_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AdaptiveCardBuilder_Static) },
        { }
    };

    static PyType_Spec type_spec_AdaptiveCardBuilder_Static =
    {
        "winrt._winrt_windows_ui_shell.AdaptiveCardBuilder_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AdaptiveCardBuilder_Static
    };

    // ----- FocusSession class --------------------

    static PyObject* _new_FocusSession(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Shell::FocusSession>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Shell::FocusSession>::type_name);
        return nullptr;
    }

    static void _dealloc_FocusSession(py::wrapper::Windows::UI::Shell::FocusSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FocusSession_End(py::wrapper::Windows::UI::Shell::FocusSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.FocusSession", L"End", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.End();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusSession_get_Id(py::wrapper::Windows::UI::Shell::FocusSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.FocusSession", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FocusSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::FocusSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FocusSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::FocusSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FocusSession[] = {
        { "end", reinterpret_cast<PyCFunction>(FocusSession_End), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_FocusSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FocusSession), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FocusSession[] = {
        { "id", reinterpret_cast<getter>(FocusSession_get_Id), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FocusSession[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FocusSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FocusSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FocusSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FocusSession) },
        { },
    };

    static PyType_Spec type_spec_FocusSession =
    {
        "winrt._winrt_windows_ui_shell.FocusSession",
        sizeof(py::wrapper::Windows::UI::Shell::FocusSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FocusSession
    };

    // ----- FocusSessionManager class --------------------

    static PyObject* _new_FocusSessionManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Shell::FocusSessionManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Shell::FocusSessionManager>::type_name);
        return nullptr;
    }

    static void _dealloc_FocusSessionManager(py::wrapper::Windows::UI::Shell::FocusSessionManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FocusSessionManager_DeactivateFocus(py::wrapper::Windows::UI::Shell::FocusSessionManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.FocusSessionManager", L"DeactivateFocus", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.DeactivateFocus();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusSessionManager_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.FocusSessionManager", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::Shell::FocusSessionManager::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusSessionManager_GetSession(py::wrapper::Windows::UI::Shell::FocusSessionManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.FocusSessionManager", L"GetSession", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetSession(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusSessionManager_TryStartFocusSession(py::wrapper::Windows::UI::Shell::FocusSessionManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.FocusSessionManager", L"TryStartFocusSession", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryStartFocusSession());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.FocusSessionManager", L"TryStartFocusSession", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

                return py::convert(self->obj.TryStartFocusSession(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusSessionManager_get_IsFocusActive(py::wrapper::Windows::UI::Shell::FocusSessionManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.FocusSessionManager", L"IsFocusActive"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsFocusActive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusSessionManager_get_IsSupported(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.FocusSessionManager", L"IsSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Shell::FocusSessionManager::IsSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusSessionManager_add_IsFocusActiveChanged(py::wrapper::Windows::UI::Shell::FocusSessionManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Shell.FocusSessionManager", L"IsFocusActiveChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Shell::FocusSessionManager, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.IsFocusActiveChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusSessionManager_remove_IsFocusActiveChanged(py::wrapper::Windows::UI::Shell::FocusSessionManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Shell.FocusSessionManager", L"IsFocusActiveChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.IsFocusActiveChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FocusSessionManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::FocusSessionManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FocusSessionManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::FocusSessionManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FocusSessionManager[] = {
        { "deactivate_focus", reinterpret_cast<PyCFunction>(FocusSessionManager_DeactivateFocus), METH_VARARGS, nullptr },
        { "get_session", reinterpret_cast<PyCFunction>(FocusSessionManager_GetSession), METH_VARARGS, nullptr },
        { "try_start_focus_session", reinterpret_cast<PyCFunction>(FocusSessionManager_TryStartFocusSession), METH_VARARGS, nullptr },
        { "add_is_focus_active_changed", reinterpret_cast<PyCFunction>(FocusSessionManager_add_IsFocusActiveChanged), METH_O, nullptr },
        { "remove_is_focus_active_changed", reinterpret_cast<PyCFunction>(FocusSessionManager_remove_IsFocusActiveChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_FocusSessionManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FocusSessionManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FocusSessionManager[] = {
        { "is_focus_active", reinterpret_cast<getter>(FocusSessionManager_get_IsFocusActive), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FocusSessionManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FocusSessionManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FocusSessionManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FocusSessionManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FocusSessionManager) },
        { },
    };

    static PyType_Spec type_spec_FocusSessionManager =
    {
        "winrt._winrt_windows_ui_shell.FocusSessionManager",
        sizeof(py::wrapper::Windows::UI::Shell::FocusSessionManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FocusSessionManager
    };

    static PyGetSetDef getset_FocusSessionManager_Static[] = {
        { "is_supported", reinterpret_cast<getter>(FocusSessionManager_get_IsSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_FocusSessionManager_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(FocusSessionManager_GetDefault), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_FocusSessionManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FocusSessionManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FocusSessionManager_Static) },
        { }
    };

    static PyType_Spec type_spec_FocusSessionManager_Static =
    {
        "winrt._winrt_windows_ui_shell.FocusSessionManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_FocusSessionManager_Static
    };

    // ----- SecurityAppManager class --------------------

    static PyObject* _new_SecurityAppManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Shell::SecurityAppManager instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SecurityAppManager(py::wrapper::Windows::UI::Shell::SecurityAppManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SecurityAppManager_Register(py::wrapper::Windows::UI::Shell::SecurityAppManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.SecurityAppManager", L"Register", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Shell::SecurityAppKind>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 2);
                auto param3 = py::convert_to<bool>(args, 3);

                return py::convert(self->obj.Register(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SecurityAppManager_Unregister(py::wrapper::Windows::UI::Shell::SecurityAppManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.SecurityAppManager", L"Unregister", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Shell::SecurityAppKind>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);

                self->obj.Unregister(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SecurityAppManager_UpdateState(py::wrapper::Windows::UI::Shell::SecurityAppManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.SecurityAppManager", L"UpdateState", 5))
            {
                py::set_arg_count_version_error(5);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Shell::SecurityAppKind>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Shell::SecurityAppState>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::UI::Shell::SecurityAppSubstatus>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 4);

                self->obj.UpdateState(param0, param1, param2, param3, param4);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_SecurityAppManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::SecurityAppManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SecurityAppManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::SecurityAppManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SecurityAppManager[] = {
        { "register", reinterpret_cast<PyCFunction>(SecurityAppManager_Register), METH_VARARGS, nullptr },
        { "unregister", reinterpret_cast<PyCFunction>(SecurityAppManager_Unregister), METH_VARARGS, nullptr },
        { "update_state", reinterpret_cast<PyCFunction>(SecurityAppManager_UpdateState), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SecurityAppManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SecurityAppManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SecurityAppManager[] = {
        { }
    };

    static PyType_Slot _type_slots_SecurityAppManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SecurityAppManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SecurityAppManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SecurityAppManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SecurityAppManager) },
        { },
    };

    static PyType_Spec type_spec_SecurityAppManager =
    {
        "winrt._winrt_windows_ui_shell.SecurityAppManager",
        sizeof(py::wrapper::Windows::UI::Shell::SecurityAppManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SecurityAppManager
    };

    // ----- ShareWindowCommandEventArgs class --------------------

    static PyObject* _new_ShareWindowCommandEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Shell::ShareWindowCommandEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Shell::ShareWindowCommandEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ShareWindowCommandEventArgs(py::wrapper::Windows::UI::Shell::ShareWindowCommandEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ShareWindowCommandEventArgs_get_Command(py::wrapper::Windows::UI::Shell::ShareWindowCommandEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.ShareWindowCommandEventArgs", L"Command"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Command());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ShareWindowCommandEventArgs_put_Command(py::wrapper::Windows::UI::Shell::ShareWindowCommandEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.ShareWindowCommandEventArgs", L"Command"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Shell::ShareWindowCommand>(arg);

            self->obj.Command(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ShareWindowCommandEventArgs_get_WindowId(py::wrapper::Windows::UI::Shell::ShareWindowCommandEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.ShareWindowCommandEventArgs", L"WindowId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WindowId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ShareWindowCommandEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::ShareWindowCommandEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ShareWindowCommandEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::ShareWindowCommandEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ShareWindowCommandEventArgs[] = {
        { "_assign_array_", _assign_array_ShareWindowCommandEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ShareWindowCommandEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ShareWindowCommandEventArgs[] = {
        { "command", reinterpret_cast<getter>(ShareWindowCommandEventArgs_get_Command), reinterpret_cast<setter>(ShareWindowCommandEventArgs_put_Command), nullptr, nullptr },
        { "window_id", reinterpret_cast<getter>(ShareWindowCommandEventArgs_get_WindowId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ShareWindowCommandEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ShareWindowCommandEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ShareWindowCommandEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ShareWindowCommandEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ShareWindowCommandEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ShareWindowCommandEventArgs =
    {
        "winrt._winrt_windows_ui_shell.ShareWindowCommandEventArgs",
        sizeof(py::wrapper::Windows::UI::Shell::ShareWindowCommandEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ShareWindowCommandEventArgs
    };

    // ----- ShareWindowCommandSource class --------------------

    static PyObject* _new_ShareWindowCommandSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Shell::ShareWindowCommandSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Shell::ShareWindowCommandSource>::type_name);
        return nullptr;
    }

    static void _dealloc_ShareWindowCommandSource(py::wrapper::Windows::UI::Shell::ShareWindowCommandSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ShareWindowCommandSource_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.ShareWindowCommandSource", L"GetForCurrentView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::Shell::ShareWindowCommandSource::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ShareWindowCommandSource_ReportCommandChanged(py::wrapper::Windows::UI::Shell::ShareWindowCommandSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.ShareWindowCommandSource", L"ReportCommandChanged", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ReportCommandChanged();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ShareWindowCommandSource_Start(py::wrapper::Windows::UI::Shell::ShareWindowCommandSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.ShareWindowCommandSource", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ShareWindowCommandSource_Stop(py::wrapper::Windows::UI::Shell::ShareWindowCommandSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.ShareWindowCommandSource", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ShareWindowCommandSource_add_CommandInvoked(py::wrapper::Windows::UI::Shell::ShareWindowCommandSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Shell.ShareWindowCommandSource", L"CommandInvoked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Shell::ShareWindowCommandSource, winrt::Windows::UI::Shell::ShareWindowCommandEventArgs>>(arg);

            return py::convert(self->obj.CommandInvoked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ShareWindowCommandSource_remove_CommandInvoked(py::wrapper::Windows::UI::Shell::ShareWindowCommandSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Shell.ShareWindowCommandSource", L"CommandInvoked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CommandInvoked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ShareWindowCommandSource_add_CommandRequested(py::wrapper::Windows::UI::Shell::ShareWindowCommandSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Shell.ShareWindowCommandSource", L"CommandRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Shell::ShareWindowCommandSource, winrt::Windows::UI::Shell::ShareWindowCommandEventArgs>>(arg);

            return py::convert(self->obj.CommandRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ShareWindowCommandSource_remove_CommandRequested(py::wrapper::Windows::UI::Shell::ShareWindowCommandSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Shell.ShareWindowCommandSource", L"CommandRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CommandRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ShareWindowCommandSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::ShareWindowCommandSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ShareWindowCommandSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::ShareWindowCommandSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ShareWindowCommandSource[] = {
        { "report_command_changed", reinterpret_cast<PyCFunction>(ShareWindowCommandSource_ReportCommandChanged), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(ShareWindowCommandSource_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(ShareWindowCommandSource_Stop), METH_VARARGS, nullptr },
        { "add_command_invoked", reinterpret_cast<PyCFunction>(ShareWindowCommandSource_add_CommandInvoked), METH_O, nullptr },
        { "remove_command_invoked", reinterpret_cast<PyCFunction>(ShareWindowCommandSource_remove_CommandInvoked), METH_O, nullptr },
        { "add_command_requested", reinterpret_cast<PyCFunction>(ShareWindowCommandSource_add_CommandRequested), METH_O, nullptr },
        { "remove_command_requested", reinterpret_cast<PyCFunction>(ShareWindowCommandSource_remove_CommandRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_ShareWindowCommandSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ShareWindowCommandSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ShareWindowCommandSource[] = {
        { }
    };

    static PyType_Slot _type_slots_ShareWindowCommandSource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ShareWindowCommandSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ShareWindowCommandSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ShareWindowCommandSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ShareWindowCommandSource) },
        { },
    };

    static PyType_Spec type_spec_ShareWindowCommandSource =
    {
        "winrt._winrt_windows_ui_shell.ShareWindowCommandSource",
        sizeof(py::wrapper::Windows::UI::Shell::ShareWindowCommandSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ShareWindowCommandSource
    };

    static PyGetSetDef getset_ShareWindowCommandSource_Static[] = {
        { }
    };

    static PyMethodDef methods_ShareWindowCommandSource_Static[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(ShareWindowCommandSource_GetForCurrentView), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_ShareWindowCommandSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ShareWindowCommandSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ShareWindowCommandSource_Static) },
        { }
    };

    static PyType_Spec type_spec_ShareWindowCommandSource_Static =
    {
        "winrt._winrt_windows_ui_shell.ShareWindowCommandSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ShareWindowCommandSource_Static
    };

    // ----- TaskbarManager class --------------------

    static PyObject* _new_TaskbarManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Shell::TaskbarManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Shell::TaskbarManager>::type_name);
        return nullptr;
    }

    static void _dealloc_TaskbarManager(py::wrapper::Windows::UI::Shell::TaskbarManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TaskbarManager_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.TaskbarManager", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::Shell::TaskbarManager::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TaskbarManager_IsAppListEntryPinnedAsync(py::wrapper::Windows::UI::Shell::TaskbarManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.TaskbarManager", L"IsAppListEntryPinnedAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Core::AppListEntry>(args, 0);

                return py::convert(self->obj.IsAppListEntryPinnedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TaskbarManager_IsCurrentAppPinnedAsync(py::wrapper::Windows::UI::Shell::TaskbarManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.TaskbarManager", L"IsCurrentAppPinnedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.IsCurrentAppPinnedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TaskbarManager_IsSecondaryTilePinnedAsync(py::wrapper::Windows::UI::Shell::TaskbarManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.TaskbarManager", L"IsSecondaryTilePinnedAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsSecondaryTilePinnedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TaskbarManager_RequestPinAppListEntryAsync(py::wrapper::Windows::UI::Shell::TaskbarManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.TaskbarManager", L"RequestPinAppListEntryAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Core::AppListEntry>(args, 0);

                return py::convert(self->obj.RequestPinAppListEntryAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TaskbarManager_RequestPinCurrentAppAsync(py::wrapper::Windows::UI::Shell::TaskbarManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.TaskbarManager", L"RequestPinCurrentAppAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RequestPinCurrentAppAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TaskbarManager_RequestPinSecondaryTileAsync(py::wrapper::Windows::UI::Shell::TaskbarManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.TaskbarManager", L"RequestPinSecondaryTileAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::StartScreen::SecondaryTile>(args, 0);

                return py::convert(self->obj.RequestPinSecondaryTileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TaskbarManager_TryUnpinSecondaryTileAsync(py::wrapper::Windows::UI::Shell::TaskbarManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.TaskbarManager", L"TryUnpinSecondaryTileAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryUnpinSecondaryTileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TaskbarManager_get_IsPinningAllowed(py::wrapper::Windows::UI::Shell::TaskbarManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.TaskbarManager", L"IsPinningAllowed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPinningAllowed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TaskbarManager_get_IsSupported(py::wrapper::Windows::UI::Shell::TaskbarManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.TaskbarManager", L"IsSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TaskbarManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::TaskbarManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TaskbarManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::TaskbarManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TaskbarManager[] = {
        { "is_app_list_entry_pinned_async", reinterpret_cast<PyCFunction>(TaskbarManager_IsAppListEntryPinnedAsync), METH_VARARGS, nullptr },
        { "is_current_app_pinned_async", reinterpret_cast<PyCFunction>(TaskbarManager_IsCurrentAppPinnedAsync), METH_VARARGS, nullptr },
        { "is_secondary_tile_pinned_async", reinterpret_cast<PyCFunction>(TaskbarManager_IsSecondaryTilePinnedAsync), METH_VARARGS, nullptr },
        { "request_pin_app_list_entry_async", reinterpret_cast<PyCFunction>(TaskbarManager_RequestPinAppListEntryAsync), METH_VARARGS, nullptr },
        { "request_pin_current_app_async", reinterpret_cast<PyCFunction>(TaskbarManager_RequestPinCurrentAppAsync), METH_VARARGS, nullptr },
        { "request_pin_secondary_tile_async", reinterpret_cast<PyCFunction>(TaskbarManager_RequestPinSecondaryTileAsync), METH_VARARGS, nullptr },
        { "try_unpin_secondary_tile_async", reinterpret_cast<PyCFunction>(TaskbarManager_TryUnpinSecondaryTileAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TaskbarManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TaskbarManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TaskbarManager[] = {
        { "is_pinning_allowed", reinterpret_cast<getter>(TaskbarManager_get_IsPinningAllowed), nullptr, nullptr, nullptr },
        { "is_supported", reinterpret_cast<getter>(TaskbarManager_get_IsSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TaskbarManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TaskbarManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TaskbarManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TaskbarManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TaskbarManager) },
        { },
    };

    static PyType_Spec type_spec_TaskbarManager =
    {
        "winrt._winrt_windows_ui_shell.TaskbarManager",
        sizeof(py::wrapper::Windows::UI::Shell::TaskbarManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TaskbarManager
    };

    static PyGetSetDef getset_TaskbarManager_Static[] = {
        { }
    };

    static PyMethodDef methods_TaskbarManager_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(TaskbarManager_GetDefault), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_TaskbarManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TaskbarManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TaskbarManager_Static) },
        { }
    };

    static PyType_Spec type_spec_TaskbarManager_Static =
    {
        "winrt._winrt_windows_ui_shell.TaskbarManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TaskbarManager_Static
    };

    // ----- WindowTab class --------------------

    static PyObject* _new_WindowTab(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Shell::WindowTab instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WindowTab(py::wrapper::Windows::UI::Shell::WindowTab* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowTab_ReportThumbnailAvailable(py::wrapper::Windows::UI::Shell::WindowTab* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTab", L"ReportThumbnailAvailable", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ReportThumbnailAvailable();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTab_get_TreatAsSecondaryTileId(py::wrapper::Windows::UI::Shell::WindowTab* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTab", L"TreatAsSecondaryTileId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TreatAsSecondaryTileId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowTab_put_TreatAsSecondaryTileId(py::wrapper::Windows::UI::Shell::WindowTab* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTab", L"TreatAsSecondaryTileId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TreatAsSecondaryTileId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowTab_get_Title(py::wrapper::Windows::UI::Shell::WindowTab* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTab", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowTab_put_Title(py::wrapper::Windows::UI::Shell::WindowTab* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTab", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowTab_get_Tag(py::wrapper::Windows::UI::Shell::WindowTab* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTab", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowTab_put_Tag(py::wrapper::Windows::UI::Shell::WindowTab* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTab", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowTab_get_Icon(py::wrapper::Windows::UI::Shell::WindowTab* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTab", L"Icon"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Icon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowTab_put_Icon(py::wrapper::Windows::UI::Shell::WindowTab* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTab", L"Icon"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Shell::WindowTabIcon>(arg);

            self->obj.Icon(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowTab_get_Group(py::wrapper::Windows::UI::Shell::WindowTab* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTab", L"Group"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Group());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowTab_put_Group(py::wrapper::Windows::UI::Shell::WindowTab* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTab", L"Group"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Shell::WindowTabGroup>(arg);

            self->obj.Group(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_WindowTab(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::WindowTab>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowTab(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::WindowTab>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowTab[] = {
        { "report_thumbnail_available", reinterpret_cast<PyCFunction>(WindowTab_ReportThumbnailAvailable), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WindowTab, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowTab), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WindowTab[] = {
        { "treat_as_secondary_tile_id", reinterpret_cast<getter>(WindowTab_get_TreatAsSecondaryTileId), reinterpret_cast<setter>(WindowTab_put_TreatAsSecondaryTileId), nullptr, nullptr },
        { "title", reinterpret_cast<getter>(WindowTab_get_Title), reinterpret_cast<setter>(WindowTab_put_Title), nullptr, nullptr },
        { "tag", reinterpret_cast<getter>(WindowTab_get_Tag), reinterpret_cast<setter>(WindowTab_put_Tag), nullptr, nullptr },
        { "icon", reinterpret_cast<getter>(WindowTab_get_Icon), reinterpret_cast<setter>(WindowTab_put_Icon), nullptr, nullptr },
        { "group", reinterpret_cast<getter>(WindowTab_get_Group), reinterpret_cast<setter>(WindowTab_put_Group), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WindowTab[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowTab) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowTab) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowTab) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowTab) },
        { },
    };

    static PyType_Spec type_spec_WindowTab =
    {
        "winrt._winrt_windows_ui_shell.WindowTab",
        sizeof(py::wrapper::Windows::UI::Shell::WindowTab),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowTab
    };

    // ----- WindowTabCloseRequestedEventArgs class --------------------

    static PyObject* _new_WindowTabCloseRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Shell::WindowTabCloseRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Shell::WindowTabCloseRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowTabCloseRequestedEventArgs(py::wrapper::Windows::UI::Shell::WindowTabCloseRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowTabCloseRequestedEventArgs_get_Tab(py::wrapper::Windows::UI::Shell::WindowTabCloseRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTabCloseRequestedEventArgs", L"Tab"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Tab());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowTabCloseRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::WindowTabCloseRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowTabCloseRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::WindowTabCloseRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowTabCloseRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_WindowTabCloseRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowTabCloseRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WindowTabCloseRequestedEventArgs[] = {
        { "tab", reinterpret_cast<getter>(WindowTabCloseRequestedEventArgs_get_Tab), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WindowTabCloseRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowTabCloseRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowTabCloseRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowTabCloseRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowTabCloseRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WindowTabCloseRequestedEventArgs =
    {
        "winrt._winrt_windows_ui_shell.WindowTabCloseRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Shell::WindowTabCloseRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowTabCloseRequestedEventArgs
    };

    // ----- WindowTabCollection class --------------------

    static PyObject* _new_WindowTabCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Shell::WindowTabCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Shell::WindowTabCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowTabCollection(py::wrapper::Windows::UI::Shell::WindowTabCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowTabCollection_Append(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabCollection", L"Append", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Shell::WindowTab>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabCollection_Clear(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabCollection", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabCollection_First(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabCollection", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabCollection_GetAt(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabCollection", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabCollection_GetMany(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabCollection", L"GetMany", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Shell::WindowTab, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabCollection_GetView(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabCollection", L"GetView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabCollection_IndexOf(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabCollection", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Shell::WindowTab>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabCollection_InsertAt(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabCollection", L"InsertAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Shell::WindowTab>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabCollection_MoveTab(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabCollection", L"MoveTab", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Shell::WindowTab>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                self->obj.MoveTab(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabCollection_RemoveAt(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabCollection", L"RemoveAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabCollection_RemoveAtEnd(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabCollection", L"RemoveAtEnd", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabCollection_ReplaceAll(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabCollection", L"ReplaceAll", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Shell::WindowTab, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabCollection_SetAt(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabCollection", L"SetAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Shell::WindowTab>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabCollection_get_Size(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTabCollection", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowTabCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::WindowTabCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowTabCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::WindowTabCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_WindowTabCollection(py::wrapper::Windows::UI::Shell::WindowTabCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_WindowTabCollection(py::wrapper::Windows::UI::Shell::WindowTabCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_WindowTabCollection(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_WindowTabCollection(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_WindowTabCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(
                    PyExc_NotImplementedError,
                    "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::UI::Shell::WindowTab> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::UI::Shell::WindowTab>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(
                    PyExc_RuntimeError,
                    "returned count %d did not match requested length %zd",
                    count,
                    length);
                return nullptr;
            }

            return convert(items);}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_WindowTabCollection(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::UI::Shell::WindowTab>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_WindowTabCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(WindowTabCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(WindowTabCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(WindowTabCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(WindowTabCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(WindowTabCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(WindowTabCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(WindowTabCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(WindowTabCollection_InsertAt), METH_VARARGS, nullptr },
        { "move_tab", reinterpret_cast<PyCFunction>(WindowTabCollection_MoveTab), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(WindowTabCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(WindowTabCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(WindowTabCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(WindowTabCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WindowTabCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowTabCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WindowTabCollection[] = {
        { "size", reinterpret_cast<getter>(WindowTabCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WindowTabCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowTabCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowTabCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowTabCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowTabCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_WindowTabCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_WindowTabCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_WindowTabCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_WindowTabCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_WindowTabCollection) },
        { },
    };

    static PyType_Spec type_spec_WindowTabCollection =
    {
        "winrt._winrt_windows_ui_shell.WindowTabCollection",
        sizeof(py::wrapper::Windows::UI::Shell::WindowTabCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowTabCollection
    };

    // ----- WindowTabGroup class --------------------

    static PyObject* _new_WindowTabGroup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Shell::WindowTabGroup instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WindowTabGroup(py::wrapper::Windows::UI::Shell::WindowTabGroup* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowTabGroup_get_Title(py::wrapper::Windows::UI::Shell::WindowTabGroup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTabGroup", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowTabGroup_put_Title(py::wrapper::Windows::UI::Shell::WindowTabGroup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTabGroup", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowTabGroup_get_Icon(py::wrapper::Windows::UI::Shell::WindowTabGroup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTabGroup", L"Icon"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Icon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowTabGroup_put_Icon(py::wrapper::Windows::UI::Shell::WindowTabGroup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTabGroup", L"Icon"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Shell::WindowTabIcon>(arg);

            self->obj.Icon(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_WindowTabGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::WindowTabGroup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowTabGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::WindowTabGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowTabGroup[] = {
        { "_assign_array_", _assign_array_WindowTabGroup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowTabGroup), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WindowTabGroup[] = {
        { "title", reinterpret_cast<getter>(WindowTabGroup_get_Title), reinterpret_cast<setter>(WindowTabGroup_put_Title), nullptr, nullptr },
        { "icon", reinterpret_cast<getter>(WindowTabGroup_get_Icon), reinterpret_cast<setter>(WindowTabGroup_put_Icon), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WindowTabGroup[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowTabGroup) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowTabGroup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowTabGroup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowTabGroup) },
        { },
    };

    static PyType_Spec type_spec_WindowTabGroup =
    {
        "winrt._winrt_windows_ui_shell.WindowTabGroup",
        sizeof(py::wrapper::Windows::UI::Shell::WindowTabGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowTabGroup
    };

    // ----- WindowTabIcon class --------------------

    static PyObject* _new_WindowTabIcon(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Shell::WindowTabIcon>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Shell::WindowTabIcon>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowTabIcon(py::wrapper::Windows::UI::Shell::WindowTabIcon* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowTabIcon_CreateFromFontGlyph(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabIcon", L"CreateFromFontGlyph", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::UI::Shell::WindowTabIcon::CreateFromFontGlyph(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabIcon", L"CreateFromFontGlyph", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 2);

                return py::convert(winrt::Windows::UI::Shell::WindowTabIcon::CreateFromFontGlyph(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabIcon_CreateFromImage(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabIcon", L"CreateFromImage", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);

                return py::convert(winrt::Windows::UI::Shell::WindowTabIcon::CreateFromImage(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowTabIcon(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::WindowTabIcon>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowTabIcon(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::WindowTabIcon>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowTabIcon[] = {
        { "_assign_array_", _assign_array_WindowTabIcon, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowTabIcon), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WindowTabIcon[] = {
        { }
    };

    static PyType_Slot _type_slots_WindowTabIcon[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowTabIcon) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowTabIcon) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowTabIcon) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowTabIcon) },
        { },
    };

    static PyType_Spec type_spec_WindowTabIcon =
    {
        "winrt._winrt_windows_ui_shell.WindowTabIcon",
        sizeof(py::wrapper::Windows::UI::Shell::WindowTabIcon),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowTabIcon
    };

    static PyGetSetDef getset_WindowTabIcon_Static[] = {
        { }
    };

    static PyMethodDef methods_WindowTabIcon_Static[] = {
        { "create_from_font_glyph", reinterpret_cast<PyCFunction>(WindowTabIcon_CreateFromFontGlyph), METH_VARARGS, nullptr },
        { "create_from_image", reinterpret_cast<PyCFunction>(WindowTabIcon_CreateFromImage), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_WindowTabIcon_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_WindowTabIcon_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_WindowTabIcon_Static) },
        { }
    };

    static PyType_Spec type_spec_WindowTabIcon_Static =
    {
        "winrt._winrt_windows_ui_shell.WindowTabIcon_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_WindowTabIcon_Static
    };

    // ----- WindowTabManager class --------------------

    static PyObject* _new_WindowTabManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Shell::WindowTabManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Shell::WindowTabManager>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowTabManager(py::wrapper::Windows::UI::Shell::WindowTabManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowTabManager_GetForWindow(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabManager", L"GetForWindow", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::WindowId>(args, 0);

                return py::convert(winrt::Windows::UI::Shell::WindowTabManager::GetForWindow(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabManager_IsSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabManager", L"IsSupported", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::Shell::WindowTabManager::IsSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabManager_IsTabTearOutSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabManager", L"IsTabTearOutSupported", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::Shell::WindowTabManager::IsTabTearOutSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabManager_SetActiveTab(py::wrapper::Windows::UI::Shell::WindowTabManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabManager", L"SetActiveTab", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Shell::WindowTab>(args, 0);

                self->obj.SetActiveTab(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabManager_get_Tabs(py::wrapper::Windows::UI::Shell::WindowTabManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTabManager", L"Tabs"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Tabs());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowTabManager_add_TabCloseRequested(py::wrapper::Windows::UI::Shell::WindowTabManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Shell.WindowTabManager", L"TabCloseRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Shell::WindowTabManager, winrt::Windows::UI::Shell::WindowTabCloseRequestedEventArgs>>(arg);

            return py::convert(self->obj.TabCloseRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowTabManager_remove_TabCloseRequested(py::wrapper::Windows::UI::Shell::WindowTabManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Shell.WindowTabManager", L"TabCloseRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TabCloseRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowTabManager_add_TabSwitchRequested(py::wrapper::Windows::UI::Shell::WindowTabManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Shell.WindowTabManager", L"TabSwitchRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Shell::WindowTabManager, winrt::Windows::UI::Shell::WindowTabSwitchRequestedEventArgs>>(arg);

            return py::convert(self->obj.TabSwitchRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowTabManager_remove_TabSwitchRequested(py::wrapper::Windows::UI::Shell::WindowTabManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Shell.WindowTabManager", L"TabSwitchRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TabSwitchRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowTabManager_add_TabTearOutRequested(py::wrapper::Windows::UI::Shell::WindowTabManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Shell.WindowTabManager", L"TabTearOutRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Shell::WindowTabManager, winrt::Windows::UI::Shell::WindowTabTearOutRequestedEventArgs>>(arg);

            return py::convert(self->obj.TabTearOutRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowTabManager_remove_TabTearOutRequested(py::wrapper::Windows::UI::Shell::WindowTabManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Shell.WindowTabManager", L"TabTearOutRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TabTearOutRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowTabManager_add_TabThumbnailRequested(py::wrapper::Windows::UI::Shell::WindowTabManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Shell.WindowTabManager", L"TabThumbnailRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Shell::WindowTabManager, winrt::Windows::UI::Shell::WindowTabThumbnailRequestedEventArgs>>(arg);

            return py::convert(self->obj.TabThumbnailRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowTabManager_remove_TabThumbnailRequested(py::wrapper::Windows::UI::Shell::WindowTabManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Shell.WindowTabManager", L"TabThumbnailRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TabThumbnailRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowTabManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::WindowTabManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowTabManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::WindowTabManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowTabManager[] = {
        { "set_active_tab", reinterpret_cast<PyCFunction>(WindowTabManager_SetActiveTab), METH_VARARGS, nullptr },
        { "add_tab_close_requested", reinterpret_cast<PyCFunction>(WindowTabManager_add_TabCloseRequested), METH_O, nullptr },
        { "remove_tab_close_requested", reinterpret_cast<PyCFunction>(WindowTabManager_remove_TabCloseRequested), METH_O, nullptr },
        { "add_tab_switch_requested", reinterpret_cast<PyCFunction>(WindowTabManager_add_TabSwitchRequested), METH_O, nullptr },
        { "remove_tab_switch_requested", reinterpret_cast<PyCFunction>(WindowTabManager_remove_TabSwitchRequested), METH_O, nullptr },
        { "add_tab_tear_out_requested", reinterpret_cast<PyCFunction>(WindowTabManager_add_TabTearOutRequested), METH_O, nullptr },
        { "remove_tab_tear_out_requested", reinterpret_cast<PyCFunction>(WindowTabManager_remove_TabTearOutRequested), METH_O, nullptr },
        { "add_tab_thumbnail_requested", reinterpret_cast<PyCFunction>(WindowTabManager_add_TabThumbnailRequested), METH_O, nullptr },
        { "remove_tab_thumbnail_requested", reinterpret_cast<PyCFunction>(WindowTabManager_remove_TabThumbnailRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_WindowTabManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowTabManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WindowTabManager[] = {
        { "tabs", reinterpret_cast<getter>(WindowTabManager_get_Tabs), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WindowTabManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowTabManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowTabManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowTabManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowTabManager) },
        { },
    };

    static PyType_Spec type_spec_WindowTabManager =
    {
        "winrt._winrt_windows_ui_shell.WindowTabManager",
        sizeof(py::wrapper::Windows::UI::Shell::WindowTabManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowTabManager
    };

    static PyGetSetDef getset_WindowTabManager_Static[] = {
        { }
    };

    static PyMethodDef methods_WindowTabManager_Static[] = {
        { "get_for_window", reinterpret_cast<PyCFunction>(WindowTabManager_GetForWindow), METH_VARARGS, nullptr },
        { "is_supported", reinterpret_cast<PyCFunction>(WindowTabManager_IsSupported), METH_VARARGS, nullptr },
        { "is_tab_tear_out_supported", reinterpret_cast<PyCFunction>(WindowTabManager_IsTabTearOutSupported), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_WindowTabManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_WindowTabManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_WindowTabManager_Static) },
        { }
    };

    static PyType_Spec type_spec_WindowTabManager_Static =
    {
        "winrt._winrt_windows_ui_shell.WindowTabManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_WindowTabManager_Static
    };

    // ----- WindowTabSwitchRequestedEventArgs class --------------------

    static PyObject* _new_WindowTabSwitchRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Shell::WindowTabSwitchRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Shell::WindowTabSwitchRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowTabSwitchRequestedEventArgs(py::wrapper::Windows::UI::Shell::WindowTabSwitchRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowTabSwitchRequestedEventArgs_get_Tab(py::wrapper::Windows::UI::Shell::WindowTabSwitchRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTabSwitchRequestedEventArgs", L"Tab"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Tab());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowTabSwitchRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::WindowTabSwitchRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowTabSwitchRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::WindowTabSwitchRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowTabSwitchRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_WindowTabSwitchRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowTabSwitchRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WindowTabSwitchRequestedEventArgs[] = {
        { "tab", reinterpret_cast<getter>(WindowTabSwitchRequestedEventArgs_get_Tab), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WindowTabSwitchRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowTabSwitchRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowTabSwitchRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowTabSwitchRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowTabSwitchRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WindowTabSwitchRequestedEventArgs =
    {
        "winrt._winrt_windows_ui_shell.WindowTabSwitchRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Shell::WindowTabSwitchRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowTabSwitchRequestedEventArgs
    };

    // ----- WindowTabTearOutRequestedEventArgs class --------------------

    static PyObject* _new_WindowTabTearOutRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Shell::WindowTabTearOutRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Shell::WindowTabTearOutRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowTabTearOutRequestedEventArgs(py::wrapper::Windows::UI::Shell::WindowTabTearOutRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowTabTearOutRequestedEventArgs_GetDeferral(py::wrapper::Windows::UI::Shell::WindowTabTearOutRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabTearOutRequestedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabTearOutRequestedEventArgs_get_WindowId(py::wrapper::Windows::UI::Shell::WindowTabTearOutRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTabTearOutRequestedEventArgs", L"WindowId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WindowId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowTabTearOutRequestedEventArgs_put_WindowId(py::wrapper::Windows::UI::Shell::WindowTabTearOutRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTabTearOutRequestedEventArgs", L"WindowId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.WindowId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowTabTearOutRequestedEventArgs_get_Tab(py::wrapper::Windows::UI::Shell::WindowTabTearOutRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTabTearOutRequestedEventArgs", L"Tab"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Tab());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowTabTearOutRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::WindowTabTearOutRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowTabTearOutRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::WindowTabTearOutRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowTabTearOutRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(WindowTabTearOutRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WindowTabTearOutRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowTabTearOutRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WindowTabTearOutRequestedEventArgs[] = {
        { "window_id", reinterpret_cast<getter>(WindowTabTearOutRequestedEventArgs_get_WindowId), reinterpret_cast<setter>(WindowTabTearOutRequestedEventArgs_put_WindowId), nullptr, nullptr },
        { "tab", reinterpret_cast<getter>(WindowTabTearOutRequestedEventArgs_get_Tab), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WindowTabTearOutRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowTabTearOutRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowTabTearOutRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowTabTearOutRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowTabTearOutRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WindowTabTearOutRequestedEventArgs =
    {
        "winrt._winrt_windows_ui_shell.WindowTabTearOutRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Shell::WindowTabTearOutRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowTabTearOutRequestedEventArgs
    };

    // ----- WindowTabThumbnailRequestedEventArgs class --------------------

    static PyObject* _new_WindowTabThumbnailRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Shell::WindowTabThumbnailRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Shell::WindowTabThumbnailRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowTabThumbnailRequestedEventArgs(py::wrapper::Windows::UI::Shell::WindowTabThumbnailRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowTabThumbnailRequestedEventArgs_GetDeferral(py::wrapper::Windows::UI::Shell::WindowTabThumbnailRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabThumbnailRequestedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabThumbnailRequestedEventArgs_get_Image(py::wrapper::Windows::UI::Shell::WindowTabThumbnailRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTabThumbnailRequestedEventArgs", L"Image"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Image());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowTabThumbnailRequestedEventArgs_put_Image(py::wrapper::Windows::UI::Shell::WindowTabThumbnailRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTabThumbnailRequestedEventArgs", L"Image"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.Image(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowTabThumbnailRequestedEventArgs_get_IsCompositedOnWindow(py::wrapper::Windows::UI::Shell::WindowTabThumbnailRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTabThumbnailRequestedEventArgs", L"IsCompositedOnWindow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCompositedOnWindow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowTabThumbnailRequestedEventArgs_get_RequestedSize(py::wrapper::Windows::UI::Shell::WindowTabThumbnailRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTabThumbnailRequestedEventArgs", L"RequestedSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestedSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowTabThumbnailRequestedEventArgs_get_Tab(py::wrapper::Windows::UI::Shell::WindowTabThumbnailRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTabThumbnailRequestedEventArgs", L"Tab"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Tab());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowTabThumbnailRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::WindowTabThumbnailRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowTabThumbnailRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::WindowTabThumbnailRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowTabThumbnailRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(WindowTabThumbnailRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WindowTabThumbnailRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowTabThumbnailRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WindowTabThumbnailRequestedEventArgs[] = {
        { "image", reinterpret_cast<getter>(WindowTabThumbnailRequestedEventArgs_get_Image), reinterpret_cast<setter>(WindowTabThumbnailRequestedEventArgs_put_Image), nullptr, nullptr },
        { "is_composited_on_window", reinterpret_cast<getter>(WindowTabThumbnailRequestedEventArgs_get_IsCompositedOnWindow), nullptr, nullptr, nullptr },
        { "requested_size", reinterpret_cast<getter>(WindowTabThumbnailRequestedEventArgs_get_RequestedSize), nullptr, nullptr, nullptr },
        { "tab", reinterpret_cast<getter>(WindowTabThumbnailRequestedEventArgs_get_Tab), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WindowTabThumbnailRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowTabThumbnailRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowTabThumbnailRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowTabThumbnailRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowTabThumbnailRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WindowTabThumbnailRequestedEventArgs =
    {
        "winrt._winrt_windows_ui_shell.WindowTabThumbnailRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Shell::WindowTabThumbnailRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowTabThumbnailRequestedEventArgs
    };

    // ----- IAdaptiveCard interface --------------------

    static PyObject* _new_IAdaptiveCard(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Shell::IAdaptiveCard>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Shell::IAdaptiveCard>::type_name);
        return nullptr;
    }

    static void _dealloc_IAdaptiveCard(py::wrapper::Windows::UI::Shell::IAdaptiveCard* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAdaptiveCard_ToJson(py::wrapper::Windows::UI::Shell::IAdaptiveCard* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.IAdaptiveCard", L"ToJson", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ToJson());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IAdaptiveCard(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::IAdaptiveCard>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAdaptiveCard(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::IAdaptiveCard>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAdaptiveCard[] = {
        { "to_json", reinterpret_cast<PyCFunction>(IAdaptiveCard_ToJson), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IAdaptiveCard, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAdaptiveCard), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAdaptiveCard[] = {
        { }
    };

    static PyType_Slot _type_slots_IAdaptiveCard[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAdaptiveCard) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAdaptiveCard) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAdaptiveCard) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAdaptiveCard) },
        { },
    };

    static PyType_Spec type_spec_IAdaptiveCard =
    {
        "winrt._winrt_windows_ui_shell.IAdaptiveCard",
        sizeof(py::wrapper::Windows::UI::Shell::IAdaptiveCard),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAdaptiveCard
    };

    // ----- IAdaptiveCardBuilderStatics interface --------------------

    static PyObject* _new_IAdaptiveCardBuilderStatics(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Shell::IAdaptiveCardBuilderStatics>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Shell::IAdaptiveCardBuilderStatics>::type_name);
        return nullptr;
    }

    static void _dealloc_IAdaptiveCardBuilderStatics(py::wrapper::Windows::UI::Shell::IAdaptiveCardBuilderStatics* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAdaptiveCardBuilderStatics_CreateAdaptiveCardFromJson(py::wrapper::Windows::UI::Shell::IAdaptiveCardBuilderStatics* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.IAdaptiveCardBuilderStatics", L"CreateAdaptiveCardFromJson", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateAdaptiveCardFromJson(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IAdaptiveCardBuilderStatics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::IAdaptiveCardBuilderStatics>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAdaptiveCardBuilderStatics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::IAdaptiveCardBuilderStatics>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAdaptiveCardBuilderStatics[] = {
        { "create_adaptive_card_from_json", reinterpret_cast<PyCFunction>(IAdaptiveCardBuilderStatics_CreateAdaptiveCardFromJson), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IAdaptiveCardBuilderStatics, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAdaptiveCardBuilderStatics), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAdaptiveCardBuilderStatics[] = {
        { }
    };

    static PyType_Slot _type_slots_IAdaptiveCardBuilderStatics[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAdaptiveCardBuilderStatics) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAdaptiveCardBuilderStatics) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAdaptiveCardBuilderStatics) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAdaptiveCardBuilderStatics) },
        { },
    };

    static PyType_Spec type_spec_IAdaptiveCardBuilderStatics =
    {
        "winrt._winrt_windows_ui_shell.IAdaptiveCardBuilderStatics",
        sizeof(py::wrapper::Windows::UI::Shell::IAdaptiveCardBuilderStatics),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAdaptiveCardBuilderStatics
    };

    // ----- Windows.UI.Shell Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::UI::Shell");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_ui_shell",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::UI::Shell

PyMODINIT_FUNC PyInit__winrt_windows_ui_shell(void) noexcept
{
    using namespace py::cpp::Windows::UI::Shell;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AdaptiveCardBuilder_Static{PyType_FromSpec(&type_spec_AdaptiveCardBuilder_Static)};
    if (!type_AdaptiveCardBuilder_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AdaptiveCardBuilder, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AdaptiveCardBuilder_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_FocusSession, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_FocusSessionManager_Static{PyType_FromSpec(&type_spec_FocusSessionManager_Static)};
    if (!type_FocusSessionManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_FocusSessionManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FocusSessionManager_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SecurityAppManager, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ShareWindowCommandEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ShareWindowCommandSource_Static{PyType_FromSpec(&type_spec_ShareWindowCommandSource_Static)};
    if (!type_ShareWindowCommandSource_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ShareWindowCommandSource, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ShareWindowCommandSource_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_TaskbarManager_Static{PyType_FromSpec(&type_spec_TaskbarManager_Static)};
    if (!type_TaskbarManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TaskbarManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TaskbarManager_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WindowTab, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WindowTabCloseRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WindowTabCollection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WindowTabGroup, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_WindowTabIcon_Static{PyType_FromSpec(&type_spec_WindowTabIcon_Static)};
    if (!type_WindowTabIcon_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WindowTabIcon, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_WindowTabIcon_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_WindowTabManager_Static{PyType_FromSpec(&type_spec_WindowTabManager_Static)};
    if (!type_WindowTabManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WindowTabManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_WindowTabManager_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WindowTabSwitchRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WindowTabTearOutRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WindowTabThumbnailRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IAdaptiveCard, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IAdaptiveCardBuilderStatics, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
