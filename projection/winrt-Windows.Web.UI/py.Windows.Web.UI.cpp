// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

#include "py.Windows.Web.UI.h"


namespace py::cpp::Windows::Web::UI
{
    // ----- WebViewControlContentLoadingEventArgs class --------------------

    static PyObject* _new_WebViewControlContentLoadingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::UI::WebViewControlContentLoadingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::UI::WebViewControlContentLoadingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebViewControlContentLoadingEventArgs(py::wrapper::Windows::Web::UI::WebViewControlContentLoadingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebViewControlContentLoadingEventArgs_get_Uri(py::wrapper::Windows::Web::UI::WebViewControlContentLoadingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlContentLoadingEventArgs", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebViewControlContentLoadingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::UI::WebViewControlContentLoadingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebViewControlContentLoadingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::UI::WebViewControlContentLoadingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebViewControlContentLoadingEventArgs[] = {
        { "_assign_array_", _assign_array_WebViewControlContentLoadingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebViewControlContentLoadingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebViewControlContentLoadingEventArgs[] = {
        { "uri", reinterpret_cast<getter>(WebViewControlContentLoadingEventArgs_get_Uri), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebViewControlContentLoadingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebViewControlContentLoadingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebViewControlContentLoadingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebViewControlContentLoadingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebViewControlContentLoadingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebViewControlContentLoadingEventArgs =
    {
        "winrt._winrt_windows_web_ui.WebViewControlContentLoadingEventArgs",
        sizeof(py::wrapper::Windows::Web::UI::WebViewControlContentLoadingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebViewControlContentLoadingEventArgs
    };

    // ----- WebViewControlDOMContentLoadedEventArgs class --------------------

    static PyObject* _new_WebViewControlDOMContentLoadedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::UI::WebViewControlDOMContentLoadedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::UI::WebViewControlDOMContentLoadedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebViewControlDOMContentLoadedEventArgs(py::wrapper::Windows::Web::UI::WebViewControlDOMContentLoadedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebViewControlDOMContentLoadedEventArgs_get_Uri(py::wrapper::Windows::Web::UI::WebViewControlDOMContentLoadedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlDOMContentLoadedEventArgs", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebViewControlDOMContentLoadedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::UI::WebViewControlDOMContentLoadedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebViewControlDOMContentLoadedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::UI::WebViewControlDOMContentLoadedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebViewControlDOMContentLoadedEventArgs[] = {
        { "_assign_array_", _assign_array_WebViewControlDOMContentLoadedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebViewControlDOMContentLoadedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebViewControlDOMContentLoadedEventArgs[] = {
        { "uri", reinterpret_cast<getter>(WebViewControlDOMContentLoadedEventArgs_get_Uri), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebViewControlDOMContentLoadedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebViewControlDOMContentLoadedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebViewControlDOMContentLoadedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebViewControlDOMContentLoadedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebViewControlDOMContentLoadedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebViewControlDOMContentLoadedEventArgs =
    {
        "winrt._winrt_windows_web_ui.WebViewControlDOMContentLoadedEventArgs",
        sizeof(py::wrapper::Windows::Web::UI::WebViewControlDOMContentLoadedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebViewControlDOMContentLoadedEventArgs
    };

    // ----- WebViewControlDeferredPermissionRequest class --------------------

    static PyObject* _new_WebViewControlDeferredPermissionRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::UI::WebViewControlDeferredPermissionRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::UI::WebViewControlDeferredPermissionRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_WebViewControlDeferredPermissionRequest(py::wrapper::Windows::Web::UI::WebViewControlDeferredPermissionRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebViewControlDeferredPermissionRequest_Allow(py::wrapper::Windows::Web::UI::WebViewControlDeferredPermissionRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.WebViewControlDeferredPermissionRequest", L"Allow", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Allow();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebViewControlDeferredPermissionRequest_Deny(py::wrapper::Windows::Web::UI::WebViewControlDeferredPermissionRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.WebViewControlDeferredPermissionRequest", L"Deny", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Deny();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebViewControlDeferredPermissionRequest_get_Id(py::wrapper::Windows::Web::UI::WebViewControlDeferredPermissionRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlDeferredPermissionRequest", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControlDeferredPermissionRequest_get_PermissionType(py::wrapper::Windows::Web::UI::WebViewControlDeferredPermissionRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlDeferredPermissionRequest", L"PermissionType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PermissionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControlDeferredPermissionRequest_get_Uri(py::wrapper::Windows::Web::UI::WebViewControlDeferredPermissionRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlDeferredPermissionRequest", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebViewControlDeferredPermissionRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::UI::WebViewControlDeferredPermissionRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebViewControlDeferredPermissionRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::UI::WebViewControlDeferredPermissionRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebViewControlDeferredPermissionRequest[] = {
        { "allow", reinterpret_cast<PyCFunction>(WebViewControlDeferredPermissionRequest_Allow), METH_VARARGS, nullptr },
        { "deny", reinterpret_cast<PyCFunction>(WebViewControlDeferredPermissionRequest_Deny), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WebViewControlDeferredPermissionRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebViewControlDeferredPermissionRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebViewControlDeferredPermissionRequest[] = {
        { "id", reinterpret_cast<getter>(WebViewControlDeferredPermissionRequest_get_Id), nullptr, nullptr, nullptr },
        { "permission_type", reinterpret_cast<getter>(WebViewControlDeferredPermissionRequest_get_PermissionType), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(WebViewControlDeferredPermissionRequest_get_Uri), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebViewControlDeferredPermissionRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebViewControlDeferredPermissionRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebViewControlDeferredPermissionRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebViewControlDeferredPermissionRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebViewControlDeferredPermissionRequest) },
        { },
    };

    static PyType_Spec type_spec_WebViewControlDeferredPermissionRequest =
    {
        "winrt._winrt_windows_web_ui.WebViewControlDeferredPermissionRequest",
        sizeof(py::wrapper::Windows::Web::UI::WebViewControlDeferredPermissionRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebViewControlDeferredPermissionRequest
    };

    // ----- WebViewControlLongRunningScriptDetectedEventArgs class --------------------

    static PyObject* _new_WebViewControlLongRunningScriptDetectedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::UI::WebViewControlLongRunningScriptDetectedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::UI::WebViewControlLongRunningScriptDetectedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebViewControlLongRunningScriptDetectedEventArgs(py::wrapper::Windows::Web::UI::WebViewControlLongRunningScriptDetectedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebViewControlLongRunningScriptDetectedEventArgs_get_StopPageScriptExecution(py::wrapper::Windows::Web::UI::WebViewControlLongRunningScriptDetectedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlLongRunningScriptDetectedEventArgs", L"StopPageScriptExecution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StopPageScriptExecution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WebViewControlLongRunningScriptDetectedEventArgs_put_StopPageScriptExecution(py::wrapper::Windows::Web::UI::WebViewControlLongRunningScriptDetectedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlLongRunningScriptDetectedEventArgs", L"StopPageScriptExecution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.StopPageScriptExecution(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WebViewControlLongRunningScriptDetectedEventArgs_get_ExecutionTime(py::wrapper::Windows::Web::UI::WebViewControlLongRunningScriptDetectedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlLongRunningScriptDetectedEventArgs", L"ExecutionTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExecutionTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebViewControlLongRunningScriptDetectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::UI::WebViewControlLongRunningScriptDetectedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebViewControlLongRunningScriptDetectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::UI::WebViewControlLongRunningScriptDetectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebViewControlLongRunningScriptDetectedEventArgs[] = {
        { "_assign_array_", _assign_array_WebViewControlLongRunningScriptDetectedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebViewControlLongRunningScriptDetectedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebViewControlLongRunningScriptDetectedEventArgs[] = {
        { "stop_page_script_execution", reinterpret_cast<getter>(WebViewControlLongRunningScriptDetectedEventArgs_get_StopPageScriptExecution), reinterpret_cast<setter>(WebViewControlLongRunningScriptDetectedEventArgs_put_StopPageScriptExecution), nullptr, nullptr },
        { "execution_time", reinterpret_cast<getter>(WebViewControlLongRunningScriptDetectedEventArgs_get_ExecutionTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebViewControlLongRunningScriptDetectedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebViewControlLongRunningScriptDetectedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebViewControlLongRunningScriptDetectedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebViewControlLongRunningScriptDetectedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebViewControlLongRunningScriptDetectedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebViewControlLongRunningScriptDetectedEventArgs =
    {
        "winrt._winrt_windows_web_ui.WebViewControlLongRunningScriptDetectedEventArgs",
        sizeof(py::wrapper::Windows::Web::UI::WebViewControlLongRunningScriptDetectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebViewControlLongRunningScriptDetectedEventArgs
    };

    // ----- WebViewControlNavigationCompletedEventArgs class --------------------

    static PyObject* _new_WebViewControlNavigationCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::UI::WebViewControlNavigationCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::UI::WebViewControlNavigationCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebViewControlNavigationCompletedEventArgs(py::wrapper::Windows::Web::UI::WebViewControlNavigationCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebViewControlNavigationCompletedEventArgs_get_IsSuccess(py::wrapper::Windows::Web::UI::WebViewControlNavigationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlNavigationCompletedEventArgs", L"IsSuccess"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSuccess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControlNavigationCompletedEventArgs_get_Uri(py::wrapper::Windows::Web::UI::WebViewControlNavigationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlNavigationCompletedEventArgs", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControlNavigationCompletedEventArgs_get_WebErrorStatus(py::wrapper::Windows::Web::UI::WebViewControlNavigationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlNavigationCompletedEventArgs", L"WebErrorStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WebErrorStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebViewControlNavigationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::UI::WebViewControlNavigationCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebViewControlNavigationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::UI::WebViewControlNavigationCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebViewControlNavigationCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_WebViewControlNavigationCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebViewControlNavigationCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebViewControlNavigationCompletedEventArgs[] = {
        { "is_success", reinterpret_cast<getter>(WebViewControlNavigationCompletedEventArgs_get_IsSuccess), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(WebViewControlNavigationCompletedEventArgs_get_Uri), nullptr, nullptr, nullptr },
        { "web_error_status", reinterpret_cast<getter>(WebViewControlNavigationCompletedEventArgs_get_WebErrorStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebViewControlNavigationCompletedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebViewControlNavigationCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebViewControlNavigationCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebViewControlNavigationCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebViewControlNavigationCompletedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebViewControlNavigationCompletedEventArgs =
    {
        "winrt._winrt_windows_web_ui.WebViewControlNavigationCompletedEventArgs",
        sizeof(py::wrapper::Windows::Web::UI::WebViewControlNavigationCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebViewControlNavigationCompletedEventArgs
    };

    // ----- WebViewControlNavigationStartingEventArgs class --------------------

    static PyObject* _new_WebViewControlNavigationStartingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::UI::WebViewControlNavigationStartingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::UI::WebViewControlNavigationStartingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebViewControlNavigationStartingEventArgs(py::wrapper::Windows::Web::UI::WebViewControlNavigationStartingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebViewControlNavigationStartingEventArgs_get_Cancel(py::wrapper::Windows::Web::UI::WebViewControlNavigationStartingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlNavigationStartingEventArgs", L"Cancel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Cancel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WebViewControlNavigationStartingEventArgs_put_Cancel(py::wrapper::Windows::Web::UI::WebViewControlNavigationStartingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlNavigationStartingEventArgs", L"Cancel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Cancel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WebViewControlNavigationStartingEventArgs_get_Uri(py::wrapper::Windows::Web::UI::WebViewControlNavigationStartingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlNavigationStartingEventArgs", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebViewControlNavigationStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::UI::WebViewControlNavigationStartingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebViewControlNavigationStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::UI::WebViewControlNavigationStartingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebViewControlNavigationStartingEventArgs[] = {
        { "_assign_array_", _assign_array_WebViewControlNavigationStartingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebViewControlNavigationStartingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebViewControlNavigationStartingEventArgs[] = {
        { "cancel", reinterpret_cast<getter>(WebViewControlNavigationStartingEventArgs_get_Cancel), reinterpret_cast<setter>(WebViewControlNavigationStartingEventArgs_put_Cancel), nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(WebViewControlNavigationStartingEventArgs_get_Uri), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebViewControlNavigationStartingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebViewControlNavigationStartingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebViewControlNavigationStartingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebViewControlNavigationStartingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebViewControlNavigationStartingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebViewControlNavigationStartingEventArgs =
    {
        "winrt._winrt_windows_web_ui.WebViewControlNavigationStartingEventArgs",
        sizeof(py::wrapper::Windows::Web::UI::WebViewControlNavigationStartingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebViewControlNavigationStartingEventArgs
    };

    // ----- WebViewControlNewWindowRequestedEventArgs class --------------------

    static PyObject* _new_WebViewControlNewWindowRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::UI::WebViewControlNewWindowRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::UI::WebViewControlNewWindowRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebViewControlNewWindowRequestedEventArgs(py::wrapper::Windows::Web::UI::WebViewControlNewWindowRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebViewControlNewWindowRequestedEventArgs_GetDeferral(py::wrapper::Windows::Web::UI::WebViewControlNewWindowRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.WebViewControlNewWindowRequestedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebViewControlNewWindowRequestedEventArgs_get_Handled(py::wrapper::Windows::Web::UI::WebViewControlNewWindowRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlNewWindowRequestedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WebViewControlNewWindowRequestedEventArgs_put_Handled(py::wrapper::Windows::Web::UI::WebViewControlNewWindowRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlNewWindowRequestedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WebViewControlNewWindowRequestedEventArgs_get_Referrer(py::wrapper::Windows::Web::UI::WebViewControlNewWindowRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlNewWindowRequestedEventArgs", L"Referrer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Referrer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControlNewWindowRequestedEventArgs_get_Uri(py::wrapper::Windows::Web::UI::WebViewControlNewWindowRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlNewWindowRequestedEventArgs", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControlNewWindowRequestedEventArgs_get_NewWindow(py::wrapper::Windows::Web::UI::WebViewControlNewWindowRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlNewWindowRequestedEventArgs", L"NewWindow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NewWindow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WebViewControlNewWindowRequestedEventArgs_put_NewWindow(py::wrapper::Windows::Web::UI::WebViewControlNewWindowRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlNewWindowRequestedEventArgs", L"NewWindow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Web::UI::IWebViewControl>(arg);

            self->obj.NewWindow(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_WebViewControlNewWindowRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::UI::WebViewControlNewWindowRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebViewControlNewWindowRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::UI::WebViewControlNewWindowRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebViewControlNewWindowRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(WebViewControlNewWindowRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WebViewControlNewWindowRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebViewControlNewWindowRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebViewControlNewWindowRequestedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(WebViewControlNewWindowRequestedEventArgs_get_Handled), reinterpret_cast<setter>(WebViewControlNewWindowRequestedEventArgs_put_Handled), nullptr, nullptr },
        { "referrer", reinterpret_cast<getter>(WebViewControlNewWindowRequestedEventArgs_get_Referrer), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(WebViewControlNewWindowRequestedEventArgs_get_Uri), nullptr, nullptr, nullptr },
        { "new_window", reinterpret_cast<getter>(WebViewControlNewWindowRequestedEventArgs_get_NewWindow), reinterpret_cast<setter>(WebViewControlNewWindowRequestedEventArgs_put_NewWindow), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebViewControlNewWindowRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebViewControlNewWindowRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebViewControlNewWindowRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebViewControlNewWindowRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebViewControlNewWindowRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebViewControlNewWindowRequestedEventArgs =
    {
        "winrt._winrt_windows_web_ui.WebViewControlNewWindowRequestedEventArgs",
        sizeof(py::wrapper::Windows::Web::UI::WebViewControlNewWindowRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebViewControlNewWindowRequestedEventArgs
    };

    // ----- WebViewControlPermissionRequest class --------------------

    static PyObject* _new_WebViewControlPermissionRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::UI::WebViewControlPermissionRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::UI::WebViewControlPermissionRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_WebViewControlPermissionRequest(py::wrapper::Windows::Web::UI::WebViewControlPermissionRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebViewControlPermissionRequest_Allow(py::wrapper::Windows::Web::UI::WebViewControlPermissionRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.WebViewControlPermissionRequest", L"Allow", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Allow();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebViewControlPermissionRequest_Defer(py::wrapper::Windows::Web::UI::WebViewControlPermissionRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.WebViewControlPermissionRequest", L"Defer", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Defer();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebViewControlPermissionRequest_Deny(py::wrapper::Windows::Web::UI::WebViewControlPermissionRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.WebViewControlPermissionRequest", L"Deny", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Deny();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebViewControlPermissionRequest_get_Id(py::wrapper::Windows::Web::UI::WebViewControlPermissionRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlPermissionRequest", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControlPermissionRequest_get_PermissionType(py::wrapper::Windows::Web::UI::WebViewControlPermissionRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlPermissionRequest", L"PermissionType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PermissionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControlPermissionRequest_get_State(py::wrapper::Windows::Web::UI::WebViewControlPermissionRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlPermissionRequest", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControlPermissionRequest_get_Uri(py::wrapper::Windows::Web::UI::WebViewControlPermissionRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlPermissionRequest", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebViewControlPermissionRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::UI::WebViewControlPermissionRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebViewControlPermissionRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::UI::WebViewControlPermissionRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebViewControlPermissionRequest[] = {
        { "allow", reinterpret_cast<PyCFunction>(WebViewControlPermissionRequest_Allow), METH_VARARGS, nullptr },
        { "defer", reinterpret_cast<PyCFunction>(WebViewControlPermissionRequest_Defer), METH_VARARGS, nullptr },
        { "deny", reinterpret_cast<PyCFunction>(WebViewControlPermissionRequest_Deny), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WebViewControlPermissionRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebViewControlPermissionRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebViewControlPermissionRequest[] = {
        { "id", reinterpret_cast<getter>(WebViewControlPermissionRequest_get_Id), nullptr, nullptr, nullptr },
        { "permission_type", reinterpret_cast<getter>(WebViewControlPermissionRequest_get_PermissionType), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(WebViewControlPermissionRequest_get_State), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(WebViewControlPermissionRequest_get_Uri), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebViewControlPermissionRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebViewControlPermissionRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebViewControlPermissionRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebViewControlPermissionRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebViewControlPermissionRequest) },
        { },
    };

    static PyType_Spec type_spec_WebViewControlPermissionRequest =
    {
        "winrt._winrt_windows_web_ui.WebViewControlPermissionRequest",
        sizeof(py::wrapper::Windows::Web::UI::WebViewControlPermissionRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebViewControlPermissionRequest
    };

    // ----- WebViewControlPermissionRequestedEventArgs class --------------------

    static PyObject* _new_WebViewControlPermissionRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::UI::WebViewControlPermissionRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::UI::WebViewControlPermissionRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebViewControlPermissionRequestedEventArgs(py::wrapper::Windows::Web::UI::WebViewControlPermissionRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebViewControlPermissionRequestedEventArgs_get_PermissionRequest(py::wrapper::Windows::Web::UI::WebViewControlPermissionRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlPermissionRequestedEventArgs", L"PermissionRequest"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PermissionRequest());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebViewControlPermissionRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::UI::WebViewControlPermissionRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebViewControlPermissionRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::UI::WebViewControlPermissionRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebViewControlPermissionRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_WebViewControlPermissionRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebViewControlPermissionRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebViewControlPermissionRequestedEventArgs[] = {
        { "permission_request", reinterpret_cast<getter>(WebViewControlPermissionRequestedEventArgs_get_PermissionRequest), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebViewControlPermissionRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebViewControlPermissionRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebViewControlPermissionRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebViewControlPermissionRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebViewControlPermissionRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebViewControlPermissionRequestedEventArgs =
    {
        "winrt._winrt_windows_web_ui.WebViewControlPermissionRequestedEventArgs",
        sizeof(py::wrapper::Windows::Web::UI::WebViewControlPermissionRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebViewControlPermissionRequestedEventArgs
    };

    // ----- WebViewControlScriptNotifyEventArgs class --------------------

    static PyObject* _new_WebViewControlScriptNotifyEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::UI::WebViewControlScriptNotifyEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::UI::WebViewControlScriptNotifyEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebViewControlScriptNotifyEventArgs(py::wrapper::Windows::Web::UI::WebViewControlScriptNotifyEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebViewControlScriptNotifyEventArgs_get_Uri(py::wrapper::Windows::Web::UI::WebViewControlScriptNotifyEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlScriptNotifyEventArgs", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControlScriptNotifyEventArgs_get_Value(py::wrapper::Windows::Web::UI::WebViewControlScriptNotifyEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlScriptNotifyEventArgs", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebViewControlScriptNotifyEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::UI::WebViewControlScriptNotifyEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebViewControlScriptNotifyEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::UI::WebViewControlScriptNotifyEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebViewControlScriptNotifyEventArgs[] = {
        { "_assign_array_", _assign_array_WebViewControlScriptNotifyEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebViewControlScriptNotifyEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebViewControlScriptNotifyEventArgs[] = {
        { "uri", reinterpret_cast<getter>(WebViewControlScriptNotifyEventArgs_get_Uri), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(WebViewControlScriptNotifyEventArgs_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebViewControlScriptNotifyEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebViewControlScriptNotifyEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebViewControlScriptNotifyEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebViewControlScriptNotifyEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebViewControlScriptNotifyEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebViewControlScriptNotifyEventArgs =
    {
        "winrt._winrt_windows_web_ui.WebViewControlScriptNotifyEventArgs",
        sizeof(py::wrapper::Windows::Web::UI::WebViewControlScriptNotifyEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebViewControlScriptNotifyEventArgs
    };

    // ----- WebViewControlSettings class --------------------

    static PyObject* _new_WebViewControlSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::UI::WebViewControlSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::UI::WebViewControlSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_WebViewControlSettings(py::wrapper::Windows::Web::UI::WebViewControlSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebViewControlSettings_get_IsScriptNotifyAllowed(py::wrapper::Windows::Web::UI::WebViewControlSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlSettings", L"IsScriptNotifyAllowed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsScriptNotifyAllowed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WebViewControlSettings_put_IsScriptNotifyAllowed(py::wrapper::Windows::Web::UI::WebViewControlSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlSettings", L"IsScriptNotifyAllowed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsScriptNotifyAllowed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WebViewControlSettings_get_IsJavaScriptEnabled(py::wrapper::Windows::Web::UI::WebViewControlSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlSettings", L"IsJavaScriptEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsJavaScriptEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WebViewControlSettings_put_IsJavaScriptEnabled(py::wrapper::Windows::Web::UI::WebViewControlSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlSettings", L"IsJavaScriptEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsJavaScriptEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WebViewControlSettings_get_IsIndexedDBEnabled(py::wrapper::Windows::Web::UI::WebViewControlSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlSettings", L"IsIndexedDBEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsIndexedDBEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WebViewControlSettings_put_IsIndexedDBEnabled(py::wrapper::Windows::Web::UI::WebViewControlSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlSettings", L"IsIndexedDBEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsIndexedDBEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_WebViewControlSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::UI::WebViewControlSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebViewControlSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::UI::WebViewControlSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebViewControlSettings[] = {
        { "_assign_array_", _assign_array_WebViewControlSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebViewControlSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebViewControlSettings[] = {
        { "is_script_notify_allowed", reinterpret_cast<getter>(WebViewControlSettings_get_IsScriptNotifyAllowed), reinterpret_cast<setter>(WebViewControlSettings_put_IsScriptNotifyAllowed), nullptr, nullptr },
        { "is_java_script_enabled", reinterpret_cast<getter>(WebViewControlSettings_get_IsJavaScriptEnabled), reinterpret_cast<setter>(WebViewControlSettings_put_IsJavaScriptEnabled), nullptr, nullptr },
        { "is_indexed_d_b_enabled", reinterpret_cast<getter>(WebViewControlSettings_get_IsIndexedDBEnabled), reinterpret_cast<setter>(WebViewControlSettings_put_IsIndexedDBEnabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebViewControlSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebViewControlSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebViewControlSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebViewControlSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebViewControlSettings) },
        { },
    };

    static PyType_Spec type_spec_WebViewControlSettings =
    {
        "winrt._winrt_windows_web_ui.WebViewControlSettings",
        sizeof(py::wrapper::Windows::Web::UI::WebViewControlSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebViewControlSettings
    };

    // ----- WebViewControlUnsupportedUriSchemeIdentifiedEventArgs class --------------------

    static PyObject* _new_WebViewControlUnsupportedUriSchemeIdentifiedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::UI::WebViewControlUnsupportedUriSchemeIdentifiedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::UI::WebViewControlUnsupportedUriSchemeIdentifiedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebViewControlUnsupportedUriSchemeIdentifiedEventArgs(py::wrapper::Windows::Web::UI::WebViewControlUnsupportedUriSchemeIdentifiedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebViewControlUnsupportedUriSchemeIdentifiedEventArgs_get_Handled(py::wrapper::Windows::Web::UI::WebViewControlUnsupportedUriSchemeIdentifiedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlUnsupportedUriSchemeIdentifiedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WebViewControlUnsupportedUriSchemeIdentifiedEventArgs_put_Handled(py::wrapper::Windows::Web::UI::WebViewControlUnsupportedUriSchemeIdentifiedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlUnsupportedUriSchemeIdentifiedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WebViewControlUnsupportedUriSchemeIdentifiedEventArgs_get_Uri(py::wrapper::Windows::Web::UI::WebViewControlUnsupportedUriSchemeIdentifiedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlUnsupportedUriSchemeIdentifiedEventArgs", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebViewControlUnsupportedUriSchemeIdentifiedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::UI::WebViewControlUnsupportedUriSchemeIdentifiedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebViewControlUnsupportedUriSchemeIdentifiedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::UI::WebViewControlUnsupportedUriSchemeIdentifiedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebViewControlUnsupportedUriSchemeIdentifiedEventArgs[] = {
        { "_assign_array_", _assign_array_WebViewControlUnsupportedUriSchemeIdentifiedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebViewControlUnsupportedUriSchemeIdentifiedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebViewControlUnsupportedUriSchemeIdentifiedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(WebViewControlUnsupportedUriSchemeIdentifiedEventArgs_get_Handled), reinterpret_cast<setter>(WebViewControlUnsupportedUriSchemeIdentifiedEventArgs_put_Handled), nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(WebViewControlUnsupportedUriSchemeIdentifiedEventArgs_get_Uri), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebViewControlUnsupportedUriSchemeIdentifiedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebViewControlUnsupportedUriSchemeIdentifiedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebViewControlUnsupportedUriSchemeIdentifiedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebViewControlUnsupportedUriSchemeIdentifiedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebViewControlUnsupportedUriSchemeIdentifiedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebViewControlUnsupportedUriSchemeIdentifiedEventArgs =
    {
        "winrt._winrt_windows_web_ui.WebViewControlUnsupportedUriSchemeIdentifiedEventArgs",
        sizeof(py::wrapper::Windows::Web::UI::WebViewControlUnsupportedUriSchemeIdentifiedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebViewControlUnsupportedUriSchemeIdentifiedEventArgs
    };

    // ----- WebViewControlUnviewableContentIdentifiedEventArgs class --------------------

    static PyObject* _new_WebViewControlUnviewableContentIdentifiedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::UI::WebViewControlUnviewableContentIdentifiedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::UI::WebViewControlUnviewableContentIdentifiedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebViewControlUnviewableContentIdentifiedEventArgs(py::wrapper::Windows::Web::UI::WebViewControlUnviewableContentIdentifiedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebViewControlUnviewableContentIdentifiedEventArgs_get_MediaType(py::wrapper::Windows::Web::UI::WebViewControlUnviewableContentIdentifiedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlUnviewableContentIdentifiedEventArgs", L"MediaType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MediaType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControlUnviewableContentIdentifiedEventArgs_get_Referrer(py::wrapper::Windows::Web::UI::WebViewControlUnviewableContentIdentifiedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlUnviewableContentIdentifiedEventArgs", L"Referrer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Referrer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControlUnviewableContentIdentifiedEventArgs_get_Uri(py::wrapper::Windows::Web::UI::WebViewControlUnviewableContentIdentifiedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlUnviewableContentIdentifiedEventArgs", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebViewControlUnviewableContentIdentifiedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::UI::WebViewControlUnviewableContentIdentifiedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebViewControlUnviewableContentIdentifiedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::UI::WebViewControlUnviewableContentIdentifiedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebViewControlUnviewableContentIdentifiedEventArgs[] = {
        { "_assign_array_", _assign_array_WebViewControlUnviewableContentIdentifiedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebViewControlUnviewableContentIdentifiedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebViewControlUnviewableContentIdentifiedEventArgs[] = {
        { "media_type", reinterpret_cast<getter>(WebViewControlUnviewableContentIdentifiedEventArgs_get_MediaType), nullptr, nullptr, nullptr },
        { "referrer", reinterpret_cast<getter>(WebViewControlUnviewableContentIdentifiedEventArgs_get_Referrer), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(WebViewControlUnviewableContentIdentifiedEventArgs_get_Uri), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebViewControlUnviewableContentIdentifiedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebViewControlUnviewableContentIdentifiedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebViewControlUnviewableContentIdentifiedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebViewControlUnviewableContentIdentifiedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebViewControlUnviewableContentIdentifiedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebViewControlUnviewableContentIdentifiedEventArgs =
    {
        "winrt._winrt_windows_web_ui.WebViewControlUnviewableContentIdentifiedEventArgs",
        sizeof(py::wrapper::Windows::Web::UI::WebViewControlUnviewableContentIdentifiedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebViewControlUnviewableContentIdentifiedEventArgs
    };

    // ----- WebViewControlWebResourceRequestedEventArgs class --------------------

    static PyObject* _new_WebViewControlWebResourceRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::UI::WebViewControlWebResourceRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::UI::WebViewControlWebResourceRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebViewControlWebResourceRequestedEventArgs(py::wrapper::Windows::Web::UI::WebViewControlWebResourceRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebViewControlWebResourceRequestedEventArgs_GetDeferral(py::wrapper::Windows::Web::UI::WebViewControlWebResourceRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.WebViewControlWebResourceRequestedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebViewControlWebResourceRequestedEventArgs_get_Response(py::wrapper::Windows::Web::UI::WebViewControlWebResourceRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlWebResourceRequestedEventArgs", L"Response"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Response());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WebViewControlWebResourceRequestedEventArgs_put_Response(py::wrapper::Windows::Web::UI::WebViewControlWebResourceRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlWebResourceRequestedEventArgs", L"Response"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpResponseMessage>(arg);

            self->obj.Response(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WebViewControlWebResourceRequestedEventArgs_get_Request(py::wrapper::Windows::Web::UI::WebViewControlWebResourceRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.WebViewControlWebResourceRequestedEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebViewControlWebResourceRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::UI::WebViewControlWebResourceRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebViewControlWebResourceRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::UI::WebViewControlWebResourceRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebViewControlWebResourceRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(WebViewControlWebResourceRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WebViewControlWebResourceRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebViewControlWebResourceRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebViewControlWebResourceRequestedEventArgs[] = {
        { "response", reinterpret_cast<getter>(WebViewControlWebResourceRequestedEventArgs_get_Response), reinterpret_cast<setter>(WebViewControlWebResourceRequestedEventArgs_put_Response), nullptr, nullptr },
        { "request", reinterpret_cast<getter>(WebViewControlWebResourceRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebViewControlWebResourceRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebViewControlWebResourceRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebViewControlWebResourceRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebViewControlWebResourceRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebViewControlWebResourceRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WebViewControlWebResourceRequestedEventArgs =
    {
        "winrt._winrt_windows_web_ui.WebViewControlWebResourceRequestedEventArgs",
        sizeof(py::wrapper::Windows::Web::UI::WebViewControlWebResourceRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebViewControlWebResourceRequestedEventArgs
    };

    // ----- IWebViewControl interface --------------------

    static PyObject* _new_IWebViewControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::UI::IWebViewControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::UI::IWebViewControl>::type_name);
        return nullptr;
    }

    static void _dealloc_IWebViewControl(py::wrapper::Windows::Web::UI::IWebViewControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWebViewControl_BuildLocalStreamUri(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.IWebViewControl", L"BuildLocalStreamUri", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.BuildLocalStreamUri(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_CapturePreviewToStreamAsync(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.IWebViewControl", L"CapturePreviewToStreamAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

                return py::convert(self->obj.CapturePreviewToStreamAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_CaptureSelectedContentToDataPackageAsync(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.IWebViewControl", L"CaptureSelectedContentToDataPackageAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CaptureSelectedContentToDataPackageAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_GetDeferredPermissionRequestById(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.IWebViewControl", L"GetDeferredPermissionRequestById", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                winrt::Windows::Web::UI::WebViewControlDeferredPermissionRequest param1 { nullptr };

                self->obj.GetDeferredPermissionRequestById(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_GoBack(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.IWebViewControl", L"GoBack", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.GoBack();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_GoForward(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.IWebViewControl", L"GoForward", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.GoForward();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_InvokeScriptAsync(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.IWebViewControl", L"InvokeScriptAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(self->obj.InvokeScriptAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_Navigate(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.IWebViewControl", L"Navigate", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                self->obj.Navigate(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_NavigateToLocalStreamUri(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.IWebViewControl", L"NavigateToLocalStreamUri", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::IUriToStreamResolver>(args, 1);

                self->obj.NavigateToLocalStreamUri(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_NavigateToString(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.IWebViewControl", L"NavigateToString", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.NavigateToString(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_NavigateWithHttpRequestMessage(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.IWebViewControl", L"NavigateWithHttpRequestMessage", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpRequestMessage>(args, 0);

                self->obj.NavigateWithHttpRequestMessage(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_Refresh(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.IWebViewControl", L"Refresh", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Refresh();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_Stop(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.IWebViewControl", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_get_CanGoBack(py::wrapper::Windows::Web::UI::IWebViewControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.IWebViewControl", L"CanGoBack"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanGoBack());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_get_CanGoForward(py::wrapper::Windows::Web::UI::IWebViewControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.IWebViewControl", L"CanGoForward"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanGoForward());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_get_ContainsFullScreenElement(py::wrapper::Windows::Web::UI::IWebViewControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.IWebViewControl", L"ContainsFullScreenElement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContainsFullScreenElement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_get_DefaultBackgroundColor(py::wrapper::Windows::Web::UI::IWebViewControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.IWebViewControl", L"DefaultBackgroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultBackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IWebViewControl_put_DefaultBackgroundColor(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.IWebViewControl", L"DefaultBackgroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.DefaultBackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IWebViewControl_get_DeferredPermissionRequests(py::wrapper::Windows::Web::UI::IWebViewControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.IWebViewControl", L"DeferredPermissionRequests"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeferredPermissionRequests());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_get_DocumentTitle(py::wrapper::Windows::Web::UI::IWebViewControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.IWebViewControl", L"DocumentTitle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DocumentTitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_get_Settings(py::wrapper::Windows::Web::UI::IWebViewControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.IWebViewControl", L"Settings"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Settings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_get_Source(py::wrapper::Windows::Web::UI::IWebViewControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.IWebViewControl", L"Source"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IWebViewControl_put_Source(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.IWebViewControl", L"Source"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Source(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IWebViewControl_add_ContainsFullScreenElementChanged(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"ContainsFullScreenElementChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ContainsFullScreenElementChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_remove_ContainsFullScreenElementChanged(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"ContainsFullScreenElementChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ContainsFullScreenElementChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_add_ContentLoading(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"ContentLoading"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlContentLoadingEventArgs>>(arg);

            return py::convert(self->obj.ContentLoading(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_remove_ContentLoading(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"ContentLoading"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ContentLoading(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_add_DOMContentLoaded(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"DOMContentLoaded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlDOMContentLoadedEventArgs>>(arg);

            return py::convert(self->obj.DOMContentLoaded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_remove_DOMContentLoaded(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"DOMContentLoaded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DOMContentLoaded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_add_FrameContentLoading(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"FrameContentLoading"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlContentLoadingEventArgs>>(arg);

            return py::convert(self->obj.FrameContentLoading(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_remove_FrameContentLoading(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"FrameContentLoading"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FrameContentLoading(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_add_FrameDOMContentLoaded(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"FrameDOMContentLoaded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlDOMContentLoadedEventArgs>>(arg);

            return py::convert(self->obj.FrameDOMContentLoaded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_remove_FrameDOMContentLoaded(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"FrameDOMContentLoaded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FrameDOMContentLoaded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_add_FrameNavigationCompleted(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"FrameNavigationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlNavigationCompletedEventArgs>>(arg);

            return py::convert(self->obj.FrameNavigationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_remove_FrameNavigationCompleted(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"FrameNavigationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FrameNavigationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_add_FrameNavigationStarting(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"FrameNavigationStarting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlNavigationStartingEventArgs>>(arg);

            return py::convert(self->obj.FrameNavigationStarting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_remove_FrameNavigationStarting(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"FrameNavigationStarting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FrameNavigationStarting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_add_LongRunningScriptDetected(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"LongRunningScriptDetected"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlLongRunningScriptDetectedEventArgs>>(arg);

            return py::convert(self->obj.LongRunningScriptDetected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_remove_LongRunningScriptDetected(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"LongRunningScriptDetected"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LongRunningScriptDetected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_add_NavigationCompleted(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"NavigationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlNavigationCompletedEventArgs>>(arg);

            return py::convert(self->obj.NavigationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_remove_NavigationCompleted(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"NavigationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NavigationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_add_NavigationStarting(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"NavigationStarting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlNavigationStartingEventArgs>>(arg);

            return py::convert(self->obj.NavigationStarting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_remove_NavigationStarting(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"NavigationStarting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NavigationStarting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_add_NewWindowRequested(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"NewWindowRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlNewWindowRequestedEventArgs>>(arg);

            return py::convert(self->obj.NewWindowRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_remove_NewWindowRequested(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"NewWindowRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NewWindowRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_add_PermissionRequested(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"PermissionRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlPermissionRequestedEventArgs>>(arg);

            return py::convert(self->obj.PermissionRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_remove_PermissionRequested(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"PermissionRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PermissionRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_add_ScriptNotify(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"ScriptNotify"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlScriptNotifyEventArgs>>(arg);

            return py::convert(self->obj.ScriptNotify(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_remove_ScriptNotify(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"ScriptNotify"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ScriptNotify(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_add_UnsafeContentWarningDisplaying(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"UnsafeContentWarningDisplaying"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.UnsafeContentWarningDisplaying(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_remove_UnsafeContentWarningDisplaying(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"UnsafeContentWarningDisplaying"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UnsafeContentWarningDisplaying(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_add_UnsupportedUriSchemeIdentified(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"UnsupportedUriSchemeIdentified"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlUnsupportedUriSchemeIdentifiedEventArgs>>(arg);

            return py::convert(self->obj.UnsupportedUriSchemeIdentified(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_remove_UnsupportedUriSchemeIdentified(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"UnsupportedUriSchemeIdentified"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UnsupportedUriSchemeIdentified(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_add_UnviewableContentIdentified(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"UnviewableContentIdentified"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlUnviewableContentIdentifiedEventArgs>>(arg);

            return py::convert(self->obj.UnviewableContentIdentified(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_remove_UnviewableContentIdentified(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"UnviewableContentIdentified"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UnviewableContentIdentified(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_add_WebResourceRequested(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"WebResourceRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlWebResourceRequestedEventArgs>>(arg);

            return py::convert(self->obj.WebResourceRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebViewControl_remove_WebResourceRequested(py::wrapper::Windows::Web::UI::IWebViewControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.IWebViewControl", L"WebResourceRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.WebResourceRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IWebViewControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::UI::IWebViewControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWebViewControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::UI::IWebViewControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWebViewControl[] = {
        { "build_local_stream_uri", reinterpret_cast<PyCFunction>(IWebViewControl_BuildLocalStreamUri), METH_VARARGS, nullptr },
        { "capture_preview_to_stream_async", reinterpret_cast<PyCFunction>(IWebViewControl_CapturePreviewToStreamAsync), METH_VARARGS, nullptr },
        { "capture_selected_content_to_data_package_async", reinterpret_cast<PyCFunction>(IWebViewControl_CaptureSelectedContentToDataPackageAsync), METH_VARARGS, nullptr },
        { "get_deferred_permission_request_by_id", reinterpret_cast<PyCFunction>(IWebViewControl_GetDeferredPermissionRequestById), METH_VARARGS, nullptr },
        { "go_back", reinterpret_cast<PyCFunction>(IWebViewControl_GoBack), METH_VARARGS, nullptr },
        { "go_forward", reinterpret_cast<PyCFunction>(IWebViewControl_GoForward), METH_VARARGS, nullptr },
        { "invoke_script_async", reinterpret_cast<PyCFunction>(IWebViewControl_InvokeScriptAsync), METH_VARARGS, nullptr },
        { "navigate", reinterpret_cast<PyCFunction>(IWebViewControl_Navigate), METH_VARARGS, nullptr },
        { "navigate_to_local_stream_uri", reinterpret_cast<PyCFunction>(IWebViewControl_NavigateToLocalStreamUri), METH_VARARGS, nullptr },
        { "navigate_to_string", reinterpret_cast<PyCFunction>(IWebViewControl_NavigateToString), METH_VARARGS, nullptr },
        { "navigate_with_http_request_message", reinterpret_cast<PyCFunction>(IWebViewControl_NavigateWithHttpRequestMessage), METH_VARARGS, nullptr },
        { "refresh", reinterpret_cast<PyCFunction>(IWebViewControl_Refresh), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(IWebViewControl_Stop), METH_VARARGS, nullptr },
        { "add_contains_full_screen_element_changed", reinterpret_cast<PyCFunction>(IWebViewControl_add_ContainsFullScreenElementChanged), METH_O, nullptr },
        { "remove_contains_full_screen_element_changed", reinterpret_cast<PyCFunction>(IWebViewControl_remove_ContainsFullScreenElementChanged), METH_O, nullptr },
        { "add_content_loading", reinterpret_cast<PyCFunction>(IWebViewControl_add_ContentLoading), METH_O, nullptr },
        { "remove_content_loading", reinterpret_cast<PyCFunction>(IWebViewControl_remove_ContentLoading), METH_O, nullptr },
        { "add_d_o_m_content_loaded", reinterpret_cast<PyCFunction>(IWebViewControl_add_DOMContentLoaded), METH_O, nullptr },
        { "remove_d_o_m_content_loaded", reinterpret_cast<PyCFunction>(IWebViewControl_remove_DOMContentLoaded), METH_O, nullptr },
        { "add_frame_content_loading", reinterpret_cast<PyCFunction>(IWebViewControl_add_FrameContentLoading), METH_O, nullptr },
        { "remove_frame_content_loading", reinterpret_cast<PyCFunction>(IWebViewControl_remove_FrameContentLoading), METH_O, nullptr },
        { "add_frame_d_o_m_content_loaded", reinterpret_cast<PyCFunction>(IWebViewControl_add_FrameDOMContentLoaded), METH_O, nullptr },
        { "remove_frame_d_o_m_content_loaded", reinterpret_cast<PyCFunction>(IWebViewControl_remove_FrameDOMContentLoaded), METH_O, nullptr },
        { "add_frame_navigation_completed", reinterpret_cast<PyCFunction>(IWebViewControl_add_FrameNavigationCompleted), METH_O, nullptr },
        { "remove_frame_navigation_completed", reinterpret_cast<PyCFunction>(IWebViewControl_remove_FrameNavigationCompleted), METH_O, nullptr },
        { "add_frame_navigation_starting", reinterpret_cast<PyCFunction>(IWebViewControl_add_FrameNavigationStarting), METH_O, nullptr },
        { "remove_frame_navigation_starting", reinterpret_cast<PyCFunction>(IWebViewControl_remove_FrameNavigationStarting), METH_O, nullptr },
        { "add_long_running_script_detected", reinterpret_cast<PyCFunction>(IWebViewControl_add_LongRunningScriptDetected), METH_O, nullptr },
        { "remove_long_running_script_detected", reinterpret_cast<PyCFunction>(IWebViewControl_remove_LongRunningScriptDetected), METH_O, nullptr },
        { "add_navigation_completed", reinterpret_cast<PyCFunction>(IWebViewControl_add_NavigationCompleted), METH_O, nullptr },
        { "remove_navigation_completed", reinterpret_cast<PyCFunction>(IWebViewControl_remove_NavigationCompleted), METH_O, nullptr },
        { "add_navigation_starting", reinterpret_cast<PyCFunction>(IWebViewControl_add_NavigationStarting), METH_O, nullptr },
        { "remove_navigation_starting", reinterpret_cast<PyCFunction>(IWebViewControl_remove_NavigationStarting), METH_O, nullptr },
        { "add_new_window_requested", reinterpret_cast<PyCFunction>(IWebViewControl_add_NewWindowRequested), METH_O, nullptr },
        { "remove_new_window_requested", reinterpret_cast<PyCFunction>(IWebViewControl_remove_NewWindowRequested), METH_O, nullptr },
        { "add_permission_requested", reinterpret_cast<PyCFunction>(IWebViewControl_add_PermissionRequested), METH_O, nullptr },
        { "remove_permission_requested", reinterpret_cast<PyCFunction>(IWebViewControl_remove_PermissionRequested), METH_O, nullptr },
        { "add_script_notify", reinterpret_cast<PyCFunction>(IWebViewControl_add_ScriptNotify), METH_O, nullptr },
        { "remove_script_notify", reinterpret_cast<PyCFunction>(IWebViewControl_remove_ScriptNotify), METH_O, nullptr },
        { "add_unsafe_content_warning_displaying", reinterpret_cast<PyCFunction>(IWebViewControl_add_UnsafeContentWarningDisplaying), METH_O, nullptr },
        { "remove_unsafe_content_warning_displaying", reinterpret_cast<PyCFunction>(IWebViewControl_remove_UnsafeContentWarningDisplaying), METH_O, nullptr },
        { "add_unsupported_uri_scheme_identified", reinterpret_cast<PyCFunction>(IWebViewControl_add_UnsupportedUriSchemeIdentified), METH_O, nullptr },
        { "remove_unsupported_uri_scheme_identified", reinterpret_cast<PyCFunction>(IWebViewControl_remove_UnsupportedUriSchemeIdentified), METH_O, nullptr },
        { "add_unviewable_content_identified", reinterpret_cast<PyCFunction>(IWebViewControl_add_UnviewableContentIdentified), METH_O, nullptr },
        { "remove_unviewable_content_identified", reinterpret_cast<PyCFunction>(IWebViewControl_remove_UnviewableContentIdentified), METH_O, nullptr },
        { "add_web_resource_requested", reinterpret_cast<PyCFunction>(IWebViewControl_add_WebResourceRequested), METH_O, nullptr },
        { "remove_web_resource_requested", reinterpret_cast<PyCFunction>(IWebViewControl_remove_WebResourceRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_IWebViewControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWebViewControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IWebViewControl[] = {
        { "can_go_back", reinterpret_cast<getter>(IWebViewControl_get_CanGoBack), nullptr, nullptr, nullptr },
        { "can_go_forward", reinterpret_cast<getter>(IWebViewControl_get_CanGoForward), nullptr, nullptr, nullptr },
        { "contains_full_screen_element", reinterpret_cast<getter>(IWebViewControl_get_ContainsFullScreenElement), nullptr, nullptr, nullptr },
        { "default_background_color", reinterpret_cast<getter>(IWebViewControl_get_DefaultBackgroundColor), reinterpret_cast<setter>(IWebViewControl_put_DefaultBackgroundColor), nullptr, nullptr },
        { "deferred_permission_requests", reinterpret_cast<getter>(IWebViewControl_get_DeferredPermissionRequests), nullptr, nullptr, nullptr },
        { "document_title", reinterpret_cast<getter>(IWebViewControl_get_DocumentTitle), nullptr, nullptr, nullptr },
        { "settings", reinterpret_cast<getter>(IWebViewControl_get_Settings), nullptr, nullptr, nullptr },
        { "source", reinterpret_cast<getter>(IWebViewControl_get_Source), reinterpret_cast<setter>(IWebViewControl_put_Source), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IWebViewControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IWebViewControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWebViewControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWebViewControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWebViewControl) },
        { },
    };

    static PyType_Spec type_spec_IWebViewControl =
    {
        "winrt._winrt_windows_web_ui.IWebViewControl",
        sizeof(py::wrapper::Windows::Web::UI::IWebViewControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWebViewControl
    };

    // ----- IWebViewControl2 interface --------------------

    static PyObject* _new_IWebViewControl2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::UI::IWebViewControl2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::UI::IWebViewControl2>::type_name);
        return nullptr;
    }

    static void _dealloc_IWebViewControl2(py::wrapper::Windows::Web::UI::IWebViewControl2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWebViewControl2_AddInitializeScript(py::wrapper::Windows::Web::UI::IWebViewControl2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.IWebViewControl2", L"AddInitializeScript", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.AddInitializeScript(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IWebViewControl2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::UI::IWebViewControl2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWebViewControl2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::UI::IWebViewControl2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWebViewControl2[] = {
        { "add_initialize_script", reinterpret_cast<PyCFunction>(IWebViewControl2_AddInitializeScript), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IWebViewControl2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWebViewControl2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IWebViewControl2[] = {
        { }
    };

    static PyType_Slot _type_slots_IWebViewControl2[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IWebViewControl2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWebViewControl2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWebViewControl2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWebViewControl2) },
        { },
    };

    static PyType_Spec type_spec_IWebViewControl2 =
    {
        "winrt._winrt_windows_web_ui.IWebViewControl2",
        sizeof(py::wrapper::Windows::Web::UI::IWebViewControl2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWebViewControl2
    };

    // ----- Windows.Web.UI Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Web::UI");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_web_ui",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Web::UI

PyMODINIT_FUNC PyInit__winrt_windows_web_ui(void) noexcept
{
    using namespace py::cpp::Windows::Web::UI;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WebViewControlContentLoadingEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WebViewControlDOMContentLoadedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WebViewControlDeferredPermissionRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WebViewControlLongRunningScriptDetectedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WebViewControlNavigationCompletedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WebViewControlNavigationStartingEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WebViewControlNewWindowRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WebViewControlPermissionRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WebViewControlPermissionRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WebViewControlScriptNotifyEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WebViewControlSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WebViewControlUnsupportedUriSchemeIdentifiedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WebViewControlUnviewableContentIdentifiedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WebViewControlWebResourceRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IWebViewControl, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IWebViewControl2, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
