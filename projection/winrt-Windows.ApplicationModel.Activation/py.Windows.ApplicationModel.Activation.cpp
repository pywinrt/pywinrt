// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.ApplicationModel.Activation.h"

namespace py::cpp::Windows::ApplicationModel::Activation
{
    // ----- AppointmentsProviderAddAppointmentActivatedEventArgs class --------------------

    static PyObject* _new_AppointmentsProviderAddAppointmentActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AppointmentsProviderAddAppointmentActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppointmentsProviderAddAppointmentActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderAddAppointmentActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderAddAppointmentActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderAddAppointmentActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderAddAppointmentActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderAddAppointmentActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderAddAppointmentActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderAddAppointmentActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderAddAppointmentActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderAddAppointmentActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderAddAppointmentActivatedEventArgs_get_AddAppointmentOperation(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderAddAppointmentActivatedEventArgs", L"AddAppointmentOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AddAppointmentOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppointmentsProviderAddAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppointmentsProviderAddAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentsProviderAddAppointmentActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_AppointmentsProviderAddAppointmentActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentsProviderAddAppointmentActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentsProviderAddAppointmentActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(AppointmentsProviderAddAppointmentActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(AppointmentsProviderAddAppointmentActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(AppointmentsProviderAddAppointmentActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(AppointmentsProviderAddAppointmentActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(AppointmentsProviderAddAppointmentActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "add_appointment_operation", reinterpret_cast<getter>(AppointmentsProviderAddAppointmentActivatedEventArgs_get_AddAppointmentOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppointmentsProviderAddAppointmentActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppointmentsProviderAddAppointmentActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppointmentsProviderAddAppointmentActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppointmentsProviderAddAppointmentActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppointmentsProviderAddAppointmentActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_AppointmentsProviderAddAppointmentActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.AppointmentsProviderAddAppointmentActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentsProviderAddAppointmentActivatedEventArgs};

    // ----- AppointmentsProviderRemoveAppointmentActivatedEventArgs class --------------------

    static PyObject* _new_AppointmentsProviderRemoveAppointmentActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AppointmentsProviderRemoveAppointmentActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderRemoveAppointmentActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderRemoveAppointmentActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderRemoveAppointmentActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderRemoveAppointmentActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderRemoveAppointmentActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_RemoveAppointmentOperation(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderRemoveAppointmentActivatedEventArgs", L"RemoveAppointmentOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemoveAppointmentOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppointmentsProviderRemoveAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppointmentsProviderRemoveAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentsProviderRemoveAppointmentActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_AppointmentsProviderRemoveAppointmentActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentsProviderRemoveAppointmentActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentsProviderRemoveAppointmentActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "remove_appointment_operation", reinterpret_cast<getter>(AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_RemoveAppointmentOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppointmentsProviderRemoveAppointmentActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppointmentsProviderRemoveAppointmentActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppointmentsProviderRemoveAppointmentActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppointmentsProviderRemoveAppointmentActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppointmentsProviderRemoveAppointmentActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_AppointmentsProviderRemoveAppointmentActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.AppointmentsProviderRemoveAppointmentActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentsProviderRemoveAppointmentActivatedEventArgs};

    // ----- AppointmentsProviderReplaceAppointmentActivatedEventArgs class --------------------

    static PyObject* _new_AppointmentsProviderReplaceAppointmentActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AppointmentsProviderReplaceAppointmentActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderReplaceAppointmentActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderReplaceAppointmentActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderReplaceAppointmentActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderReplaceAppointmentActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderReplaceAppointmentActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_ReplaceAppointmentOperation(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderReplaceAppointmentActivatedEventArgs", L"ReplaceAppointmentOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReplaceAppointmentOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppointmentsProviderReplaceAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppointmentsProviderReplaceAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentsProviderReplaceAppointmentActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_AppointmentsProviderReplaceAppointmentActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentsProviderReplaceAppointmentActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentsProviderReplaceAppointmentActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "replace_appointment_operation", reinterpret_cast<getter>(AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_ReplaceAppointmentOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppointmentsProviderReplaceAppointmentActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppointmentsProviderReplaceAppointmentActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppointmentsProviderReplaceAppointmentActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppointmentsProviderReplaceAppointmentActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppointmentsProviderReplaceAppointmentActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_AppointmentsProviderReplaceAppointmentActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.AppointmentsProviderReplaceAppointmentActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentsProviderReplaceAppointmentActivatedEventArgs};

    // ----- AppointmentsProviderShowAppointmentDetailsActivatedEventArgs class --------------------

    static PyObject* _new_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_InstanceStartDate(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"InstanceStartDate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InstanceStartDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_LocalId(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"LocalId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_RoamingId(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"RoamingId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RoamingId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "instance_start_date", reinterpret_cast<getter>(AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_InstanceStartDate), nullptr, nullptr, nullptr },
        { "local_id", reinterpret_cast<getter>(AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_LocalId), nullptr, nullptr, nullptr },
        { "roaming_id", reinterpret_cast<getter>(AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_RoamingId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.AppointmentsProviderShowAppointmentDetailsActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs};

    // ----- AppointmentsProviderShowTimeFrameActivatedEventArgs class --------------------

    static PyObject* _new_AppointmentsProviderShowTimeFrameActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AppointmentsProviderShowTimeFrameActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppointmentsProviderShowTimeFrameActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderShowTimeFrameActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowTimeFrameActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderShowTimeFrameActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowTimeFrameActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderShowTimeFrameActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowTimeFrameActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderShowTimeFrameActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowTimeFrameActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderShowTimeFrameActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowTimeFrameActivatedEventArgs_get_Duration(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderShowTimeFrameActivatedEventArgs", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowTimeFrameActivatedEventArgs_get_TimeToShow(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderShowTimeFrameActivatedEventArgs", L"TimeToShow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TimeToShow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppointmentsProviderShowTimeFrameActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppointmentsProviderShowTimeFrameActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentsProviderShowTimeFrameActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_AppointmentsProviderShowTimeFrameActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentsProviderShowTimeFrameActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentsProviderShowTimeFrameActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(AppointmentsProviderShowTimeFrameActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(AppointmentsProviderShowTimeFrameActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(AppointmentsProviderShowTimeFrameActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(AppointmentsProviderShowTimeFrameActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(AppointmentsProviderShowTimeFrameActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(AppointmentsProviderShowTimeFrameActivatedEventArgs_get_Duration), nullptr, nullptr, nullptr },
        { "time_to_show", reinterpret_cast<getter>(AppointmentsProviderShowTimeFrameActivatedEventArgs_get_TimeToShow), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppointmentsProviderShowTimeFrameActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppointmentsProviderShowTimeFrameActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppointmentsProviderShowTimeFrameActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppointmentsProviderShowTimeFrameActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppointmentsProviderShowTimeFrameActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_AppointmentsProviderShowTimeFrameActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.AppointmentsProviderShowTimeFrameActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentsProviderShowTimeFrameActivatedEventArgs};

    // ----- BackgroundActivatedEventArgs class --------------------

    static PyObject* _new_BackgroundActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::BackgroundActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::BackgroundActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_BackgroundActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::BackgroundActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundActivatedEventArgs_get_TaskInstance(py::wrapper::Windows::ApplicationModel::Activation::BackgroundActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.BackgroundActivatedEventArgs", L"TaskInstance");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TaskInstance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BackgroundActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::BackgroundActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackgroundActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::BackgroundActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_BackgroundActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundActivatedEventArgs[] = {
        { "task_instance", reinterpret_cast<getter>(BackgroundActivatedEventArgs_get_TaskInstance), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_BackgroundActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.BackgroundActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::BackgroundActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundActivatedEventArgs};

    // ----- BarcodeScannerPreviewActivatedEventArgs class --------------------

    static PyObject* _new_BarcodeScannerPreviewActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::BarcodeScannerPreviewActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::BarcodeScannerPreviewActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_BarcodeScannerPreviewActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::BarcodeScannerPreviewActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BarcodeScannerPreviewActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::BarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.BarcodeScannerPreviewActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerPreviewActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::BarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.BarcodeScannerPreviewActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerPreviewActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::BarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.BarcodeScannerPreviewActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerPreviewActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::BarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.BarcodeScannerPreviewActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerPreviewActivatedEventArgs_get_ConnectionId(py::wrapper::Windows::ApplicationModel::Activation::BarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.BarcodeScannerPreviewActivatedEventArgs", L"ConnectionId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ConnectionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BarcodeScannerPreviewActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::BarcodeScannerPreviewActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BarcodeScannerPreviewActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::BarcodeScannerPreviewActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeScannerPreviewActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_BarcodeScannerPreviewActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BarcodeScannerPreviewActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarcodeScannerPreviewActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(BarcodeScannerPreviewActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(BarcodeScannerPreviewActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(BarcodeScannerPreviewActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(BarcodeScannerPreviewActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "connection_id", reinterpret_cast<getter>(BarcodeScannerPreviewActivatedEventArgs_get_ConnectionId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BarcodeScannerPreviewActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BarcodeScannerPreviewActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BarcodeScannerPreviewActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BarcodeScannerPreviewActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BarcodeScannerPreviewActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_BarcodeScannerPreviewActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.BarcodeScannerPreviewActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::BarcodeScannerPreviewActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeScannerPreviewActivatedEventArgs};

    // ----- CachedFileUpdaterActivatedEventArgs class --------------------

    static PyObject* _new_CachedFileUpdaterActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CachedFileUpdaterActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CachedFileUpdaterActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CachedFileUpdaterActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CachedFileUpdaterActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CachedFileUpdaterActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CachedFileUpdaterActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterActivatedEventArgs_get_CachedFileUpdaterUI(py::wrapper::Windows::ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CachedFileUpdaterActivatedEventArgs", L"CachedFileUpdaterUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CachedFileUpdaterUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CachedFileUpdaterActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CachedFileUpdaterActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CachedFileUpdaterActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_CachedFileUpdaterActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CachedFileUpdaterActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CachedFileUpdaterActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(CachedFileUpdaterActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(CachedFileUpdaterActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(CachedFileUpdaterActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(CachedFileUpdaterActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "cached_file_updater_u_i", reinterpret_cast<getter>(CachedFileUpdaterActivatedEventArgs_get_CachedFileUpdaterUI), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CachedFileUpdaterActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CachedFileUpdaterActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CachedFileUpdaterActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CachedFileUpdaterActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CachedFileUpdaterActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_CachedFileUpdaterActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.CachedFileUpdaterActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CachedFileUpdaterActivatedEventArgs};

    // ----- CameraSettingsActivatedEventArgs class --------------------

    static PyObject* _new_CameraSettingsActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::CameraSettingsActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::CameraSettingsActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CameraSettingsActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::CameraSettingsActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CameraSettingsActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::CameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CameraSettingsActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraSettingsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::CameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CameraSettingsActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraSettingsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::CameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CameraSettingsActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraSettingsActivatedEventArgs_get_VideoDeviceController(py::wrapper::Windows::ApplicationModel::Activation::CameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CameraSettingsActivatedEventArgs", L"VideoDeviceController");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoDeviceController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraSettingsActivatedEventArgs_get_VideoDeviceExtension(py::wrapper::Windows::ApplicationModel::Activation::CameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CameraSettingsActivatedEventArgs", L"VideoDeviceExtension");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoDeviceExtension());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CameraSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::CameraSettingsActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CameraSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::CameraSettingsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CameraSettingsActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_CameraSettingsActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CameraSettingsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CameraSettingsActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(CameraSettingsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(CameraSettingsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(CameraSettingsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "video_device_controller", reinterpret_cast<getter>(CameraSettingsActivatedEventArgs_get_VideoDeviceController), nullptr, nullptr, nullptr },
        { "video_device_extension", reinterpret_cast<getter>(CameraSettingsActivatedEventArgs_get_VideoDeviceExtension), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CameraSettingsActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CameraSettingsActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CameraSettingsActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CameraSettingsActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CameraSettingsActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_CameraSettingsActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.CameraSettingsActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::CameraSettingsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CameraSettingsActivatedEventArgs};

    // ----- CommandLineActivatedEventArgs class --------------------

    static PyObject* _new_CommandLineActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::CommandLineActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::CommandLineActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CommandLineActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CommandLineActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CommandLineActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandLineActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CommandLineActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandLineActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CommandLineActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandLineActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CommandLineActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandLineActivatedEventArgs_get_Operation(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CommandLineActivatedEventArgs", L"Operation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Operation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CommandLineActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::CommandLineActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CommandLineActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::CommandLineActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CommandLineActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_CommandLineActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CommandLineActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CommandLineActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(CommandLineActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(CommandLineActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(CommandLineActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(CommandLineActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "operation", reinterpret_cast<getter>(CommandLineActivatedEventArgs_get_Operation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CommandLineActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CommandLineActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CommandLineActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CommandLineActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CommandLineActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_CommandLineActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.CommandLineActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CommandLineActivatedEventArgs};

    // ----- CommandLineActivationOperation class --------------------

    static PyObject* _new_CommandLineActivationOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::CommandLineActivationOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::CommandLineActivationOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_CommandLineActivationOperation(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivationOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CommandLineActivationOperation_GetDeferral(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivationOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Activation.CommandLineActivationOperation", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CommandLineActivationOperation_get_ExitCode(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivationOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CommandLineActivationOperation", L"ExitCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExitCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CommandLineActivationOperation_put_ExitCode(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivationOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CommandLineActivationOperation", L"ExitCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ExitCode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CommandLineActivationOperation_get_Arguments(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivationOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CommandLineActivationOperation", L"Arguments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Arguments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandLineActivationOperation_get_CurrentDirectoryPath(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivationOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CommandLineActivationOperation", L"CurrentDirectoryPath");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CurrentDirectoryPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CommandLineActivationOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::CommandLineActivationOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CommandLineActivationOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::CommandLineActivationOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CommandLineActivationOperation[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CommandLineActivationOperation_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CommandLineActivationOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CommandLineActivationOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CommandLineActivationOperation[] = {
        { "exit_code", reinterpret_cast<getter>(CommandLineActivationOperation_get_ExitCode), reinterpret_cast<setter>(CommandLineActivationOperation_put_ExitCode), nullptr, nullptr },
        { "arguments", reinterpret_cast<getter>(CommandLineActivationOperation_get_Arguments), nullptr, nullptr, nullptr },
        { "current_directory_path", reinterpret_cast<getter>(CommandLineActivationOperation_get_CurrentDirectoryPath), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CommandLineActivationOperation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CommandLineActivationOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CommandLineActivationOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CommandLineActivationOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CommandLineActivationOperation) },
        { }
    };

    static PyType_Spec type_spec_CommandLineActivationOperation = {
        "winrt._winrt_windows_applicationmodel_activation.CommandLineActivationOperation",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivationOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CommandLineActivationOperation};

    // ----- ContactCallActivatedEventArgs class --------------------

    static PyObject* _new_ContactCallActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactCallActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactCallActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactCallActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactCallActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactCallActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactCallActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactCallActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactCallActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactCallActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactCallActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactCallActivatedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactCallActivatedEventArgs_get_ServiceId(py::wrapper::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactCallActivatedEventArgs", L"ServiceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactCallActivatedEventArgs_get_ServiceUserId(py::wrapper::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactCallActivatedEventArgs", L"ServiceUserId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServiceUserId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactCallActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ContactCallActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactCallActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactCallActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(ContactCallActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ContactCallActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ContactCallActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(ContactCallActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(ContactCallActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(ContactCallActivatedEventArgs_get_ServiceId), nullptr, nullptr, nullptr },
        { "service_user_id", reinterpret_cast<getter>(ContactCallActivatedEventArgs_get_ServiceUserId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactCallActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactCallActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactCallActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactCallActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactCallActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ContactCallActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ContactCallActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactCallActivatedEventArgs};

    // ----- ContactMapActivatedEventArgs class --------------------

    static PyObject* _new_ContactMapActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactMapActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactMapActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactMapActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMapActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactMapActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMapActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactMapActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMapActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactMapActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMapActivatedEventArgs_get_Address(py::wrapper::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactMapActivatedEventArgs", L"Address");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Address());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMapActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactMapActivatedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactMapActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactMapActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactMapActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ContactMapActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactMapActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactMapActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(ContactMapActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ContactMapActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ContactMapActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(ContactMapActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "address", reinterpret_cast<getter>(ContactMapActivatedEventArgs_get_Address), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(ContactMapActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactMapActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactMapActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactMapActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactMapActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactMapActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ContactMapActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ContactMapActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactMapActivatedEventArgs};

    // ----- ContactMessageActivatedEventArgs class --------------------

    static PyObject* _new_ContactMessageActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactMessageActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactMessageActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactMessageActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMessageActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactMessageActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMessageActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactMessageActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMessageActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactMessageActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMessageActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactMessageActivatedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMessageActivatedEventArgs_get_ServiceId(py::wrapper::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactMessageActivatedEventArgs", L"ServiceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMessageActivatedEventArgs_get_ServiceUserId(py::wrapper::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactMessageActivatedEventArgs", L"ServiceUserId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServiceUserId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactMessageActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactMessageActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactMessageActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ContactMessageActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactMessageActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactMessageActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(ContactMessageActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ContactMessageActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ContactMessageActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(ContactMessageActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(ContactMessageActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(ContactMessageActivatedEventArgs_get_ServiceId), nullptr, nullptr, nullptr },
        { "service_user_id", reinterpret_cast<getter>(ContactMessageActivatedEventArgs_get_ServiceUserId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactMessageActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactMessageActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactMessageActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactMessageActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactMessageActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ContactMessageActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ContactMessageActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactMessageActivatedEventArgs};

    // ----- ContactPanelActivatedEventArgs class --------------------

    static PyObject* _new_ContactPanelActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactPanelActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactPanelActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPanelActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPanelActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPanelActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPanelActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPanelActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPanelActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPanelActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPanelActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPanelActivatedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPanelActivatedEventArgs_get_ContactPanel(py::wrapper::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPanelActivatedEventArgs", L"ContactPanel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContactPanel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactPanelActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactPanelActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactPanelActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ContactPanelActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactPanelActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactPanelActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(ContactPanelActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ContactPanelActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ContactPanelActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(ContactPanelActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(ContactPanelActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "contact_panel", reinterpret_cast<getter>(ContactPanelActivatedEventArgs_get_ContactPanel), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactPanelActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactPanelActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactPanelActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactPanelActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactPanelActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ContactPanelActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ContactPanelActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactPanelActivatedEventArgs};

    // ----- ContactPickerActivatedEventArgs class --------------------

    static PyObject* _new_ContactPickerActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ContactPickerActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ContactPickerActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactPickerActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ContactPickerActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactPickerActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPickerActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPickerActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPickerActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPickerActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPickerActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPickerActivatedEventArgs_get_ContactPickerUI(py::wrapper::Windows::ApplicationModel::Activation::ContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPickerActivatedEventArgs", L"ContactPickerUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContactPickerUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactPickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ContactPickerActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactPickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ContactPickerActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactPickerActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ContactPickerActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactPickerActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactPickerActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(ContactPickerActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ContactPickerActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ContactPickerActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "contact_picker_u_i", reinterpret_cast<getter>(ContactPickerActivatedEventArgs_get_ContactPickerUI), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactPickerActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactPickerActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactPickerActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactPickerActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactPickerActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ContactPickerActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ContactPickerActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ContactPickerActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactPickerActivatedEventArgs};

    // ----- ContactPostActivatedEventArgs class --------------------

    static PyObject* _new_ContactPostActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactPostActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactPostActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPostActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPostActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPostActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPostActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPostActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPostActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPostActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPostActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPostActivatedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPostActivatedEventArgs_get_ServiceId(py::wrapper::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPostActivatedEventArgs", L"ServiceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPostActivatedEventArgs_get_ServiceUserId(py::wrapper::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPostActivatedEventArgs", L"ServiceUserId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServiceUserId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactPostActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactPostActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactPostActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ContactPostActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactPostActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactPostActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(ContactPostActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ContactPostActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ContactPostActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(ContactPostActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(ContactPostActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(ContactPostActivatedEventArgs_get_ServiceId), nullptr, nullptr, nullptr },
        { "service_user_id", reinterpret_cast<getter>(ContactPostActivatedEventArgs_get_ServiceUserId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactPostActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactPostActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactPostActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactPostActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactPostActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ContactPostActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ContactPostActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactPostActivatedEventArgs};

    // ----- ContactVideoCallActivatedEventArgs class --------------------

    static PyObject* _new_ContactVideoCallActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactVideoCallActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactVideoCallActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactVideoCallActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactVideoCallActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactVideoCallActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactVideoCallActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactVideoCallActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactVideoCallActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactVideoCallActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactVideoCallActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactVideoCallActivatedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactVideoCallActivatedEventArgs_get_ServiceId(py::wrapper::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactVideoCallActivatedEventArgs", L"ServiceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactVideoCallActivatedEventArgs_get_ServiceUserId(py::wrapper::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactVideoCallActivatedEventArgs", L"ServiceUserId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServiceUserId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactVideoCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactVideoCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactVideoCallActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ContactVideoCallActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactVideoCallActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactVideoCallActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(ContactVideoCallActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ContactVideoCallActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ContactVideoCallActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(ContactVideoCallActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(ContactVideoCallActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(ContactVideoCallActivatedEventArgs_get_ServiceId), nullptr, nullptr, nullptr },
        { "service_user_id", reinterpret_cast<getter>(ContactVideoCallActivatedEventArgs_get_ServiceUserId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactVideoCallActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactVideoCallActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactVideoCallActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactVideoCallActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactVideoCallActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ContactVideoCallActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ContactVideoCallActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactVideoCallActivatedEventArgs};

    // ----- DeviceActivatedEventArgs class --------------------

    static PyObject* _new_DeviceActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_DeviceActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DeviceActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DeviceActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DeviceActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DeviceActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DeviceActivatedEventArgs", L"CurrentlyShownApplicationViewId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CurrentlyShownApplicationViewId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceActivatedEventArgs_get_DeviceInformationId(py::wrapper::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DeviceActivatedEventArgs", L"DeviceInformationId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceInformationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DeviceActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceActivatedEventArgs_get_ViewSwitcher(py::wrapper::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DeviceActivatedEventArgs", L"ViewSwitcher");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ViewSwitcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_DeviceActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(DeviceActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(DeviceActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(DeviceActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(DeviceActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(DeviceActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "device_information_id", reinterpret_cast<getter>(DeviceActivatedEventArgs_get_DeviceInformationId), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(DeviceActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "view_switcher", reinterpret_cast<getter>(DeviceActivatedEventArgs_get_ViewSwitcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_DeviceActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.DeviceActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceActivatedEventArgs};

    // ----- DevicePairingActivatedEventArgs class --------------------

    static PyObject* _new_DevicePairingActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::DevicePairingActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::DevicePairingActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_DevicePairingActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::DevicePairingActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DevicePairingActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::DevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DevicePairingActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePairingActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::DevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DevicePairingActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePairingActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::DevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DevicePairingActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePairingActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::DevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DevicePairingActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePairingActivatedEventArgs_get_DeviceInformation(py::wrapper::Windows::ApplicationModel::Activation::DevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DevicePairingActivatedEventArgs", L"DeviceInformation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DevicePairingActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::DevicePairingActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DevicePairingActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::DevicePairingActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DevicePairingActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_DevicePairingActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DevicePairingActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DevicePairingActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(DevicePairingActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(DevicePairingActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(DevicePairingActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(DevicePairingActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "device_information", reinterpret_cast<getter>(DevicePairingActivatedEventArgs_get_DeviceInformation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DevicePairingActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DevicePairingActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DevicePairingActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DevicePairingActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DevicePairingActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_DevicePairingActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.DevicePairingActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::DevicePairingActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DevicePairingActivatedEventArgs};

    // ----- DialReceiverActivatedEventArgs class --------------------

    static PyObject* _new_DialReceiverActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_DialReceiverActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DialReceiverActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DialReceiverActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DialReceiverActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DialReceiverActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DialReceiverActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DialReceiverActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DialReceiverActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DialReceiverActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DialReceiverActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DialReceiverActivatedEventArgs", L"CurrentlyShownApplicationViewId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CurrentlyShownApplicationViewId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DialReceiverActivatedEventArgs_get_AppName(py::wrapper::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DialReceiverActivatedEventArgs", L"AppName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DialReceiverActivatedEventArgs_get_Arguments(py::wrapper::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DialReceiverActivatedEventArgs", L"Arguments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Arguments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DialReceiverActivatedEventArgs_get_TileId(py::wrapper::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DialReceiverActivatedEventArgs", L"TileId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TileId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DialReceiverActivatedEventArgs_get_ViewSwitcher(py::wrapper::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DialReceiverActivatedEventArgs", L"ViewSwitcher");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ViewSwitcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DialReceiverActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DialReceiverActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DialReceiverActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_DialReceiverActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DialReceiverActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DialReceiverActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(DialReceiverActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(DialReceiverActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(DialReceiverActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(DialReceiverActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(DialReceiverActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "app_name", reinterpret_cast<getter>(DialReceiverActivatedEventArgs_get_AppName), nullptr, nullptr, nullptr },
        { "arguments", reinterpret_cast<getter>(DialReceiverActivatedEventArgs_get_Arguments), nullptr, nullptr, nullptr },
        { "tile_id", reinterpret_cast<getter>(DialReceiverActivatedEventArgs_get_TileId), nullptr, nullptr, nullptr },
        { "view_switcher", reinterpret_cast<getter>(DialReceiverActivatedEventArgs_get_ViewSwitcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DialReceiverActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DialReceiverActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DialReceiverActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DialReceiverActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DialReceiverActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_DialReceiverActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.DialReceiverActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DialReceiverActivatedEventArgs};

    // ----- FileActivatedEventArgs class --------------------

    static PyObject* _new_FileActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::FileActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::FileActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_FileActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FileActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileActivatedEventArgs", L"CurrentlyShownApplicationViewId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CurrentlyShownApplicationViewId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileActivatedEventArgs_get_Files(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileActivatedEventArgs", L"Files");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Files());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileActivatedEventArgs_get_CallerPackageFamilyName(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileActivatedEventArgs", L"CallerPackageFamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CallerPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileActivatedEventArgs_get_NeighboringFilesQuery(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileActivatedEventArgs", L"NeighboringFilesQuery");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NeighboringFilesQuery());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileActivatedEventArgs_get_ViewSwitcher(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileActivatedEventArgs", L"ViewSwitcher");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ViewSwitcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FileActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::FileActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FileActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::FileActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_FileActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FileActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FileActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(FileActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(FileActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(FileActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(FileActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(FileActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "files", reinterpret_cast<getter>(FileActivatedEventArgs_get_Files), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(FileActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "caller_package_family_name", reinterpret_cast<getter>(FileActivatedEventArgs_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { "neighboring_files_query", reinterpret_cast<getter>(FileActivatedEventArgs_get_NeighboringFilesQuery), nullptr, nullptr, nullptr },
        { "view_switcher", reinterpret_cast<getter>(FileActivatedEventArgs_get_ViewSwitcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FileActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FileActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FileActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FileActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FileActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_FileActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.FileActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileActivatedEventArgs};

    // ----- FileOpenPickerActivatedEventArgs class --------------------

    static PyObject* _new_FileOpenPickerActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_FileOpenPickerActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FileOpenPickerActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileOpenPickerActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileOpenPickerActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileOpenPickerActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileOpenPickerActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerActivatedEventArgs_get_FileOpenPickerUI(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileOpenPickerActivatedEventArgs", L"FileOpenPickerUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FileOpenPickerUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerActivatedEventArgs_get_CallerPackageFamilyName(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileOpenPickerActivatedEventArgs", L"CallerPackageFamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CallerPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FileOpenPickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FileOpenPickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileOpenPickerActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_FileOpenPickerActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FileOpenPickerActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FileOpenPickerActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(FileOpenPickerActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(FileOpenPickerActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(FileOpenPickerActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(FileOpenPickerActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "file_open_picker_u_i", reinterpret_cast<getter>(FileOpenPickerActivatedEventArgs_get_FileOpenPickerUI), nullptr, nullptr, nullptr },
        { "caller_package_family_name", reinterpret_cast<getter>(FileOpenPickerActivatedEventArgs_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FileOpenPickerActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FileOpenPickerActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FileOpenPickerActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FileOpenPickerActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FileOpenPickerActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_FileOpenPickerActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.FileOpenPickerActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileOpenPickerActivatedEventArgs};

    // ----- FileOpenPickerContinuationEventArgs class --------------------

    static PyObject* _new_FileOpenPickerContinuationEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_FileOpenPickerContinuationEventArgs(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FileOpenPickerContinuationEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileOpenPickerContinuationEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerContinuationEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileOpenPickerContinuationEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerContinuationEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileOpenPickerContinuationEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerContinuationEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileOpenPickerContinuationEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerContinuationEventArgs_get_ContinuationData(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileOpenPickerContinuationEventArgs", L"ContinuationData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContinuationData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerContinuationEventArgs_get_Files(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileOpenPickerContinuationEventArgs", L"Files");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Files());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FileOpenPickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FileOpenPickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileOpenPickerContinuationEventArgs[] = {
        { "_assign_array_", _assign_array_FileOpenPickerContinuationEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FileOpenPickerContinuationEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FileOpenPickerContinuationEventArgs[] = {
        { "kind", reinterpret_cast<getter>(FileOpenPickerContinuationEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(FileOpenPickerContinuationEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(FileOpenPickerContinuationEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(FileOpenPickerContinuationEventArgs_get_User), nullptr, nullptr, nullptr },
        { "continuation_data", reinterpret_cast<getter>(FileOpenPickerContinuationEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "files", reinterpret_cast<getter>(FileOpenPickerContinuationEventArgs_get_Files), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FileOpenPickerContinuationEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FileOpenPickerContinuationEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FileOpenPickerContinuationEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FileOpenPickerContinuationEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FileOpenPickerContinuationEventArgs) },
        { }
    };

    static PyType_Spec type_spec_FileOpenPickerContinuationEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.FileOpenPickerContinuationEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileOpenPickerContinuationEventArgs};

    // ----- FileSavePickerActivatedEventArgs class --------------------

    static PyObject* _new_FileSavePickerActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_FileSavePickerActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FileSavePickerActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileSavePickerActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileSavePickerActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileSavePickerActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileSavePickerActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerActivatedEventArgs_get_FileSavePickerUI(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileSavePickerActivatedEventArgs", L"FileSavePickerUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FileSavePickerUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerActivatedEventArgs_get_CallerPackageFamilyName(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileSavePickerActivatedEventArgs", L"CallerPackageFamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CallerPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerActivatedEventArgs_get_EnterpriseId(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileSavePickerActivatedEventArgs", L"EnterpriseId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EnterpriseId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FileSavePickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FileSavePickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileSavePickerActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_FileSavePickerActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FileSavePickerActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FileSavePickerActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(FileSavePickerActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(FileSavePickerActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(FileSavePickerActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(FileSavePickerActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "file_save_picker_u_i", reinterpret_cast<getter>(FileSavePickerActivatedEventArgs_get_FileSavePickerUI), nullptr, nullptr, nullptr },
        { "caller_package_family_name", reinterpret_cast<getter>(FileSavePickerActivatedEventArgs_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { "enterprise_id", reinterpret_cast<getter>(FileSavePickerActivatedEventArgs_get_EnterpriseId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FileSavePickerActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FileSavePickerActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FileSavePickerActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FileSavePickerActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FileSavePickerActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_FileSavePickerActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.FileSavePickerActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileSavePickerActivatedEventArgs};

    // ----- FileSavePickerContinuationEventArgs class --------------------

    static PyObject* _new_FileSavePickerContinuationEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_FileSavePickerContinuationEventArgs(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FileSavePickerContinuationEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileSavePickerContinuationEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerContinuationEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileSavePickerContinuationEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerContinuationEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileSavePickerContinuationEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerContinuationEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileSavePickerContinuationEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerContinuationEventArgs_get_ContinuationData(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileSavePickerContinuationEventArgs", L"ContinuationData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContinuationData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerContinuationEventArgs_get_File(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileSavePickerContinuationEventArgs", L"File");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.File());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FileSavePickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FileSavePickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileSavePickerContinuationEventArgs[] = {
        { "_assign_array_", _assign_array_FileSavePickerContinuationEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FileSavePickerContinuationEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FileSavePickerContinuationEventArgs[] = {
        { "kind", reinterpret_cast<getter>(FileSavePickerContinuationEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(FileSavePickerContinuationEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(FileSavePickerContinuationEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(FileSavePickerContinuationEventArgs_get_User), nullptr, nullptr, nullptr },
        { "continuation_data", reinterpret_cast<getter>(FileSavePickerContinuationEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "file", reinterpret_cast<getter>(FileSavePickerContinuationEventArgs_get_File), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FileSavePickerContinuationEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FileSavePickerContinuationEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FileSavePickerContinuationEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FileSavePickerContinuationEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FileSavePickerContinuationEventArgs) },
        { }
    };

    static PyType_Spec type_spec_FileSavePickerContinuationEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.FileSavePickerContinuationEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileSavePickerContinuationEventArgs};

    // ----- FolderPickerContinuationEventArgs class --------------------

    static PyObject* _new_FolderPickerContinuationEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_FolderPickerContinuationEventArgs(py::wrapper::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FolderPickerContinuationEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FolderPickerContinuationEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FolderPickerContinuationEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FolderPickerContinuationEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FolderPickerContinuationEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FolderPickerContinuationEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FolderPickerContinuationEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FolderPickerContinuationEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FolderPickerContinuationEventArgs_get_ContinuationData(py::wrapper::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FolderPickerContinuationEventArgs", L"ContinuationData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContinuationData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FolderPickerContinuationEventArgs_get_Folder(py::wrapper::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FolderPickerContinuationEventArgs", L"Folder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Folder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FolderPickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FolderPickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FolderPickerContinuationEventArgs[] = {
        { "_assign_array_", _assign_array_FolderPickerContinuationEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FolderPickerContinuationEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FolderPickerContinuationEventArgs[] = {
        { "kind", reinterpret_cast<getter>(FolderPickerContinuationEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(FolderPickerContinuationEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(FolderPickerContinuationEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(FolderPickerContinuationEventArgs_get_User), nullptr, nullptr, nullptr },
        { "continuation_data", reinterpret_cast<getter>(FolderPickerContinuationEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "folder", reinterpret_cast<getter>(FolderPickerContinuationEventArgs_get_Folder), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FolderPickerContinuationEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FolderPickerContinuationEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FolderPickerContinuationEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FolderPickerContinuationEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FolderPickerContinuationEventArgs) },
        { }
    };

    static PyType_Spec type_spec_FolderPickerContinuationEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.FolderPickerContinuationEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FolderPickerContinuationEventArgs};

    // ----- LaunchActivatedEventArgs class --------------------

    static PyObject* _new_LaunchActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_LaunchActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LaunchActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LaunchActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LaunchActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LaunchActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LaunchActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LaunchActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LaunchActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LaunchActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LaunchActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LaunchActivatedEventArgs", L"CurrentlyShownApplicationViewId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CurrentlyShownApplicationViewId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LaunchActivatedEventArgs_get_Arguments(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LaunchActivatedEventArgs", L"Arguments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Arguments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LaunchActivatedEventArgs_get_TileId(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LaunchActivatedEventArgs", L"TileId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TileId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LaunchActivatedEventArgs_get_TileActivatedInfo(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LaunchActivatedEventArgs", L"TileActivatedInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TileActivatedInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LaunchActivatedEventArgs_get_PrelaunchActivated(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LaunchActivatedEventArgs", L"PrelaunchActivated");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PrelaunchActivated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LaunchActivatedEventArgs_get_ViewSwitcher(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LaunchActivatedEventArgs", L"ViewSwitcher");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ViewSwitcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LaunchActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_LaunchActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LaunchActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LaunchActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(LaunchActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(LaunchActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(LaunchActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(LaunchActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(LaunchActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "arguments", reinterpret_cast<getter>(LaunchActivatedEventArgs_get_Arguments), nullptr, nullptr, nullptr },
        { "tile_id", reinterpret_cast<getter>(LaunchActivatedEventArgs_get_TileId), nullptr, nullptr, nullptr },
        { "tile_activated_info", reinterpret_cast<getter>(LaunchActivatedEventArgs_get_TileActivatedInfo), nullptr, nullptr, nullptr },
        { "prelaunch_activated", reinterpret_cast<getter>(LaunchActivatedEventArgs_get_PrelaunchActivated), nullptr, nullptr, nullptr },
        { "view_switcher", reinterpret_cast<getter>(LaunchActivatedEventArgs_get_ViewSwitcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LaunchActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LaunchActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LaunchActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LaunchActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LaunchActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_LaunchActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.LaunchActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LaunchActivatedEventArgs};

    // ----- LockScreenActivatedEventArgs class --------------------

    static PyObject* _new_LockScreenActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::LockScreenActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::LockScreenActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_LockScreenActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::LockScreenActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LockScreenActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::LockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LockScreenActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::LockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LockScreenActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::LockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LockScreenActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::LockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LockScreenActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenActivatedEventArgs_get_Info(py::wrapper::Windows::ApplicationModel::Activation::LockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LockScreenActivatedEventArgs", L"Info");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Info());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LockScreenActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::LockScreenActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LockScreenActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::LockScreenActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LockScreenActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_LockScreenActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LockScreenActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LockScreenActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(LockScreenActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(LockScreenActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(LockScreenActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(LockScreenActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "info", reinterpret_cast<getter>(LockScreenActivatedEventArgs_get_Info), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LockScreenActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LockScreenActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LockScreenActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LockScreenActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LockScreenActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_LockScreenActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.LockScreenActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::LockScreenActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LockScreenActivatedEventArgs};

    // ----- LockScreenCallActivatedEventArgs class --------------------

    static PyObject* _new_LockScreenCallActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_LockScreenCallActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LockScreenCallActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LockScreenCallActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenCallActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LockScreenCallActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenCallActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LockScreenCallActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenCallActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LockScreenCallActivatedEventArgs", L"CurrentlyShownApplicationViewId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CurrentlyShownApplicationViewId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenCallActivatedEventArgs_get_Arguments(py::wrapper::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LockScreenCallActivatedEventArgs", L"Arguments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Arguments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenCallActivatedEventArgs_get_TileId(py::wrapper::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LockScreenCallActivatedEventArgs", L"TileId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TileId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenCallActivatedEventArgs_get_CallUI(py::wrapper::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LockScreenCallActivatedEventArgs", L"CallUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CallUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenCallActivatedEventArgs_get_ViewSwitcher(py::wrapper::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LockScreenCallActivatedEventArgs", L"ViewSwitcher");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ViewSwitcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LockScreenCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LockScreenCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LockScreenCallActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_LockScreenCallActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LockScreenCallActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LockScreenCallActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(LockScreenCallActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(LockScreenCallActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(LockScreenCallActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(LockScreenCallActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "arguments", reinterpret_cast<getter>(LockScreenCallActivatedEventArgs_get_Arguments), nullptr, nullptr, nullptr },
        { "tile_id", reinterpret_cast<getter>(LockScreenCallActivatedEventArgs_get_TileId), nullptr, nullptr, nullptr },
        { "call_u_i", reinterpret_cast<getter>(LockScreenCallActivatedEventArgs_get_CallUI), nullptr, nullptr, nullptr },
        { "view_switcher", reinterpret_cast<getter>(LockScreenCallActivatedEventArgs_get_ViewSwitcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LockScreenCallActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LockScreenCallActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LockScreenCallActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LockScreenCallActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LockScreenCallActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_LockScreenCallActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.LockScreenCallActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LockScreenCallActivatedEventArgs};

    // ----- LockScreenComponentActivatedEventArgs class --------------------

    static PyObject* _new_LockScreenComponentActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::LockScreenComponentActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::LockScreenComponentActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_LockScreenComponentActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::LockScreenComponentActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LockScreenComponentActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::LockScreenComponentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LockScreenComponentActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenComponentActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::LockScreenComponentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LockScreenComponentActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenComponentActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::LockScreenComponentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LockScreenComponentActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LockScreenComponentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::LockScreenComponentActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LockScreenComponentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::LockScreenComponentActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LockScreenComponentActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_LockScreenComponentActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LockScreenComponentActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LockScreenComponentActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(LockScreenComponentActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(LockScreenComponentActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(LockScreenComponentActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LockScreenComponentActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LockScreenComponentActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LockScreenComponentActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LockScreenComponentActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LockScreenComponentActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_LockScreenComponentActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.LockScreenComponentActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::LockScreenComponentActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LockScreenComponentActivatedEventArgs};

    // ----- PhoneCallActivatedEventArgs class --------------------

    static PyObject* _new_PhoneCallActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::PhoneCallActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::PhoneCallActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PhoneCallActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::PhoneCallActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneCallActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::PhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.PhoneCallActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::PhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.PhoneCallActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::PhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.PhoneCallActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::PhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.PhoneCallActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallActivatedEventArgs_get_LineId(py::wrapper::Windows::ApplicationModel::Activation::PhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.PhoneCallActivatedEventArgs", L"LineId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LineId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::PhoneCallActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::PhoneCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_PhoneCallActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(PhoneCallActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(PhoneCallActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(PhoneCallActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(PhoneCallActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "line_id", reinterpret_cast<getter>(PhoneCallActivatedEventArgs_get_LineId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneCallActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneCallActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_PhoneCallActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.PhoneCallActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::PhoneCallActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallActivatedEventArgs};

    // ----- PickerReturnedActivatedEventArgs class --------------------

    static PyObject* _new_PickerReturnedActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::PickerReturnedActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::PickerReturnedActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PickerReturnedActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::PickerReturnedActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PickerReturnedActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::PickerReturnedActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.PickerReturnedActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PickerReturnedActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::PickerReturnedActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.PickerReturnedActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PickerReturnedActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::PickerReturnedActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.PickerReturnedActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PickerReturnedActivatedEventArgs_get_PickerOperationId(py::wrapper::Windows::ApplicationModel::Activation::PickerReturnedActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.PickerReturnedActivatedEventArgs", L"PickerOperationId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PickerOperationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PickerReturnedActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::PickerReturnedActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PickerReturnedActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::PickerReturnedActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PickerReturnedActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_PickerReturnedActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PickerReturnedActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PickerReturnedActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(PickerReturnedActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(PickerReturnedActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(PickerReturnedActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "picker_operation_id", reinterpret_cast<getter>(PickerReturnedActivatedEventArgs_get_PickerOperationId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PickerReturnedActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PickerReturnedActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PickerReturnedActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PickerReturnedActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PickerReturnedActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_PickerReturnedActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.PickerReturnedActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::PickerReturnedActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PickerReturnedActivatedEventArgs};

    // ----- Print3DWorkflowActivatedEventArgs class --------------------

    static PyObject* _new_Print3DWorkflowActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::Print3DWorkflowActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::Print3DWorkflowActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_Print3DWorkflowActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::Print3DWorkflowActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Print3DWorkflowActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::Print3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.Print3DWorkflowActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Print3DWorkflowActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::Print3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.Print3DWorkflowActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Print3DWorkflowActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::Print3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.Print3DWorkflowActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Print3DWorkflowActivatedEventArgs_get_Workflow(py::wrapper::Windows::ApplicationModel::Activation::Print3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.Print3DWorkflowActivatedEventArgs", L"Workflow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Workflow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Print3DWorkflowActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::Print3DWorkflowActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Print3DWorkflowActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::Print3DWorkflowActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Print3DWorkflowActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_Print3DWorkflowActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Print3DWorkflowActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Print3DWorkflowActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(Print3DWorkflowActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(Print3DWorkflowActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(Print3DWorkflowActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "workflow", reinterpret_cast<getter>(Print3DWorkflowActivatedEventArgs_get_Workflow), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Print3DWorkflowActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Print3DWorkflowActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Print3DWorkflowActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Print3DWorkflowActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Print3DWorkflowActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_Print3DWorkflowActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.Print3DWorkflowActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::Print3DWorkflowActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Print3DWorkflowActivatedEventArgs};

    // ----- PrintTaskSettingsActivatedEventArgs class --------------------

    static PyObject* _new_PrintTaskSettingsActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::PrintTaskSettingsActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::PrintTaskSettingsActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintTaskSettingsActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::PrintTaskSettingsActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintTaskSettingsActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::PrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.PrintTaskSettingsActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintTaskSettingsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::PrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.PrintTaskSettingsActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintTaskSettingsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::PrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.PrintTaskSettingsActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintTaskSettingsActivatedEventArgs_get_Configuration(py::wrapper::Windows::ApplicationModel::Activation::PrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.PrintTaskSettingsActivatedEventArgs", L"Configuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Configuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintTaskSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::PrintTaskSettingsActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintTaskSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::PrintTaskSettingsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintTaskSettingsActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_PrintTaskSettingsActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintTaskSettingsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PrintTaskSettingsActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(PrintTaskSettingsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(PrintTaskSettingsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(PrintTaskSettingsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "configuration", reinterpret_cast<getter>(PrintTaskSettingsActivatedEventArgs_get_Configuration), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PrintTaskSettingsActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintTaskSettingsActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintTaskSettingsActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintTaskSettingsActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintTaskSettingsActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_PrintTaskSettingsActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.PrintTaskSettingsActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::PrintTaskSettingsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintTaskSettingsActivatedEventArgs};

    // ----- ProtocolActivatedEventArgs class --------------------

    static PyObject* _new_ProtocolActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ProtocolActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProtocolActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolActivatedEventArgs", L"CurrentlyShownApplicationViewId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CurrentlyShownApplicationViewId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolActivatedEventArgs_get_Uri(py::wrapper::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolActivatedEventArgs", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolActivatedEventArgs_get_CallerPackageFamilyName(py::wrapper::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolActivatedEventArgs", L"CallerPackageFamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CallerPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolActivatedEventArgs_get_Data(py::wrapper::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolActivatedEventArgs", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolActivatedEventArgs_get_ViewSwitcher(py::wrapper::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolActivatedEventArgs", L"ViewSwitcher");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ViewSwitcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProtocolActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProtocolActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProtocolActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ProtocolActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProtocolActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProtocolActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(ProtocolActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ProtocolActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ProtocolActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(ProtocolActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(ProtocolActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(ProtocolActivatedEventArgs_get_Uri), nullptr, nullptr, nullptr },
        { "caller_package_family_name", reinterpret_cast<getter>(ProtocolActivatedEventArgs_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { "data", reinterpret_cast<getter>(ProtocolActivatedEventArgs_get_Data), nullptr, nullptr, nullptr },
        { "view_switcher", reinterpret_cast<getter>(ProtocolActivatedEventArgs_get_ViewSwitcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProtocolActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProtocolActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProtocolActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProtocolActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProtocolActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ProtocolActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ProtocolActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProtocolActivatedEventArgs};

    // ----- ProtocolForResultsActivatedEventArgs class --------------------

    static PyObject* _new_ProtocolForResultsActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ProtocolForResultsActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProtocolForResultsActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolForResultsActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolForResultsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolForResultsActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolForResultsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolForResultsActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolForResultsActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolForResultsActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolForResultsActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolForResultsActivatedEventArgs", L"CurrentlyShownApplicationViewId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CurrentlyShownApplicationViewId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolForResultsActivatedEventArgs_get_Uri(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolForResultsActivatedEventArgs", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolForResultsActivatedEventArgs_get_CallerPackageFamilyName(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolForResultsActivatedEventArgs", L"CallerPackageFamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CallerPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolForResultsActivatedEventArgs_get_Data(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolForResultsActivatedEventArgs", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolForResultsActivatedEventArgs_get_ProtocolForResultsOperation(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolForResultsActivatedEventArgs", L"ProtocolForResultsOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProtocolForResultsOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolForResultsActivatedEventArgs_get_ViewSwitcher(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolForResultsActivatedEventArgs", L"ViewSwitcher");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ViewSwitcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProtocolForResultsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProtocolForResultsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProtocolForResultsActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ProtocolForResultsActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProtocolForResultsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProtocolForResultsActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(ProtocolForResultsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ProtocolForResultsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ProtocolForResultsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(ProtocolForResultsActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(ProtocolForResultsActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(ProtocolForResultsActivatedEventArgs_get_Uri), nullptr, nullptr, nullptr },
        { "caller_package_family_name", reinterpret_cast<getter>(ProtocolForResultsActivatedEventArgs_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { "data", reinterpret_cast<getter>(ProtocolForResultsActivatedEventArgs_get_Data), nullptr, nullptr, nullptr },
        { "protocol_for_results_operation", reinterpret_cast<getter>(ProtocolForResultsActivatedEventArgs_get_ProtocolForResultsOperation), nullptr, nullptr, nullptr },
        { "view_switcher", reinterpret_cast<getter>(ProtocolForResultsActivatedEventArgs_get_ViewSwitcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProtocolForResultsActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProtocolForResultsActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProtocolForResultsActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProtocolForResultsActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProtocolForResultsActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ProtocolForResultsActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ProtocolForResultsActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProtocolForResultsActivatedEventArgs};

    // ----- RestrictedLaunchActivatedEventArgs class --------------------

    static PyObject* _new_RestrictedLaunchActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::RestrictedLaunchActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::RestrictedLaunchActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RestrictedLaunchActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::RestrictedLaunchActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RestrictedLaunchActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::RestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.RestrictedLaunchActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RestrictedLaunchActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::RestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.RestrictedLaunchActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RestrictedLaunchActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::RestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.RestrictedLaunchActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RestrictedLaunchActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::RestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.RestrictedLaunchActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RestrictedLaunchActivatedEventArgs_get_SharedContext(py::wrapper::Windows::ApplicationModel::Activation::RestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.RestrictedLaunchActivatedEventArgs", L"SharedContext");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SharedContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RestrictedLaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::RestrictedLaunchActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RestrictedLaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::RestrictedLaunchActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RestrictedLaunchActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_RestrictedLaunchActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RestrictedLaunchActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RestrictedLaunchActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(RestrictedLaunchActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(RestrictedLaunchActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(RestrictedLaunchActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(RestrictedLaunchActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "shared_context", reinterpret_cast<getter>(RestrictedLaunchActivatedEventArgs_get_SharedContext), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RestrictedLaunchActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RestrictedLaunchActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RestrictedLaunchActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RestrictedLaunchActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RestrictedLaunchActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_RestrictedLaunchActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.RestrictedLaunchActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::RestrictedLaunchActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RestrictedLaunchActivatedEventArgs};

    // ----- SearchActivatedEventArgs class --------------------

    static PyObject* _new_SearchActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::SearchActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::SearchActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SearchActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::SearchActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::SearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.SearchActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::SearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.SearchActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::SearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.SearchActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::SearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.SearchActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::ApplicationModel::Activation::SearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.SearchActivatedEventArgs", L"CurrentlyShownApplicationViewId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CurrentlyShownApplicationViewId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchActivatedEventArgs_get_Language(py::wrapper::Windows::ApplicationModel::Activation::SearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.SearchActivatedEventArgs", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchActivatedEventArgs_get_QueryText(py::wrapper::Windows::ApplicationModel::Activation::SearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.SearchActivatedEventArgs", L"QueryText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.QueryText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchActivatedEventArgs_get_LinguisticDetails(py::wrapper::Windows::ApplicationModel::Activation::SearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.SearchActivatedEventArgs", L"LinguisticDetails");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LinguisticDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchActivatedEventArgs_get_ViewSwitcher(py::wrapper::Windows::ApplicationModel::Activation::SearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.SearchActivatedEventArgs", L"ViewSwitcher");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ViewSwitcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::SearchActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::SearchActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_SearchActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SearchActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(SearchActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(SearchActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(SearchActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(SearchActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(SearchActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "language", reinterpret_cast<getter>(SearchActivatedEventArgs_get_Language), nullptr, nullptr, nullptr },
        { "query_text", reinterpret_cast<getter>(SearchActivatedEventArgs_get_QueryText), nullptr, nullptr, nullptr },
        { "linguistic_details", reinterpret_cast<getter>(SearchActivatedEventArgs_get_LinguisticDetails), nullptr, nullptr, nullptr },
        { "view_switcher", reinterpret_cast<getter>(SearchActivatedEventArgs_get_ViewSwitcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SearchActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_SearchActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.SearchActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::SearchActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchActivatedEventArgs};

    // ----- ShareTargetActivatedEventArgs class --------------------

    static PyObject* _new_ShareTargetActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ShareTargetActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ShareTargetActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ShareTargetActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ShareTargetActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ShareTargetActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ShareTargetActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ShareTargetActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ShareTargetActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ShareTargetActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ShareTargetActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ShareTargetActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::ShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ShareTargetActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ShareTargetActivatedEventArgs_get_ShareOperation(py::wrapper::Windows::ApplicationModel::Activation::ShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ShareTargetActivatedEventArgs", L"ShareOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ShareOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ShareTargetActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ShareTargetActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ShareTargetActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ShareTargetActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ShareTargetActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ShareTargetActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ShareTargetActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ShareTargetActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(ShareTargetActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ShareTargetActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ShareTargetActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(ShareTargetActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "share_operation", reinterpret_cast<getter>(ShareTargetActivatedEventArgs_get_ShareOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ShareTargetActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ShareTargetActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ShareTargetActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ShareTargetActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ShareTargetActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ShareTargetActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ShareTargetActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ShareTargetActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ShareTargetActivatedEventArgs};

    // ----- SplashScreen class --------------------

    static PyObject* _new_SplashScreen(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::SplashScreen>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::SplashScreen>::type_name);
        return nullptr;
    }

    static void _dealloc_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::SplashScreen* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SplashScreen_get_ImageLocation(py::wrapper::Windows::ApplicationModel::Activation::SplashScreen* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.SplashScreen", L"ImageLocation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ImageLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplashScreen_add_Dismissed(py::wrapper::Windows::ApplicationModel::Activation::SplashScreen* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Activation.SplashScreen", L"Dismissed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Activation::SplashScreen, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Dismissed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplashScreen_remove_Dismissed(py::wrapper::Windows::ApplicationModel::Activation::SplashScreen* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Activation.SplashScreen", L"Dismissed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Dismissed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SplashScreen(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::SplashScreen>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SplashScreen(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::SplashScreen>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SplashScreen[] = {
        { "add_dismissed", reinterpret_cast<PyCFunction>(SplashScreen_add_Dismissed), METH_O, nullptr },
        { "remove_dismissed", reinterpret_cast<PyCFunction>(SplashScreen_remove_Dismissed), METH_O, nullptr },
        { "_assign_array_", _assign_array_SplashScreen, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SplashScreen), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SplashScreen[] = {
        { "image_location", reinterpret_cast<getter>(SplashScreen_get_ImageLocation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SplashScreen[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SplashScreen) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SplashScreen) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SplashScreen) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SplashScreen) },
        { }
    };

    static PyType_Spec type_spec_SplashScreen = {
        "winrt._winrt_windows_applicationmodel_activation.SplashScreen",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::SplashScreen),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SplashScreen};

    // ----- StartupTaskActivatedEventArgs class --------------------

    static PyObject* _new_StartupTaskActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::StartupTaskActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::StartupTaskActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_StartupTaskActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::StartupTaskActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StartupTaskActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::StartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.StartupTaskActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StartupTaskActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::StartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.StartupTaskActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StartupTaskActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::StartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.StartupTaskActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StartupTaskActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::StartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.StartupTaskActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StartupTaskActivatedEventArgs_get_TaskId(py::wrapper::Windows::ApplicationModel::Activation::StartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.StartupTaskActivatedEventArgs", L"TaskId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TaskId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StartupTaskActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::StartupTaskActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StartupTaskActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::StartupTaskActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StartupTaskActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_StartupTaskActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StartupTaskActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StartupTaskActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(StartupTaskActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(StartupTaskActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(StartupTaskActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(StartupTaskActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "task_id", reinterpret_cast<getter>(StartupTaskActivatedEventArgs_get_TaskId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StartupTaskActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StartupTaskActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StartupTaskActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StartupTaskActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StartupTaskActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_StartupTaskActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.StartupTaskActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::StartupTaskActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StartupTaskActivatedEventArgs};

    // ----- TileActivatedInfo class --------------------

    static PyObject* _new_TileActivatedInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::TileActivatedInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::TileActivatedInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_TileActivatedInfo(py::wrapper::Windows::ApplicationModel::Activation::TileActivatedInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TileActivatedInfo_get_RecentlyShownNotifications(py::wrapper::Windows::ApplicationModel::Activation::TileActivatedInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.TileActivatedInfo", L"RecentlyShownNotifications");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RecentlyShownNotifications());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TileActivatedInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::TileActivatedInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TileActivatedInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::TileActivatedInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TileActivatedInfo[] = {
        { "_assign_array_", _assign_array_TileActivatedInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TileActivatedInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TileActivatedInfo[] = {
        { "recently_shown_notifications", reinterpret_cast<getter>(TileActivatedInfo_get_RecentlyShownNotifications), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TileActivatedInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TileActivatedInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TileActivatedInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TileActivatedInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TileActivatedInfo) },
        { }
    };

    static PyType_Spec type_spec_TileActivatedInfo = {
        "winrt._winrt_windows_applicationmodel_activation.TileActivatedInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::TileActivatedInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TileActivatedInfo};

    // ----- ToastNotificationActivatedEventArgs class --------------------

    static PyObject* _new_ToastNotificationActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ToastNotificationActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToastNotificationActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ToastNotificationActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ToastNotificationActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ToastNotificationActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ToastNotificationActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ToastNotificationActivatedEventArgs", L"CurrentlyShownApplicationViewId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CurrentlyShownApplicationViewId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationActivatedEventArgs_get_Argument(py::wrapper::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ToastNotificationActivatedEventArgs", L"Argument");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Argument());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationActivatedEventArgs_get_UserInput(py::wrapper::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ToastNotificationActivatedEventArgs", L"UserInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UserInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToastNotificationActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToastNotificationActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastNotificationActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ToastNotificationActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToastNotificationActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToastNotificationActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(ToastNotificationActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ToastNotificationActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ToastNotificationActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(ToastNotificationActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(ToastNotificationActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "argument", reinterpret_cast<getter>(ToastNotificationActivatedEventArgs_get_Argument), nullptr, nullptr, nullptr },
        { "user_input", reinterpret_cast<getter>(ToastNotificationActivatedEventArgs_get_UserInput), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToastNotificationActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToastNotificationActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToastNotificationActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToastNotificationActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToastNotificationActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ToastNotificationActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ToastNotificationActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastNotificationActivatedEventArgs};

    // ----- UserDataAccountProviderActivatedEventArgs class --------------------

    static PyObject* _new_UserDataAccountProviderActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::UserDataAccountProviderActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::UserDataAccountProviderActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_UserDataAccountProviderActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::UserDataAccountProviderActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UserDataAccountProviderActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::UserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.UserDataAccountProviderActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataAccountProviderActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::UserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.UserDataAccountProviderActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataAccountProviderActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::UserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.UserDataAccountProviderActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataAccountProviderActivatedEventArgs_get_Operation(py::wrapper::Windows::ApplicationModel::Activation::UserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.UserDataAccountProviderActivatedEventArgs", L"Operation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Operation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UserDataAccountProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::UserDataAccountProviderActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UserDataAccountProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::UserDataAccountProviderActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserDataAccountProviderActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_UserDataAccountProviderActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UserDataAccountProviderActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UserDataAccountProviderActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(UserDataAccountProviderActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(UserDataAccountProviderActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(UserDataAccountProviderActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "operation", reinterpret_cast<getter>(UserDataAccountProviderActivatedEventArgs_get_Operation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UserDataAccountProviderActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_UserDataAccountProviderActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UserDataAccountProviderActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UserDataAccountProviderActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UserDataAccountProviderActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_UserDataAccountProviderActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.UserDataAccountProviderActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::UserDataAccountProviderActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserDataAccountProviderActivatedEventArgs};

    // ----- VoiceCommandActivatedEventArgs class --------------------

    static PyObject* _new_VoiceCommandActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::VoiceCommandActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::VoiceCommandActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_VoiceCommandActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::VoiceCommandActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VoiceCommandActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::VoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.VoiceCommandActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoiceCommandActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::VoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.VoiceCommandActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoiceCommandActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::VoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.VoiceCommandActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoiceCommandActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::VoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.VoiceCommandActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoiceCommandActivatedEventArgs_get_Result(py::wrapper::Windows::ApplicationModel::Activation::VoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.VoiceCommandActivatedEventArgs", L"Result");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Result());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VoiceCommandActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::VoiceCommandActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VoiceCommandActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::VoiceCommandActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VoiceCommandActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_VoiceCommandActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VoiceCommandActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VoiceCommandActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(VoiceCommandActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(VoiceCommandActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(VoiceCommandActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(VoiceCommandActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "result", reinterpret_cast<getter>(VoiceCommandActivatedEventArgs_get_Result), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VoiceCommandActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VoiceCommandActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VoiceCommandActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VoiceCommandActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VoiceCommandActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_VoiceCommandActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.VoiceCommandActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::VoiceCommandActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VoiceCommandActivatedEventArgs};

    // ----- WalletActionActivatedEventArgs class --------------------

    static PyObject* _new_WalletActionActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WalletActionActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WalletActionActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.WalletActionActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WalletActionActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.WalletActionActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WalletActionActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.WalletActionActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WalletActionActivatedEventArgs_get_ActionId(py::wrapper::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.WalletActionActivatedEventArgs", L"ActionId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WalletActionActivatedEventArgs_get_ActionKind(py::wrapper::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.WalletActionActivatedEventArgs", L"ActionKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActionKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WalletActionActivatedEventArgs_get_ItemId(py::wrapper::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.WalletActionActivatedEventArgs", L"ItemId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ItemId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WalletActionActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WalletActionActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WalletActionActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WalletActionActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WalletActionActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WalletActionActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WalletActionActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WalletActionActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WalletActionActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "action_id", reinterpret_cast<getter>(WalletActionActivatedEventArgs_get_ActionId), nullptr, nullptr, nullptr },
        { "action_kind", reinterpret_cast<getter>(WalletActionActivatedEventArgs_get_ActionKind), nullptr, nullptr, nullptr },
        { "item_id", reinterpret_cast<getter>(WalletActionActivatedEventArgs_get_ItemId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WalletActionActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WalletActionActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WalletActionActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WalletActionActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WalletActionActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_WalletActionActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.WalletActionActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WalletActionActivatedEventArgs};

    // ----- WebAccountProviderActivatedEventArgs class --------------------

    static PyObject* _new_WebAccountProviderActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::WebAccountProviderActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::WebAccountProviderActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebAccountProviderActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::WebAccountProviderActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebAccountProviderActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::WebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.WebAccountProviderActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAccountProviderActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::WebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.WebAccountProviderActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAccountProviderActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::WebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.WebAccountProviderActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAccountProviderActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::WebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.WebAccountProviderActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAccountProviderActivatedEventArgs_get_Operation(py::wrapper::Windows::ApplicationModel::Activation::WebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.WebAccountProviderActivatedEventArgs", L"Operation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Operation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebAccountProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::WebAccountProviderActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebAccountProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::WebAccountProviderActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebAccountProviderActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebAccountProviderActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebAccountProviderActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebAccountProviderActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebAccountProviderActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebAccountProviderActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebAccountProviderActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebAccountProviderActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "operation", reinterpret_cast<getter>(WebAccountProviderActivatedEventArgs_get_Operation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebAccountProviderActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebAccountProviderActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebAccountProviderActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebAccountProviderActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebAccountProviderActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_WebAccountProviderActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.WebAccountProviderActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::WebAccountProviderActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebAccountProviderActivatedEventArgs};

    // ----- WebAuthenticationBrokerContinuationEventArgs class --------------------

    static PyObject* _new_WebAuthenticationBrokerContinuationEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::WebAuthenticationBrokerContinuationEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::WebAuthenticationBrokerContinuationEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebAuthenticationBrokerContinuationEventArgs(py::wrapper::Windows::ApplicationModel::Activation::WebAuthenticationBrokerContinuationEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebAuthenticationBrokerContinuationEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::WebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.WebAuthenticationBrokerContinuationEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAuthenticationBrokerContinuationEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::WebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.WebAuthenticationBrokerContinuationEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAuthenticationBrokerContinuationEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::WebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.WebAuthenticationBrokerContinuationEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAuthenticationBrokerContinuationEventArgs_get_ContinuationData(py::wrapper::Windows::ApplicationModel::Activation::WebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.WebAuthenticationBrokerContinuationEventArgs", L"ContinuationData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContinuationData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAuthenticationBrokerContinuationEventArgs_get_WebAuthenticationResult(py::wrapper::Windows::ApplicationModel::Activation::WebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.WebAuthenticationBrokerContinuationEventArgs", L"WebAuthenticationResult");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WebAuthenticationResult());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebAuthenticationBrokerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::WebAuthenticationBrokerContinuationEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebAuthenticationBrokerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::WebAuthenticationBrokerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebAuthenticationBrokerContinuationEventArgs[] = {
        { "_assign_array_", _assign_array_WebAuthenticationBrokerContinuationEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebAuthenticationBrokerContinuationEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebAuthenticationBrokerContinuationEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebAuthenticationBrokerContinuationEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebAuthenticationBrokerContinuationEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebAuthenticationBrokerContinuationEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "continuation_data", reinterpret_cast<getter>(WebAuthenticationBrokerContinuationEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "web_authentication_result", reinterpret_cast<getter>(WebAuthenticationBrokerContinuationEventArgs_get_WebAuthenticationResult), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebAuthenticationBrokerContinuationEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebAuthenticationBrokerContinuationEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebAuthenticationBrokerContinuationEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebAuthenticationBrokerContinuationEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebAuthenticationBrokerContinuationEventArgs) },
        { }
    };

    static PyType_Spec type_spec_WebAuthenticationBrokerContinuationEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.WebAuthenticationBrokerContinuationEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::WebAuthenticationBrokerContinuationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebAuthenticationBrokerContinuationEventArgs};

    // ----- IActivatedEventArgs interface --------------------

    static PyObject* _new_IActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(IActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IActivatedEventArgs};

    // ----- IActivatedEventArgsWithUser interface --------------------

    static PyObject* _new_IActivatedEventArgsWithUser(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IActivatedEventArgsWithUser>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IActivatedEventArgsWithUser>::type_name);
        return nullptr;
    }

    static void _dealloc_IActivatedEventArgsWithUser(py::wrapper::Windows::ApplicationModel::Activation::IActivatedEventArgsWithUser* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IActivatedEventArgsWithUser_get_User(py::wrapper::Windows::ApplicationModel::Activation::IActivatedEventArgsWithUser* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgsWithUser", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IActivatedEventArgsWithUser_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IActivatedEventArgsWithUser* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IActivatedEventArgsWithUser_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IActivatedEventArgsWithUser* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IActivatedEventArgsWithUser_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IActivatedEventArgsWithUser* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IActivatedEventArgsWithUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IActivatedEventArgsWithUser>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IActivatedEventArgsWithUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IActivatedEventArgsWithUser>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IActivatedEventArgsWithUser[] = {
        { "_assign_array_", _assign_array_IActivatedEventArgsWithUser, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IActivatedEventArgsWithUser), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IActivatedEventArgsWithUser[] = {
        { "user", reinterpret_cast<getter>(IActivatedEventArgsWithUser_get_User), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IActivatedEventArgsWithUser_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IActivatedEventArgsWithUser_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IActivatedEventArgsWithUser_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IActivatedEventArgsWithUser[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IActivatedEventArgsWithUser) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IActivatedEventArgsWithUser) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IActivatedEventArgsWithUser) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IActivatedEventArgsWithUser) },
        { }
    };

    static PyType_Spec type_spec_IActivatedEventArgsWithUser = {
        "winrt._winrt_windows_applicationmodel_activation.IActivatedEventArgsWithUser",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IActivatedEventArgsWithUser),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IActivatedEventArgsWithUser};

    // ----- IApplicationViewActivatedEventArgs interface --------------------

    static PyObject* _new_IApplicationViewActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IApplicationViewActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IApplicationViewActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IApplicationViewActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IApplicationViewActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IApplicationViewActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::ApplicationModel::Activation::IApplicationViewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IApplicationViewActivatedEventArgs", L"CurrentlyShownApplicationViewId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CurrentlyShownApplicationViewId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IApplicationViewActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IApplicationViewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IApplicationViewActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IApplicationViewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IApplicationViewActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IApplicationViewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IApplicationViewActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IApplicationViewActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IApplicationViewActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IApplicationViewActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IApplicationViewActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IApplicationViewActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IApplicationViewActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IApplicationViewActivatedEventArgs[] = {
        { "currently_shown_application_view_id", reinterpret_cast<getter>(IApplicationViewActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IApplicationViewActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IApplicationViewActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IApplicationViewActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IApplicationViewActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IApplicationViewActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IApplicationViewActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IApplicationViewActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IApplicationViewActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IApplicationViewActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IApplicationViewActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IApplicationViewActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IApplicationViewActivatedEventArgs};

    // ----- IAppointmentsProviderActivatedEventArgs interface --------------------

    static PyObject* _new_IAppointmentsProviderActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IAppointmentsProviderActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAppointmentsProviderActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IAppointmentsProviderActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IAppointmentsProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAppointmentsProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAppointmentsProviderActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IAppointmentsProviderActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAppointmentsProviderActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAppointmentsProviderActivatedEventArgs[] = {
        { "verb", reinterpret_cast<getter>(IAppointmentsProviderActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IAppointmentsProviderActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IAppointmentsProviderActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IAppointmentsProviderActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAppointmentsProviderActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAppointmentsProviderActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAppointmentsProviderActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAppointmentsProviderActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAppointmentsProviderActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IAppointmentsProviderActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IAppointmentsProviderActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAppointmentsProviderActivatedEventArgs};

    // ----- IAppointmentsProviderAddAppointmentActivatedEventArgs interface --------------------

    static PyObject* _new_IAppointmentsProviderAddAppointmentActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IAppointmentsProviderAddAppointmentActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAppointmentsProviderAddAppointmentActivatedEventArgs_get_AddAppointmentOperation(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IAppointmentsProviderAddAppointmentActivatedEventArgs", L"AddAppointmentOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AddAppointmentOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderAddAppointmentActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IAppointmentsProviderActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderAddAppointmentActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderAddAppointmentActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderAddAppointmentActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IAppointmentsProviderAddAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAppointmentsProviderAddAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAppointmentsProviderAddAppointmentActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IAppointmentsProviderAddAppointmentActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAppointmentsProviderAddAppointmentActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAppointmentsProviderAddAppointmentActivatedEventArgs[] = {
        { "add_appointment_operation", reinterpret_cast<getter>(IAppointmentsProviderAddAppointmentActivatedEventArgs_get_AddAppointmentOperation), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IAppointmentsProviderAddAppointmentActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IAppointmentsProviderAddAppointmentActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IAppointmentsProviderAddAppointmentActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IAppointmentsProviderAddAppointmentActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAppointmentsProviderAddAppointmentActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAppointmentsProviderAddAppointmentActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAppointmentsProviderAddAppointmentActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAppointmentsProviderAddAppointmentActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAppointmentsProviderAddAppointmentActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IAppointmentsProviderAddAppointmentActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IAppointmentsProviderAddAppointmentActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAppointmentsProviderAddAppointmentActivatedEventArgs};

    // ----- IAppointmentsProviderRemoveAppointmentActivatedEventArgs interface --------------------

    static PyObject* _new_IAppointmentsProviderRemoveAppointmentActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IAppointmentsProviderRemoveAppointmentActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_RemoveAppointmentOperation(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IAppointmentsProviderRemoveAppointmentActivatedEventArgs", L"RemoveAppointmentOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemoveAppointmentOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IAppointmentsProviderActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IAppointmentsProviderRemoveAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAppointmentsProviderRemoveAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAppointmentsProviderRemoveAppointmentActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IAppointmentsProviderRemoveAppointmentActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAppointmentsProviderRemoveAppointmentActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAppointmentsProviderRemoveAppointmentActivatedEventArgs[] = {
        { "remove_appointment_operation", reinterpret_cast<getter>(IAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_RemoveAppointmentOperation), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAppointmentsProviderRemoveAppointmentActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAppointmentsProviderRemoveAppointmentActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAppointmentsProviderRemoveAppointmentActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAppointmentsProviderRemoveAppointmentActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAppointmentsProviderRemoveAppointmentActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IAppointmentsProviderRemoveAppointmentActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IAppointmentsProviderRemoveAppointmentActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAppointmentsProviderRemoveAppointmentActivatedEventArgs};

    // ----- IAppointmentsProviderReplaceAppointmentActivatedEventArgs interface --------------------

    static PyObject* _new_IAppointmentsProviderReplaceAppointmentActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IAppointmentsProviderReplaceAppointmentActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_ReplaceAppointmentOperation(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IAppointmentsProviderReplaceAppointmentActivatedEventArgs", L"ReplaceAppointmentOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReplaceAppointmentOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IAppointmentsProviderActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IAppointmentsProviderReplaceAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAppointmentsProviderReplaceAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAppointmentsProviderReplaceAppointmentActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IAppointmentsProviderReplaceAppointmentActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAppointmentsProviderReplaceAppointmentActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAppointmentsProviderReplaceAppointmentActivatedEventArgs[] = {
        { "replace_appointment_operation", reinterpret_cast<getter>(IAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_ReplaceAppointmentOperation), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAppointmentsProviderReplaceAppointmentActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAppointmentsProviderReplaceAppointmentActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAppointmentsProviderReplaceAppointmentActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAppointmentsProviderReplaceAppointmentActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAppointmentsProviderReplaceAppointmentActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IAppointmentsProviderReplaceAppointmentActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IAppointmentsProviderReplaceAppointmentActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAppointmentsProviderReplaceAppointmentActivatedEventArgs};

    // ----- IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs interface --------------------

    static PyObject* _new_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_InstanceStartDate(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"InstanceStartDate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InstanceStartDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_LocalId(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"LocalId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_RoamingId(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"RoamingId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RoamingId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IAppointmentsProviderActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs[] = {
        { "instance_start_date", reinterpret_cast<getter>(IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_InstanceStartDate), nullptr, nullptr, nullptr },
        { "local_id", reinterpret_cast<getter>(IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_LocalId), nullptr, nullptr, nullptr },
        { "roaming_id", reinterpret_cast<getter>(IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_RoamingId), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs};

    // ----- IAppointmentsProviderShowTimeFrameActivatedEventArgs interface --------------------

    static PyObject* _new_IAppointmentsProviderShowTimeFrameActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IAppointmentsProviderShowTimeFrameActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_Duration(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IAppointmentsProviderShowTimeFrameActivatedEventArgs", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_TimeToShow(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IAppointmentsProviderShowTimeFrameActivatedEventArgs", L"TimeToShow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TimeToShow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IAppointmentsProviderActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IAppointmentsProviderShowTimeFrameActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAppointmentsProviderShowTimeFrameActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAppointmentsProviderShowTimeFrameActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IAppointmentsProviderShowTimeFrameActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAppointmentsProviderShowTimeFrameActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAppointmentsProviderShowTimeFrameActivatedEventArgs[] = {
        { "duration", reinterpret_cast<getter>(IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_Duration), nullptr, nullptr, nullptr },
        { "time_to_show", reinterpret_cast<getter>(IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_TimeToShow), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAppointmentsProviderShowTimeFrameActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAppointmentsProviderShowTimeFrameActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAppointmentsProviderShowTimeFrameActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAppointmentsProviderShowTimeFrameActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAppointmentsProviderShowTimeFrameActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IAppointmentsProviderShowTimeFrameActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IAppointmentsProviderShowTimeFrameActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAppointmentsProviderShowTimeFrameActivatedEventArgs};

    // ----- IBackgroundActivatedEventArgs interface --------------------

    static PyObject* _new_IBackgroundActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IBackgroundActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IBackgroundActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IBackgroundActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IBackgroundActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBackgroundActivatedEventArgs_get_TaskInstance(py::wrapper::Windows::ApplicationModel::Activation::IBackgroundActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IBackgroundActivatedEventArgs", L"TaskInstance");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TaskInstance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IBackgroundActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IBackgroundActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBackgroundActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IBackgroundActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IBackgroundActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBackgroundActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBackgroundActivatedEventArgs[] = {
        { "task_instance", reinterpret_cast<getter>(IBackgroundActivatedEventArgs_get_TaskInstance), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBackgroundActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBackgroundActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBackgroundActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBackgroundActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBackgroundActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IBackgroundActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IBackgroundActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IBackgroundActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundActivatedEventArgs};

    // ----- IBarcodeScannerPreviewActivatedEventArgs interface --------------------

    static PyObject* _new_IBarcodeScannerPreviewActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IBarcodeScannerPreviewActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IBarcodeScannerPreviewActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IBarcodeScannerPreviewActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IBarcodeScannerPreviewActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBarcodeScannerPreviewActivatedEventArgs_get_ConnectionId(py::wrapper::Windows::ApplicationModel::Activation::IBarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IBarcodeScannerPreviewActivatedEventArgs", L"ConnectionId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ConnectionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBarcodeScannerPreviewActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IBarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBarcodeScannerPreviewActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IBarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBarcodeScannerPreviewActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IBarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IBarcodeScannerPreviewActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IBarcodeScannerPreviewActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBarcodeScannerPreviewActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IBarcodeScannerPreviewActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBarcodeScannerPreviewActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IBarcodeScannerPreviewActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBarcodeScannerPreviewActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBarcodeScannerPreviewActivatedEventArgs[] = {
        { "connection_id", reinterpret_cast<getter>(IBarcodeScannerPreviewActivatedEventArgs_get_ConnectionId), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IBarcodeScannerPreviewActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IBarcodeScannerPreviewActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IBarcodeScannerPreviewActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBarcodeScannerPreviewActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBarcodeScannerPreviewActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBarcodeScannerPreviewActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBarcodeScannerPreviewActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBarcodeScannerPreviewActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IBarcodeScannerPreviewActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IBarcodeScannerPreviewActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IBarcodeScannerPreviewActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBarcodeScannerPreviewActivatedEventArgs};

    // ----- ICachedFileUpdaterActivatedEventArgs interface --------------------

    static PyObject* _new_ICachedFileUpdaterActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ICachedFileUpdaterActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ICachedFileUpdaterActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ICachedFileUpdaterActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ICachedFileUpdaterActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICachedFileUpdaterActivatedEventArgs_get_CachedFileUpdaterUI(py::wrapper::Windows::ApplicationModel::Activation::ICachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ICachedFileUpdaterActivatedEventArgs", L"CachedFileUpdaterUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CachedFileUpdaterUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICachedFileUpdaterActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ICachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICachedFileUpdaterActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ICachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICachedFileUpdaterActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ICachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICachedFileUpdaterActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ICachedFileUpdaterActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICachedFileUpdaterActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ICachedFileUpdaterActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICachedFileUpdaterActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ICachedFileUpdaterActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICachedFileUpdaterActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICachedFileUpdaterActivatedEventArgs[] = {
        { "cached_file_updater_u_i", reinterpret_cast<getter>(ICachedFileUpdaterActivatedEventArgs_get_CachedFileUpdaterUI), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ICachedFileUpdaterActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ICachedFileUpdaterActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ICachedFileUpdaterActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICachedFileUpdaterActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICachedFileUpdaterActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICachedFileUpdaterActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICachedFileUpdaterActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICachedFileUpdaterActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ICachedFileUpdaterActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ICachedFileUpdaterActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ICachedFileUpdaterActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICachedFileUpdaterActivatedEventArgs};

    // ----- ICameraSettingsActivatedEventArgs interface --------------------

    static PyObject* _new_ICameraSettingsActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ICameraSettingsActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICameraSettingsActivatedEventArgs_get_VideoDeviceController(py::wrapper::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ICameraSettingsActivatedEventArgs", L"VideoDeviceController");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoDeviceController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICameraSettingsActivatedEventArgs_get_VideoDeviceExtension(py::wrapper::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ICameraSettingsActivatedEventArgs", L"VideoDeviceExtension");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoDeviceExtension());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICameraSettingsActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICameraSettingsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICameraSettingsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICameraSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICameraSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICameraSettingsActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ICameraSettingsActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICameraSettingsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICameraSettingsActivatedEventArgs[] = {
        { "video_device_controller", reinterpret_cast<getter>(ICameraSettingsActivatedEventArgs_get_VideoDeviceController), nullptr, nullptr, nullptr },
        { "video_device_extension", reinterpret_cast<getter>(ICameraSettingsActivatedEventArgs_get_VideoDeviceExtension), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ICameraSettingsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ICameraSettingsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ICameraSettingsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICameraSettingsActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICameraSettingsActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICameraSettingsActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICameraSettingsActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICameraSettingsActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ICameraSettingsActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ICameraSettingsActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICameraSettingsActivatedEventArgs};

    // ----- ICommandLineActivatedEventArgs interface --------------------

    static PyObject* _new_ICommandLineActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ICommandLineActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ICommandLineActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ICommandLineActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ICommandLineActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICommandLineActivatedEventArgs_get_Operation(py::wrapper::Windows::ApplicationModel::Activation::ICommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ICommandLineActivatedEventArgs", L"Operation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Operation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommandLineActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ICommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommandLineActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ICommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommandLineActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ICommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICommandLineActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ICommandLineActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICommandLineActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ICommandLineActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICommandLineActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ICommandLineActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICommandLineActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICommandLineActivatedEventArgs[] = {
        { "operation", reinterpret_cast<getter>(ICommandLineActivatedEventArgs_get_Operation), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ICommandLineActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ICommandLineActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ICommandLineActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICommandLineActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICommandLineActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICommandLineActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICommandLineActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICommandLineActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ICommandLineActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ICommandLineActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ICommandLineActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICommandLineActivatedEventArgs};

    // ----- IContactActivatedEventArgs interface --------------------

    static PyObject* _new_IContactActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IContactActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IContactActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IContactActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IContactActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IContactActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IContactActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IContactActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IContactActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IContactActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IContactActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IContactActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContactActivatedEventArgs[] = {
        { "verb", reinterpret_cast<getter>(IContactActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IContactActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IContactActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IContactActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IContactActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IContactActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IContactActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IContactActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IContactActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IContactActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IContactActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IContactActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactActivatedEventArgs};

    // ----- IContactCallActivatedEventArgs interface --------------------

    static PyObject* _new_IContactCallActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IContactCallActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactCallActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactCallActivatedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactCallActivatedEventArgs_get_ServiceId(py::wrapper::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactCallActivatedEventArgs", L"ServiceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactCallActivatedEventArgs_get_ServiceUserId(py::wrapper::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactCallActivatedEventArgs", L"ServiceUserId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServiceUserId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactCallActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactCallActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactCallActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactCallActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IContactCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IContactCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactCallActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IContactCallActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactCallActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContactCallActivatedEventArgs[] = {
        { "contact", reinterpret_cast<getter>(IContactCallActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(IContactCallActivatedEventArgs_get_ServiceId), nullptr, nullptr, nullptr },
        { "service_user_id", reinterpret_cast<getter>(IContactCallActivatedEventArgs_get_ServiceUserId), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IContactCallActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IContactCallActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IContactCallActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IContactCallActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IContactCallActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IContactCallActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IContactCallActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IContactCallActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IContactCallActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IContactCallActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IContactCallActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactCallActivatedEventArgs};

    // ----- IContactMapActivatedEventArgs interface --------------------

    static PyObject* _new_IContactMapActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IContactMapActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactMapActivatedEventArgs_get_Address(py::wrapper::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactMapActivatedEventArgs", L"Address");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Address());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactMapActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactMapActivatedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactMapActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactMapActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactMapActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactMapActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IContactMapActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IContactMapActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactMapActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IContactMapActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactMapActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContactMapActivatedEventArgs[] = {
        { "address", reinterpret_cast<getter>(IContactMapActivatedEventArgs_get_Address), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(IContactMapActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IContactMapActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IContactMapActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IContactMapActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IContactMapActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IContactMapActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IContactMapActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IContactMapActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IContactMapActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IContactMapActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IContactMapActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IContactMapActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactMapActivatedEventArgs};

    // ----- IContactMessageActivatedEventArgs interface --------------------

    static PyObject* _new_IContactMessageActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IContactMessageActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactMessageActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactMessageActivatedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactMessageActivatedEventArgs_get_ServiceId(py::wrapper::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactMessageActivatedEventArgs", L"ServiceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactMessageActivatedEventArgs_get_ServiceUserId(py::wrapper::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactMessageActivatedEventArgs", L"ServiceUserId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServiceUserId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactMessageActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactMessageActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactMessageActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactMessageActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IContactMessageActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IContactMessageActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactMessageActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IContactMessageActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactMessageActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContactMessageActivatedEventArgs[] = {
        { "contact", reinterpret_cast<getter>(IContactMessageActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(IContactMessageActivatedEventArgs_get_ServiceId), nullptr, nullptr, nullptr },
        { "service_user_id", reinterpret_cast<getter>(IContactMessageActivatedEventArgs_get_ServiceUserId), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IContactMessageActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IContactMessageActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IContactMessageActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IContactMessageActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IContactMessageActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IContactMessageActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IContactMessageActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IContactMessageActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IContactMessageActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IContactMessageActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IContactMessageActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactMessageActivatedEventArgs};

    // ----- IContactPanelActivatedEventArgs interface --------------------

    static PyObject* _new_IContactPanelActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactPanelActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactPanelActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IContactPanelActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IContactPanelActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactPanelActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::IContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactPanelActivatedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactPanelActivatedEventArgs_get_ContactPanel(py::wrapper::Windows::ApplicationModel::Activation::IContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactPanelActivatedEventArgs", L"ContactPanel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContactPanel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IContactPanelActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IContactPanelActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IContactPanelActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IContactPanelActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactPanelActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IContactPanelActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactPanelActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContactPanelActivatedEventArgs[] = {
        { "contact", reinterpret_cast<getter>(IContactPanelActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "contact_panel", reinterpret_cast<getter>(IContactPanelActivatedEventArgs_get_ContactPanel), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IContactPanelActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IContactPanelActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IContactPanelActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IContactPanelActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IContactPanelActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IContactPanelActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IContactPanelActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IContactPanelActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactPanelActivatedEventArgs};

    // ----- IContactPickerActivatedEventArgs interface --------------------

    static PyObject* _new_IContactPickerActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactPickerActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactPickerActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IContactPickerActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IContactPickerActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactPickerActivatedEventArgs_get_ContactPickerUI(py::wrapper::Windows::ApplicationModel::Activation::IContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactPickerActivatedEventArgs", L"ContactPickerUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContactPickerUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactPickerActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactPickerActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactPickerActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IContactPickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IContactPickerActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IContactPickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IContactPickerActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactPickerActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IContactPickerActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactPickerActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContactPickerActivatedEventArgs[] = {
        { "contact_picker_u_i", reinterpret_cast<getter>(IContactPickerActivatedEventArgs_get_ContactPickerUI), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IContactPickerActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IContactPickerActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IContactPickerActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IContactPickerActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IContactPickerActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IContactPickerActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IContactPickerActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IContactPickerActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IContactPickerActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IContactPickerActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IContactPickerActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactPickerActivatedEventArgs};

    // ----- IContactPostActivatedEventArgs interface --------------------

    static PyObject* _new_IContactPostActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IContactPostActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactPostActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactPostActivatedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactPostActivatedEventArgs_get_ServiceId(py::wrapper::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactPostActivatedEventArgs", L"ServiceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactPostActivatedEventArgs_get_ServiceUserId(py::wrapper::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactPostActivatedEventArgs", L"ServiceUserId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServiceUserId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactPostActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactPostActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactPostActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactPostActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IContactPostActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IContactPostActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactPostActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IContactPostActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactPostActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContactPostActivatedEventArgs[] = {
        { "contact", reinterpret_cast<getter>(IContactPostActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(IContactPostActivatedEventArgs_get_ServiceId), nullptr, nullptr, nullptr },
        { "service_user_id", reinterpret_cast<getter>(IContactPostActivatedEventArgs_get_ServiceUserId), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IContactPostActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IContactPostActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IContactPostActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IContactPostActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IContactPostActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IContactPostActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IContactPostActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IContactPostActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IContactPostActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IContactPostActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IContactPostActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactPostActivatedEventArgs};

    // ----- IContactVideoCallActivatedEventArgs interface --------------------

    static PyObject* _new_IContactVideoCallActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IContactVideoCallActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactVideoCallActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactVideoCallActivatedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactVideoCallActivatedEventArgs_get_ServiceId(py::wrapper::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactVideoCallActivatedEventArgs", L"ServiceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactVideoCallActivatedEventArgs_get_ServiceUserId(py::wrapper::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactVideoCallActivatedEventArgs", L"ServiceUserId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServiceUserId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactVideoCallActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactVideoCallActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactVideoCallActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactVideoCallActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IContactVideoCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IContactVideoCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactVideoCallActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IContactVideoCallActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactVideoCallActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContactVideoCallActivatedEventArgs[] = {
        { "contact", reinterpret_cast<getter>(IContactVideoCallActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(IContactVideoCallActivatedEventArgs_get_ServiceId), nullptr, nullptr, nullptr },
        { "service_user_id", reinterpret_cast<getter>(IContactVideoCallActivatedEventArgs_get_ServiceUserId), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IContactVideoCallActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IContactVideoCallActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IContactVideoCallActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IContactVideoCallActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IContactVideoCallActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IContactVideoCallActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IContactVideoCallActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IContactVideoCallActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IContactVideoCallActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IContactVideoCallActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IContactVideoCallActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactVideoCallActivatedEventArgs};

    // ----- IContactsProviderActivatedEventArgs interface --------------------

    static PyObject* _new_IContactsProviderActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactsProviderActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactsProviderActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IContactsProviderActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IContactsProviderActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactsProviderActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IContactsProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactsProviderActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactsProviderActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IContactsProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactsProviderActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IContactsProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactsProviderActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IContactsProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IContactsProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IContactsProviderActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IContactsProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IContactsProviderActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactsProviderActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IContactsProviderActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactsProviderActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContactsProviderActivatedEventArgs[] = {
        { "verb", reinterpret_cast<getter>(IContactsProviderActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IContactsProviderActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IContactsProviderActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IContactsProviderActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IContactsProviderActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IContactsProviderActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IContactsProviderActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IContactsProviderActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IContactsProviderActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IContactsProviderActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IContactsProviderActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IContactsProviderActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactsProviderActivatedEventArgs};

    // ----- IContinuationActivatedEventArgs interface --------------------

    static PyObject* _new_IContinuationActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IContinuationActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IContinuationActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IContinuationActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IContinuationActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContinuationActivatedEventArgs_get_ContinuationData(py::wrapper::Windows::ApplicationModel::Activation::IContinuationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContinuationActivatedEventArgs", L"ContinuationData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContinuationData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContinuationActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IContinuationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContinuationActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IContinuationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContinuationActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IContinuationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IContinuationActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IContinuationActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IContinuationActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IContinuationActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContinuationActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IContinuationActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContinuationActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContinuationActivatedEventArgs[] = {
        { "continuation_data", reinterpret_cast<getter>(IContinuationActivatedEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IContinuationActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IContinuationActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IContinuationActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IContinuationActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IContinuationActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IContinuationActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IContinuationActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IContinuationActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IContinuationActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IContinuationActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IContinuationActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContinuationActivatedEventArgs};

    // ----- IDeviceActivatedEventArgs interface --------------------

    static PyObject* _new_IDeviceActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IDeviceActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IDeviceActivatedEventArgs_get_DeviceInformationId(py::wrapper::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IDeviceActivatedEventArgs", L"DeviceInformationId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceInformationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDeviceActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IDeviceActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDeviceActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDeviceActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDeviceActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IDeviceActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IDeviceActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IDeviceActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IDeviceActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IDeviceActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IDeviceActivatedEventArgs[] = {
        { "device_information_id", reinterpret_cast<getter>(IDeviceActivatedEventArgs_get_DeviceInformationId), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IDeviceActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IDeviceActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IDeviceActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IDeviceActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IDeviceActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IDeviceActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IDeviceActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IDeviceActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IDeviceActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IDeviceActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IDeviceActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IDeviceActivatedEventArgs};

    // ----- IDevicePairingActivatedEventArgs interface --------------------

    static PyObject* _new_IDevicePairingActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IDevicePairingActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IDevicePairingActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IDevicePairingActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IDevicePairingActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IDevicePairingActivatedEventArgs_get_DeviceInformation(py::wrapper::Windows::ApplicationModel::Activation::IDevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IDevicePairingActivatedEventArgs", L"DeviceInformation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDevicePairingActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IDevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDevicePairingActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IDevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDevicePairingActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IDevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IDevicePairingActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IDevicePairingActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IDevicePairingActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IDevicePairingActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IDevicePairingActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IDevicePairingActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IDevicePairingActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IDevicePairingActivatedEventArgs[] = {
        { "device_information", reinterpret_cast<getter>(IDevicePairingActivatedEventArgs_get_DeviceInformation), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IDevicePairingActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IDevicePairingActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IDevicePairingActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IDevicePairingActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IDevicePairingActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IDevicePairingActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IDevicePairingActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IDevicePairingActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IDevicePairingActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IDevicePairingActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IDevicePairingActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IDevicePairingActivatedEventArgs};

    // ----- IDialReceiverActivatedEventArgs interface --------------------

    static PyObject* _new_IDialReceiverActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IDialReceiverActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IDialReceiverActivatedEventArgs_get_AppName(py::wrapper::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IDialReceiverActivatedEventArgs", L"AppName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDialReceiverActivatedEventArgs_get_Arguments(py::wrapper::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ILaunchActivatedEventArgs", L"Arguments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Arguments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDialReceiverActivatedEventArgs_get_TileId(py::wrapper::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ILaunchActivatedEventArgs", L"TileId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TileId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDialReceiverActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDialReceiverActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDialReceiverActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IDialReceiverActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IDialReceiverActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IDialReceiverActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IDialReceiverActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IDialReceiverActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IDialReceiverActivatedEventArgs[] = {
        { "app_name", reinterpret_cast<getter>(IDialReceiverActivatedEventArgs_get_AppName), nullptr, nullptr, nullptr },
        { "arguments", reinterpret_cast<getter>(IDialReceiverActivatedEventArgs_get_Arguments), nullptr, nullptr, nullptr },
        { "tile_id", reinterpret_cast<getter>(IDialReceiverActivatedEventArgs_get_TileId), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IDialReceiverActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IDialReceiverActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IDialReceiverActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IDialReceiverActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IDialReceiverActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IDialReceiverActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IDialReceiverActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IDialReceiverActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IDialReceiverActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IDialReceiverActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IDialReceiverActivatedEventArgs};

    // ----- IFileActivatedEventArgs interface --------------------

    static PyObject* _new_IFileActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IFileActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IFileActivatedEventArgs_get_Files(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IFileActivatedEventArgs", L"Files");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Files());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IFileActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IFileActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IFileActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IFileActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IFileActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IFileActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IFileActivatedEventArgs[] = {
        { "files", reinterpret_cast<getter>(IFileActivatedEventArgs_get_Files), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IFileActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IFileActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IFileActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IFileActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IFileActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IFileActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IFileActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IFileActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IFileActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IFileActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IFileActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IFileActivatedEventArgs};

    // ----- IFileActivatedEventArgsWithCallerPackageFamilyName interface --------------------

    static PyObject* _new_IFileActivatedEventArgsWithCallerPackageFamilyName(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithCallerPackageFamilyName>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithCallerPackageFamilyName>::type_name);
        return nullptr;
    }

    static void _dealloc_IFileActivatedEventArgsWithCallerPackageFamilyName(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithCallerPackageFamilyName* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IFileActivatedEventArgsWithCallerPackageFamilyName_get_CallerPackageFamilyName(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithCallerPackageFamilyName* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IFileActivatedEventArgsWithCallerPackageFamilyName", L"CallerPackageFamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CallerPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgsWithCallerPackageFamilyName_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithCallerPackageFamilyName* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgsWithCallerPackageFamilyName_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithCallerPackageFamilyName* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgsWithCallerPackageFamilyName_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithCallerPackageFamilyName* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IFileActivatedEventArgsWithCallerPackageFamilyName(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithCallerPackageFamilyName>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IFileActivatedEventArgsWithCallerPackageFamilyName(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithCallerPackageFamilyName>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IFileActivatedEventArgsWithCallerPackageFamilyName[] = {
        { "_assign_array_", _assign_array_IFileActivatedEventArgsWithCallerPackageFamilyName, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IFileActivatedEventArgsWithCallerPackageFamilyName), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IFileActivatedEventArgsWithCallerPackageFamilyName[] = {
        { "caller_package_family_name", reinterpret_cast<getter>(IFileActivatedEventArgsWithCallerPackageFamilyName_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IFileActivatedEventArgsWithCallerPackageFamilyName_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IFileActivatedEventArgsWithCallerPackageFamilyName_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IFileActivatedEventArgsWithCallerPackageFamilyName_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IFileActivatedEventArgsWithCallerPackageFamilyName[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IFileActivatedEventArgsWithCallerPackageFamilyName) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IFileActivatedEventArgsWithCallerPackageFamilyName) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IFileActivatedEventArgsWithCallerPackageFamilyName) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IFileActivatedEventArgsWithCallerPackageFamilyName) },
        { }
    };

    static PyType_Spec type_spec_IFileActivatedEventArgsWithCallerPackageFamilyName = {
        "winrt._winrt_windows_applicationmodel_activation.IFileActivatedEventArgsWithCallerPackageFamilyName",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithCallerPackageFamilyName),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IFileActivatedEventArgsWithCallerPackageFamilyName};

    // ----- IFileActivatedEventArgsWithNeighboringFiles interface --------------------

    static PyObject* _new_IFileActivatedEventArgsWithNeighboringFiles(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles>::type_name);
        return nullptr;
    }

    static void _dealloc_IFileActivatedEventArgsWithNeighboringFiles(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IFileActivatedEventArgsWithNeighboringFiles_get_NeighboringFilesQuery(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IFileActivatedEventArgsWithNeighboringFiles", L"NeighboringFilesQuery");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NeighboringFilesQuery());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgsWithNeighboringFiles_get_Files(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IFileActivatedEventArgs", L"Files");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Files());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgsWithNeighboringFiles_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IFileActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgsWithNeighboringFiles_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgsWithNeighboringFiles_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgsWithNeighboringFiles_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IFileActivatedEventArgsWithNeighboringFiles(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IFileActivatedEventArgsWithNeighboringFiles(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IFileActivatedEventArgsWithNeighboringFiles[] = {
        { "_assign_array_", _assign_array_IFileActivatedEventArgsWithNeighboringFiles, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IFileActivatedEventArgsWithNeighboringFiles), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IFileActivatedEventArgsWithNeighboringFiles[] = {
        { "neighboring_files_query", reinterpret_cast<getter>(IFileActivatedEventArgsWithNeighboringFiles_get_NeighboringFilesQuery), nullptr, nullptr, nullptr },
        { "files", reinterpret_cast<getter>(IFileActivatedEventArgsWithNeighboringFiles_get_Files), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IFileActivatedEventArgsWithNeighboringFiles_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IFileActivatedEventArgsWithNeighboringFiles_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IFileActivatedEventArgsWithNeighboringFiles_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IFileActivatedEventArgsWithNeighboringFiles_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IFileActivatedEventArgsWithNeighboringFiles[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IFileActivatedEventArgsWithNeighboringFiles) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IFileActivatedEventArgsWithNeighboringFiles) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IFileActivatedEventArgsWithNeighboringFiles) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IFileActivatedEventArgsWithNeighboringFiles) },
        { }
    };

    static PyType_Spec type_spec_IFileActivatedEventArgsWithNeighboringFiles = {
        "winrt._winrt_windows_applicationmodel_activation.IFileActivatedEventArgsWithNeighboringFiles",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IFileActivatedEventArgsWithNeighboringFiles};

    // ----- IFileOpenPickerActivatedEventArgs interface --------------------

    static PyObject* _new_IFileOpenPickerActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IFileOpenPickerActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IFileOpenPickerActivatedEventArgs_get_FileOpenPickerUI(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IFileOpenPickerActivatedEventArgs", L"FileOpenPickerUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FileOpenPickerUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileOpenPickerActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileOpenPickerActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileOpenPickerActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IFileOpenPickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IFileOpenPickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IFileOpenPickerActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IFileOpenPickerActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IFileOpenPickerActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IFileOpenPickerActivatedEventArgs[] = {
        { "file_open_picker_u_i", reinterpret_cast<getter>(IFileOpenPickerActivatedEventArgs_get_FileOpenPickerUI), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IFileOpenPickerActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IFileOpenPickerActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IFileOpenPickerActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IFileOpenPickerActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IFileOpenPickerActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IFileOpenPickerActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IFileOpenPickerActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IFileOpenPickerActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IFileOpenPickerActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IFileOpenPickerActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IFileOpenPickerActivatedEventArgs};

    // ----- IFileOpenPickerActivatedEventArgs2 interface --------------------

    static PyObject* _new_IFileOpenPickerActivatedEventArgs2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs2>::type_name);
        return nullptr;
    }

    static void _dealloc_IFileOpenPickerActivatedEventArgs2(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IFileOpenPickerActivatedEventArgs2_get_CallerPackageFamilyName(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IFileOpenPickerActivatedEventArgs2", L"CallerPackageFamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CallerPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IFileOpenPickerActivatedEventArgs2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IFileOpenPickerActivatedEventArgs2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IFileOpenPickerActivatedEventArgs2[] = {
        { "_assign_array_", _assign_array_IFileOpenPickerActivatedEventArgs2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IFileOpenPickerActivatedEventArgs2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IFileOpenPickerActivatedEventArgs2[] = {
        { "caller_package_family_name", reinterpret_cast<getter>(IFileOpenPickerActivatedEventArgs2_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IFileOpenPickerActivatedEventArgs2[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IFileOpenPickerActivatedEventArgs2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IFileOpenPickerActivatedEventArgs2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IFileOpenPickerActivatedEventArgs2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IFileOpenPickerActivatedEventArgs2) },
        { }
    };

    static PyType_Spec type_spec_IFileOpenPickerActivatedEventArgs2 = {
        "winrt._winrt_windows_applicationmodel_activation.IFileOpenPickerActivatedEventArgs2",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IFileOpenPickerActivatedEventArgs2};

    // ----- IFileOpenPickerContinuationEventArgs interface --------------------

    static PyObject* _new_IFileOpenPickerContinuationEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IFileOpenPickerContinuationEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IFileOpenPickerContinuationEventArgs_get_Files(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IFileOpenPickerContinuationEventArgs", L"Files");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Files());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileOpenPickerContinuationEventArgs_get_ContinuationData(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContinuationActivatedEventArgs", L"ContinuationData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContinuationData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileOpenPickerContinuationEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileOpenPickerContinuationEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileOpenPickerContinuationEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IFileOpenPickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IFileOpenPickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IFileOpenPickerContinuationEventArgs[] = {
        { "_assign_array_", _assign_array_IFileOpenPickerContinuationEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IFileOpenPickerContinuationEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IFileOpenPickerContinuationEventArgs[] = {
        { "files", reinterpret_cast<getter>(IFileOpenPickerContinuationEventArgs_get_Files), nullptr, nullptr, nullptr },
        { "continuation_data", reinterpret_cast<getter>(IFileOpenPickerContinuationEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IFileOpenPickerContinuationEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IFileOpenPickerContinuationEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IFileOpenPickerContinuationEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IFileOpenPickerContinuationEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IFileOpenPickerContinuationEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IFileOpenPickerContinuationEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IFileOpenPickerContinuationEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IFileOpenPickerContinuationEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IFileOpenPickerContinuationEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IFileOpenPickerContinuationEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IFileOpenPickerContinuationEventArgs};

    // ----- IFileSavePickerActivatedEventArgs interface --------------------

    static PyObject* _new_IFileSavePickerActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IFileSavePickerActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IFileSavePickerActivatedEventArgs_get_FileSavePickerUI(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IFileSavePickerActivatedEventArgs", L"FileSavePickerUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FileSavePickerUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileSavePickerActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileSavePickerActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileSavePickerActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IFileSavePickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IFileSavePickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IFileSavePickerActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IFileSavePickerActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IFileSavePickerActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IFileSavePickerActivatedEventArgs[] = {
        { "file_save_picker_u_i", reinterpret_cast<getter>(IFileSavePickerActivatedEventArgs_get_FileSavePickerUI), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IFileSavePickerActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IFileSavePickerActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IFileSavePickerActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IFileSavePickerActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IFileSavePickerActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IFileSavePickerActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IFileSavePickerActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IFileSavePickerActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IFileSavePickerActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IFileSavePickerActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IFileSavePickerActivatedEventArgs};

    // ----- IFileSavePickerActivatedEventArgs2 interface --------------------

    static PyObject* _new_IFileSavePickerActivatedEventArgs2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs2>::type_name);
        return nullptr;
    }

    static void _dealloc_IFileSavePickerActivatedEventArgs2(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IFileSavePickerActivatedEventArgs2_get_CallerPackageFamilyName(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IFileSavePickerActivatedEventArgs2", L"CallerPackageFamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CallerPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileSavePickerActivatedEventArgs2_get_EnterpriseId(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IFileSavePickerActivatedEventArgs2", L"EnterpriseId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EnterpriseId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IFileSavePickerActivatedEventArgs2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IFileSavePickerActivatedEventArgs2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IFileSavePickerActivatedEventArgs2[] = {
        { "_assign_array_", _assign_array_IFileSavePickerActivatedEventArgs2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IFileSavePickerActivatedEventArgs2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IFileSavePickerActivatedEventArgs2[] = {
        { "caller_package_family_name", reinterpret_cast<getter>(IFileSavePickerActivatedEventArgs2_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { "enterprise_id", reinterpret_cast<getter>(IFileSavePickerActivatedEventArgs2_get_EnterpriseId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IFileSavePickerActivatedEventArgs2[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IFileSavePickerActivatedEventArgs2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IFileSavePickerActivatedEventArgs2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IFileSavePickerActivatedEventArgs2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IFileSavePickerActivatedEventArgs2) },
        { }
    };

    static PyType_Spec type_spec_IFileSavePickerActivatedEventArgs2 = {
        "winrt._winrt_windows_applicationmodel_activation.IFileSavePickerActivatedEventArgs2",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IFileSavePickerActivatedEventArgs2};

    // ----- IFileSavePickerContinuationEventArgs interface --------------------

    static PyObject* _new_IFileSavePickerContinuationEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IFileSavePickerContinuationEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IFileSavePickerContinuationEventArgs_get_File(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IFileSavePickerContinuationEventArgs", L"File");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.File());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileSavePickerContinuationEventArgs_get_ContinuationData(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContinuationActivatedEventArgs", L"ContinuationData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContinuationData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileSavePickerContinuationEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileSavePickerContinuationEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileSavePickerContinuationEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IFileSavePickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IFileSavePickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IFileSavePickerContinuationEventArgs[] = {
        { "_assign_array_", _assign_array_IFileSavePickerContinuationEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IFileSavePickerContinuationEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IFileSavePickerContinuationEventArgs[] = {
        { "file", reinterpret_cast<getter>(IFileSavePickerContinuationEventArgs_get_File), nullptr, nullptr, nullptr },
        { "continuation_data", reinterpret_cast<getter>(IFileSavePickerContinuationEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IFileSavePickerContinuationEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IFileSavePickerContinuationEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IFileSavePickerContinuationEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IFileSavePickerContinuationEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IFileSavePickerContinuationEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IFileSavePickerContinuationEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IFileSavePickerContinuationEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IFileSavePickerContinuationEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IFileSavePickerContinuationEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IFileSavePickerContinuationEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IFileSavePickerContinuationEventArgs};

    // ----- IFolderPickerContinuationEventArgs interface --------------------

    static PyObject* _new_IFolderPickerContinuationEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IFolderPickerContinuationEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IFolderPickerContinuationEventArgs_get_Folder(py::wrapper::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IFolderPickerContinuationEventArgs", L"Folder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Folder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFolderPickerContinuationEventArgs_get_ContinuationData(py::wrapper::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContinuationActivatedEventArgs", L"ContinuationData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContinuationData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFolderPickerContinuationEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFolderPickerContinuationEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFolderPickerContinuationEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IFolderPickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IFolderPickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IFolderPickerContinuationEventArgs[] = {
        { "_assign_array_", _assign_array_IFolderPickerContinuationEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IFolderPickerContinuationEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IFolderPickerContinuationEventArgs[] = {
        { "folder", reinterpret_cast<getter>(IFolderPickerContinuationEventArgs_get_Folder), nullptr, nullptr, nullptr },
        { "continuation_data", reinterpret_cast<getter>(IFolderPickerContinuationEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IFolderPickerContinuationEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IFolderPickerContinuationEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IFolderPickerContinuationEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IFolderPickerContinuationEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IFolderPickerContinuationEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IFolderPickerContinuationEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IFolderPickerContinuationEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IFolderPickerContinuationEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IFolderPickerContinuationEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IFolderPickerContinuationEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IFolderPickerContinuationEventArgs};

    // ----- ILaunchActivatedEventArgs interface --------------------

    static PyObject* _new_ILaunchActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ILaunchActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ILaunchActivatedEventArgs_get_Arguments(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ILaunchActivatedEventArgs", L"Arguments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Arguments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILaunchActivatedEventArgs_get_TileId(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ILaunchActivatedEventArgs", L"TileId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TileId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILaunchActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILaunchActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILaunchActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ILaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ILaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILaunchActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ILaunchActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ILaunchActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ILaunchActivatedEventArgs[] = {
        { "arguments", reinterpret_cast<getter>(ILaunchActivatedEventArgs_get_Arguments), nullptr, nullptr, nullptr },
        { "tile_id", reinterpret_cast<getter>(ILaunchActivatedEventArgs_get_TileId), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ILaunchActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ILaunchActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ILaunchActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ILaunchActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ILaunchActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ILaunchActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ILaunchActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ILaunchActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ILaunchActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ILaunchActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILaunchActivatedEventArgs};

    // ----- ILaunchActivatedEventArgs2 interface --------------------

    static PyObject* _new_ILaunchActivatedEventArgs2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2>::type_name);
        return nullptr;
    }

    static void _dealloc_ILaunchActivatedEventArgs2(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ILaunchActivatedEventArgs2_get_TileActivatedInfo(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ILaunchActivatedEventArgs2", L"TileActivatedInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TileActivatedInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILaunchActivatedEventArgs2_get_Arguments(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ILaunchActivatedEventArgs", L"Arguments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Arguments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILaunchActivatedEventArgs2_get_TileId(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ILaunchActivatedEventArgs", L"TileId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TileId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILaunchActivatedEventArgs2_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILaunchActivatedEventArgs2_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILaunchActivatedEventArgs2_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ILaunchActivatedEventArgs2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ILaunchActivatedEventArgs2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILaunchActivatedEventArgs2[] = {
        { "_assign_array_", _assign_array_ILaunchActivatedEventArgs2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ILaunchActivatedEventArgs2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ILaunchActivatedEventArgs2[] = {
        { "tile_activated_info", reinterpret_cast<getter>(ILaunchActivatedEventArgs2_get_TileActivatedInfo), nullptr, nullptr, nullptr },
        { "arguments", reinterpret_cast<getter>(ILaunchActivatedEventArgs2_get_Arguments), nullptr, nullptr, nullptr },
        { "tile_id", reinterpret_cast<getter>(ILaunchActivatedEventArgs2_get_TileId), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ILaunchActivatedEventArgs2_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ILaunchActivatedEventArgs2_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ILaunchActivatedEventArgs2_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ILaunchActivatedEventArgs2[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ILaunchActivatedEventArgs2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ILaunchActivatedEventArgs2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ILaunchActivatedEventArgs2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ILaunchActivatedEventArgs2) },
        { }
    };

    static PyType_Spec type_spec_ILaunchActivatedEventArgs2 = {
        "winrt._winrt_windows_applicationmodel_activation.ILaunchActivatedEventArgs2",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILaunchActivatedEventArgs2};

    // ----- ILockScreenActivatedEventArgs interface --------------------

    static PyObject* _new_ILockScreenActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ILockScreenActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ILockScreenActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ILockScreenActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ILockScreenActivatedEventArgs_get_Info(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ILockScreenActivatedEventArgs", L"Info");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Info());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILockScreenActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILockScreenActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILockScreenActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ILockScreenActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ILockScreenActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ILockScreenActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ILockScreenActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILockScreenActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ILockScreenActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ILockScreenActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ILockScreenActivatedEventArgs[] = {
        { "info", reinterpret_cast<getter>(ILockScreenActivatedEventArgs_get_Info), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ILockScreenActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ILockScreenActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ILockScreenActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ILockScreenActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ILockScreenActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ILockScreenActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ILockScreenActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ILockScreenActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ILockScreenActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ILockScreenActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILockScreenActivatedEventArgs};

    // ----- ILockScreenCallActivatedEventArgs interface --------------------

    static PyObject* _new_ILockScreenCallActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ILockScreenCallActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ILockScreenCallActivatedEventArgs_get_CallUI(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ILockScreenCallActivatedEventArgs", L"CallUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CallUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILockScreenCallActivatedEventArgs_get_Arguments(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ILaunchActivatedEventArgs", L"Arguments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Arguments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILockScreenCallActivatedEventArgs_get_TileId(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ILaunchActivatedEventArgs", L"TileId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TileId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILockScreenCallActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILockScreenCallActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILockScreenCallActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ILockScreenCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ILockScreenCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILockScreenCallActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ILockScreenCallActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ILockScreenCallActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ILockScreenCallActivatedEventArgs[] = {
        { "call_u_i", reinterpret_cast<getter>(ILockScreenCallActivatedEventArgs_get_CallUI), nullptr, nullptr, nullptr },
        { "arguments", reinterpret_cast<getter>(ILockScreenCallActivatedEventArgs_get_Arguments), nullptr, nullptr, nullptr },
        { "tile_id", reinterpret_cast<getter>(ILockScreenCallActivatedEventArgs_get_TileId), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ILockScreenCallActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ILockScreenCallActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ILockScreenCallActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ILockScreenCallActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ILockScreenCallActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ILockScreenCallActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ILockScreenCallActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ILockScreenCallActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ILockScreenCallActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ILockScreenCallActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILockScreenCallActivatedEventArgs};

    // ----- IPhoneCallActivatedEventArgs interface --------------------

    static PyObject* _new_IPhoneCallActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IPhoneCallActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IPhoneCallActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IPhoneCallActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IPhoneCallActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPhoneCallActivatedEventArgs_get_LineId(py::wrapper::Windows::ApplicationModel::Activation::IPhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IPhoneCallActivatedEventArgs", L"LineId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LineId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPhoneCallActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IPhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPhoneCallActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IPhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPhoneCallActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IPhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IPhoneCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IPhoneCallActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPhoneCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IPhoneCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPhoneCallActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IPhoneCallActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPhoneCallActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IPhoneCallActivatedEventArgs[] = {
        { "line_id", reinterpret_cast<getter>(IPhoneCallActivatedEventArgs_get_LineId), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IPhoneCallActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IPhoneCallActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IPhoneCallActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IPhoneCallActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPhoneCallActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPhoneCallActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPhoneCallActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPhoneCallActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IPhoneCallActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IPhoneCallActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IPhoneCallActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPhoneCallActivatedEventArgs};

    // ----- IPickerReturnedActivatedEventArgs interface --------------------

    static PyObject* _new_IPickerReturnedActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IPickerReturnedActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IPickerReturnedActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IPickerReturnedActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IPickerReturnedActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPickerReturnedActivatedEventArgs_get_PickerOperationId(py::wrapper::Windows::ApplicationModel::Activation::IPickerReturnedActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IPickerReturnedActivatedEventArgs", L"PickerOperationId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PickerOperationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPickerReturnedActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IPickerReturnedActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPickerReturnedActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IPickerReturnedActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPickerReturnedActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IPickerReturnedActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IPickerReturnedActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IPickerReturnedActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPickerReturnedActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IPickerReturnedActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPickerReturnedActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IPickerReturnedActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPickerReturnedActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IPickerReturnedActivatedEventArgs[] = {
        { "picker_operation_id", reinterpret_cast<getter>(IPickerReturnedActivatedEventArgs_get_PickerOperationId), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IPickerReturnedActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IPickerReturnedActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IPickerReturnedActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IPickerReturnedActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPickerReturnedActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPickerReturnedActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPickerReturnedActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPickerReturnedActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IPickerReturnedActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IPickerReturnedActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IPickerReturnedActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPickerReturnedActivatedEventArgs};

    // ----- IPrelaunchActivatedEventArgs interface --------------------

    static PyObject* _new_IPrelaunchActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IPrelaunchActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IPrelaunchActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IPrelaunchActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IPrelaunchActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPrelaunchActivatedEventArgs_get_PrelaunchActivated(py::wrapper::Windows::ApplicationModel::Activation::IPrelaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IPrelaunchActivatedEventArgs", L"PrelaunchActivated");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PrelaunchActivated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrelaunchActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IPrelaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrelaunchActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IPrelaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrelaunchActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IPrelaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IPrelaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IPrelaunchActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPrelaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IPrelaunchActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPrelaunchActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IPrelaunchActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPrelaunchActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IPrelaunchActivatedEventArgs[] = {
        { "prelaunch_activated", reinterpret_cast<getter>(IPrelaunchActivatedEventArgs_get_PrelaunchActivated), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IPrelaunchActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IPrelaunchActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IPrelaunchActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IPrelaunchActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPrelaunchActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPrelaunchActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPrelaunchActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPrelaunchActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IPrelaunchActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IPrelaunchActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IPrelaunchActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPrelaunchActivatedEventArgs};

    // ----- IPrint3DWorkflowActivatedEventArgs interface --------------------

    static PyObject* _new_IPrint3DWorkflowActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IPrint3DWorkflowActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IPrint3DWorkflowActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IPrint3DWorkflowActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IPrint3DWorkflowActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPrint3DWorkflowActivatedEventArgs_get_Workflow(py::wrapper::Windows::ApplicationModel::Activation::IPrint3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IPrint3DWorkflowActivatedEventArgs", L"Workflow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Workflow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrint3DWorkflowActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IPrint3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrint3DWorkflowActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IPrint3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrint3DWorkflowActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IPrint3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IPrint3DWorkflowActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IPrint3DWorkflowActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPrint3DWorkflowActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IPrint3DWorkflowActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPrint3DWorkflowActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IPrint3DWorkflowActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPrint3DWorkflowActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IPrint3DWorkflowActivatedEventArgs[] = {
        { "workflow", reinterpret_cast<getter>(IPrint3DWorkflowActivatedEventArgs_get_Workflow), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IPrint3DWorkflowActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IPrint3DWorkflowActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IPrint3DWorkflowActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IPrint3DWorkflowActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPrint3DWorkflowActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPrint3DWorkflowActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPrint3DWorkflowActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPrint3DWorkflowActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IPrint3DWorkflowActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IPrint3DWorkflowActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IPrint3DWorkflowActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPrint3DWorkflowActivatedEventArgs};

    // ----- IPrintTaskSettingsActivatedEventArgs interface --------------------

    static PyObject* _new_IPrintTaskSettingsActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IPrintTaskSettingsActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IPrintTaskSettingsActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IPrintTaskSettingsActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IPrintTaskSettingsActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPrintTaskSettingsActivatedEventArgs_get_Configuration(py::wrapper::Windows::ApplicationModel::Activation::IPrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IPrintTaskSettingsActivatedEventArgs", L"Configuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Configuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrintTaskSettingsActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IPrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrintTaskSettingsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IPrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrintTaskSettingsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IPrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IPrintTaskSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IPrintTaskSettingsActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPrintTaskSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IPrintTaskSettingsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPrintTaskSettingsActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IPrintTaskSettingsActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPrintTaskSettingsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IPrintTaskSettingsActivatedEventArgs[] = {
        { "configuration", reinterpret_cast<getter>(IPrintTaskSettingsActivatedEventArgs_get_Configuration), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IPrintTaskSettingsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IPrintTaskSettingsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IPrintTaskSettingsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IPrintTaskSettingsActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPrintTaskSettingsActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPrintTaskSettingsActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPrintTaskSettingsActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPrintTaskSettingsActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IPrintTaskSettingsActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IPrintTaskSettingsActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IPrintTaskSettingsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPrintTaskSettingsActivatedEventArgs};

    // ----- IProtocolActivatedEventArgs interface --------------------

    static PyObject* _new_IProtocolActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IProtocolActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IProtocolActivatedEventArgs_get_Uri(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IProtocolActivatedEventArgs", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IProtocolActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IProtocolActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IProtocolActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IProtocolActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IProtocolActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IProtocolActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IProtocolActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IProtocolActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IProtocolActivatedEventArgs[] = {
        { "uri", reinterpret_cast<getter>(IProtocolActivatedEventArgs_get_Uri), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IProtocolActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IProtocolActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IProtocolActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IProtocolActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IProtocolActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IProtocolActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IProtocolActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IProtocolActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IProtocolActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IProtocolActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IProtocolActivatedEventArgs};

    // ----- IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData interface --------------------

    static PyObject* _new_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData>::type_name);
        return nullptr;
    }

    static void _dealloc_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_get_CallerPackageFamilyName(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData", L"CallerPackageFamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CallerPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_get_Data(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData[] = {
        { "_assign_array_", _assign_array_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData[] = {
        { "caller_package_family_name", reinterpret_cast<getter>(IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { "data", reinterpret_cast<getter>(IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_get_Data), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData) },
        { }
    };

    static PyType_Spec type_spec_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData = {
        "winrt._winrt_windows_applicationmodel_activation.IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData};

    // ----- IProtocolForResultsActivatedEventArgs interface --------------------

    static PyObject* _new_IProtocolForResultsActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IProtocolForResultsActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IProtocolForResultsActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IProtocolForResultsActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IProtocolForResultsActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IProtocolForResultsActivatedEventArgs_get_ProtocolForResultsOperation(py::wrapper::Windows::ApplicationModel::Activation::IProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IProtocolForResultsActivatedEventArgs", L"ProtocolForResultsOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProtocolForResultsOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IProtocolForResultsActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IProtocolForResultsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IProtocolForResultsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IProtocolForResultsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IProtocolForResultsActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IProtocolForResultsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IProtocolForResultsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IProtocolForResultsActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IProtocolForResultsActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IProtocolForResultsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IProtocolForResultsActivatedEventArgs[] = {
        { "protocol_for_results_operation", reinterpret_cast<getter>(IProtocolForResultsActivatedEventArgs_get_ProtocolForResultsOperation), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IProtocolForResultsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IProtocolForResultsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IProtocolForResultsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IProtocolForResultsActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IProtocolForResultsActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IProtocolForResultsActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IProtocolForResultsActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IProtocolForResultsActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IProtocolForResultsActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IProtocolForResultsActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IProtocolForResultsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IProtocolForResultsActivatedEventArgs};

    // ----- IRestrictedLaunchActivatedEventArgs interface --------------------

    static PyObject* _new_IRestrictedLaunchActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IRestrictedLaunchActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IRestrictedLaunchActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IRestrictedLaunchActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IRestrictedLaunchActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IRestrictedLaunchActivatedEventArgs_get_SharedContext(py::wrapper::Windows::ApplicationModel::Activation::IRestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IRestrictedLaunchActivatedEventArgs", L"SharedContext");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SharedContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IRestrictedLaunchActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IRestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IRestrictedLaunchActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IRestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IRestrictedLaunchActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IRestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IRestrictedLaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IRestrictedLaunchActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IRestrictedLaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IRestrictedLaunchActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IRestrictedLaunchActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IRestrictedLaunchActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IRestrictedLaunchActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IRestrictedLaunchActivatedEventArgs[] = {
        { "shared_context", reinterpret_cast<getter>(IRestrictedLaunchActivatedEventArgs_get_SharedContext), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IRestrictedLaunchActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IRestrictedLaunchActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IRestrictedLaunchActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IRestrictedLaunchActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IRestrictedLaunchActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IRestrictedLaunchActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IRestrictedLaunchActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IRestrictedLaunchActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IRestrictedLaunchActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IRestrictedLaunchActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IRestrictedLaunchActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IRestrictedLaunchActivatedEventArgs};

    // ----- ISearchActivatedEventArgs interface --------------------

    static PyObject* _new_ISearchActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ISearchActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISearchActivatedEventArgs_get_Language(py::wrapper::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ISearchActivatedEventArgs", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISearchActivatedEventArgs_get_QueryText(py::wrapper::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ISearchActivatedEventArgs", L"QueryText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.QueryText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISearchActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISearchActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISearchActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ISearchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISearchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISearchActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ISearchActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISearchActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISearchActivatedEventArgs[] = {
        { "language", reinterpret_cast<getter>(ISearchActivatedEventArgs_get_Language), nullptr, nullptr, nullptr },
        { "query_text", reinterpret_cast<getter>(ISearchActivatedEventArgs_get_QueryText), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ISearchActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ISearchActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ISearchActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ISearchActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISearchActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISearchActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISearchActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISearchActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ISearchActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ISearchActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISearchActivatedEventArgs};

    // ----- ISearchActivatedEventArgsWithLinguisticDetails interface --------------------

    static PyObject* _new_ISearchActivatedEventArgsWithLinguisticDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ISearchActivatedEventArgsWithLinguisticDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ISearchActivatedEventArgsWithLinguisticDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_ISearchActivatedEventArgsWithLinguisticDetails(py::wrapper::Windows::ApplicationModel::Activation::ISearchActivatedEventArgsWithLinguisticDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISearchActivatedEventArgsWithLinguisticDetails_get_LinguisticDetails(py::wrapper::Windows::ApplicationModel::Activation::ISearchActivatedEventArgsWithLinguisticDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ISearchActivatedEventArgsWithLinguisticDetails", L"LinguisticDetails");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LinguisticDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ISearchActivatedEventArgsWithLinguisticDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ISearchActivatedEventArgsWithLinguisticDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISearchActivatedEventArgsWithLinguisticDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ISearchActivatedEventArgsWithLinguisticDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISearchActivatedEventArgsWithLinguisticDetails[] = {
        { "_assign_array_", _assign_array_ISearchActivatedEventArgsWithLinguisticDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISearchActivatedEventArgsWithLinguisticDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISearchActivatedEventArgsWithLinguisticDetails[] = {
        { "linguistic_details", reinterpret_cast<getter>(ISearchActivatedEventArgsWithLinguisticDetails_get_LinguisticDetails), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ISearchActivatedEventArgsWithLinguisticDetails[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISearchActivatedEventArgsWithLinguisticDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISearchActivatedEventArgsWithLinguisticDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISearchActivatedEventArgsWithLinguisticDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISearchActivatedEventArgsWithLinguisticDetails) },
        { }
    };

    static PyType_Spec type_spec_ISearchActivatedEventArgsWithLinguisticDetails = {
        "winrt._winrt_windows_applicationmodel_activation.ISearchActivatedEventArgsWithLinguisticDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ISearchActivatedEventArgsWithLinguisticDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISearchActivatedEventArgsWithLinguisticDetails};

    // ----- IShareTargetActivatedEventArgs interface --------------------

    static PyObject* _new_IShareTargetActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IShareTargetActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IShareTargetActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IShareTargetActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IShareTargetActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IShareTargetActivatedEventArgs_get_ShareOperation(py::wrapper::Windows::ApplicationModel::Activation::IShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IShareTargetActivatedEventArgs", L"ShareOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ShareOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IShareTargetActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IShareTargetActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IShareTargetActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IShareTargetActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IShareTargetActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IShareTargetActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IShareTargetActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IShareTargetActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IShareTargetActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IShareTargetActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IShareTargetActivatedEventArgs[] = {
        { "share_operation", reinterpret_cast<getter>(IShareTargetActivatedEventArgs_get_ShareOperation), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IShareTargetActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IShareTargetActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IShareTargetActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IShareTargetActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IShareTargetActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IShareTargetActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IShareTargetActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IShareTargetActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IShareTargetActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IShareTargetActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IShareTargetActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IShareTargetActivatedEventArgs};

    // ----- IStartupTaskActivatedEventArgs interface --------------------

    static PyObject* _new_IStartupTaskActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IStartupTaskActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IStartupTaskActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IStartupTaskActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IStartupTaskActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStartupTaskActivatedEventArgs_get_TaskId(py::wrapper::Windows::ApplicationModel::Activation::IStartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IStartupTaskActivatedEventArgs", L"TaskId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TaskId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStartupTaskActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IStartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStartupTaskActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IStartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStartupTaskActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IStartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IStartupTaskActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IStartupTaskActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStartupTaskActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IStartupTaskActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStartupTaskActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IStartupTaskActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStartupTaskActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStartupTaskActivatedEventArgs[] = {
        { "task_id", reinterpret_cast<getter>(IStartupTaskActivatedEventArgs_get_TaskId), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IStartupTaskActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IStartupTaskActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IStartupTaskActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IStartupTaskActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IStartupTaskActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStartupTaskActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStartupTaskActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStartupTaskActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IStartupTaskActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IStartupTaskActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IStartupTaskActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStartupTaskActivatedEventArgs};

    // ----- IToastNotificationActivatedEventArgs interface --------------------

    static PyObject* _new_IToastNotificationActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IToastNotificationActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IToastNotificationActivatedEventArgs_get_Argument(py::wrapper::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IToastNotificationActivatedEventArgs", L"Argument");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Argument());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IToastNotificationActivatedEventArgs_get_UserInput(py::wrapper::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IToastNotificationActivatedEventArgs", L"UserInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UserInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IToastNotificationActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IToastNotificationActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IToastNotificationActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IToastNotificationActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IToastNotificationActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IToastNotificationActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IToastNotificationActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IToastNotificationActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IToastNotificationActivatedEventArgs[] = {
        { "argument", reinterpret_cast<getter>(IToastNotificationActivatedEventArgs_get_Argument), nullptr, nullptr, nullptr },
        { "user_input", reinterpret_cast<getter>(IToastNotificationActivatedEventArgs_get_UserInput), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IToastNotificationActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IToastNotificationActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IToastNotificationActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IToastNotificationActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IToastNotificationActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IToastNotificationActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IToastNotificationActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IToastNotificationActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IToastNotificationActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IToastNotificationActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IToastNotificationActivatedEventArgs};

    // ----- IUserDataAccountProviderActivatedEventArgs interface --------------------

    static PyObject* _new_IUserDataAccountProviderActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IUserDataAccountProviderActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IUserDataAccountProviderActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IUserDataAccountProviderActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IUserDataAccountProviderActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IUserDataAccountProviderActivatedEventArgs_get_Operation(py::wrapper::Windows::ApplicationModel::Activation::IUserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IUserDataAccountProviderActivatedEventArgs", L"Operation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Operation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IUserDataAccountProviderActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IUserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IUserDataAccountProviderActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IUserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IUserDataAccountProviderActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IUserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IUserDataAccountProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IUserDataAccountProviderActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IUserDataAccountProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IUserDataAccountProviderActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IUserDataAccountProviderActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IUserDataAccountProviderActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IUserDataAccountProviderActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IUserDataAccountProviderActivatedEventArgs[] = {
        { "operation", reinterpret_cast<getter>(IUserDataAccountProviderActivatedEventArgs_get_Operation), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IUserDataAccountProviderActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IUserDataAccountProviderActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IUserDataAccountProviderActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IUserDataAccountProviderActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IUserDataAccountProviderActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IUserDataAccountProviderActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IUserDataAccountProviderActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IUserDataAccountProviderActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IUserDataAccountProviderActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IUserDataAccountProviderActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IUserDataAccountProviderActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IUserDataAccountProviderActivatedEventArgs};

    // ----- IViewSwitcherProvider interface --------------------

    static PyObject* _new_IViewSwitcherProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IViewSwitcherProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IViewSwitcherProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IViewSwitcherProvider(py::wrapper::Windows::ApplicationModel::Activation::IViewSwitcherProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IViewSwitcherProvider_get_ViewSwitcher(py::wrapper::Windows::ApplicationModel::Activation::IViewSwitcherProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IViewSwitcherProvider", L"ViewSwitcher");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ViewSwitcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IViewSwitcherProvider_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IViewSwitcherProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IViewSwitcherProvider_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IViewSwitcherProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IViewSwitcherProvider_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IViewSwitcherProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IViewSwitcherProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IViewSwitcherProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IViewSwitcherProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IViewSwitcherProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IViewSwitcherProvider[] = {
        { "_assign_array_", _assign_array_IViewSwitcherProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IViewSwitcherProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IViewSwitcherProvider[] = {
        { "view_switcher", reinterpret_cast<getter>(IViewSwitcherProvider_get_ViewSwitcher), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IViewSwitcherProvider_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IViewSwitcherProvider_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IViewSwitcherProvider_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IViewSwitcherProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IViewSwitcherProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IViewSwitcherProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IViewSwitcherProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IViewSwitcherProvider) },
        { }
    };

    static PyType_Spec type_spec_IViewSwitcherProvider = {
        "winrt._winrt_windows_applicationmodel_activation.IViewSwitcherProvider",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IViewSwitcherProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IViewSwitcherProvider};

    // ----- IVoiceCommandActivatedEventArgs interface --------------------

    static PyObject* _new_IVoiceCommandActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IVoiceCommandActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IVoiceCommandActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IVoiceCommandActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IVoiceCommandActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVoiceCommandActivatedEventArgs_get_Result(py::wrapper::Windows::ApplicationModel::Activation::IVoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IVoiceCommandActivatedEventArgs", L"Result");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Result());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IVoiceCommandActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IVoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IVoiceCommandActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IVoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IVoiceCommandActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IVoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IVoiceCommandActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IVoiceCommandActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVoiceCommandActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IVoiceCommandActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVoiceCommandActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IVoiceCommandActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVoiceCommandActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVoiceCommandActivatedEventArgs[] = {
        { "result", reinterpret_cast<getter>(IVoiceCommandActivatedEventArgs_get_Result), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IVoiceCommandActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IVoiceCommandActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IVoiceCommandActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IVoiceCommandActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVoiceCommandActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVoiceCommandActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVoiceCommandActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVoiceCommandActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IVoiceCommandActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IVoiceCommandActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IVoiceCommandActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVoiceCommandActivatedEventArgs};

    // ----- IWalletActionActivatedEventArgs interface --------------------

    static PyObject* _new_IWalletActionActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IWalletActionActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWalletActionActivatedEventArgs_get_ActionId(py::wrapper::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IWalletActionActivatedEventArgs", L"ActionId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWalletActionActivatedEventArgs_get_ActionKind(py::wrapper::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IWalletActionActivatedEventArgs", L"ActionKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActionKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWalletActionActivatedEventArgs_get_ItemId(py::wrapper::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IWalletActionActivatedEventArgs", L"ItemId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ItemId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWalletActionActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWalletActionActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWalletActionActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IWalletActionActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWalletActionActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWalletActionActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IWalletActionActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWalletActionActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IWalletActionActivatedEventArgs[] = {
        { "action_id", reinterpret_cast<getter>(IWalletActionActivatedEventArgs_get_ActionId), nullptr, nullptr, nullptr },
        { "action_kind", reinterpret_cast<getter>(IWalletActionActivatedEventArgs_get_ActionKind), nullptr, nullptr, nullptr },
        { "item_id", reinterpret_cast<getter>(IWalletActionActivatedEventArgs_get_ItemId), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IWalletActionActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IWalletActionActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IWalletActionActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IWalletActionActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IWalletActionActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWalletActionActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWalletActionActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWalletActionActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IWalletActionActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IWalletActionActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWalletActionActivatedEventArgs};

    // ----- IWebAccountProviderActivatedEventArgs interface --------------------

    static PyObject* _new_IWebAccountProviderActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IWebAccountProviderActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IWebAccountProviderActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IWebAccountProviderActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IWebAccountProviderActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWebAccountProviderActivatedEventArgs_get_Operation(py::wrapper::Windows::ApplicationModel::Activation::IWebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IWebAccountProviderActivatedEventArgs", L"Operation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Operation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebAccountProviderActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IWebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebAccountProviderActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IWebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebAccountProviderActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IWebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IWebAccountProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IWebAccountProviderActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWebAccountProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IWebAccountProviderActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWebAccountProviderActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IWebAccountProviderActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWebAccountProviderActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IWebAccountProviderActivatedEventArgs[] = {
        { "operation", reinterpret_cast<getter>(IWebAccountProviderActivatedEventArgs_get_Operation), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IWebAccountProviderActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IWebAccountProviderActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IWebAccountProviderActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IWebAccountProviderActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IWebAccountProviderActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWebAccountProviderActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWebAccountProviderActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWebAccountProviderActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IWebAccountProviderActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IWebAccountProviderActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IWebAccountProviderActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWebAccountProviderActivatedEventArgs};

    // ----- IWebAuthenticationBrokerContinuationEventArgs interface --------------------

    static PyObject* _new_IWebAuthenticationBrokerContinuationEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IWebAuthenticationBrokerContinuationEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWebAuthenticationBrokerContinuationEventArgs_get_WebAuthenticationResult(py::wrapper::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IWebAuthenticationBrokerContinuationEventArgs", L"WebAuthenticationResult");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WebAuthenticationResult());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebAuthenticationBrokerContinuationEventArgs_get_ContinuationData(py::wrapper::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContinuationActivatedEventArgs", L"ContinuationData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContinuationData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebAuthenticationBrokerContinuationEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebAuthenticationBrokerContinuationEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebAuthenticationBrokerContinuationEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IWebAuthenticationBrokerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWebAuthenticationBrokerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWebAuthenticationBrokerContinuationEventArgs[] = {
        { "_assign_array_", _assign_array_IWebAuthenticationBrokerContinuationEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWebAuthenticationBrokerContinuationEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IWebAuthenticationBrokerContinuationEventArgs[] = {
        { "web_authentication_result", reinterpret_cast<getter>(IWebAuthenticationBrokerContinuationEventArgs_get_WebAuthenticationResult), nullptr, nullptr, nullptr },
        { "continuation_data", reinterpret_cast<getter>(IWebAuthenticationBrokerContinuationEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IWebAuthenticationBrokerContinuationEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IWebAuthenticationBrokerContinuationEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IWebAuthenticationBrokerContinuationEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IWebAuthenticationBrokerContinuationEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IWebAuthenticationBrokerContinuationEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWebAuthenticationBrokerContinuationEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWebAuthenticationBrokerContinuationEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWebAuthenticationBrokerContinuationEventArgs) },
        { }
    };

    static PyType_Spec type_spec_IWebAuthenticationBrokerContinuationEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IWebAuthenticationBrokerContinuationEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWebAuthenticationBrokerContinuationEventArgs};

    // ----- Windows.ApplicationModel.Activation Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.ApplicationModel.Activation");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_applicationmodel_activation",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::ApplicationModel::Activation

PyMODINIT_FUNC PyInit__winrt_windows_applicationmodel_activation(void) noexcept
{
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle AppointmentsProviderAddAppointmentActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_AppointmentsProviderAddAppointmentActivatedEventArgs, object_bases.get(), nullptr)};
    if (!AppointmentsProviderAddAppointmentActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle AppointmentsProviderRemoveAppointmentActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_AppointmentsProviderRemoveAppointmentActivatedEventArgs, object_bases.get(), nullptr)};
    if (!AppointmentsProviderRemoveAppointmentActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle AppointmentsProviderReplaceAppointmentActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_AppointmentsProviderReplaceAppointmentActivatedEventArgs, object_bases.get(), nullptr)};
    if (!AppointmentsProviderReplaceAppointmentActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs, object_bases.get(), nullptr)};
    if (!AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle AppointmentsProviderShowTimeFrameActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_AppointmentsProviderShowTimeFrameActivatedEventArgs, object_bases.get(), nullptr)};
    if (!AppointmentsProviderShowTimeFrameActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle BackgroundActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_BackgroundActivatedEventArgs, object_bases.get(), nullptr)};
    if (!BackgroundActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle BarcodeScannerPreviewActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_BarcodeScannerPreviewActivatedEventArgs, object_bases.get(), nullptr)};
    if (!BarcodeScannerPreviewActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle CachedFileUpdaterActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_CachedFileUpdaterActivatedEventArgs, object_bases.get(), nullptr)};
    if (!CachedFileUpdaterActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle CameraSettingsActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_CameraSettingsActivatedEventArgs, object_bases.get(), nullptr)};
    if (!CameraSettingsActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle CommandLineActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_CommandLineActivatedEventArgs, object_bases.get(), nullptr)};
    if (!CommandLineActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle CommandLineActivationOperation_type{py::register_python_type(module.get(), &type_spec_CommandLineActivationOperation, object_bases.get(), nullptr)};
    if (!CommandLineActivationOperation_type)
    {
        return nullptr;
    }

    py::pytype_handle ContactCallActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ContactCallActivatedEventArgs, object_bases.get(), nullptr)};
    if (!ContactCallActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ContactMapActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ContactMapActivatedEventArgs, object_bases.get(), nullptr)};
    if (!ContactMapActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ContactMessageActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ContactMessageActivatedEventArgs, object_bases.get(), nullptr)};
    if (!ContactMessageActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ContactPanelActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ContactPanelActivatedEventArgs, object_bases.get(), nullptr)};
    if (!ContactPanelActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ContactPickerActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ContactPickerActivatedEventArgs, object_bases.get(), nullptr)};
    if (!ContactPickerActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ContactPostActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ContactPostActivatedEventArgs, object_bases.get(), nullptr)};
    if (!ContactPostActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ContactVideoCallActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ContactVideoCallActivatedEventArgs, object_bases.get(), nullptr)};
    if (!ContactVideoCallActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle DeviceActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_DeviceActivatedEventArgs, object_bases.get(), nullptr)};
    if (!DeviceActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle DevicePairingActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_DevicePairingActivatedEventArgs, object_bases.get(), nullptr)};
    if (!DevicePairingActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle DialReceiverActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_DialReceiverActivatedEventArgs, object_bases.get(), nullptr)};
    if (!DialReceiverActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle FileActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_FileActivatedEventArgs, object_bases.get(), nullptr)};
    if (!FileActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle FileOpenPickerActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_FileOpenPickerActivatedEventArgs, object_bases.get(), nullptr)};
    if (!FileOpenPickerActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle FileOpenPickerContinuationEventArgs_type{py::register_python_type(module.get(), &type_spec_FileOpenPickerContinuationEventArgs, object_bases.get(), nullptr)};
    if (!FileOpenPickerContinuationEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle FileSavePickerActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_FileSavePickerActivatedEventArgs, object_bases.get(), nullptr)};
    if (!FileSavePickerActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle FileSavePickerContinuationEventArgs_type{py::register_python_type(module.get(), &type_spec_FileSavePickerContinuationEventArgs, object_bases.get(), nullptr)};
    if (!FileSavePickerContinuationEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle FolderPickerContinuationEventArgs_type{py::register_python_type(module.get(), &type_spec_FolderPickerContinuationEventArgs, object_bases.get(), nullptr)};
    if (!FolderPickerContinuationEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle LaunchActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_LaunchActivatedEventArgs, object_bases.get(), nullptr)};
    if (!LaunchActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle LockScreenActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_LockScreenActivatedEventArgs, object_bases.get(), nullptr)};
    if (!LockScreenActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle LockScreenCallActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_LockScreenCallActivatedEventArgs, object_bases.get(), nullptr)};
    if (!LockScreenCallActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle LockScreenComponentActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_LockScreenComponentActivatedEventArgs, object_bases.get(), nullptr)};
    if (!LockScreenComponentActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PhoneCallActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_PhoneCallActivatedEventArgs, object_bases.get(), nullptr)};
    if (!PhoneCallActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PickerReturnedActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_PickerReturnedActivatedEventArgs, object_bases.get(), nullptr)};
    if (!PickerReturnedActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle Print3DWorkflowActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_Print3DWorkflowActivatedEventArgs, object_bases.get(), nullptr)};
    if (!Print3DWorkflowActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintTaskSettingsActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_PrintTaskSettingsActivatedEventArgs, object_bases.get(), nullptr)};
    if (!PrintTaskSettingsActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ProtocolActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ProtocolActivatedEventArgs, object_bases.get(), nullptr)};
    if (!ProtocolActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ProtocolForResultsActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ProtocolForResultsActivatedEventArgs, object_bases.get(), nullptr)};
    if (!ProtocolForResultsActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle RestrictedLaunchActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_RestrictedLaunchActivatedEventArgs, object_bases.get(), nullptr)};
    if (!RestrictedLaunchActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SearchActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_SearchActivatedEventArgs, object_bases.get(), nullptr)};
    if (!SearchActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ShareTargetActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ShareTargetActivatedEventArgs, object_bases.get(), nullptr)};
    if (!ShareTargetActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SplashScreen_type{py::register_python_type(module.get(), &type_spec_SplashScreen, object_bases.get(), nullptr)};
    if (!SplashScreen_type)
    {
        return nullptr;
    }

    py::pytype_handle StartupTaskActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_StartupTaskActivatedEventArgs, object_bases.get(), nullptr)};
    if (!StartupTaskActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle TileActivatedInfo_type{py::register_python_type(module.get(), &type_spec_TileActivatedInfo, object_bases.get(), nullptr)};
    if (!TileActivatedInfo_type)
    {
        return nullptr;
    }

    py::pytype_handle ToastNotificationActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ToastNotificationActivatedEventArgs, object_bases.get(), nullptr)};
    if (!ToastNotificationActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle UserDataAccountProviderActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_UserDataAccountProviderActivatedEventArgs, object_bases.get(), nullptr)};
    if (!UserDataAccountProviderActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle VoiceCommandActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_VoiceCommandActivatedEventArgs, object_bases.get(), nullptr)};
    if (!VoiceCommandActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WalletActionActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WalletActionActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WalletActionActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebAccountProviderActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebAccountProviderActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebAccountProviderActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebAuthenticationBrokerContinuationEventArgs_type{py::register_python_type(module.get(), &type_spec_WebAuthenticationBrokerContinuationEventArgs, object_bases.get(), nullptr)};
    if (!WebAuthenticationBrokerContinuationEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IActivatedEventArgsWithUser_type{py::register_python_type(module.get(), &type_spec_IActivatedEventArgsWithUser, object_bases.get(), nullptr)};
    if (!IActivatedEventArgsWithUser_type)
    {
        return nullptr;
    }

    py::pytype_handle IApplicationViewActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IApplicationViewActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IApplicationViewActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IAppointmentsProviderActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IAppointmentsProviderActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IAppointmentsProviderActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IAppointmentsProviderAddAppointmentActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IAppointmentsProviderAddAppointmentActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IAppointmentsProviderAddAppointmentActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IAppointmentsProviderRemoveAppointmentActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IAppointmentsProviderRemoveAppointmentActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IAppointmentsProviderRemoveAppointmentActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IAppointmentsProviderReplaceAppointmentActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IAppointmentsProviderReplaceAppointmentActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IAppointmentsProviderReplaceAppointmentActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IAppointmentsProviderShowTimeFrameActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IAppointmentsProviderShowTimeFrameActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IAppointmentsProviderShowTimeFrameActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IBackgroundActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IBackgroundActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IBackgroundActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IBarcodeScannerPreviewActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IBarcodeScannerPreviewActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IBarcodeScannerPreviewActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ICachedFileUpdaterActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ICachedFileUpdaterActivatedEventArgs, object_bases.get(), nullptr)};
    if (!ICachedFileUpdaterActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ICameraSettingsActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ICameraSettingsActivatedEventArgs, object_bases.get(), nullptr)};
    if (!ICameraSettingsActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ICommandLineActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ICommandLineActivatedEventArgs, object_bases.get(), nullptr)};
    if (!ICommandLineActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IContactActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IContactActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IContactActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IContactCallActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IContactCallActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IContactCallActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IContactMapActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IContactMapActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IContactMapActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IContactMessageActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IContactMessageActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IContactMessageActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IContactPanelActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IContactPanelActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IContactPanelActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IContactPickerActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IContactPickerActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IContactPickerActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IContactPostActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IContactPostActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IContactPostActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IContactVideoCallActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IContactVideoCallActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IContactVideoCallActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IContactsProviderActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IContactsProviderActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IContactsProviderActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IContinuationActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IContinuationActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IContinuationActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IDeviceActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IDeviceActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IDeviceActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IDevicePairingActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IDevicePairingActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IDevicePairingActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IDialReceiverActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IDialReceiverActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IDialReceiverActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IFileActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IFileActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IFileActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IFileActivatedEventArgsWithCallerPackageFamilyName_type{py::register_python_type(module.get(), &type_spec_IFileActivatedEventArgsWithCallerPackageFamilyName, object_bases.get(), nullptr)};
    if (!IFileActivatedEventArgsWithCallerPackageFamilyName_type)
    {
        return nullptr;
    }

    py::pytype_handle IFileActivatedEventArgsWithNeighboringFiles_type{py::register_python_type(module.get(), &type_spec_IFileActivatedEventArgsWithNeighboringFiles, object_bases.get(), nullptr)};
    if (!IFileActivatedEventArgsWithNeighboringFiles_type)
    {
        return nullptr;
    }

    py::pytype_handle IFileOpenPickerActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IFileOpenPickerActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IFileOpenPickerActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IFileOpenPickerActivatedEventArgs2_type{py::register_python_type(module.get(), &type_spec_IFileOpenPickerActivatedEventArgs2, object_bases.get(), nullptr)};
    if (!IFileOpenPickerActivatedEventArgs2_type)
    {
        return nullptr;
    }

    py::pytype_handle IFileOpenPickerContinuationEventArgs_type{py::register_python_type(module.get(), &type_spec_IFileOpenPickerContinuationEventArgs, object_bases.get(), nullptr)};
    if (!IFileOpenPickerContinuationEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IFileSavePickerActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IFileSavePickerActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IFileSavePickerActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IFileSavePickerActivatedEventArgs2_type{py::register_python_type(module.get(), &type_spec_IFileSavePickerActivatedEventArgs2, object_bases.get(), nullptr)};
    if (!IFileSavePickerActivatedEventArgs2_type)
    {
        return nullptr;
    }

    py::pytype_handle IFileSavePickerContinuationEventArgs_type{py::register_python_type(module.get(), &type_spec_IFileSavePickerContinuationEventArgs, object_bases.get(), nullptr)};
    if (!IFileSavePickerContinuationEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IFolderPickerContinuationEventArgs_type{py::register_python_type(module.get(), &type_spec_IFolderPickerContinuationEventArgs, object_bases.get(), nullptr)};
    if (!IFolderPickerContinuationEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ILaunchActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ILaunchActivatedEventArgs, object_bases.get(), nullptr)};
    if (!ILaunchActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ILaunchActivatedEventArgs2_type{py::register_python_type(module.get(), &type_spec_ILaunchActivatedEventArgs2, object_bases.get(), nullptr)};
    if (!ILaunchActivatedEventArgs2_type)
    {
        return nullptr;
    }

    py::pytype_handle ILockScreenActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ILockScreenActivatedEventArgs, object_bases.get(), nullptr)};
    if (!ILockScreenActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ILockScreenCallActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ILockScreenCallActivatedEventArgs, object_bases.get(), nullptr)};
    if (!ILockScreenCallActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IPhoneCallActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IPhoneCallActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IPhoneCallActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IPickerReturnedActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IPickerReturnedActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IPickerReturnedActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IPrelaunchActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IPrelaunchActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IPrelaunchActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IPrint3DWorkflowActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IPrint3DWorkflowActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IPrint3DWorkflowActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IPrintTaskSettingsActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IPrintTaskSettingsActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IPrintTaskSettingsActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IProtocolActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IProtocolActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IProtocolActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_type{py::register_python_type(module.get(), &type_spec_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData, object_bases.get(), nullptr)};
    if (!IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_type)
    {
        return nullptr;
    }

    py::pytype_handle IProtocolForResultsActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IProtocolForResultsActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IProtocolForResultsActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IRestrictedLaunchActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IRestrictedLaunchActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IRestrictedLaunchActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ISearchActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ISearchActivatedEventArgs, object_bases.get(), nullptr)};
    if (!ISearchActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ISearchActivatedEventArgsWithLinguisticDetails_type{py::register_python_type(module.get(), &type_spec_ISearchActivatedEventArgsWithLinguisticDetails, object_bases.get(), nullptr)};
    if (!ISearchActivatedEventArgsWithLinguisticDetails_type)
    {
        return nullptr;
    }

    py::pytype_handle IShareTargetActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IShareTargetActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IShareTargetActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IStartupTaskActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IStartupTaskActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IStartupTaskActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IToastNotificationActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IToastNotificationActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IToastNotificationActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IUserDataAccountProviderActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IUserDataAccountProviderActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IUserDataAccountProviderActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IViewSwitcherProvider_type{py::register_python_type(module.get(), &type_spec_IViewSwitcherProvider, object_bases.get(), nullptr)};
    if (!IViewSwitcherProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle IVoiceCommandActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IVoiceCommandActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IVoiceCommandActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IWalletActionActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IWalletActionActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IWalletActionActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IWebAccountProviderActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IWebAccountProviderActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IWebAccountProviderActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IWebAuthenticationBrokerContinuationEventArgs_type{py::register_python_type(module.get(), &type_spec_IWebAuthenticationBrokerContinuationEventArgs, object_bases.get(), nullptr)};
    if (!IWebAuthenticationBrokerContinuationEventArgs_type)
    {
        return nullptr;
    }


    return module.detach();
}
