// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

#include "py.Windows.ApplicationModel.UserDataAccounts.SystemAccess.h"


namespace py::cpp::Windows::ApplicationModel::UserDataAccounts::SystemAccess
{
    // ----- DeviceAccountConfiguration class --------------------

    static PyObject* _new_DeviceAccountConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DeviceAccountConfiguration(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceAccountConfiguration_get_EmailAddress(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"EmailAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmailAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_EmailAddress(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"EmailAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.EmailAddress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_Domain(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"Domain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Domain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_Domain(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"Domain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Domain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_DeviceAccountTypeId(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"DeviceAccountTypeId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceAccountTypeId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_DeviceAccountTypeId(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"DeviceAccountTypeId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DeviceAccountTypeId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_OutgoingServerAddress(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"OutgoingServerAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingServerAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_OutgoingServerAddress(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"OutgoingServerAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.OutgoingServerAddress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_ContactsSyncEnabled(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"ContactsSyncEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContactsSyncEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_ContactsSyncEnabled(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"ContactsSyncEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ContactsSyncEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_CalendarSyncEnabled(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"CalendarSyncEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CalendarSyncEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_CalendarSyncEnabled(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"CalendarSyncEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CalendarSyncEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_AccountName(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"AccountName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccountName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_AccountName(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"AccountName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AccountName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_IncomingServerUsername(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"IncomingServerUsername"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IncomingServerUsername());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_IncomingServerUsername(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"IncomingServerUsername"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.IncomingServerUsername(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_IncomingServerRequiresSsl(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"IncomingServerRequiresSsl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IncomingServerRequiresSsl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_IncomingServerRequiresSsl(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"IncomingServerRequiresSsl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IncomingServerRequiresSsl(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_IncomingServerPort(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"IncomingServerPort"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IncomingServerPort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_IncomingServerPort(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"IncomingServerPort"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.IncomingServerPort(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_IncomingServerAddress(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"IncomingServerAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IncomingServerAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_IncomingServerAddress(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"IncomingServerAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.IncomingServerAddress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_EmailSyncEnabled(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"EmailSyncEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmailSyncEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_EmailSyncEnabled(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"EmailSyncEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.EmailSyncEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_ServerType(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"ServerType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServerType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_ServerType(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"ServerType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountServerType>(arg);

            self->obj.ServerType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_OutgoingServerUsername(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"OutgoingServerUsername"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingServerUsername());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_OutgoingServerUsername(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"OutgoingServerUsername"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.OutgoingServerUsername(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_OutgoingServerRequiresSsl(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"OutgoingServerRequiresSsl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingServerRequiresSsl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_OutgoingServerRequiresSsl(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"OutgoingServerRequiresSsl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.OutgoingServerRequiresSsl(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_OutgoingServerPort(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"OutgoingServerPort"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingServerPort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_OutgoingServerPort(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"OutgoingServerPort"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.OutgoingServerPort(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_AccountIconId(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"AccountIconId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccountIconId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_AccountIconId(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"AccountIconId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountIconId>(arg);

            self->obj.AccountIconId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_CalDavServerUrl(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"CalDavServerUrl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CalDavServerUrl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_CalDavServerUrl(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"CalDavServerUrl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.CalDavServerUrl(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_CalDavRequiresSsl(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"CalDavRequiresSsl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CalDavRequiresSsl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_CalDavRequiresSsl(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"CalDavRequiresSsl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CalDavRequiresSsl(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_AutoSelectAuthenticationCertificate(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"AutoSelectAuthenticationCertificate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutoSelectAuthenticationCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_AutoSelectAuthenticationCertificate(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"AutoSelectAuthenticationCertificate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AutoSelectAuthenticationCertificate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_AuthenticationType(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"AuthenticationType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AuthenticationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_AuthenticationType(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"AuthenticationType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountAuthenticationType>(arg);

            self->obj.AuthenticationType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_AuthenticationCertificateId(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"AuthenticationCertificateId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AuthenticationCertificateId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_AuthenticationCertificateId(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"AuthenticationCertificateId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AuthenticationCertificateId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_IsOutgoingServerAuthenticationEnabled(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"IsOutgoingServerAuthenticationEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsOutgoingServerAuthenticationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_IsOutgoingServerAuthenticationEnabled(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"IsOutgoingServerAuthenticationEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsOutgoingServerAuthenticationEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_IsClientAuthenticationCertificateRequired(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"IsClientAuthenticationCertificateRequired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsClientAuthenticationCertificateRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_IsClientAuthenticationCertificateRequired(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"IsClientAuthenticationCertificateRequired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsClientAuthenticationCertificateRequired(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_IncomingServerCredential(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"IncomingServerCredential"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IncomingServerCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_IncomingServerCredential(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"IncomingServerCredential"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.IncomingServerCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_IsOutgoingServerAuthenticationRequired(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"IsOutgoingServerAuthenticationRequired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsOutgoingServerAuthenticationRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_IsOutgoingServerAuthenticationRequired(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"IsOutgoingServerAuthenticationRequired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsOutgoingServerAuthenticationRequired(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_CardDavSyncScheduleKind(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"CardDavSyncScheduleKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CardDavSyncScheduleKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_CardDavSyncScheduleKind(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"CardDavSyncScheduleKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountSyncScheduleKind>(arg);

            self->obj.CardDavSyncScheduleKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_AlwaysDownloadFullMessage(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"AlwaysDownloadFullMessage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AlwaysDownloadFullMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_AlwaysDownloadFullMessage(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"AlwaysDownloadFullMessage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AlwaysDownloadFullMessage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_CardDavServerUrl(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"CardDavServerUrl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CardDavServerUrl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_CardDavServerUrl(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"CardDavServerUrl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.CardDavServerUrl(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_CardDavRequiresSsl(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"CardDavRequiresSsl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CardDavRequiresSsl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_CardDavRequiresSsl(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"CardDavRequiresSsl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CardDavRequiresSsl(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_CalDavSyncScheduleKind(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"CalDavSyncScheduleKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CalDavSyncScheduleKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_CalDavSyncScheduleKind(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"CalDavSyncScheduleKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountSyncScheduleKind>(arg);

            self->obj.CalDavSyncScheduleKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_IncomingServerCertificateHash(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"IncomingServerCertificateHash"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IncomingServerCertificateHash());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_IncomingServerCertificateHash(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"IncomingServerCertificateHash"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.IncomingServerCertificateHash(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_WasOutgoingServerCertificateHashConfirmed(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"WasOutgoingServerCertificateHashConfirmed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WasOutgoingServerCertificateHashConfirmed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_WasOutgoingServerCertificateHashConfirmed(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"WasOutgoingServerCertificateHashConfirmed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.WasOutgoingServerCertificateHashConfirmed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_WasModifiedByUser(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"WasModifiedByUser"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WasModifiedByUser());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_WasModifiedByUser(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"WasModifiedByUser"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.WasModifiedByUser(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_SyncScheduleKind(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"SyncScheduleKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SyncScheduleKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_SyncScheduleKind(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"SyncScheduleKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountSyncScheduleKind>(arg);

            self->obj.SyncScheduleKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_SsoAccountId(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"SsoAccountId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SsoAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_SsoAccountId(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"SsoAccountId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SsoAccountId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_WasIncomingServerCertificateHashConfirmed(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"WasIncomingServerCertificateHashConfirmed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WasIncomingServerCertificateHashConfirmed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_WasIncomingServerCertificateHashConfirmed(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"WasIncomingServerCertificateHashConfirmed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.WasIncomingServerCertificateHashConfirmed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_OAuthRefreshToken(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"OAuthRefreshToken"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OAuthRefreshToken());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_OAuthRefreshToken(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"OAuthRefreshToken"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.OAuthRefreshToken(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_IsExternallyManaged(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"IsExternallyManaged"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsExternallyManaged());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_IsExternallyManaged(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"IsExternallyManaged"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsExternallyManaged(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_MailAgeFilter(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"MailAgeFilter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MailAgeFilter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_MailAgeFilter(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"MailAgeFilter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountMailAgeFilter>(arg);

            self->obj.MailAgeFilter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_IsSyncScheduleManagedBySystem(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"IsSyncScheduleManagedBySystem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSyncScheduleManagedBySystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_IsSyncScheduleManagedBySystem(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"IsSyncScheduleManagedBySystem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSyncScheduleManagedBySystem(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_OutgoingServerCertificateHash(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"OutgoingServerCertificateHash"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingServerCertificateHash());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_OutgoingServerCertificateHash(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"OutgoingServerCertificateHash"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.OutgoingServerCertificateHash(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_OutgoingServerCredential(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"OutgoingServerCredential"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingServerCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_OutgoingServerCredential(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"OutgoingServerCredential"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.OutgoingServerCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_DoesPolicyAllowMailSync(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"DoesPolicyAllowMailSync"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DoesPolicyAllowMailSync());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_IsSsoAuthenticationSupported(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration", L"IsSsoAuthenticationSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSsoAuthenticationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceAccountConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceAccountConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceAccountConfiguration[] = {
        { "_assign_array_", _assign_array_DeviceAccountConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceAccountConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceAccountConfiguration[] = {
        { "email_address", reinterpret_cast<getter>(DeviceAccountConfiguration_get_EmailAddress), reinterpret_cast<setter>(DeviceAccountConfiguration_put_EmailAddress), nullptr, nullptr },
        { "domain", reinterpret_cast<getter>(DeviceAccountConfiguration_get_Domain), reinterpret_cast<setter>(DeviceAccountConfiguration_put_Domain), nullptr, nullptr },
        { "device_account_type_id", reinterpret_cast<getter>(DeviceAccountConfiguration_get_DeviceAccountTypeId), reinterpret_cast<setter>(DeviceAccountConfiguration_put_DeviceAccountTypeId), nullptr, nullptr },
        { "outgoing_server_address", reinterpret_cast<getter>(DeviceAccountConfiguration_get_OutgoingServerAddress), reinterpret_cast<setter>(DeviceAccountConfiguration_put_OutgoingServerAddress), nullptr, nullptr },
        { "contacts_sync_enabled", reinterpret_cast<getter>(DeviceAccountConfiguration_get_ContactsSyncEnabled), reinterpret_cast<setter>(DeviceAccountConfiguration_put_ContactsSyncEnabled), nullptr, nullptr },
        { "calendar_sync_enabled", reinterpret_cast<getter>(DeviceAccountConfiguration_get_CalendarSyncEnabled), reinterpret_cast<setter>(DeviceAccountConfiguration_put_CalendarSyncEnabled), nullptr, nullptr },
        { "account_name", reinterpret_cast<getter>(DeviceAccountConfiguration_get_AccountName), reinterpret_cast<setter>(DeviceAccountConfiguration_put_AccountName), nullptr, nullptr },
        { "incoming_server_username", reinterpret_cast<getter>(DeviceAccountConfiguration_get_IncomingServerUsername), reinterpret_cast<setter>(DeviceAccountConfiguration_put_IncomingServerUsername), nullptr, nullptr },
        { "incoming_server_requires_ssl", reinterpret_cast<getter>(DeviceAccountConfiguration_get_IncomingServerRequiresSsl), reinterpret_cast<setter>(DeviceAccountConfiguration_put_IncomingServerRequiresSsl), nullptr, nullptr },
        { "incoming_server_port", reinterpret_cast<getter>(DeviceAccountConfiguration_get_IncomingServerPort), reinterpret_cast<setter>(DeviceAccountConfiguration_put_IncomingServerPort), nullptr, nullptr },
        { "incoming_server_address", reinterpret_cast<getter>(DeviceAccountConfiguration_get_IncomingServerAddress), reinterpret_cast<setter>(DeviceAccountConfiguration_put_IncomingServerAddress), nullptr, nullptr },
        { "email_sync_enabled", reinterpret_cast<getter>(DeviceAccountConfiguration_get_EmailSyncEnabled), reinterpret_cast<setter>(DeviceAccountConfiguration_put_EmailSyncEnabled), nullptr, nullptr },
        { "server_type", reinterpret_cast<getter>(DeviceAccountConfiguration_get_ServerType), reinterpret_cast<setter>(DeviceAccountConfiguration_put_ServerType), nullptr, nullptr },
        { "outgoing_server_username", reinterpret_cast<getter>(DeviceAccountConfiguration_get_OutgoingServerUsername), reinterpret_cast<setter>(DeviceAccountConfiguration_put_OutgoingServerUsername), nullptr, nullptr },
        { "outgoing_server_requires_ssl", reinterpret_cast<getter>(DeviceAccountConfiguration_get_OutgoingServerRequiresSsl), reinterpret_cast<setter>(DeviceAccountConfiguration_put_OutgoingServerRequiresSsl), nullptr, nullptr },
        { "outgoing_server_port", reinterpret_cast<getter>(DeviceAccountConfiguration_get_OutgoingServerPort), reinterpret_cast<setter>(DeviceAccountConfiguration_put_OutgoingServerPort), nullptr, nullptr },
        { "account_icon_id", reinterpret_cast<getter>(DeviceAccountConfiguration_get_AccountIconId), reinterpret_cast<setter>(DeviceAccountConfiguration_put_AccountIconId), nullptr, nullptr },
        { "cal_dav_server_url", reinterpret_cast<getter>(DeviceAccountConfiguration_get_CalDavServerUrl), reinterpret_cast<setter>(DeviceAccountConfiguration_put_CalDavServerUrl), nullptr, nullptr },
        { "cal_dav_requires_ssl", reinterpret_cast<getter>(DeviceAccountConfiguration_get_CalDavRequiresSsl), reinterpret_cast<setter>(DeviceAccountConfiguration_put_CalDavRequiresSsl), nullptr, nullptr },
        { "auto_select_authentication_certificate", reinterpret_cast<getter>(DeviceAccountConfiguration_get_AutoSelectAuthenticationCertificate), reinterpret_cast<setter>(DeviceAccountConfiguration_put_AutoSelectAuthenticationCertificate), nullptr, nullptr },
        { "authentication_type", reinterpret_cast<getter>(DeviceAccountConfiguration_get_AuthenticationType), reinterpret_cast<setter>(DeviceAccountConfiguration_put_AuthenticationType), nullptr, nullptr },
        { "authentication_certificate_id", reinterpret_cast<getter>(DeviceAccountConfiguration_get_AuthenticationCertificateId), reinterpret_cast<setter>(DeviceAccountConfiguration_put_AuthenticationCertificateId), nullptr, nullptr },
        { "is_outgoing_server_authentication_enabled", reinterpret_cast<getter>(DeviceAccountConfiguration_get_IsOutgoingServerAuthenticationEnabled), reinterpret_cast<setter>(DeviceAccountConfiguration_put_IsOutgoingServerAuthenticationEnabled), nullptr, nullptr },
        { "is_client_authentication_certificate_required", reinterpret_cast<getter>(DeviceAccountConfiguration_get_IsClientAuthenticationCertificateRequired), reinterpret_cast<setter>(DeviceAccountConfiguration_put_IsClientAuthenticationCertificateRequired), nullptr, nullptr },
        { "incoming_server_credential", reinterpret_cast<getter>(DeviceAccountConfiguration_get_IncomingServerCredential), reinterpret_cast<setter>(DeviceAccountConfiguration_put_IncomingServerCredential), nullptr, nullptr },
        { "is_outgoing_server_authentication_required", reinterpret_cast<getter>(DeviceAccountConfiguration_get_IsOutgoingServerAuthenticationRequired), reinterpret_cast<setter>(DeviceAccountConfiguration_put_IsOutgoingServerAuthenticationRequired), nullptr, nullptr },
        { "card_dav_sync_schedule_kind", reinterpret_cast<getter>(DeviceAccountConfiguration_get_CardDavSyncScheduleKind), reinterpret_cast<setter>(DeviceAccountConfiguration_put_CardDavSyncScheduleKind), nullptr, nullptr },
        { "always_download_full_message", reinterpret_cast<getter>(DeviceAccountConfiguration_get_AlwaysDownloadFullMessage), reinterpret_cast<setter>(DeviceAccountConfiguration_put_AlwaysDownloadFullMessage), nullptr, nullptr },
        { "card_dav_server_url", reinterpret_cast<getter>(DeviceAccountConfiguration_get_CardDavServerUrl), reinterpret_cast<setter>(DeviceAccountConfiguration_put_CardDavServerUrl), nullptr, nullptr },
        { "card_dav_requires_ssl", reinterpret_cast<getter>(DeviceAccountConfiguration_get_CardDavRequiresSsl), reinterpret_cast<setter>(DeviceAccountConfiguration_put_CardDavRequiresSsl), nullptr, nullptr },
        { "cal_dav_sync_schedule_kind", reinterpret_cast<getter>(DeviceAccountConfiguration_get_CalDavSyncScheduleKind), reinterpret_cast<setter>(DeviceAccountConfiguration_put_CalDavSyncScheduleKind), nullptr, nullptr },
        { "incoming_server_certificate_hash", reinterpret_cast<getter>(DeviceAccountConfiguration_get_IncomingServerCertificateHash), reinterpret_cast<setter>(DeviceAccountConfiguration_put_IncomingServerCertificateHash), nullptr, nullptr },
        { "was_outgoing_server_certificate_hash_confirmed", reinterpret_cast<getter>(DeviceAccountConfiguration_get_WasOutgoingServerCertificateHashConfirmed), reinterpret_cast<setter>(DeviceAccountConfiguration_put_WasOutgoingServerCertificateHashConfirmed), nullptr, nullptr },
        { "was_modified_by_user", reinterpret_cast<getter>(DeviceAccountConfiguration_get_WasModifiedByUser), reinterpret_cast<setter>(DeviceAccountConfiguration_put_WasModifiedByUser), nullptr, nullptr },
        { "sync_schedule_kind", reinterpret_cast<getter>(DeviceAccountConfiguration_get_SyncScheduleKind), reinterpret_cast<setter>(DeviceAccountConfiguration_put_SyncScheduleKind), nullptr, nullptr },
        { "sso_account_id", reinterpret_cast<getter>(DeviceAccountConfiguration_get_SsoAccountId), reinterpret_cast<setter>(DeviceAccountConfiguration_put_SsoAccountId), nullptr, nullptr },
        { "was_incoming_server_certificate_hash_confirmed", reinterpret_cast<getter>(DeviceAccountConfiguration_get_WasIncomingServerCertificateHashConfirmed), reinterpret_cast<setter>(DeviceAccountConfiguration_put_WasIncomingServerCertificateHashConfirmed), nullptr, nullptr },
        { "o_auth_refresh_token", reinterpret_cast<getter>(DeviceAccountConfiguration_get_OAuthRefreshToken), reinterpret_cast<setter>(DeviceAccountConfiguration_put_OAuthRefreshToken), nullptr, nullptr },
        { "is_externally_managed", reinterpret_cast<getter>(DeviceAccountConfiguration_get_IsExternallyManaged), reinterpret_cast<setter>(DeviceAccountConfiguration_put_IsExternallyManaged), nullptr, nullptr },
        { "mail_age_filter", reinterpret_cast<getter>(DeviceAccountConfiguration_get_MailAgeFilter), reinterpret_cast<setter>(DeviceAccountConfiguration_put_MailAgeFilter), nullptr, nullptr },
        { "is_sync_schedule_managed_by_system", reinterpret_cast<getter>(DeviceAccountConfiguration_get_IsSyncScheduleManagedBySystem), reinterpret_cast<setter>(DeviceAccountConfiguration_put_IsSyncScheduleManagedBySystem), nullptr, nullptr },
        { "outgoing_server_certificate_hash", reinterpret_cast<getter>(DeviceAccountConfiguration_get_OutgoingServerCertificateHash), reinterpret_cast<setter>(DeviceAccountConfiguration_put_OutgoingServerCertificateHash), nullptr, nullptr },
        { "outgoing_server_credential", reinterpret_cast<getter>(DeviceAccountConfiguration_get_OutgoingServerCredential), reinterpret_cast<setter>(DeviceAccountConfiguration_put_OutgoingServerCredential), nullptr, nullptr },
        { "does_policy_allow_mail_sync", reinterpret_cast<getter>(DeviceAccountConfiguration_get_DoesPolicyAllowMailSync), nullptr, nullptr, nullptr },
        { "is_sso_authentication_supported", reinterpret_cast<getter>(DeviceAccountConfiguration_get_IsSsoAuthenticationSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceAccountConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceAccountConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceAccountConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceAccountConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceAccountConfiguration) },
        { },
    };

    static PyType_Spec type_spec_DeviceAccountConfiguration =
    {
        "winrt._winrt_windows_applicationmodel_userdataaccounts_systemaccess.DeviceAccountConfiguration",
        sizeof(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceAccountConfiguration
    };

    // ----- UserDataAccountSystemAccessManager class --------------------

    static PyObject* _new_UserDataAccountSystemAccessManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::UserDataAccountSystemAccessManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::UserDataAccountSystemAccessManager>::type_name);
        return nullptr;
    }

    static PyObject* UserDataAccountSystemAccessManager_AddAndShowDeviceAccountsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.UserDataAccountSystemAccessManager", L"AddAndShowDeviceAccountsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration>>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::UserDataAccountSystemAccessManager::AddAndShowDeviceAccountsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserDataAccountSystemAccessManager_CreateDeviceAccountAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.UserDataAccountSystemAccessManager", L"CreateDeviceAccountAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::UserDataAccountSystemAccessManager::CreateDeviceAccountAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserDataAccountSystemAccessManager_DeleteDeviceAccountAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.UserDataAccountSystemAccessManager", L"DeleteDeviceAccountAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::UserDataAccountSystemAccessManager::DeleteDeviceAccountAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserDataAccountSystemAccessManager_GetDeviceAccountConfigurationAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.UserDataAccountSystemAccessManager", L"GetDeviceAccountConfigurationAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::UserDataAccountSystemAccessManager::GetDeviceAccountConfigurationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserDataAccountSystemAccessManager_SuppressLocalAccountWithAccountAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.UserDataAccounts.SystemAccess.UserDataAccountSystemAccessManager", L"SuppressLocalAccountWithAccountAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::UserDataAccountSystemAccessManager::SuppressLocalAccountWithAccountAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserDataAccountSystemAccessManager[] = {
        { }
    };

    static PyGetSetDef _getset_UserDataAccountSystemAccessManager[] = {
        { }
    };

    static PyType_Slot _type_slots_UserDataAccountSystemAccessManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UserDataAccountSystemAccessManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UserDataAccountSystemAccessManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UserDataAccountSystemAccessManager) },
        { },
    };

    static PyType_Spec type_spec_UserDataAccountSystemAccessManager =
    {
        "winrt._winrt_windows_applicationmodel_userdataaccounts_systemaccess.UserDataAccountSystemAccessManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserDataAccountSystemAccessManager
    };

    static PyGetSetDef getset_UserDataAccountSystemAccessManager_Static[] = {
        { }
    };

    static PyMethodDef methods_UserDataAccountSystemAccessManager_Static[] = {
        { "add_and_show_device_accounts_async", reinterpret_cast<PyCFunction>(UserDataAccountSystemAccessManager_AddAndShowDeviceAccountsAsync), METH_VARARGS, nullptr },
        { "create_device_account_async", reinterpret_cast<PyCFunction>(UserDataAccountSystemAccessManager_CreateDeviceAccountAsync), METH_VARARGS, nullptr },
        { "delete_device_account_async", reinterpret_cast<PyCFunction>(UserDataAccountSystemAccessManager_DeleteDeviceAccountAsync), METH_VARARGS, nullptr },
        { "get_device_account_configuration_async", reinterpret_cast<PyCFunction>(UserDataAccountSystemAccessManager_GetDeviceAccountConfigurationAsync), METH_VARARGS, nullptr },
        { "suppress_local_account_with_account_async", reinterpret_cast<PyCFunction>(UserDataAccountSystemAccessManager_SuppressLocalAccountWithAccountAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_UserDataAccountSystemAccessManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_UserDataAccountSystemAccessManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_UserDataAccountSystemAccessManager_Static) },
        { }
    };

    static PyType_Spec type_spec_UserDataAccountSystemAccessManager_Static =
    {
        "winrt._winrt_windows_applicationmodel_userdataaccounts_systemaccess.UserDataAccountSystemAccessManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_UserDataAccountSystemAccessManager_Static
    };

    // ----- Windows.ApplicationModel.UserDataAccounts.SystemAccess Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::ApplicationModel::UserDataAccounts::SystemAccess");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_applicationmodel_userdataaccounts_systemaccess",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::ApplicationModel::UserDataAccounts::SystemAccess

PyMODINIT_FUNC PyInit__winrt_windows_applicationmodel_userdataaccounts_systemaccess(void) noexcept
{
    using namespace py::cpp::Windows::ApplicationModel::UserDataAccounts::SystemAccess;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DeviceAccountConfiguration, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_UserDataAccountSystemAccessManager_Static{PyType_FromSpec(&type_spec_UserDataAccountSystemAccessManager_Static)};
    if (!type_UserDataAccountSystemAccessManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UserDataAccountSystemAccessManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_UserDataAccountSystemAccessManager_Static.get())) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
