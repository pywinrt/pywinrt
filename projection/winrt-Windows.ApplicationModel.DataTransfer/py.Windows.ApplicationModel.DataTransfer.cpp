// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.ApplicationModel.DataTransfer.h"


namespace py::cpp::Windows::ApplicationModel::DataTransfer
{
    // ----- Clipboard class --------------------

    static PyObject* _new_Clipboard(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::Clipboard>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::Clipboard>::type_name);
        return nullptr;
    }

    static PyObject* Clipboard_Clear(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.Clipboard", L"Clear", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::Windows::ApplicationModel::DataTransfer::Clipboard::Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Clipboard_ClearHistory(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.Clipboard", L"ClearHistory", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::ApplicationModel::DataTransfer::Clipboard::ClearHistory());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Clipboard_DeleteItemFromHistory(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.Clipboard", L"DeleteItemFromHistory", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItem>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::DataTransfer::Clipboard::DeleteItemFromHistory(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Clipboard_Flush(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.Clipboard", L"Flush", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::Windows::ApplicationModel::DataTransfer::Clipboard::Flush();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Clipboard_GetContent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.Clipboard", L"GetContent", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::ApplicationModel::DataTransfer::Clipboard::GetContent());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Clipboard_GetHistoryItemsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.Clipboard", L"GetHistoryItemsAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::ApplicationModel::DataTransfer::Clipboard::GetHistoryItemsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Clipboard_IsHistoryEnabled(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.Clipboard", L"IsHistoryEnabled", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::ApplicationModel::DataTransfer::Clipboard::IsHistoryEnabled());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Clipboard_IsRoamingEnabled(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.Clipboard", L"IsRoamingEnabled", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::ApplicationModel::DataTransfer::Clipboard::IsRoamingEnabled());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Clipboard_SetContent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.Clipboard", L"SetContent", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::DataTransfer::DataPackage>(args, 0);

                winrt::Windows::ApplicationModel::DataTransfer::Clipboard::SetContent(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Clipboard_SetContentWithOptions(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.Clipboard", L"SetContentWithOptions", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::DataTransfer::DataPackage>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::DataTransfer::ClipboardContentOptions>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::DataTransfer::Clipboard::SetContentWithOptions(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Clipboard_SetHistoryItemAsContent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.Clipboard", L"SetHistoryItemAsContent", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItem>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::DataTransfer::Clipboard::SetHistoryItemAsContent(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Clipboard_add_HistoryChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.DataTransfer.Clipboard", L"HistoryChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::ApplicationModel::DataTransfer::ClipboardHistoryChangedEventArgs>>(arg);

            return py::convert(winrt::Windows::ApplicationModel::DataTransfer::Clipboard::HistoryChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Clipboard_remove_HistoryChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.DataTransfer.Clipboard", L"HistoryChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::ApplicationModel::DataTransfer::Clipboard::HistoryChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Clipboard_add_HistoryEnabledChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.DataTransfer.Clipboard", L"HistoryEnabledChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::ApplicationModel::DataTransfer::Clipboard::HistoryEnabledChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Clipboard_remove_HistoryEnabledChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.DataTransfer.Clipboard", L"HistoryEnabledChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::ApplicationModel::DataTransfer::Clipboard::HistoryEnabledChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Clipboard_add_RoamingEnabledChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.DataTransfer.Clipboard", L"RoamingEnabledChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::ApplicationModel::DataTransfer::Clipboard::RoamingEnabledChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Clipboard_remove_RoamingEnabledChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.DataTransfer.Clipboard", L"RoamingEnabledChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::ApplicationModel::DataTransfer::Clipboard::RoamingEnabledChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Clipboard_add_ContentChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.DataTransfer.Clipboard", L"ContentChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::ApplicationModel::DataTransfer::Clipboard::ContentChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Clipboard_remove_ContentChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.DataTransfer.Clipboard", L"ContentChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::ApplicationModel::DataTransfer::Clipboard::ContentChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Clipboard[] = {
        { "add_history_changed", reinterpret_cast<PyCFunction>(Clipboard_add_HistoryChanged), METH_O | METH_STATIC, nullptr },
        { "remove_history_changed", reinterpret_cast<PyCFunction>(Clipboard_remove_HistoryChanged), METH_O | METH_STATIC, nullptr },
        { "add_history_enabled_changed", reinterpret_cast<PyCFunction>(Clipboard_add_HistoryEnabledChanged), METH_O | METH_STATIC, nullptr },
        { "remove_history_enabled_changed", reinterpret_cast<PyCFunction>(Clipboard_remove_HistoryEnabledChanged), METH_O | METH_STATIC, nullptr },
        { "add_roaming_enabled_changed", reinterpret_cast<PyCFunction>(Clipboard_add_RoamingEnabledChanged), METH_O | METH_STATIC, nullptr },
        { "remove_roaming_enabled_changed", reinterpret_cast<PyCFunction>(Clipboard_remove_RoamingEnabledChanged), METH_O | METH_STATIC, nullptr },
        { "add_content_changed", reinterpret_cast<PyCFunction>(Clipboard_add_ContentChanged), METH_O | METH_STATIC, nullptr },
        { "remove_content_changed", reinterpret_cast<PyCFunction>(Clipboard_remove_ContentChanged), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Clipboard[] = {
        { }
    };

    static PyType_Slot _type_slots_Clipboard[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Clipboard) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Clipboard) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Clipboard) },
        { },
    };

    static PyType_Spec type_spec_Clipboard = {
        "winrt._winrt_windows_applicationmodel_datatransfer.Clipboard",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Clipboard};

    static PyGetSetDef getset_Clipboard_Static[] = {
        { }
    };

    static PyMethodDef methods_Clipboard_Static[] = {
        { "clear", reinterpret_cast<PyCFunction>(Clipboard_Clear), METH_VARARGS, nullptr },
        { "clear_history", reinterpret_cast<PyCFunction>(Clipboard_ClearHistory), METH_VARARGS, nullptr },
        { "delete_item_from_history", reinterpret_cast<PyCFunction>(Clipboard_DeleteItemFromHistory), METH_VARARGS, nullptr },
        { "flush", reinterpret_cast<PyCFunction>(Clipboard_Flush), METH_VARARGS, nullptr },
        { "get_content", reinterpret_cast<PyCFunction>(Clipboard_GetContent), METH_VARARGS, nullptr },
        { "get_history_items_async", reinterpret_cast<PyCFunction>(Clipboard_GetHistoryItemsAsync), METH_VARARGS, nullptr },
        { "is_history_enabled", reinterpret_cast<PyCFunction>(Clipboard_IsHistoryEnabled), METH_VARARGS, nullptr },
        { "is_roaming_enabled", reinterpret_cast<PyCFunction>(Clipboard_IsRoamingEnabled), METH_VARARGS, nullptr },
        { "set_content", reinterpret_cast<PyCFunction>(Clipboard_SetContent), METH_VARARGS, nullptr },
        { "set_content_with_options", reinterpret_cast<PyCFunction>(Clipboard_SetContentWithOptions), METH_VARARGS, nullptr },
        { "set_history_item_as_content", reinterpret_cast<PyCFunction>(Clipboard_SetHistoryItemAsContent), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_Clipboard_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Clipboard_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Clipboard_Static) },
        { }
    };

    static PyType_Spec type_spec_Clipboard_Static =
    {
        "winrt._winrt_windows_applicationmodel_datatransfer.Clipboard_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Clipboard_Static
    };

    // ----- ClipboardContentOptions class --------------------

    static PyObject* _new_ClipboardContentOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::DataTransfer::ClipboardContentOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ClipboardContentOptions(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardContentOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ClipboardContentOptions_get_IsRoamable(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardContentOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.ClipboardContentOptions", L"IsRoamable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsRoamable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClipboardContentOptions_put_IsRoamable(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardContentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.ClipboardContentOptions", L"IsRoamable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsRoamable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClipboardContentOptions_get_IsAllowedInHistory(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardContentOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.ClipboardContentOptions", L"IsAllowedInHistory"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsAllowedInHistory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClipboardContentOptions_put_IsAllowedInHistory(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardContentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.ClipboardContentOptions", L"IsAllowedInHistory"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAllowedInHistory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClipboardContentOptions_get_HistoryFormats(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardContentOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.ClipboardContentOptions", L"HistoryFormats"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HistoryFormats());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClipboardContentOptions_get_RoamingFormats(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardContentOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.ClipboardContentOptions", L"RoamingFormats"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RoamingFormats());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ClipboardContentOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::DataTransfer::ClipboardContentOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ClipboardContentOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::ClipboardContentOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClipboardContentOptions[] = {
        { "_assign_array_", _assign_array_ClipboardContentOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClipboardContentOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClipboardContentOptions[] = {
        { "is_roamable", reinterpret_cast<getter>(ClipboardContentOptions_get_IsRoamable), reinterpret_cast<setter>(ClipboardContentOptions_put_IsRoamable), nullptr, nullptr },
        { "is_allowed_in_history", reinterpret_cast<getter>(ClipboardContentOptions_get_IsAllowedInHistory), reinterpret_cast<setter>(ClipboardContentOptions_put_IsAllowedInHistory), nullptr, nullptr },
        { "history_formats", reinterpret_cast<getter>(ClipboardContentOptions_get_HistoryFormats), nullptr, nullptr, nullptr },
        { "roaming_formats", reinterpret_cast<getter>(ClipboardContentOptions_get_RoamingFormats), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ClipboardContentOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClipboardContentOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ClipboardContentOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClipboardContentOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClipboardContentOptions) },
        { },
    };

    static PyType_Spec type_spec_ClipboardContentOptions = {
        "winrt._winrt_windows_applicationmodel_datatransfer.ClipboardContentOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardContentOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClipboardContentOptions};

    // ----- ClipboardHistoryChangedEventArgs class --------------------

    static PyObject* _new_ClipboardHistoryChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::ClipboardHistoryChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::ClipboardHistoryChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ClipboardHistoryChangedEventArgs(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardHistoryChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ClipboardHistoryChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::DataTransfer::ClipboardHistoryChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ClipboardHistoryChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::ClipboardHistoryChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClipboardHistoryChangedEventArgs[] = {
        { "_assign_array_", _assign_array_ClipboardHistoryChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClipboardHistoryChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClipboardHistoryChangedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_ClipboardHistoryChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClipboardHistoryChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ClipboardHistoryChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClipboardHistoryChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClipboardHistoryChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ClipboardHistoryChangedEventArgs = {
        "winrt._winrt_windows_applicationmodel_datatransfer.ClipboardHistoryChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardHistoryChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClipboardHistoryChangedEventArgs};

    // ----- ClipboardHistoryItem class --------------------

    static PyObject* _new_ClipboardHistoryItem(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItem>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItem>::type_name);
        return nullptr;
    }

    static void _dealloc_ClipboardHistoryItem(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ClipboardHistoryItem_get_Content(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItem* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.ClipboardHistoryItem", L"Content"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClipboardHistoryItem_get_Id(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItem* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.ClipboardHistoryItem", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClipboardHistoryItem_get_Timestamp(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItem* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.ClipboardHistoryItem", L"Timestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ClipboardHistoryItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ClipboardHistoryItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClipboardHistoryItem[] = {
        { "_assign_array_", _assign_array_ClipboardHistoryItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClipboardHistoryItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClipboardHistoryItem[] = {
        { "content", reinterpret_cast<getter>(ClipboardHistoryItem_get_Content), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ClipboardHistoryItem_get_Id), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(ClipboardHistoryItem_get_Timestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ClipboardHistoryItem[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClipboardHistoryItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ClipboardHistoryItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClipboardHistoryItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClipboardHistoryItem) },
        { },
    };

    static PyType_Spec type_spec_ClipboardHistoryItem = {
        "winrt._winrt_windows_applicationmodel_datatransfer.ClipboardHistoryItem",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClipboardHistoryItem};

    // ----- ClipboardHistoryItemsResult class --------------------

    static PyObject* _new_ClipboardHistoryItemsResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItemsResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItemsResult>::type_name);
        return nullptr;
    }

    static void _dealloc_ClipboardHistoryItemsResult(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItemsResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ClipboardHistoryItemsResult_get_Items(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.ClipboardHistoryItemsResult", L"Items"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Items());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClipboardHistoryItemsResult_get_Status(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.ClipboardHistoryItemsResult", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ClipboardHistoryItemsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItemsResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ClipboardHistoryItemsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItemsResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClipboardHistoryItemsResult[] = {
        { "_assign_array_", _assign_array_ClipboardHistoryItemsResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClipboardHistoryItemsResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClipboardHistoryItemsResult[] = {
        { "items", reinterpret_cast<getter>(ClipboardHistoryItemsResult_get_Items), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(ClipboardHistoryItemsResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ClipboardHistoryItemsResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClipboardHistoryItemsResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ClipboardHistoryItemsResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClipboardHistoryItemsResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClipboardHistoryItemsResult) },
        { },
    };

    static PyType_Spec type_spec_ClipboardHistoryItemsResult = {
        "winrt._winrt_windows_applicationmodel_datatransfer.ClipboardHistoryItemsResult",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItemsResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClipboardHistoryItemsResult};

    // ----- DataPackage class --------------------

    static PyObject* _new_DataPackage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::DataTransfer::DataPackage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DataPackage(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DataPackage_GetView(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackage", L"GetView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackage_SetApplicationLink(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackage", L"SetApplicationLink", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                self->obj.SetApplicationLink(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackage_SetBitmap(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackage", L"SetBitmap", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::RandomAccessStreamReference>(args, 0);

                self->obj.SetBitmap(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackage_SetData(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackage", L"SetData", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetData(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackage_SetDataProvider(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackage", L"SetDataProvider", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::DataTransfer::DataProviderHandler>(args, 1);

                self->obj.SetDataProvider(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackage_SetHtmlFormat(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackage", L"SetHtmlFormat", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.SetHtmlFormat(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackage_SetRtf(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackage", L"SetRtf", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.SetRtf(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackage_SetStorageItems(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackage", L"SetStorageItems", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Storage::IStorageItem>>(args, 0);

                self->obj.SetStorageItems(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackage", L"SetStorageItems", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Storage::IStorageItem>>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                self->obj.SetStorageItems(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackage_SetText(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackage", L"SetText", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.SetText(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackage_SetUri(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackage", L"SetUri", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                self->obj.SetUri(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackage_SetWebLink(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackage", L"SetWebLink", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                self->obj.SetWebLink(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackage_get_RequestedOperation(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackage", L"RequestedOperation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequestedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataPackage_put_RequestedOperation(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackage", L"RequestedOperation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation>(arg);

            self->obj.RequestedOperation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataPackage_get_Properties(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackage", L"Properties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackage_get_ResourceMap(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackage", L"ResourceMap"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResourceMap());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackage_add_Destroyed(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.DataTransfer.DataPackage", L"Destroyed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::DataTransfer::DataPackage, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Destroyed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackage_remove_Destroyed(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.DataTransfer.DataPackage", L"Destroyed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Destroyed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackage_add_OperationCompleted(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.DataTransfer.DataPackage", L"OperationCompleted"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::DataTransfer::DataPackage, winrt::Windows::ApplicationModel::DataTransfer::OperationCompletedEventArgs>>(arg);

            return py::convert(self->obj.OperationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackage_remove_OperationCompleted(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.DataTransfer.DataPackage", L"OperationCompleted"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.OperationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackage_add_ShareCompleted(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.DataTransfer.DataPackage", L"ShareCompleted"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::DataTransfer::DataPackage, winrt::Windows::ApplicationModel::DataTransfer::ShareCompletedEventArgs>>(arg);

            return py::convert(self->obj.ShareCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackage_remove_ShareCompleted(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.DataTransfer.DataPackage", L"ShareCompleted"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ShareCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackage_add_ShareCanceled(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.DataTransfer.DataPackage", L"ShareCanceled"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::DataTransfer::DataPackage, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ShareCanceled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackage_remove_ShareCanceled(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.DataTransfer.DataPackage", L"ShareCanceled"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ShareCanceled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DataPackage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::DataTransfer::DataPackage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DataPackage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::DataPackage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataPackage[] = {
        { "get_view", reinterpret_cast<PyCFunction>(DataPackage_GetView), METH_VARARGS, nullptr },
        { "set_application_link", reinterpret_cast<PyCFunction>(DataPackage_SetApplicationLink), METH_VARARGS, nullptr },
        { "set_bitmap", reinterpret_cast<PyCFunction>(DataPackage_SetBitmap), METH_VARARGS, nullptr },
        { "set_data", reinterpret_cast<PyCFunction>(DataPackage_SetData), METH_VARARGS, nullptr },
        { "set_data_provider", reinterpret_cast<PyCFunction>(DataPackage_SetDataProvider), METH_VARARGS, nullptr },
        { "set_html_format", reinterpret_cast<PyCFunction>(DataPackage_SetHtmlFormat), METH_VARARGS, nullptr },
        { "set_rtf", reinterpret_cast<PyCFunction>(DataPackage_SetRtf), METH_VARARGS, nullptr },
        { "set_storage_items", reinterpret_cast<PyCFunction>(DataPackage_SetStorageItems), METH_VARARGS, nullptr },
        { "set_text", reinterpret_cast<PyCFunction>(DataPackage_SetText), METH_VARARGS, nullptr },
        { "set_uri", reinterpret_cast<PyCFunction>(DataPackage_SetUri), METH_VARARGS, nullptr },
        { "set_web_link", reinterpret_cast<PyCFunction>(DataPackage_SetWebLink), METH_VARARGS, nullptr },
        { "add_destroyed", reinterpret_cast<PyCFunction>(DataPackage_add_Destroyed), METH_O, nullptr },
        { "remove_destroyed", reinterpret_cast<PyCFunction>(DataPackage_remove_Destroyed), METH_O, nullptr },
        { "add_operation_completed", reinterpret_cast<PyCFunction>(DataPackage_add_OperationCompleted), METH_O, nullptr },
        { "remove_operation_completed", reinterpret_cast<PyCFunction>(DataPackage_remove_OperationCompleted), METH_O, nullptr },
        { "add_share_completed", reinterpret_cast<PyCFunction>(DataPackage_add_ShareCompleted), METH_O, nullptr },
        { "remove_share_completed", reinterpret_cast<PyCFunction>(DataPackage_remove_ShareCompleted), METH_O, nullptr },
        { "add_share_canceled", reinterpret_cast<PyCFunction>(DataPackage_add_ShareCanceled), METH_O, nullptr },
        { "remove_share_canceled", reinterpret_cast<PyCFunction>(DataPackage_remove_ShareCanceled), METH_O, nullptr },
        { "_assign_array_", _assign_array_DataPackage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DataPackage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataPackage[] = {
        { "requested_operation", reinterpret_cast<getter>(DataPackage_get_RequestedOperation), reinterpret_cast<setter>(DataPackage_put_RequestedOperation), nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DataPackage_get_Properties), nullptr, nullptr, nullptr },
        { "resource_map", reinterpret_cast<getter>(DataPackage_get_ResourceMap), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DataPackage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DataPackage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DataPackage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DataPackage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DataPackage) },
        { },
    };

    static PyType_Spec type_spec_DataPackage = {
        "winrt._winrt_windows_applicationmodel_datatransfer.DataPackage",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataPackage};

    // ----- DataPackagePropertySet class --------------------

    static PyObject* _new_DataPackagePropertySet(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet>::type_name);
        return nullptr;
    }

    static void _dealloc_DataPackagePropertySet(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DataPackagePropertySet_Clear(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySet", L"Clear", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySet_First(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySet", L"First", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySet_GetView(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySet", L"GetView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySet_HasKey(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySet", L"HasKey", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySet_Insert(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySet", L"Insert", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Insert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySet_Lookup(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySet", L"Lookup", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySet_Remove(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySet", L"Remove", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySet_get_Title(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySet", L"Title"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataPackagePropertySet_put_Title(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySet", L"Title"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataPackagePropertySet_get_Thumbnail(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySet", L"Thumbnail"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataPackagePropertySet_put_Thumbnail(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySet", L"Thumbnail"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.Thumbnail(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataPackagePropertySet_get_Description(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySet", L"Description"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataPackagePropertySet_put_Description(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySet", L"Description"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataPackagePropertySet_get_ApplicationName(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySet", L"ApplicationName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ApplicationName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataPackagePropertySet_put_ApplicationName(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySet", L"ApplicationName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ApplicationName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataPackagePropertySet_get_ApplicationListingUri(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySet", L"ApplicationListingUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ApplicationListingUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataPackagePropertySet_put_ApplicationListingUri(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySet", L"ApplicationListingUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.ApplicationListingUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataPackagePropertySet_get_FileTypes(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySet", L"FileTypes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FileTypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySet_get_Square30x30Logo(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySet", L"Square30x30Logo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Square30x30Logo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataPackagePropertySet_put_Square30x30Logo(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySet", L"Square30x30Logo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.Square30x30Logo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataPackagePropertySet_get_PackageFamilyName(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySet", L"PackageFamilyName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataPackagePropertySet_put_PackageFamilyName(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySet", L"PackageFamilyName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PackageFamilyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataPackagePropertySet_get_LogoBackgroundColor(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySet", L"LogoBackgroundColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LogoBackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataPackagePropertySet_put_LogoBackgroundColor(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySet", L"LogoBackgroundColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.LogoBackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataPackagePropertySet_get_ContentSourceWebLink(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySet", L"ContentSourceWebLink"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentSourceWebLink());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataPackagePropertySet_put_ContentSourceWebLink(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySet", L"ContentSourceWebLink"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.ContentSourceWebLink(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataPackagePropertySet_get_ContentSourceApplicationLink(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySet", L"ContentSourceApplicationLink"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentSourceApplicationLink());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataPackagePropertySet_put_ContentSourceApplicationLink(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySet", L"ContentSourceApplicationLink"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.ContentSourceApplicationLink(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataPackagePropertySet_get_EnterpriseId(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySet", L"EnterpriseId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EnterpriseId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataPackagePropertySet_put_EnterpriseId(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySet", L"EnterpriseId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.EnterpriseId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataPackagePropertySet_get_ContentSourceUserActivityJson(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySet", L"ContentSourceUserActivityJson"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentSourceUserActivityJson());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataPackagePropertySet_put_ContentSourceUserActivityJson(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySet", L"ContentSourceUserActivityJson"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContentSourceUserActivityJson(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataPackagePropertySet_get_Size(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySet", L"Size"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DataPackagePropertySet(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DataPackagePropertySet(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_DataPackagePropertySet(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self) noexcept
    {
        try
        {
            py::pyobj_handle iter{py::convert(self->obj.First())};

            if (!iter)
            {
                return nullptr;
            }

            return py::wrap_mapping_iter(iter.get());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_contains_DataPackagePropertySet(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* key) noexcept
    {
        try
        {
            return static_cast<int>(self->obj.HasKey(py::convert_to<winrt::hstring>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static Py_ssize_t _map_length_DataPackagePropertySet(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_DataPackagePropertySet(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* key) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);
            auto value = self->obj.TryLookup(_key);

            if (!value) {
                if constexpr (std::is_base_of_v<winrt::Windows::Foundation::IUnknown, decltype(value)>)
                {
                    if (self->obj.HasKey(_key))
                    {
                        Py_RETURN_NONE;
                    }
                }

                PyErr_SetObject(PyExc_KeyError, key);
                return nullptr;
            }

            return py::convert(value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_DataPackagePropertySet(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);

            if (value == nullptr) {
                if (!self->obj.TryRemove(_key)) {
                    PyErr_SetObject(PyExc_KeyError, key);
                    return -1;
                }

                return 0;
            }

            self->obj.Insert(_key, py::convert_to<winrt::Windows::Foundation::IInspectable>(value));

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_DataPackagePropertySet[] = {
        { "clear", reinterpret_cast<PyCFunction>(DataPackagePropertySet_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(DataPackagePropertySet_First), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(DataPackagePropertySet_GetView), METH_VARARGS, nullptr },
        { "has_key", reinterpret_cast<PyCFunction>(DataPackagePropertySet_HasKey), METH_VARARGS, nullptr },
        { "insert", reinterpret_cast<PyCFunction>(DataPackagePropertySet_Insert), METH_VARARGS, nullptr },
        { "lookup", reinterpret_cast<PyCFunction>(DataPackagePropertySet_Lookup), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(DataPackagePropertySet_Remove), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DataPackagePropertySet, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DataPackagePropertySet), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataPackagePropertySet[] = {
        { "title", reinterpret_cast<getter>(DataPackagePropertySet_get_Title), reinterpret_cast<setter>(DataPackagePropertySet_put_Title), nullptr, nullptr },
        { "thumbnail", reinterpret_cast<getter>(DataPackagePropertySet_get_Thumbnail), reinterpret_cast<setter>(DataPackagePropertySet_put_Thumbnail), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(DataPackagePropertySet_get_Description), reinterpret_cast<setter>(DataPackagePropertySet_put_Description), nullptr, nullptr },
        { "application_name", reinterpret_cast<getter>(DataPackagePropertySet_get_ApplicationName), reinterpret_cast<setter>(DataPackagePropertySet_put_ApplicationName), nullptr, nullptr },
        { "application_listing_uri", reinterpret_cast<getter>(DataPackagePropertySet_get_ApplicationListingUri), reinterpret_cast<setter>(DataPackagePropertySet_put_ApplicationListingUri), nullptr, nullptr },
        { "file_types", reinterpret_cast<getter>(DataPackagePropertySet_get_FileTypes), nullptr, nullptr, nullptr },
        { "square30x30_logo", reinterpret_cast<getter>(DataPackagePropertySet_get_Square30x30Logo), reinterpret_cast<setter>(DataPackagePropertySet_put_Square30x30Logo), nullptr, nullptr },
        { "package_family_name", reinterpret_cast<getter>(DataPackagePropertySet_get_PackageFamilyName), reinterpret_cast<setter>(DataPackagePropertySet_put_PackageFamilyName), nullptr, nullptr },
        { "logo_background_color", reinterpret_cast<getter>(DataPackagePropertySet_get_LogoBackgroundColor), reinterpret_cast<setter>(DataPackagePropertySet_put_LogoBackgroundColor), nullptr, nullptr },
        { "content_source_web_link", reinterpret_cast<getter>(DataPackagePropertySet_get_ContentSourceWebLink), reinterpret_cast<setter>(DataPackagePropertySet_put_ContentSourceWebLink), nullptr, nullptr },
        { "content_source_application_link", reinterpret_cast<getter>(DataPackagePropertySet_get_ContentSourceApplicationLink), reinterpret_cast<setter>(DataPackagePropertySet_put_ContentSourceApplicationLink), nullptr, nullptr },
        { "enterprise_id", reinterpret_cast<getter>(DataPackagePropertySet_get_EnterpriseId), reinterpret_cast<setter>(DataPackagePropertySet_put_EnterpriseId), nullptr, nullptr },
        { "content_source_user_activity_json", reinterpret_cast<getter>(DataPackagePropertySet_get_ContentSourceUserActivityJson), reinterpret_cast<setter>(DataPackagePropertySet_put_ContentSourceUserActivityJson), nullptr, nullptr },
        { "size", reinterpret_cast<getter>(DataPackagePropertySet_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DataPackagePropertySet[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DataPackagePropertySet) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DataPackagePropertySet) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DataPackagePropertySet) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DataPackagePropertySet) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_DataPackagePropertySet) },
        { Py_sq_contains, reinterpret_cast<void*>(_map_contains_DataPackagePropertySet) },
        { Py_mp_length, reinterpret_cast<void*>(_map_length_DataPackagePropertySet) },
        { Py_mp_subscript, reinterpret_cast<void*>(_map_subscript_DataPackagePropertySet) },
        { Py_mp_ass_subscript, reinterpret_cast<void*>(_map_assign_DataPackagePropertySet) },
        { },
    };

    static PyType_Spec type_spec_DataPackagePropertySet = {
        "winrt._winrt_windows_applicationmodel_datatransfer.DataPackagePropertySet",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataPackagePropertySet};

    // ----- DataPackagePropertySetView class --------------------

    static PyObject* _new_DataPackagePropertySetView(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView>::type_name);
        return nullptr;
    }

    static void _dealloc_DataPackagePropertySetView(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DataPackagePropertySetView_First(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView", L"First", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_HasKey(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView", L"HasKey", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_Lookup(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView", L"Lookup", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_Split(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView", L"Split", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::IInspectable> param0{nullptr};
                winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::IInspectable> param1{nullptr};

                self->obj.Split(param0, param1);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out0.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_get_ApplicationListingUri(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView", L"ApplicationListingUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ApplicationListingUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_get_ApplicationName(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView", L"ApplicationName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ApplicationName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_get_Description(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView", L"Description"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_get_FileTypes(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView", L"FileTypes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FileTypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_get_Thumbnail(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView", L"Thumbnail"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_get_Title(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView", L"Title"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_get_ContentSourceApplicationLink(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView", L"ContentSourceApplicationLink"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentSourceApplicationLink());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_get_ContentSourceWebLink(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView", L"ContentSourceWebLink"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentSourceWebLink());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_get_LogoBackgroundColor(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView", L"LogoBackgroundColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LogoBackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_get_PackageFamilyName(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView", L"PackageFamilyName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_get_Square30x30Logo(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView", L"Square30x30Logo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Square30x30Logo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_get_EnterpriseId(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView", L"EnterpriseId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EnterpriseId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_get_ContentSourceUserActivityJson(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView", L"ContentSourceUserActivityJson"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentSourceUserActivityJson());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_get_IsFromRoamingClipboard(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView", L"IsFromRoamingClipboard"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsFromRoamingClipboard());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_get_Size(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView", L"Size"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DataPackagePropertySetView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DataPackagePropertySetView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_DataPackagePropertySetView(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self) noexcept
    {
        try
        {
            py::pyobj_handle iter{py::convert(self->obj.First())};

            if (!iter)
            {
                return nullptr;
            }

            return py::wrap_mapping_iter(iter.get());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_contains_DataPackagePropertySetView(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, PyObject* key) noexcept
    {
        try
        {
            return static_cast<int>(self->obj.HasKey(py::convert_to<winrt::hstring>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static Py_ssize_t _map_length_DataPackagePropertySetView(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_DataPackagePropertySetView(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, PyObject* key) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);
            auto value = self->obj.TryLookup(_key);

            if (!value) {
                if constexpr (std::is_base_of_v<winrt::Windows::Foundation::IUnknown, decltype(value)>)
                {
                    if (self->obj.HasKey(_key))
                    {
                        Py_RETURN_NONE;
                    }
                }

                PyErr_SetObject(PyExc_KeyError, key);
                return nullptr;
            }

            return py::convert(value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataPackagePropertySetView[] = {
        { "first", reinterpret_cast<PyCFunction>(DataPackagePropertySetView_First), METH_VARARGS, nullptr },
        { "has_key", reinterpret_cast<PyCFunction>(DataPackagePropertySetView_HasKey), METH_VARARGS, nullptr },
        { "lookup", reinterpret_cast<PyCFunction>(DataPackagePropertySetView_Lookup), METH_VARARGS, nullptr },
        { "split", reinterpret_cast<PyCFunction>(DataPackagePropertySetView_Split), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DataPackagePropertySetView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DataPackagePropertySetView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataPackagePropertySetView[] = {
        { "application_listing_uri", reinterpret_cast<getter>(DataPackagePropertySetView_get_ApplicationListingUri), nullptr, nullptr, nullptr },
        { "application_name", reinterpret_cast<getter>(DataPackagePropertySetView_get_ApplicationName), nullptr, nullptr, nullptr },
        { "description", reinterpret_cast<getter>(DataPackagePropertySetView_get_Description), nullptr, nullptr, nullptr },
        { "file_types", reinterpret_cast<getter>(DataPackagePropertySetView_get_FileTypes), nullptr, nullptr, nullptr },
        { "thumbnail", reinterpret_cast<getter>(DataPackagePropertySetView_get_Thumbnail), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(DataPackagePropertySetView_get_Title), nullptr, nullptr, nullptr },
        { "content_source_application_link", reinterpret_cast<getter>(DataPackagePropertySetView_get_ContentSourceApplicationLink), nullptr, nullptr, nullptr },
        { "content_source_web_link", reinterpret_cast<getter>(DataPackagePropertySetView_get_ContentSourceWebLink), nullptr, nullptr, nullptr },
        { "logo_background_color", reinterpret_cast<getter>(DataPackagePropertySetView_get_LogoBackgroundColor), nullptr, nullptr, nullptr },
        { "package_family_name", reinterpret_cast<getter>(DataPackagePropertySetView_get_PackageFamilyName), nullptr, nullptr, nullptr },
        { "square30x30_logo", reinterpret_cast<getter>(DataPackagePropertySetView_get_Square30x30Logo), nullptr, nullptr, nullptr },
        { "enterprise_id", reinterpret_cast<getter>(DataPackagePropertySetView_get_EnterpriseId), nullptr, nullptr, nullptr },
        { "content_source_user_activity_json", reinterpret_cast<getter>(DataPackagePropertySetView_get_ContentSourceUserActivityJson), nullptr, nullptr, nullptr },
        { "is_from_roaming_clipboard", reinterpret_cast<getter>(DataPackagePropertySetView_get_IsFromRoamingClipboard), nullptr, nullptr, nullptr },
        { "size", reinterpret_cast<getter>(DataPackagePropertySetView_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DataPackagePropertySetView[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DataPackagePropertySetView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DataPackagePropertySetView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DataPackagePropertySetView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DataPackagePropertySetView) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_DataPackagePropertySetView) },
        { Py_sq_contains, reinterpret_cast<void*>(_map_contains_DataPackagePropertySetView) },
        { Py_mp_length, reinterpret_cast<void*>(_map_length_DataPackagePropertySetView) },
        { Py_mp_subscript, reinterpret_cast<void*>(_map_subscript_DataPackagePropertySetView) },
        { },
    };

    static PyType_Spec type_spec_DataPackagePropertySetView = {
        "winrt._winrt_windows_applicationmodel_datatransfer.DataPackagePropertySetView",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataPackagePropertySetView};

    // ----- DataPackageView class --------------------

    static PyObject* _new_DataPackageView(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::DataPackageView>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::DataPackageView>::type_name);
        return nullptr;
    }

    static void _dealloc_DataPackageView(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DataPackageView_Contains(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackageView", L"Contains", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.Contains(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackageView_GetApplicationLinkAsync(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackageView", L"GetApplicationLinkAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetApplicationLinkAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackageView_GetBitmapAsync(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackageView", L"GetBitmapAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetBitmapAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackageView_GetDataAsync(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackageView", L"GetDataAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetDataAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackageView_GetHtmlFormatAsync(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackageView", L"GetHtmlFormatAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetHtmlFormatAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackageView_GetResourceMapAsync(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackageView", L"GetResourceMapAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetResourceMapAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackageView_GetRtfAsync(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackageView", L"GetRtfAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetRtfAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackageView_GetStorageItemsAsync(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackageView", L"GetStorageItemsAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetStorageItemsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackageView_GetTextAsync(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackageView", L"GetTextAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetTextAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackageView", L"GetTextAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetTextAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackageView_GetUriAsync(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackageView", L"GetUriAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetUriAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackageView_GetWebLinkAsync(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackageView", L"GetWebLinkAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetWebLinkAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackageView_ReportOperationCompleted(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackageView", L"ReportOperationCompleted", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation>(args, 0);

                self->obj.ReportOperationCompleted(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackageView_RequestAccessAsync(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackageView", L"RequestAccessAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.RequestAccessAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackageView", L"RequestAccessAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RequestAccessAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackageView_SetAcceptedFormatId(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackageView", L"SetAcceptedFormatId", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.SetAcceptedFormatId(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackageView_UnlockAndAssumeEnterpriseIdentity(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataPackageView", L"UnlockAndAssumeEnterpriseIdentity", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.UnlockAndAssumeEnterpriseIdentity());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackageView_get_AvailableFormats(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackageView", L"AvailableFormats"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AvailableFormats());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackageView_get_Properties(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackageView", L"Properties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackageView_get_RequestedOperation(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataPackageView", L"RequestedOperation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequestedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DataPackageView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::DataTransfer::DataPackageView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DataPackageView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::DataPackageView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataPackageView[] = {
        { "contains", reinterpret_cast<PyCFunction>(DataPackageView_Contains), METH_VARARGS, nullptr },
        { "get_application_link_async", reinterpret_cast<PyCFunction>(DataPackageView_GetApplicationLinkAsync), METH_VARARGS, nullptr },
        { "get_bitmap_async", reinterpret_cast<PyCFunction>(DataPackageView_GetBitmapAsync), METH_VARARGS, nullptr },
        { "get_data_async", reinterpret_cast<PyCFunction>(DataPackageView_GetDataAsync), METH_VARARGS, nullptr },
        { "get_html_format_async", reinterpret_cast<PyCFunction>(DataPackageView_GetHtmlFormatAsync), METH_VARARGS, nullptr },
        { "get_resource_map_async", reinterpret_cast<PyCFunction>(DataPackageView_GetResourceMapAsync), METH_VARARGS, nullptr },
        { "get_rtf_async", reinterpret_cast<PyCFunction>(DataPackageView_GetRtfAsync), METH_VARARGS, nullptr },
        { "get_storage_items_async", reinterpret_cast<PyCFunction>(DataPackageView_GetStorageItemsAsync), METH_VARARGS, nullptr },
        { "get_text_async", reinterpret_cast<PyCFunction>(DataPackageView_GetTextAsync), METH_VARARGS, nullptr },
        { "get_uri_async", reinterpret_cast<PyCFunction>(DataPackageView_GetUriAsync), METH_VARARGS, nullptr },
        { "get_web_link_async", reinterpret_cast<PyCFunction>(DataPackageView_GetWebLinkAsync), METH_VARARGS, nullptr },
        { "report_operation_completed", reinterpret_cast<PyCFunction>(DataPackageView_ReportOperationCompleted), METH_VARARGS, nullptr },
        { "request_access_async", reinterpret_cast<PyCFunction>(DataPackageView_RequestAccessAsync), METH_VARARGS, nullptr },
        { "set_accepted_format_id", reinterpret_cast<PyCFunction>(DataPackageView_SetAcceptedFormatId), METH_VARARGS, nullptr },
        { "unlock_and_assume_enterprise_identity", reinterpret_cast<PyCFunction>(DataPackageView_UnlockAndAssumeEnterpriseIdentity), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DataPackageView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DataPackageView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataPackageView[] = {
        { "available_formats", reinterpret_cast<getter>(DataPackageView_get_AvailableFormats), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DataPackageView_get_Properties), nullptr, nullptr, nullptr },
        { "requested_operation", reinterpret_cast<getter>(DataPackageView_get_RequestedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DataPackageView[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DataPackageView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DataPackageView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DataPackageView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DataPackageView) },
        { },
    };

    static PyType_Spec type_spec_DataPackageView = {
        "winrt._winrt_windows_applicationmodel_datatransfer.DataPackageView",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataPackageView};

    // ----- DataProviderDeferral class --------------------

    static PyObject* _new_DataProviderDeferral(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::DataProviderDeferral>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::DataProviderDeferral>::type_name);
        return nullptr;
    }

    static void _dealloc_DataProviderDeferral(py::wrapper::Windows::ApplicationModel::DataTransfer::DataProviderDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DataProviderDeferral_Complete(py::wrapper::Windows::ApplicationModel::DataTransfer::DataProviderDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataProviderDeferral", L"Complete", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_DataProviderDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::DataTransfer::DataProviderDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DataProviderDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::DataProviderDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataProviderDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(DataProviderDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DataProviderDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DataProviderDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataProviderDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_DataProviderDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DataProviderDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DataProviderDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DataProviderDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DataProviderDeferral) },
        { },
    };

    static PyType_Spec type_spec_DataProviderDeferral = {
        "winrt._winrt_windows_applicationmodel_datatransfer.DataProviderDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::DataProviderDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataProviderDeferral};

    // ----- DataProviderRequest class --------------------

    static PyObject* _new_DataProviderRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::DataProviderRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::DataProviderRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_DataProviderRequest(py::wrapper::Windows::ApplicationModel::DataTransfer::DataProviderRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DataProviderRequest_GetDeferral(py::wrapper::Windows::ApplicationModel::DataTransfer::DataProviderRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataProviderRequest", L"GetDeferral", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataProviderRequest_SetData(py::wrapper::Windows::ApplicationModel::DataTransfer::DataProviderRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataProviderRequest", L"SetData", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                self->obj.SetData(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataProviderRequest_get_Deadline(py::wrapper::Windows::ApplicationModel::DataTransfer::DataProviderRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataProviderRequest", L"Deadline"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Deadline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataProviderRequest_get_FormatId(py::wrapper::Windows::ApplicationModel::DataTransfer::DataProviderRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataProviderRequest", L"FormatId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FormatId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DataProviderRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::DataTransfer::DataProviderRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DataProviderRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::DataProviderRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataProviderRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(DataProviderRequest_GetDeferral), METH_VARARGS, nullptr },
        { "set_data", reinterpret_cast<PyCFunction>(DataProviderRequest_SetData), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DataProviderRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DataProviderRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataProviderRequest[] = {
        { "deadline", reinterpret_cast<getter>(DataProviderRequest_get_Deadline), nullptr, nullptr, nullptr },
        { "format_id", reinterpret_cast<getter>(DataProviderRequest_get_FormatId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DataProviderRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DataProviderRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DataProviderRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DataProviderRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DataProviderRequest) },
        { },
    };

    static PyType_Spec type_spec_DataProviderRequest = {
        "winrt._winrt_windows_applicationmodel_datatransfer.DataProviderRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::DataProviderRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataProviderRequest};

    // ----- DataRequest class --------------------

    static PyObject* _new_DataRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::DataRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::DataRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_DataRequest(py::wrapper::Windows::ApplicationModel::DataTransfer::DataRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DataRequest_FailWithDisplayText(py::wrapper::Windows::ApplicationModel::DataTransfer::DataRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataRequest", L"FailWithDisplayText", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.FailWithDisplayText(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataRequest_GetDeferral(py::wrapper::Windows::ApplicationModel::DataTransfer::DataRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataRequest", L"GetDeferral", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataRequest_get_Data(py::wrapper::Windows::ApplicationModel::DataTransfer::DataRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataRequest", L"Data"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataRequest_put_Data(py::wrapper::Windows::ApplicationModel::DataTransfer::DataRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataRequest", L"Data"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::DataTransfer::DataPackage>(arg);

            self->obj.Data(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataRequest_get_Deadline(py::wrapper::Windows::ApplicationModel::DataTransfer::DataRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataRequest", L"Deadline"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Deadline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DataRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::DataTransfer::DataRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DataRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::DataRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataRequest[] = {
        { "fail_with_display_text", reinterpret_cast<PyCFunction>(DataRequest_FailWithDisplayText), METH_VARARGS, nullptr },
        { "get_deferral", reinterpret_cast<PyCFunction>(DataRequest_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DataRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DataRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataRequest[] = {
        { "data", reinterpret_cast<getter>(DataRequest_get_Data), reinterpret_cast<setter>(DataRequest_put_Data), nullptr, nullptr },
        { "deadline", reinterpret_cast<getter>(DataRequest_get_Deadline), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DataRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DataRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DataRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DataRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DataRequest) },
        { },
    };

    static PyType_Spec type_spec_DataRequest = {
        "winrt._winrt_windows_applicationmodel_datatransfer.DataRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::DataRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataRequest};

    // ----- DataRequestDeferral class --------------------

    static PyObject* _new_DataRequestDeferral(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::DataRequestDeferral>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::DataRequestDeferral>::type_name);
        return nullptr;
    }

    static void _dealloc_DataRequestDeferral(py::wrapper::Windows::ApplicationModel::DataTransfer::DataRequestDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DataRequestDeferral_Complete(py::wrapper::Windows::ApplicationModel::DataTransfer::DataRequestDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataRequestDeferral", L"Complete", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_DataRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::DataTransfer::DataRequestDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DataRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::DataRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataRequestDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(DataRequestDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DataRequestDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DataRequestDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataRequestDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_DataRequestDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DataRequestDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DataRequestDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DataRequestDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DataRequestDeferral) },
        { },
    };

    static PyType_Spec type_spec_DataRequestDeferral = {
        "winrt._winrt_windows_applicationmodel_datatransfer.DataRequestDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::DataRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataRequestDeferral};

    // ----- DataRequestedEventArgs class --------------------

    static PyObject* _new_DataRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::DataRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::DataRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_DataRequestedEventArgs(py::wrapper::Windows::ApplicationModel::DataTransfer::DataRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DataRequestedEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::DataTransfer::DataRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.DataRequestedEventArgs", L"Request"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DataRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::DataTransfer::DataRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DataRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::DataRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_DataRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DataRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataRequestedEventArgs[] = {
        { "request", reinterpret_cast<getter>(DataRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DataRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DataRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DataRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DataRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DataRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DataRequestedEventArgs = {
        "winrt._winrt_windows_applicationmodel_datatransfer.DataRequestedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::DataRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataRequestedEventArgs};

    // ----- DataTransferManager class --------------------

    static PyObject* _new_DataTransferManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::DataTransferManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::DataTransferManager>::type_name);
        return nullptr;
    }

    static void _dealloc_DataTransferManager(py::wrapper::Windows::ApplicationModel::DataTransfer::DataTransferManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DataTransferManager_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataTransferManager", L"GetForCurrentView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::ApplicationModel::DataTransfer::DataTransferManager::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataTransferManager_IsSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataTransferManager", L"IsSupported", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::ApplicationModel::DataTransfer::DataTransferManager::IsSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataTransferManager_ShowShareUI(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataTransferManager", L"ShowShareUI", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::Windows::ApplicationModel::DataTransfer::DataTransferManager::ShowShareUI();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.DataTransferManager", L"ShowShareUI", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::DataTransfer::ShareUIOptions>(args, 0);

                winrt::Windows::ApplicationModel::DataTransfer::DataTransferManager::ShowShareUI(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataTransferManager_add_DataRequested(py::wrapper::Windows::ApplicationModel::DataTransfer::DataTransferManager* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.DataTransfer.DataTransferManager", L"DataRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::DataTransfer::DataTransferManager, winrt::Windows::ApplicationModel::DataTransfer::DataRequestedEventArgs>>(arg);

            return py::convert(self->obj.DataRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataTransferManager_remove_DataRequested(py::wrapper::Windows::ApplicationModel::DataTransfer::DataTransferManager* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.DataTransfer.DataTransferManager", L"DataRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DataRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataTransferManager_add_TargetApplicationChosen(py::wrapper::Windows::ApplicationModel::DataTransfer::DataTransferManager* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.DataTransfer.DataTransferManager", L"TargetApplicationChosen"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::DataTransfer::DataTransferManager, winrt::Windows::ApplicationModel::DataTransfer::TargetApplicationChosenEventArgs>>(arg);

            return py::convert(self->obj.TargetApplicationChosen(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataTransferManager_remove_TargetApplicationChosen(py::wrapper::Windows::ApplicationModel::DataTransfer::DataTransferManager* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.DataTransfer.DataTransferManager", L"TargetApplicationChosen"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TargetApplicationChosen(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataTransferManager_add_ShareProvidersRequested(py::wrapper::Windows::ApplicationModel::DataTransfer::DataTransferManager* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.DataTransfer.DataTransferManager", L"ShareProvidersRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::DataTransfer::DataTransferManager, winrt::Windows::ApplicationModel::DataTransfer::ShareProvidersRequestedEventArgs>>(arg);

            return py::convert(self->obj.ShareProvidersRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataTransferManager_remove_ShareProvidersRequested(py::wrapper::Windows::ApplicationModel::DataTransfer::DataTransferManager* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.DataTransfer.DataTransferManager", L"ShareProvidersRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ShareProvidersRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DataTransferManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::DataTransfer::DataTransferManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DataTransferManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::DataTransferManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataTransferManager[] = {
        { "add_data_requested", reinterpret_cast<PyCFunction>(DataTransferManager_add_DataRequested), METH_O, nullptr },
        { "remove_data_requested", reinterpret_cast<PyCFunction>(DataTransferManager_remove_DataRequested), METH_O, nullptr },
        { "add_target_application_chosen", reinterpret_cast<PyCFunction>(DataTransferManager_add_TargetApplicationChosen), METH_O, nullptr },
        { "remove_target_application_chosen", reinterpret_cast<PyCFunction>(DataTransferManager_remove_TargetApplicationChosen), METH_O, nullptr },
        { "add_share_providers_requested", reinterpret_cast<PyCFunction>(DataTransferManager_add_ShareProvidersRequested), METH_O, nullptr },
        { "remove_share_providers_requested", reinterpret_cast<PyCFunction>(DataTransferManager_remove_ShareProvidersRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_DataTransferManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DataTransferManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataTransferManager[] = {
        { }
    };

    static PyType_Slot _type_slots_DataTransferManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DataTransferManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DataTransferManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DataTransferManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DataTransferManager) },
        { },
    };

    static PyType_Spec type_spec_DataTransferManager = {
        "winrt._winrt_windows_applicationmodel_datatransfer.DataTransferManager",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::DataTransferManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataTransferManager};

    static PyGetSetDef getset_DataTransferManager_Static[] = {
        { }
    };

    static PyMethodDef methods_DataTransferManager_Static[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(DataTransferManager_GetForCurrentView), METH_VARARGS, nullptr },
        { "is_supported", reinterpret_cast<PyCFunction>(DataTransferManager_IsSupported), METH_VARARGS, nullptr },
        { "show_share_u_i", reinterpret_cast<PyCFunction>(DataTransferManager_ShowShareUI), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_DataTransferManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DataTransferManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DataTransferManager_Static) },
        { }
    };

    static PyType_Spec type_spec_DataTransferManager_Static =
    {
        "winrt._winrt_windows_applicationmodel_datatransfer.DataTransferManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DataTransferManager_Static
    };

    // ----- HtmlFormatHelper class --------------------

    static PyObject* _new_HtmlFormatHelper(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::HtmlFormatHelper>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::HtmlFormatHelper>::type_name);
        return nullptr;
    }

    static PyObject* HtmlFormatHelper_CreateHtmlFormat(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.HtmlFormatHelper", L"CreateHtmlFormat", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::DataTransfer::HtmlFormatHelper::CreateHtmlFormat(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HtmlFormatHelper_GetStaticFragment(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.HtmlFormatHelper", L"GetStaticFragment", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::DataTransfer::HtmlFormatHelper::GetStaticFragment(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_HtmlFormatHelper[] = {
        { }
    };

    static PyGetSetDef _getset_HtmlFormatHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_HtmlFormatHelper[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HtmlFormatHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HtmlFormatHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HtmlFormatHelper) },
        { },
    };

    static PyType_Spec type_spec_HtmlFormatHelper = {
        "winrt._winrt_windows_applicationmodel_datatransfer.HtmlFormatHelper",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HtmlFormatHelper};

    static PyGetSetDef getset_HtmlFormatHelper_Static[] = {
        { }
    };

    static PyMethodDef methods_HtmlFormatHelper_Static[] = {
        { "create_html_format", reinterpret_cast<PyCFunction>(HtmlFormatHelper_CreateHtmlFormat), METH_VARARGS, nullptr },
        { "get_static_fragment", reinterpret_cast<PyCFunction>(HtmlFormatHelper_GetStaticFragment), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_HtmlFormatHelper_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HtmlFormatHelper_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HtmlFormatHelper_Static) },
        { }
    };

    static PyType_Spec type_spec_HtmlFormatHelper_Static =
    {
        "winrt._winrt_windows_applicationmodel_datatransfer.HtmlFormatHelper_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HtmlFormatHelper_Static
    };

    // ----- OperationCompletedEventArgs class --------------------

    static PyObject* _new_OperationCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::OperationCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::OperationCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_OperationCompletedEventArgs(py::wrapper::Windows::ApplicationModel::DataTransfer::OperationCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* OperationCompletedEventArgs_get_Operation(py::wrapper::Windows::ApplicationModel::DataTransfer::OperationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.OperationCompletedEventArgs", L"Operation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Operation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OperationCompletedEventArgs_get_AcceptedFormatId(py::wrapper::Windows::ApplicationModel::DataTransfer::OperationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.OperationCompletedEventArgs", L"AcceptedFormatId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AcceptedFormatId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_OperationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::DataTransfer::OperationCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_OperationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::OperationCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_OperationCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_OperationCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_OperationCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_OperationCompletedEventArgs[] = {
        { "operation", reinterpret_cast<getter>(OperationCompletedEventArgs_get_Operation), nullptr, nullptr, nullptr },
        { "accepted_format_id", reinterpret_cast<getter>(OperationCompletedEventArgs_get_AcceptedFormatId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_OperationCompletedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_OperationCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_OperationCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_OperationCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_OperationCompletedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_OperationCompletedEventArgs = {
        "winrt._winrt_windows_applicationmodel_datatransfer.OperationCompletedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::OperationCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_OperationCompletedEventArgs};

    // ----- ShareCompletedEventArgs class --------------------

    static PyObject* _new_ShareCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::ShareCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::ShareCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ShareCompletedEventArgs(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ShareCompletedEventArgs_get_ShareTarget(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.ShareCompletedEventArgs", L"ShareTarget"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ShareTarget());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ShareCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::DataTransfer::ShareCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ShareCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::ShareCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ShareCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_ShareCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ShareCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ShareCompletedEventArgs[] = {
        { "share_target", reinterpret_cast<getter>(ShareCompletedEventArgs_get_ShareTarget), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ShareCompletedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ShareCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ShareCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ShareCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ShareCompletedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ShareCompletedEventArgs = {
        "winrt._winrt_windows_applicationmodel_datatransfer.ShareCompletedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ShareCompletedEventArgs};

    // ----- ShareProvider class --------------------

    static PyObject* _new_ShareProvider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::RandomAccessStreamReference>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Color>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::DataTransfer::ShareProviderHandler>(args, 3);

                winrt::Windows::ApplicationModel::DataTransfer::ShareProvider instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ShareProvider(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ShareProvider_get_Tag(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.ShareProvider", L"Tag"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ShareProvider_put_Tag(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProvider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.ShareProvider", L"Tag"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ShareProvider_get_BackgroundColor(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.ShareProvider", L"BackgroundColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ShareProvider_get_DisplayIcon(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.ShareProvider", L"DisplayIcon"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayIcon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ShareProvider_get_Title(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.ShareProvider", L"Title"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ShareProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::DataTransfer::ShareProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ShareProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::ShareProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ShareProvider[] = {
        { "_assign_array_", _assign_array_ShareProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ShareProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ShareProvider[] = {
        { "tag", reinterpret_cast<getter>(ShareProvider_get_Tag), reinterpret_cast<setter>(ShareProvider_put_Tag), nullptr, nullptr },
        { "background_color", reinterpret_cast<getter>(ShareProvider_get_BackgroundColor), nullptr, nullptr, nullptr },
        { "display_icon", reinterpret_cast<getter>(ShareProvider_get_DisplayIcon), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(ShareProvider_get_Title), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ShareProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ShareProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ShareProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ShareProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ShareProvider) },
        { },
    };

    static PyType_Spec type_spec_ShareProvider = {
        "winrt._winrt_windows_applicationmodel_datatransfer.ShareProvider",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ShareProvider};

    // ----- ShareProviderOperation class --------------------

    static PyObject* _new_ShareProviderOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::ShareProviderOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::ShareProviderOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_ShareProviderOperation(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProviderOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ShareProviderOperation_ReportCompleted(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProviderOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.ShareProviderOperation", L"ReportCompleted", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ReportCompleted();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ShareProviderOperation_get_Data(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProviderOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.ShareProviderOperation", L"Data"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ShareProviderOperation_get_Provider(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProviderOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.ShareProviderOperation", L"Provider"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Provider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ShareProviderOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::DataTransfer::ShareProviderOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ShareProviderOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::ShareProviderOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ShareProviderOperation[] = {
        { "report_completed", reinterpret_cast<PyCFunction>(ShareProviderOperation_ReportCompleted), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ShareProviderOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ShareProviderOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ShareProviderOperation[] = {
        { "data", reinterpret_cast<getter>(ShareProviderOperation_get_Data), nullptr, nullptr, nullptr },
        { "provider", reinterpret_cast<getter>(ShareProviderOperation_get_Provider), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ShareProviderOperation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ShareProviderOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ShareProviderOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ShareProviderOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ShareProviderOperation) },
        { },
    };

    static PyType_Spec type_spec_ShareProviderOperation = {
        "winrt._winrt_windows_applicationmodel_datatransfer.ShareProviderOperation",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProviderOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ShareProviderOperation};

    // ----- ShareProvidersRequestedEventArgs class --------------------

    static PyObject* _new_ShareProvidersRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::ShareProvidersRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::ShareProvidersRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ShareProvidersRequestedEventArgs(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProvidersRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ShareProvidersRequestedEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProvidersRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.ShareProvidersRequestedEventArgs", L"GetDeferral", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ShareProvidersRequestedEventArgs_get_Data(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProvidersRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.ShareProvidersRequestedEventArgs", L"Data"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ShareProvidersRequestedEventArgs_get_Providers(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProvidersRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.ShareProvidersRequestedEventArgs", L"Providers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Providers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ShareProvidersRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::DataTransfer::ShareProvidersRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ShareProvidersRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::ShareProvidersRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ShareProvidersRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(ShareProvidersRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ShareProvidersRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ShareProvidersRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ShareProvidersRequestedEventArgs[] = {
        { "data", reinterpret_cast<getter>(ShareProvidersRequestedEventArgs_get_Data), nullptr, nullptr, nullptr },
        { "providers", reinterpret_cast<getter>(ShareProvidersRequestedEventArgs_get_Providers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ShareProvidersRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ShareProvidersRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ShareProvidersRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ShareProvidersRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ShareProvidersRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ShareProvidersRequestedEventArgs = {
        "winrt._winrt_windows_applicationmodel_datatransfer.ShareProvidersRequestedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProvidersRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ShareProvidersRequestedEventArgs};

    // ----- ShareTargetInfo class --------------------

    static PyObject* _new_ShareTargetInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::ShareTargetInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::ShareTargetInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_ShareTargetInfo(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareTargetInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ShareTargetInfo_get_AppUserModelId(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareTargetInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.ShareTargetInfo", L"AppUserModelId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppUserModelId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ShareTargetInfo_get_ShareProvider(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareTargetInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.ShareTargetInfo", L"ShareProvider"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ShareProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ShareTargetInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::DataTransfer::ShareTargetInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ShareTargetInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::ShareTargetInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ShareTargetInfo[] = {
        { "_assign_array_", _assign_array_ShareTargetInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ShareTargetInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ShareTargetInfo[] = {
        { "app_user_model_id", reinterpret_cast<getter>(ShareTargetInfo_get_AppUserModelId), nullptr, nullptr, nullptr },
        { "share_provider", reinterpret_cast<getter>(ShareTargetInfo_get_ShareProvider), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ShareTargetInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ShareTargetInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ShareTargetInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ShareTargetInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ShareTargetInfo) },
        { },
    };

    static PyType_Spec type_spec_ShareTargetInfo = {
        "winrt._winrt_windows_applicationmodel_datatransfer.ShareTargetInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareTargetInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ShareTargetInfo};

    // ----- ShareUIOptions class --------------------

    static PyObject* _new_ShareUIOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::DataTransfer::ShareUIOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ShareUIOptions(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareUIOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ShareUIOptions_get_Theme(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareUIOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.ShareUIOptions", L"Theme"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Theme());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ShareUIOptions_put_Theme(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareUIOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.ShareUIOptions", L"Theme"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::DataTransfer::ShareUITheme>(arg);

            self->obj.Theme(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ShareUIOptions_get_SelectionRect(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareUIOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.ShareUIOptions", L"SelectionRect"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectionRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ShareUIOptions_put_SelectionRect(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareUIOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.ShareUIOptions", L"SelectionRect"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Rect>>(arg);

            self->obj.SelectionRect(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ShareUIOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::DataTransfer::ShareUIOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ShareUIOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::ShareUIOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ShareUIOptions[] = {
        { "_assign_array_", _assign_array_ShareUIOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ShareUIOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ShareUIOptions[] = {
        { "theme", reinterpret_cast<getter>(ShareUIOptions_get_Theme), reinterpret_cast<setter>(ShareUIOptions_put_Theme), nullptr, nullptr },
        { "selection_rect", reinterpret_cast<getter>(ShareUIOptions_get_SelectionRect), reinterpret_cast<setter>(ShareUIOptions_put_SelectionRect), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ShareUIOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ShareUIOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ShareUIOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ShareUIOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ShareUIOptions) },
        { },
    };

    static PyType_Spec type_spec_ShareUIOptions = {
        "winrt._winrt_windows_applicationmodel_datatransfer.ShareUIOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareUIOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ShareUIOptions};

    // ----- SharedStorageAccessManager class --------------------

    static PyObject* _new_SharedStorageAccessManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::SharedStorageAccessManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::SharedStorageAccessManager>::type_name);
        return nullptr;
    }

    static PyObject* SharedStorageAccessManager_AddFile(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.SharedStorageAccessManager", L"AddFile", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::DataTransfer::SharedStorageAccessManager::AddFile(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SharedStorageAccessManager_RedeemTokenForFileAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.SharedStorageAccessManager", L"RedeemTokenForFileAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::DataTransfer::SharedStorageAccessManager::RedeemTokenForFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SharedStorageAccessManager_RemoveFile(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.DataTransfer.SharedStorageAccessManager", L"RemoveFile", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::DataTransfer::SharedStorageAccessManager::RemoveFile(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_SharedStorageAccessManager[] = {
        { }
    };

    static PyGetSetDef _getset_SharedStorageAccessManager[] = {
        { }
    };

    static PyType_Slot _type_slots_SharedStorageAccessManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SharedStorageAccessManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SharedStorageAccessManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SharedStorageAccessManager) },
        { },
    };

    static PyType_Spec type_spec_SharedStorageAccessManager = {
        "winrt._winrt_windows_applicationmodel_datatransfer.SharedStorageAccessManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SharedStorageAccessManager};

    static PyGetSetDef getset_SharedStorageAccessManager_Static[] = {
        { }
    };

    static PyMethodDef methods_SharedStorageAccessManager_Static[] = {
        { "add_file", reinterpret_cast<PyCFunction>(SharedStorageAccessManager_AddFile), METH_VARARGS, nullptr },
        { "redeem_token_for_file_async", reinterpret_cast<PyCFunction>(SharedStorageAccessManager_RedeemTokenForFileAsync), METH_VARARGS, nullptr },
        { "remove_file", reinterpret_cast<PyCFunction>(SharedStorageAccessManager_RemoveFile), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_SharedStorageAccessManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SharedStorageAccessManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SharedStorageAccessManager_Static) },
        { }
    };

    static PyType_Spec type_spec_SharedStorageAccessManager_Static =
    {
        "winrt._winrt_windows_applicationmodel_datatransfer.SharedStorageAccessManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SharedStorageAccessManager_Static
    };

    // ----- StandardDataFormats class --------------------

    static PyObject* _new_StandardDataFormats(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::StandardDataFormats>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::StandardDataFormats>::type_name);
        return nullptr;
    }

    static PyObject* StandardDataFormats_get_Bitmap(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.StandardDataFormats", L"Bitmap"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::DataTransfer::StandardDataFormats::Bitmap());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StandardDataFormats_get_Html(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.StandardDataFormats", L"Html"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::DataTransfer::StandardDataFormats::Html());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StandardDataFormats_get_Rtf(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.StandardDataFormats", L"Rtf"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::DataTransfer::StandardDataFormats::Rtf());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StandardDataFormats_get_StorageItems(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.StandardDataFormats", L"StorageItems"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::DataTransfer::StandardDataFormats::StorageItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StandardDataFormats_get_Text(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.StandardDataFormats", L"Text"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::DataTransfer::StandardDataFormats::Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StandardDataFormats_get_Uri(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.StandardDataFormats", L"Uri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::DataTransfer::StandardDataFormats::Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StandardDataFormats_get_ApplicationLink(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.StandardDataFormats", L"ApplicationLink"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::DataTransfer::StandardDataFormats::ApplicationLink());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StandardDataFormats_get_WebLink(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.StandardDataFormats", L"WebLink"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::DataTransfer::StandardDataFormats::WebLink());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StandardDataFormats_get_UserActivityJsonArray(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.StandardDataFormats", L"UserActivityJsonArray"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::DataTransfer::StandardDataFormats::UserActivityJsonArray());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StandardDataFormats[] = {
        { }
    };

    static PyGetSetDef _getset_StandardDataFormats[] = {
        { }
    };

    static PyType_Slot _type_slots_StandardDataFormats[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StandardDataFormats) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StandardDataFormats) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StandardDataFormats) },
        { },
    };

    static PyType_Spec type_spec_StandardDataFormats = {
        "winrt._winrt_windows_applicationmodel_datatransfer.StandardDataFormats",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StandardDataFormats};

    static PyGetSetDef getset_StandardDataFormats_Static[] = {
        { "bitmap", reinterpret_cast<getter>(StandardDataFormats_get_Bitmap), nullptr, nullptr, nullptr },
        { "html", reinterpret_cast<getter>(StandardDataFormats_get_Html), nullptr, nullptr, nullptr },
        { "rtf", reinterpret_cast<getter>(StandardDataFormats_get_Rtf), nullptr, nullptr, nullptr },
        { "storage_items", reinterpret_cast<getter>(StandardDataFormats_get_StorageItems), nullptr, nullptr, nullptr },
        { "text", reinterpret_cast<getter>(StandardDataFormats_get_Text), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(StandardDataFormats_get_Uri), nullptr, nullptr, nullptr },
        { "application_link", reinterpret_cast<getter>(StandardDataFormats_get_ApplicationLink), nullptr, nullptr, nullptr },
        { "web_link", reinterpret_cast<getter>(StandardDataFormats_get_WebLink), nullptr, nullptr, nullptr },
        { "user_activity_json_array", reinterpret_cast<getter>(StandardDataFormats_get_UserActivityJsonArray), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_StandardDataFormats_Static[] = {
        { }
    };

    static PyType_Slot type_slots_StandardDataFormats_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_StandardDataFormats_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_StandardDataFormats_Static) },
        { }
    };

    static PyType_Spec type_spec_StandardDataFormats_Static =
    {
        "winrt._winrt_windows_applicationmodel_datatransfer.StandardDataFormats_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_StandardDataFormats_Static
    };

    // ----- TargetApplicationChosenEventArgs class --------------------

    static PyObject* _new_TargetApplicationChosenEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::TargetApplicationChosenEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::DataTransfer::TargetApplicationChosenEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_TargetApplicationChosenEventArgs(py::wrapper::Windows::ApplicationModel::DataTransfer::TargetApplicationChosenEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TargetApplicationChosenEventArgs_get_ApplicationName(py::wrapper::Windows::ApplicationModel::DataTransfer::TargetApplicationChosenEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DataTransfer.TargetApplicationChosenEventArgs", L"ApplicationName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ApplicationName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TargetApplicationChosenEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::DataTransfer::TargetApplicationChosenEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TargetApplicationChosenEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::TargetApplicationChosenEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TargetApplicationChosenEventArgs[] = {
        { "_assign_array_", _assign_array_TargetApplicationChosenEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TargetApplicationChosenEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TargetApplicationChosenEventArgs[] = {
        { "application_name", reinterpret_cast<getter>(TargetApplicationChosenEventArgs_get_ApplicationName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TargetApplicationChosenEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TargetApplicationChosenEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TargetApplicationChosenEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TargetApplicationChosenEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TargetApplicationChosenEventArgs) },
        { },
    };

    static PyType_Spec type_spec_TargetApplicationChosenEventArgs = {
        "winrt._winrt_windows_applicationmodel_datatransfer.TargetApplicationChosenEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::TargetApplicationChosenEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TargetApplicationChosenEventArgs};

    // ----- Windows.ApplicationModel.DataTransfer Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.ApplicationModel.DataTransfer");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_applicationmodel_datatransfer",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::ApplicationModel::DataTransfer

PyMODINIT_FUNC PyInit__winrt_windows_applicationmodel_datatransfer(void) noexcept
{
    using namespace py::cpp::Windows::ApplicationModel::DataTransfer;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Clipboard_Static{PyType_FromSpec(&type_spec_Clipboard_Static)};
    if (!type_Clipboard_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Clipboard, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Clipboard_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ClipboardContentOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ClipboardHistoryChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ClipboardHistoryItem, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ClipboardHistoryItemsResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DataPackage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DataPackagePropertySet, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DataPackagePropertySetView, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DataPackageView, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DataProviderDeferral, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DataProviderRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DataRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DataRequestDeferral, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DataRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_DataTransferManager_Static{PyType_FromSpec(&type_spec_DataTransferManager_Static)};
    if (!type_DataTransferManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DataTransferManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DataTransferManager_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_HtmlFormatHelper_Static{PyType_FromSpec(&type_spec_HtmlFormatHelper_Static)};
    if (!type_HtmlFormatHelper_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HtmlFormatHelper, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HtmlFormatHelper_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_OperationCompletedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ShareCompletedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ShareProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ShareProviderOperation, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ShareProvidersRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ShareTargetInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ShareUIOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SharedStorageAccessManager_Static{PyType_FromSpec(&type_spec_SharedStorageAccessManager_Static)};
    if (!type_SharedStorageAccessManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SharedStorageAccessManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SharedStorageAccessManager_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_StandardDataFormats_Static{PyType_FromSpec(&type_spec_StandardDataFormats_Static)};
    if (!type_StandardDataFormats_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StandardDataFormats, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_StandardDataFormats_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TargetApplicationChosenEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
