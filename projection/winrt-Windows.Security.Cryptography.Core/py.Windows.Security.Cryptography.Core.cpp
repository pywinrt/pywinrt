// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Security.Cryptography.Core.h"

namespace py::cpp::Windows::Security::Cryptography::Core
{
    // ----- AsymmetricAlgorithmNames class --------------------

    static PyObject* _new_AsymmetricAlgorithmNames(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames>::type_name);
        return nullptr;
    }

    static PyObject* AsymmetricAlgorithmNames_get_EcdsaP521Sha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"EcdsaP521Sha512"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::EcdsaP521Sha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_DsaSha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"DsaSha1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::DsaSha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_DsaSha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"DsaSha256"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::DsaSha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_EcdsaP256Sha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"EcdsaP256Sha256"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::EcdsaP256Sha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_EcdsaP384Sha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"EcdsaP384Sha384"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::EcdsaP384Sha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaSignPkcs1Sha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"RsaSignPkcs1Sha256"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaSignPkcs1Sha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaOaepSha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"RsaOaepSha1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaOaepSha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaOaepSha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"RsaOaepSha256"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaOaepSha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaOaepSha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"RsaOaepSha384"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaOaepSha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaOaepSha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"RsaOaepSha512"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaOaepSha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaPkcs1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"RsaPkcs1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaPkcs1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaSignPkcs1Sha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"RsaSignPkcs1Sha1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaSignPkcs1Sha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaSignPkcs1Sha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"RsaSignPkcs1Sha384"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaSignPkcs1Sha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaSignPkcs1Sha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"RsaSignPkcs1Sha512"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaSignPkcs1Sha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaSignPssSha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"RsaSignPssSha1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaSignPssSha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaSignPssSha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"RsaSignPssSha256"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaSignPssSha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaSignPssSha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"RsaSignPssSha384"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaSignPssSha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaSignPssSha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"RsaSignPssSha512"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaSignPssSha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_EcdsaSha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"EcdsaSha384"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::EcdsaSha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_EcdsaSha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"EcdsaSha512"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::EcdsaSha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_EcdsaSha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames", L"EcdsaSha256"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::EcdsaSha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AsymmetricAlgorithmNames[] = {
        { }
    };

    static PyGetSetDef _getset_AsymmetricAlgorithmNames[] = {
        { }
    };

    static PyType_Slot _type_slots_AsymmetricAlgorithmNames[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AsymmetricAlgorithmNames) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AsymmetricAlgorithmNames) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AsymmetricAlgorithmNames) },
        { }
    };

    static PyType_Spec type_spec_AsymmetricAlgorithmNames = {
        "winrt._winrt_windows_security_cryptography_core.AsymmetricAlgorithmNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AsymmetricAlgorithmNames};

    static PyGetSetDef getset_AsymmetricAlgorithmNames_Static[] = {
        { "ecdsa_p521_sha512", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_EcdsaP521Sha512), nullptr, nullptr, nullptr },
        { "dsa_sha1", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_DsaSha1), nullptr, nullptr, nullptr },
        { "dsa_sha256", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_DsaSha256), nullptr, nullptr, nullptr },
        { "ecdsa_p256_sha256", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_EcdsaP256Sha256), nullptr, nullptr, nullptr },
        { "ecdsa_p384_sha384", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_EcdsaP384Sha384), nullptr, nullptr, nullptr },
        { "rsa_sign_pkcs1_sha256", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_RsaSignPkcs1Sha256), nullptr, nullptr, nullptr },
        { "rsa_oaep_sha1", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_RsaOaepSha1), nullptr, nullptr, nullptr },
        { "rsa_oaep_sha256", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_RsaOaepSha256), nullptr, nullptr, nullptr },
        { "rsa_oaep_sha384", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_RsaOaepSha384), nullptr, nullptr, nullptr },
        { "rsa_oaep_sha512", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_RsaOaepSha512), nullptr, nullptr, nullptr },
        { "rsa_pkcs1", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_RsaPkcs1), nullptr, nullptr, nullptr },
        { "rsa_sign_pkcs1_sha1", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_RsaSignPkcs1Sha1), nullptr, nullptr, nullptr },
        { "rsa_sign_pkcs1_sha384", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_RsaSignPkcs1Sha384), nullptr, nullptr, nullptr },
        { "rsa_sign_pkcs1_sha512", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_RsaSignPkcs1Sha512), nullptr, nullptr, nullptr },
        { "rsa_sign_pss_sha1", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_RsaSignPssSha1), nullptr, nullptr, nullptr },
        { "rsa_sign_pss_sha256", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_RsaSignPssSha256), nullptr, nullptr, nullptr },
        { "rsa_sign_pss_sha384", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_RsaSignPssSha384), nullptr, nullptr, nullptr },
        { "rsa_sign_pss_sha512", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_RsaSignPssSha512), nullptr, nullptr, nullptr },
        { "ecdsa_sha384", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_EcdsaSha384), nullptr, nullptr, nullptr },
        { "ecdsa_sha512", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_EcdsaSha512), nullptr, nullptr, nullptr },
        { "ecdsa_sha256", reinterpret_cast<getter>(AsymmetricAlgorithmNames_get_EcdsaSha256), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_AsymmetricAlgorithmNames_Static[] = {
        { }
    };

    static PyType_Slot type_slots_AsymmetricAlgorithmNames_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AsymmetricAlgorithmNames_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AsymmetricAlgorithmNames_Static) },
        { }
    };

    static PyType_Spec type_spec_AsymmetricAlgorithmNames_Static =
    {
        "winrt._winrt_windows_security_cryptography_core.AsymmetricAlgorithmNames_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AsymmetricAlgorithmNames_Static
    };

    // ----- AsymmetricKeyAlgorithmProvider class --------------------

    static PyObject* _new_AsymmetricKeyAlgorithmProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_AsymmetricKeyAlgorithmProvider(py::wrapper::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AsymmetricKeyAlgorithmProvider_CreateKeyPair(py::wrapper::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider", L"CreateKeyPair", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.CreateKeyPair(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsymmetricKeyAlgorithmProvider_CreateKeyPairWithCurveName(py::wrapper::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider", L"CreateKeyPairWithCurveName", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateKeyPairWithCurveName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsymmetricKeyAlgorithmProvider_CreateKeyPairWithCurveParameters(py::wrapper::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider", L"CreateKeyPairWithCurveParameters", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert(self->obj.CreateKeyPairWithCurveParameters(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsymmetricKeyAlgorithmProvider_ImportKeyPair(py::wrapper::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider", L"ImportKeyPair", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.ImportKeyPair(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider", L"ImportKeyPair", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicPrivateKeyBlobType>(args, 1);

                return py::convert(self->obj.ImportKeyPair(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsymmetricKeyAlgorithmProvider_ImportPublicKey(py::wrapper::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider", L"ImportPublicKey", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.ImportPublicKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider", L"ImportPublicKey", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicPublicKeyBlobType>(args, 1);

                return py::convert(self->obj.ImportPublicKey(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsymmetricKeyAlgorithmProvider_OpenAlgorithm(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider", L"OpenAlgorithm", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider::OpenAlgorithm(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsymmetricKeyAlgorithmProvider_get_AlgorithmName(py::wrapper::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider", L"AlgorithmName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AsymmetricKeyAlgorithmProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AsymmetricKeyAlgorithmProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AsymmetricKeyAlgorithmProvider[] = {
        { "create_key_pair", reinterpret_cast<PyCFunction>(AsymmetricKeyAlgorithmProvider_CreateKeyPair), METH_VARARGS, nullptr },
        { "create_key_pair_with_curve_name", reinterpret_cast<PyCFunction>(AsymmetricKeyAlgorithmProvider_CreateKeyPairWithCurveName), METH_VARARGS, nullptr },
        { "create_key_pair_with_curve_parameters", reinterpret_cast<PyCFunction>(AsymmetricKeyAlgorithmProvider_CreateKeyPairWithCurveParameters), METH_VARARGS, nullptr },
        { "import_key_pair", reinterpret_cast<PyCFunction>(AsymmetricKeyAlgorithmProvider_ImportKeyPair), METH_VARARGS, nullptr },
        { "import_public_key", reinterpret_cast<PyCFunction>(AsymmetricKeyAlgorithmProvider_ImportPublicKey), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AsymmetricKeyAlgorithmProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AsymmetricKeyAlgorithmProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AsymmetricKeyAlgorithmProvider[] = {
        { "algorithm_name", reinterpret_cast<getter>(AsymmetricKeyAlgorithmProvider_get_AlgorithmName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AsymmetricKeyAlgorithmProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AsymmetricKeyAlgorithmProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AsymmetricKeyAlgorithmProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AsymmetricKeyAlgorithmProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AsymmetricKeyAlgorithmProvider) },
        { }
    };

    static PyType_Spec type_spec_AsymmetricKeyAlgorithmProvider = {
        "winrt._winrt_windows_security_cryptography_core.AsymmetricKeyAlgorithmProvider",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AsymmetricKeyAlgorithmProvider};

    static PyGetSetDef getset_AsymmetricKeyAlgorithmProvider_Static[] = {
        { }
    };

    static PyMethodDef methods_AsymmetricKeyAlgorithmProvider_Static[] = {
        { "open_algorithm", reinterpret_cast<PyCFunction>(AsymmetricKeyAlgorithmProvider_OpenAlgorithm), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AsymmetricKeyAlgorithmProvider_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AsymmetricKeyAlgorithmProvider_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AsymmetricKeyAlgorithmProvider_Static) },
        { }
    };

    static PyType_Spec type_spec_AsymmetricKeyAlgorithmProvider_Static =
    {
        "winrt._winrt_windows_security_cryptography_core.AsymmetricKeyAlgorithmProvider_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AsymmetricKeyAlgorithmProvider_Static
    };

    // ----- CryptographicEngine class --------------------

    static PyObject* _new_CryptographicEngine(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Cryptography::Core::CryptographicEngine>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Cryptography::Core::CryptographicEngine>::type_name);
        return nullptr;
    }

    static PyObject* CryptographicEngine_Decrypt(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicEngine", L"Decrypt", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::Decrypt(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_DecryptAndAuthenticate(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicEngine", L"DecryptAndAuthenticate", 5))
                {
                    py::set_arg_count_version_error(5);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 4);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::DecryptAndAuthenticate(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_DecryptAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicEngine", L"DecryptAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::DecryptAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_DeriveKeyMaterial(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicEngine", L"DeriveKeyMaterial", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::DeriveKeyMaterial(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_Encrypt(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicEngine", L"Encrypt", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::Encrypt(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_EncryptAndAuthenticate(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicEngine", L"EncryptAndAuthenticate", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 3);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::EncryptAndAuthenticate(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_Sign(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicEngine", L"Sign", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::Sign(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_SignAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicEngine", L"SignAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::SignAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_SignHashedData(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicEngine", L"SignHashedData", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::SignHashedData(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_SignHashedDataAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicEngine", L"SignHashedDataAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::SignHashedDataAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_VerifySignature(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicEngine", L"VerifySignature", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::VerifySignature(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_VerifySignatureWithHashInput(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicEngine", L"VerifySignatureWithHashInput", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::VerifySignatureWithHashInput(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_CryptographicEngine[] = {
        { }
    };

    static PyGetSetDef _getset_CryptographicEngine[] = {
        { }
    };

    static PyType_Slot _type_slots_CryptographicEngine[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CryptographicEngine) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CryptographicEngine) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CryptographicEngine) },
        { }
    };

    static PyType_Spec type_spec_CryptographicEngine = {
        "winrt._winrt_windows_security_cryptography_core.CryptographicEngine",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CryptographicEngine};

    static PyGetSetDef getset_CryptographicEngine_Static[] = {
        { }
    };

    static PyMethodDef methods_CryptographicEngine_Static[] = {
        { "decrypt", reinterpret_cast<PyCFunction>(CryptographicEngine_Decrypt), METH_VARARGS, nullptr },
        { "decrypt_and_authenticate", reinterpret_cast<PyCFunction>(CryptographicEngine_DecryptAndAuthenticate), METH_VARARGS, nullptr },
        { "decrypt_async", reinterpret_cast<PyCFunction>(CryptographicEngine_DecryptAsync), METH_VARARGS, nullptr },
        { "derive_key_material", reinterpret_cast<PyCFunction>(CryptographicEngine_DeriveKeyMaterial), METH_VARARGS, nullptr },
        { "encrypt", reinterpret_cast<PyCFunction>(CryptographicEngine_Encrypt), METH_VARARGS, nullptr },
        { "encrypt_and_authenticate", reinterpret_cast<PyCFunction>(CryptographicEngine_EncryptAndAuthenticate), METH_VARARGS, nullptr },
        { "sign", reinterpret_cast<PyCFunction>(CryptographicEngine_Sign), METH_VARARGS, nullptr },
        { "sign_async", reinterpret_cast<PyCFunction>(CryptographicEngine_SignAsync), METH_VARARGS, nullptr },
        { "sign_hashed_data", reinterpret_cast<PyCFunction>(CryptographicEngine_SignHashedData), METH_VARARGS, nullptr },
        { "sign_hashed_data_async", reinterpret_cast<PyCFunction>(CryptographicEngine_SignHashedDataAsync), METH_VARARGS, nullptr },
        { "verify_signature", reinterpret_cast<PyCFunction>(CryptographicEngine_VerifySignature), METH_VARARGS, nullptr },
        { "verify_signature_with_hash_input", reinterpret_cast<PyCFunction>(CryptographicEngine_VerifySignatureWithHashInput), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_CryptographicEngine_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CryptographicEngine_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CryptographicEngine_Static) },
        { }
    };

    static PyType_Spec type_spec_CryptographicEngine_Static =
    {
        "winrt._winrt_windows_security_cryptography_core.CryptographicEngine_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CryptographicEngine_Static
    };

    // ----- CryptographicHash class --------------------

    static PyObject* _new_CryptographicHash(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Cryptography::Core::CryptographicHash>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Cryptography::Core::CryptographicHash>::type_name);
        return nullptr;
    }

    static void _dealloc_CryptographicHash(py::wrapper::Windows::Security::Cryptography::Core::CryptographicHash* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CryptographicHash_Append(py::wrapper::Windows::Security::Cryptography::Core::CryptographicHash* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicHash", L"Append", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicHash_GetValueAndReset(py::wrapper::Windows::Security::Cryptography::Core::CryptographicHash* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicHash", L"GetValueAndReset", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetValueAndReset());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_CryptographicHash(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Core::CryptographicHash>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CryptographicHash(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::CryptographicHash>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CryptographicHash[] = {
        { "append", reinterpret_cast<PyCFunction>(CryptographicHash_Append), METH_VARARGS, nullptr },
        { "get_value_and_reset", reinterpret_cast<PyCFunction>(CryptographicHash_GetValueAndReset), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CryptographicHash, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CryptographicHash), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CryptographicHash[] = {
        { }
    };

    static PyType_Slot _type_slots_CryptographicHash[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CryptographicHash) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CryptographicHash) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CryptographicHash) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CryptographicHash) },
        { }
    };

    static PyType_Spec type_spec_CryptographicHash = {
        "winrt._winrt_windows_security_cryptography_core.CryptographicHash",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::CryptographicHash),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CryptographicHash};

    // ----- CryptographicKey class --------------------

    static PyObject* _new_CryptographicKey(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Cryptography::Core::CryptographicKey>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Cryptography::Core::CryptographicKey>::type_name);
        return nullptr;
    }

    static void _dealloc_CryptographicKey(py::wrapper::Windows::Security::Cryptography::Core::CryptographicKey* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CryptographicKey_Export(py::wrapper::Windows::Security::Cryptography::Core::CryptographicKey* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicKey", L"Export", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.Export());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicKey", L"Export", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicPrivateKeyBlobType>(args, 0);

                return py::convert(self->obj.Export(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicKey_ExportPublicKey(py::wrapper::Windows::Security::Cryptography::Core::CryptographicKey* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicKey", L"ExportPublicKey", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ExportPublicKey());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.CryptographicKey", L"ExportPublicKey", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicPublicKeyBlobType>(args, 0);

                return py::convert(self->obj.ExportPublicKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicKey_get_KeySize(py::wrapper::Windows::Security::Cryptography::Core::CryptographicKey* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.CryptographicKey", L"KeySize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeySize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CryptographicKey(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Core::CryptographicKey>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CryptographicKey(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::CryptographicKey>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CryptographicKey[] = {
        { "export", reinterpret_cast<PyCFunction>(CryptographicKey_Export), METH_VARARGS, nullptr },
        { "export_public_key", reinterpret_cast<PyCFunction>(CryptographicKey_ExportPublicKey), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CryptographicKey, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CryptographicKey), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CryptographicKey[] = {
        { "key_size", reinterpret_cast<getter>(CryptographicKey_get_KeySize), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CryptographicKey[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CryptographicKey) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CryptographicKey) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CryptographicKey) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CryptographicKey) },
        { }
    };

    static PyType_Spec type_spec_CryptographicKey = {
        "winrt._winrt_windows_security_cryptography_core.CryptographicKey",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::CryptographicKey),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CryptographicKey};

    // ----- EccCurveNames class --------------------

    static PyObject* _new_EccCurveNames(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Cryptography::Core::EccCurveNames>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Cryptography::Core::EccCurveNames>::type_name);
        return nullptr;
    }

    static PyObject* EccCurveNames_get_AllEccCurveNames(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"AllEccCurveNames"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::AllEccCurveNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP160r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"BrainpoolP160r1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP160r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP160t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"BrainpoolP160t1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP160t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP192r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"BrainpoolP192r1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP192r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP192t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"BrainpoolP192t1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP192t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP224r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"BrainpoolP224r1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP224r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP224t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"BrainpoolP224t1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP224t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP256r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"BrainpoolP256r1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP256r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP256t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"BrainpoolP256t1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP256t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP320r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"BrainpoolP320r1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP320r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP320t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"BrainpoolP320t1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP320t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP384r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"BrainpoolP384r1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP384r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP384t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"BrainpoolP384t1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP384t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP512r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"BrainpoolP512r1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP512r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP512t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"BrainpoolP512t1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP512t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_Curve25519(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"Curve25519"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::Curve25519());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_Ec192wapi(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"Ec192wapi"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::Ec192wapi());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_NistP192(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"NistP192"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::NistP192());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_NistP224(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"NistP224"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::NistP224());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_NistP256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"NistP256"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::NistP256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_NistP384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"NistP384"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::NistP384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_NistP521(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"NistP521"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::NistP521());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_NumsP256t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"NumsP256t1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::NumsP256t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_NumsP384t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"NumsP384t1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::NumsP384t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_NumsP512t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"NumsP512t1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::NumsP512t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP160k1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"SecP160k1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP160k1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP160r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"SecP160r1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP160r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP160r2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"SecP160r2"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP160r2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP192k1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"SecP192k1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP192k1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP192r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"SecP192r1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP192r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP224k1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"SecP224k1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP224k1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP224r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"SecP224r1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP224r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP256k1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"SecP256k1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP256k1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP256r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"SecP256r1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP256r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP384r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"SecP384r1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP384r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP521r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"SecP521r1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP521r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_Wtls12(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"Wtls12"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::Wtls12());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_Wtls7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"Wtls7"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::Wtls7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_Wtls9(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"Wtls9"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::Wtls9());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_X962P192v1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"X962P192v1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::X962P192v1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_X962P192v2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"X962P192v2"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::X962P192v2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_X962P192v3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"X962P192v3"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::X962P192v3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_X962P239v1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"X962P239v1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::X962P239v1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_X962P239v2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"X962P239v2"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::X962P239v2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_X962P239v3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"X962P239v3"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::X962P239v3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_X962P256v1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EccCurveNames", L"X962P256v1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::X962P256v1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EccCurveNames[] = {
        { }
    };

    static PyGetSetDef _getset_EccCurveNames[] = {
        { }
    };

    static PyType_Slot _type_slots_EccCurveNames[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EccCurveNames) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EccCurveNames) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EccCurveNames) },
        { }
    };

    static PyType_Spec type_spec_EccCurveNames = {
        "winrt._winrt_windows_security_cryptography_core.EccCurveNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EccCurveNames};

    static PyGetSetDef getset_EccCurveNames_Static[] = {
        { "all_ecc_curve_names", reinterpret_cast<getter>(EccCurveNames_get_AllEccCurveNames), nullptr, nullptr, nullptr },
        { "brainpool_p160r1", reinterpret_cast<getter>(EccCurveNames_get_BrainpoolP160r1), nullptr, nullptr, nullptr },
        { "brainpool_p160t1", reinterpret_cast<getter>(EccCurveNames_get_BrainpoolP160t1), nullptr, nullptr, nullptr },
        { "brainpool_p192r1", reinterpret_cast<getter>(EccCurveNames_get_BrainpoolP192r1), nullptr, nullptr, nullptr },
        { "brainpool_p192t1", reinterpret_cast<getter>(EccCurveNames_get_BrainpoolP192t1), nullptr, nullptr, nullptr },
        { "brainpool_p224r1", reinterpret_cast<getter>(EccCurveNames_get_BrainpoolP224r1), nullptr, nullptr, nullptr },
        { "brainpool_p224t1", reinterpret_cast<getter>(EccCurveNames_get_BrainpoolP224t1), nullptr, nullptr, nullptr },
        { "brainpool_p256r1", reinterpret_cast<getter>(EccCurveNames_get_BrainpoolP256r1), nullptr, nullptr, nullptr },
        { "brainpool_p256t1", reinterpret_cast<getter>(EccCurveNames_get_BrainpoolP256t1), nullptr, nullptr, nullptr },
        { "brainpool_p320r1", reinterpret_cast<getter>(EccCurveNames_get_BrainpoolP320r1), nullptr, nullptr, nullptr },
        { "brainpool_p320t1", reinterpret_cast<getter>(EccCurveNames_get_BrainpoolP320t1), nullptr, nullptr, nullptr },
        { "brainpool_p384r1", reinterpret_cast<getter>(EccCurveNames_get_BrainpoolP384r1), nullptr, nullptr, nullptr },
        { "brainpool_p384t1", reinterpret_cast<getter>(EccCurveNames_get_BrainpoolP384t1), nullptr, nullptr, nullptr },
        { "brainpool_p512r1", reinterpret_cast<getter>(EccCurveNames_get_BrainpoolP512r1), nullptr, nullptr, nullptr },
        { "brainpool_p512t1", reinterpret_cast<getter>(EccCurveNames_get_BrainpoolP512t1), nullptr, nullptr, nullptr },
        { "curve25519", reinterpret_cast<getter>(EccCurveNames_get_Curve25519), nullptr, nullptr, nullptr },
        { "ec192wapi", reinterpret_cast<getter>(EccCurveNames_get_Ec192wapi), nullptr, nullptr, nullptr },
        { "nist_p192", reinterpret_cast<getter>(EccCurveNames_get_NistP192), nullptr, nullptr, nullptr },
        { "nist_p224", reinterpret_cast<getter>(EccCurveNames_get_NistP224), nullptr, nullptr, nullptr },
        { "nist_p256", reinterpret_cast<getter>(EccCurveNames_get_NistP256), nullptr, nullptr, nullptr },
        { "nist_p384", reinterpret_cast<getter>(EccCurveNames_get_NistP384), nullptr, nullptr, nullptr },
        { "nist_p521", reinterpret_cast<getter>(EccCurveNames_get_NistP521), nullptr, nullptr, nullptr },
        { "nums_p256t1", reinterpret_cast<getter>(EccCurveNames_get_NumsP256t1), nullptr, nullptr, nullptr },
        { "nums_p384t1", reinterpret_cast<getter>(EccCurveNames_get_NumsP384t1), nullptr, nullptr, nullptr },
        { "nums_p512t1", reinterpret_cast<getter>(EccCurveNames_get_NumsP512t1), nullptr, nullptr, nullptr },
        { "sec_p160k1", reinterpret_cast<getter>(EccCurveNames_get_SecP160k1), nullptr, nullptr, nullptr },
        { "sec_p160r1", reinterpret_cast<getter>(EccCurveNames_get_SecP160r1), nullptr, nullptr, nullptr },
        { "sec_p160r2", reinterpret_cast<getter>(EccCurveNames_get_SecP160r2), nullptr, nullptr, nullptr },
        { "sec_p192k1", reinterpret_cast<getter>(EccCurveNames_get_SecP192k1), nullptr, nullptr, nullptr },
        { "sec_p192r1", reinterpret_cast<getter>(EccCurveNames_get_SecP192r1), nullptr, nullptr, nullptr },
        { "sec_p224k1", reinterpret_cast<getter>(EccCurveNames_get_SecP224k1), nullptr, nullptr, nullptr },
        { "sec_p224r1", reinterpret_cast<getter>(EccCurveNames_get_SecP224r1), nullptr, nullptr, nullptr },
        { "sec_p256k1", reinterpret_cast<getter>(EccCurveNames_get_SecP256k1), nullptr, nullptr, nullptr },
        { "sec_p256r1", reinterpret_cast<getter>(EccCurveNames_get_SecP256r1), nullptr, nullptr, nullptr },
        { "sec_p384r1", reinterpret_cast<getter>(EccCurveNames_get_SecP384r1), nullptr, nullptr, nullptr },
        { "sec_p521r1", reinterpret_cast<getter>(EccCurveNames_get_SecP521r1), nullptr, nullptr, nullptr },
        { "wtls12", reinterpret_cast<getter>(EccCurveNames_get_Wtls12), nullptr, nullptr, nullptr },
        { "wtls7", reinterpret_cast<getter>(EccCurveNames_get_Wtls7), nullptr, nullptr, nullptr },
        { "wtls9", reinterpret_cast<getter>(EccCurveNames_get_Wtls9), nullptr, nullptr, nullptr },
        { "x962_p192v1", reinterpret_cast<getter>(EccCurveNames_get_X962P192v1), nullptr, nullptr, nullptr },
        { "x962_p192v2", reinterpret_cast<getter>(EccCurveNames_get_X962P192v2), nullptr, nullptr, nullptr },
        { "x962_p192v3", reinterpret_cast<getter>(EccCurveNames_get_X962P192v3), nullptr, nullptr, nullptr },
        { "x962_p239v1", reinterpret_cast<getter>(EccCurveNames_get_X962P239v1), nullptr, nullptr, nullptr },
        { "x962_p239v2", reinterpret_cast<getter>(EccCurveNames_get_X962P239v2), nullptr, nullptr, nullptr },
        { "x962_p239v3", reinterpret_cast<getter>(EccCurveNames_get_X962P239v3), nullptr, nullptr, nullptr },
        { "x962_p256v1", reinterpret_cast<getter>(EccCurveNames_get_X962P256v1), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_EccCurveNames_Static[] = {
        { }
    };

    static PyType_Slot type_slots_EccCurveNames_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_EccCurveNames_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_EccCurveNames_Static) },
        { }
    };

    static PyType_Spec type_spec_EccCurveNames_Static =
    {
        "winrt._winrt_windows_security_cryptography_core.EccCurveNames_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_EccCurveNames_Static
    };

    // ----- EncryptedAndAuthenticatedData class --------------------

    static PyObject* _new_EncryptedAndAuthenticatedData(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Cryptography::Core::EncryptedAndAuthenticatedData>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Cryptography::Core::EncryptedAndAuthenticatedData>::type_name);
        return nullptr;
    }

    static void _dealloc_EncryptedAndAuthenticatedData(py::wrapper::Windows::Security::Cryptography::Core::EncryptedAndAuthenticatedData* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EncryptedAndAuthenticatedData_get_AuthenticationTag(py::wrapper::Windows::Security::Cryptography::Core::EncryptedAndAuthenticatedData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EncryptedAndAuthenticatedData", L"AuthenticationTag"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AuthenticationTag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EncryptedAndAuthenticatedData_get_EncryptedData(py::wrapper::Windows::Security::Cryptography::Core::EncryptedAndAuthenticatedData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.EncryptedAndAuthenticatedData", L"EncryptedData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EncryptedData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EncryptedAndAuthenticatedData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Core::EncryptedAndAuthenticatedData>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EncryptedAndAuthenticatedData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::EncryptedAndAuthenticatedData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EncryptedAndAuthenticatedData[] = {
        { "_assign_array_", _assign_array_EncryptedAndAuthenticatedData, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EncryptedAndAuthenticatedData), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EncryptedAndAuthenticatedData[] = {
        { "authentication_tag", reinterpret_cast<getter>(EncryptedAndAuthenticatedData_get_AuthenticationTag), nullptr, nullptr, nullptr },
        { "encrypted_data", reinterpret_cast<getter>(EncryptedAndAuthenticatedData_get_EncryptedData), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EncryptedAndAuthenticatedData[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EncryptedAndAuthenticatedData) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EncryptedAndAuthenticatedData) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EncryptedAndAuthenticatedData) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EncryptedAndAuthenticatedData) },
        { }
    };

    static PyType_Spec type_spec_EncryptedAndAuthenticatedData = {
        "winrt._winrt_windows_security_cryptography_core.EncryptedAndAuthenticatedData",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::EncryptedAndAuthenticatedData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EncryptedAndAuthenticatedData};

    // ----- HashAlgorithmNames class --------------------

    static PyObject* _new_HashAlgorithmNames(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Cryptography::Core::HashAlgorithmNames>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Cryptography::Core::HashAlgorithmNames>::type_name);
        return nullptr;
    }

    static PyObject* HashAlgorithmNames_get_Md5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.HashAlgorithmNames", L"Md5"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::HashAlgorithmNames::Md5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HashAlgorithmNames_get_Sha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.HashAlgorithmNames", L"Sha1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::HashAlgorithmNames::Sha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HashAlgorithmNames_get_Sha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.HashAlgorithmNames", L"Sha256"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::HashAlgorithmNames::Sha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HashAlgorithmNames_get_Sha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.HashAlgorithmNames", L"Sha384"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::HashAlgorithmNames::Sha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HashAlgorithmNames_get_Sha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.HashAlgorithmNames", L"Sha512"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::HashAlgorithmNames::Sha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HashAlgorithmNames[] = {
        { }
    };

    static PyGetSetDef _getset_HashAlgorithmNames[] = {
        { }
    };

    static PyType_Slot _type_slots_HashAlgorithmNames[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HashAlgorithmNames) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HashAlgorithmNames) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HashAlgorithmNames) },
        { }
    };

    static PyType_Spec type_spec_HashAlgorithmNames = {
        "winrt._winrt_windows_security_cryptography_core.HashAlgorithmNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HashAlgorithmNames};

    static PyGetSetDef getset_HashAlgorithmNames_Static[] = {
        { "md5", reinterpret_cast<getter>(HashAlgorithmNames_get_Md5), nullptr, nullptr, nullptr },
        { "sha1", reinterpret_cast<getter>(HashAlgorithmNames_get_Sha1), nullptr, nullptr, nullptr },
        { "sha256", reinterpret_cast<getter>(HashAlgorithmNames_get_Sha256), nullptr, nullptr, nullptr },
        { "sha384", reinterpret_cast<getter>(HashAlgorithmNames_get_Sha384), nullptr, nullptr, nullptr },
        { "sha512", reinterpret_cast<getter>(HashAlgorithmNames_get_Sha512), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_HashAlgorithmNames_Static[] = {
        { }
    };

    static PyType_Slot type_slots_HashAlgorithmNames_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HashAlgorithmNames_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HashAlgorithmNames_Static) },
        { }
    };

    static PyType_Spec type_spec_HashAlgorithmNames_Static =
    {
        "winrt._winrt_windows_security_cryptography_core.HashAlgorithmNames_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HashAlgorithmNames_Static
    };

    // ----- HashAlgorithmProvider class --------------------

    static PyObject* _new_HashAlgorithmProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Cryptography::Core::HashAlgorithmProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Cryptography::Core::HashAlgorithmProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_HashAlgorithmProvider(py::wrapper::Windows::Security::Cryptography::Core::HashAlgorithmProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HashAlgorithmProvider_CreateHash(py::wrapper::Windows::Security::Cryptography::Core::HashAlgorithmProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.HashAlgorithmProvider", L"CreateHash", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateHash());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HashAlgorithmProvider_HashData(py::wrapper::Windows::Security::Cryptography::Core::HashAlgorithmProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.HashAlgorithmProvider", L"HashData", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.HashData(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HashAlgorithmProvider_OpenAlgorithm(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.HashAlgorithmProvider", L"OpenAlgorithm", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Core::HashAlgorithmProvider::OpenAlgorithm(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HashAlgorithmProvider_get_AlgorithmName(py::wrapper::Windows::Security::Cryptography::Core::HashAlgorithmProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.HashAlgorithmProvider", L"AlgorithmName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HashAlgorithmProvider_get_HashLength(py::wrapper::Windows::Security::Cryptography::Core::HashAlgorithmProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.HashAlgorithmProvider", L"HashLength"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HashLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HashAlgorithmProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Core::HashAlgorithmProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HashAlgorithmProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::HashAlgorithmProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HashAlgorithmProvider[] = {
        { "create_hash", reinterpret_cast<PyCFunction>(HashAlgorithmProvider_CreateHash), METH_VARARGS, nullptr },
        { "hash_data", reinterpret_cast<PyCFunction>(HashAlgorithmProvider_HashData), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HashAlgorithmProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HashAlgorithmProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HashAlgorithmProvider[] = {
        { "algorithm_name", reinterpret_cast<getter>(HashAlgorithmProvider_get_AlgorithmName), nullptr, nullptr, nullptr },
        { "hash_length", reinterpret_cast<getter>(HashAlgorithmProvider_get_HashLength), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HashAlgorithmProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HashAlgorithmProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HashAlgorithmProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HashAlgorithmProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HashAlgorithmProvider) },
        { }
    };

    static PyType_Spec type_spec_HashAlgorithmProvider = {
        "winrt._winrt_windows_security_cryptography_core.HashAlgorithmProvider",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::HashAlgorithmProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HashAlgorithmProvider};

    static PyGetSetDef getset_HashAlgorithmProvider_Static[] = {
        { }
    };

    static PyMethodDef methods_HashAlgorithmProvider_Static[] = {
        { "open_algorithm", reinterpret_cast<PyCFunction>(HashAlgorithmProvider_OpenAlgorithm), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_HashAlgorithmProvider_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HashAlgorithmProvider_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HashAlgorithmProvider_Static) },
        { }
    };

    static PyType_Spec type_spec_HashAlgorithmProvider_Static =
    {
        "winrt._winrt_windows_security_cryptography_core.HashAlgorithmProvider_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HashAlgorithmProvider_Static
    };

    // ----- KeyDerivationAlgorithmNames class --------------------

    static PyObject* _new_KeyDerivationAlgorithmNames(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames>::type_name);
        return nullptr;
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Pbkdf2Sha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"Pbkdf2Sha256"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Pbkdf2Sha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Pbkdf2Md5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"Pbkdf2Md5"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Pbkdf2Md5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Pbkdf2Sha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"Pbkdf2Sha1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Pbkdf2Sha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp800108CtrHmacSha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"Sp800108CtrHmacSha512"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp800108CtrHmacSha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Pbkdf2Sha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"Pbkdf2Sha384"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Pbkdf2Sha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Pbkdf2Sha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"Pbkdf2Sha512"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Pbkdf2Sha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp800108CtrHmacMd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"Sp800108CtrHmacMd5"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp800108CtrHmacMd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp800108CtrHmacSha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"Sp800108CtrHmacSha1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp800108CtrHmacSha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp800108CtrHmacSha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"Sp800108CtrHmacSha256"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp800108CtrHmacSha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp800108CtrHmacSha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"Sp800108CtrHmacSha384"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp800108CtrHmacSha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp80056aConcatMd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"Sp80056aConcatMd5"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp80056aConcatMd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp80056aConcatSha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"Sp80056aConcatSha1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp80056aConcatSha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp80056aConcatSha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"Sp80056aConcatSha256"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp80056aConcatSha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp80056aConcatSha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"Sp80056aConcatSha384"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp80056aConcatSha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp80056aConcatSha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"Sp80056aConcatSha512"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp80056aConcatSha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_CapiKdfSha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"CapiKdfSha1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::CapiKdfSha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_CapiKdfSha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"CapiKdfSha256"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::CapiKdfSha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_CapiKdfSha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"CapiKdfSha384"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::CapiKdfSha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_CapiKdfSha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"CapiKdfSha512"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::CapiKdfSha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_CapiKdfMd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames", L"CapiKdfMd5"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::CapiKdfMd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyDerivationAlgorithmNames[] = {
        { }
    };

    static PyGetSetDef _getset_KeyDerivationAlgorithmNames[] = {
        { }
    };

    static PyType_Slot _type_slots_KeyDerivationAlgorithmNames[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_KeyDerivationAlgorithmNames) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KeyDerivationAlgorithmNames) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KeyDerivationAlgorithmNames) },
        { }
    };

    static PyType_Spec type_spec_KeyDerivationAlgorithmNames = {
        "winrt._winrt_windows_security_cryptography_core.KeyDerivationAlgorithmNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyDerivationAlgorithmNames};

    static PyGetSetDef getset_KeyDerivationAlgorithmNames_Static[] = {
        { "pbkdf2_sha256", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_Pbkdf2Sha256), nullptr, nullptr, nullptr },
        { "pbkdf2_md5", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_Pbkdf2Md5), nullptr, nullptr, nullptr },
        { "pbkdf2_sha1", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_Pbkdf2Sha1), nullptr, nullptr, nullptr },
        { "sp800108_ctr_hmac_sha512", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_Sp800108CtrHmacSha512), nullptr, nullptr, nullptr },
        { "pbkdf2_sha384", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_Pbkdf2Sha384), nullptr, nullptr, nullptr },
        { "pbkdf2_sha512", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_Pbkdf2Sha512), nullptr, nullptr, nullptr },
        { "sp800108_ctr_hmac_md5", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_Sp800108CtrHmacMd5), nullptr, nullptr, nullptr },
        { "sp800108_ctr_hmac_sha1", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_Sp800108CtrHmacSha1), nullptr, nullptr, nullptr },
        { "sp800108_ctr_hmac_sha256", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_Sp800108CtrHmacSha256), nullptr, nullptr, nullptr },
        { "sp800108_ctr_hmac_sha384", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_Sp800108CtrHmacSha384), nullptr, nullptr, nullptr },
        { "sp80056a_concat_md5", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_Sp80056aConcatMd5), nullptr, nullptr, nullptr },
        { "sp80056a_concat_sha1", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_Sp80056aConcatSha1), nullptr, nullptr, nullptr },
        { "sp80056a_concat_sha256", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_Sp80056aConcatSha256), nullptr, nullptr, nullptr },
        { "sp80056a_concat_sha384", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_Sp80056aConcatSha384), nullptr, nullptr, nullptr },
        { "sp80056a_concat_sha512", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_Sp80056aConcatSha512), nullptr, nullptr, nullptr },
        { "capi_kdf_sha1", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_CapiKdfSha1), nullptr, nullptr, nullptr },
        { "capi_kdf_sha256", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_CapiKdfSha256), nullptr, nullptr, nullptr },
        { "capi_kdf_sha384", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_CapiKdfSha384), nullptr, nullptr, nullptr },
        { "capi_kdf_sha512", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_CapiKdfSha512), nullptr, nullptr, nullptr },
        { "capi_kdf_md5", reinterpret_cast<getter>(KeyDerivationAlgorithmNames_get_CapiKdfMd5), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_KeyDerivationAlgorithmNames_Static[] = {
        { }
    };

    static PyType_Slot type_slots_KeyDerivationAlgorithmNames_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KeyDerivationAlgorithmNames_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_KeyDerivationAlgorithmNames_Static) },
        { }
    };

    static PyType_Spec type_spec_KeyDerivationAlgorithmNames_Static =
    {
        "winrt._winrt_windows_security_cryptography_core.KeyDerivationAlgorithmNames_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KeyDerivationAlgorithmNames_Static
    };

    // ----- KeyDerivationAlgorithmProvider class --------------------

    static PyObject* _new_KeyDerivationAlgorithmProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_KeyDerivationAlgorithmProvider(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* KeyDerivationAlgorithmProvider_CreateKey(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmProvider", L"CreateKey", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.CreateKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmProvider_OpenAlgorithm(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmProvider", L"OpenAlgorithm", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider::OpenAlgorithm(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmProvider_get_AlgorithmName(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationAlgorithmProvider", L"AlgorithmName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_KeyDerivationAlgorithmProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_KeyDerivationAlgorithmProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyDerivationAlgorithmProvider[] = {
        { "create_key", reinterpret_cast<PyCFunction>(KeyDerivationAlgorithmProvider_CreateKey), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_KeyDerivationAlgorithmProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_KeyDerivationAlgorithmProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KeyDerivationAlgorithmProvider[] = {
        { "algorithm_name", reinterpret_cast<getter>(KeyDerivationAlgorithmProvider_get_AlgorithmName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_KeyDerivationAlgorithmProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_KeyDerivationAlgorithmProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_KeyDerivationAlgorithmProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KeyDerivationAlgorithmProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KeyDerivationAlgorithmProvider) },
        { }
    };

    static PyType_Spec type_spec_KeyDerivationAlgorithmProvider = {
        "winrt._winrt_windows_security_cryptography_core.KeyDerivationAlgorithmProvider",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyDerivationAlgorithmProvider};

    static PyGetSetDef getset_KeyDerivationAlgorithmProvider_Static[] = {
        { }
    };

    static PyMethodDef methods_KeyDerivationAlgorithmProvider_Static[] = {
        { "open_algorithm", reinterpret_cast<PyCFunction>(KeyDerivationAlgorithmProvider_OpenAlgorithm), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_KeyDerivationAlgorithmProvider_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KeyDerivationAlgorithmProvider_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_KeyDerivationAlgorithmProvider_Static) },
        { }
    };

    static PyType_Spec type_spec_KeyDerivationAlgorithmProvider_Static =
    {
        "winrt._winrt_windows_security_cryptography_core.KeyDerivationAlgorithmProvider_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KeyDerivationAlgorithmProvider_Static
    };

    // ----- KeyDerivationParameters class --------------------

    static PyObject* _new_KeyDerivationParameters(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters>::type_name);
        return nullptr;
    }

    static void _dealloc_KeyDerivationParameters(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationParameters* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* KeyDerivationParameters_BuildForCapi1Kdf(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.KeyDerivationParameters", L"BuildForCapi1Kdf", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::Capi1KdfTargetAlgorithm>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters::BuildForCapi1Kdf(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyDerivationParameters_BuildForPbkdf2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.KeyDerivationParameters", L"BuildForPbkdf2", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters::BuildForPbkdf2(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyDerivationParameters_BuildForSP800108(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.KeyDerivationParameters", L"BuildForSP800108", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters::BuildForSP800108(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyDerivationParameters_BuildForSP80056a(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.KeyDerivationParameters", L"BuildForSP80056a", 5))
                {
                    py::set_arg_count_version_error(5);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 4);

                return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters::BuildForSP80056a(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyDerivationParameters_get_KdfGenericBinary(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationParameters", L"KdfGenericBinary"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KdfGenericBinary());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeyDerivationParameters_put_KdfGenericBinary(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationParameters", L"KdfGenericBinary"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.KdfGenericBinary(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* KeyDerivationParameters_get_IterationCount(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationParameters", L"IterationCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IterationCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationParameters_get_Capi1KdfTargetAlgorithm(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationParameters", L"Capi1KdfTargetAlgorithm"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Capi1KdfTargetAlgorithm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeyDerivationParameters_put_Capi1KdfTargetAlgorithm(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.KeyDerivationParameters", L"Capi1KdfTargetAlgorithm"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::Capi1KdfTargetAlgorithm>(arg);

            self->obj.Capi1KdfTargetAlgorithm(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_KeyDerivationParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_KeyDerivationParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyDerivationParameters[] = {
        { "_assign_array_", _assign_array_KeyDerivationParameters, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_KeyDerivationParameters), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KeyDerivationParameters[] = {
        { "kdf_generic_binary", reinterpret_cast<getter>(KeyDerivationParameters_get_KdfGenericBinary), reinterpret_cast<setter>(KeyDerivationParameters_put_KdfGenericBinary), nullptr, nullptr },
        { "iteration_count", reinterpret_cast<getter>(KeyDerivationParameters_get_IterationCount), nullptr, nullptr, nullptr },
        { "capi1_kdf_target_algorithm", reinterpret_cast<getter>(KeyDerivationParameters_get_Capi1KdfTargetAlgorithm), reinterpret_cast<setter>(KeyDerivationParameters_put_Capi1KdfTargetAlgorithm), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_KeyDerivationParameters[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_KeyDerivationParameters) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_KeyDerivationParameters) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KeyDerivationParameters) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KeyDerivationParameters) },
        { }
    };

    static PyType_Spec type_spec_KeyDerivationParameters = {
        "winrt._winrt_windows_security_cryptography_core.KeyDerivationParameters",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationParameters),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyDerivationParameters};

    static PyGetSetDef getset_KeyDerivationParameters_Static[] = {
        { }
    };

    static PyMethodDef methods_KeyDerivationParameters_Static[] = {
        { "build_for_capi1_kdf", reinterpret_cast<PyCFunction>(KeyDerivationParameters_BuildForCapi1Kdf), METH_VARARGS, nullptr },
        { "build_for_pbkdf2", reinterpret_cast<PyCFunction>(KeyDerivationParameters_BuildForPbkdf2), METH_VARARGS, nullptr },
        { "build_for_s_p800108", reinterpret_cast<PyCFunction>(KeyDerivationParameters_BuildForSP800108), METH_VARARGS, nullptr },
        { "build_for_s_p80056a", reinterpret_cast<PyCFunction>(KeyDerivationParameters_BuildForSP80056a), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_KeyDerivationParameters_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KeyDerivationParameters_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_KeyDerivationParameters_Static) },
        { }
    };

    static PyType_Spec type_spec_KeyDerivationParameters_Static =
    {
        "winrt._winrt_windows_security_cryptography_core.KeyDerivationParameters_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KeyDerivationParameters_Static
    };

    // ----- MacAlgorithmNames class --------------------

    static PyObject* _new_MacAlgorithmNames(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Cryptography::Core::MacAlgorithmNames>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Cryptography::Core::MacAlgorithmNames>::type_name);
        return nullptr;
    }

    static PyObject* MacAlgorithmNames_get_AesCmac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.MacAlgorithmNames", L"AesCmac"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::MacAlgorithmNames::AesCmac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmNames_get_HmacMd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.MacAlgorithmNames", L"HmacMd5"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::MacAlgorithmNames::HmacMd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmNames_get_HmacSha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.MacAlgorithmNames", L"HmacSha1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::MacAlgorithmNames::HmacSha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmNames_get_HmacSha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.MacAlgorithmNames", L"HmacSha256"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::MacAlgorithmNames::HmacSha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmNames_get_HmacSha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.MacAlgorithmNames", L"HmacSha384"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::MacAlgorithmNames::HmacSha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmNames_get_HmacSha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.MacAlgorithmNames", L"HmacSha512"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::MacAlgorithmNames::HmacSha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MacAlgorithmNames[] = {
        { }
    };

    static PyGetSetDef _getset_MacAlgorithmNames[] = {
        { }
    };

    static PyType_Slot _type_slots_MacAlgorithmNames[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MacAlgorithmNames) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MacAlgorithmNames) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MacAlgorithmNames) },
        { }
    };

    static PyType_Spec type_spec_MacAlgorithmNames = {
        "winrt._winrt_windows_security_cryptography_core.MacAlgorithmNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MacAlgorithmNames};

    static PyGetSetDef getset_MacAlgorithmNames_Static[] = {
        { "aes_cmac", reinterpret_cast<getter>(MacAlgorithmNames_get_AesCmac), nullptr, nullptr, nullptr },
        { "hmac_md5", reinterpret_cast<getter>(MacAlgorithmNames_get_HmacMd5), nullptr, nullptr, nullptr },
        { "hmac_sha1", reinterpret_cast<getter>(MacAlgorithmNames_get_HmacSha1), nullptr, nullptr, nullptr },
        { "hmac_sha256", reinterpret_cast<getter>(MacAlgorithmNames_get_HmacSha256), nullptr, nullptr, nullptr },
        { "hmac_sha384", reinterpret_cast<getter>(MacAlgorithmNames_get_HmacSha384), nullptr, nullptr, nullptr },
        { "hmac_sha512", reinterpret_cast<getter>(MacAlgorithmNames_get_HmacSha512), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_MacAlgorithmNames_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MacAlgorithmNames_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MacAlgorithmNames_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MacAlgorithmNames_Static) },
        { }
    };

    static PyType_Spec type_spec_MacAlgorithmNames_Static =
    {
        "winrt._winrt_windows_security_cryptography_core.MacAlgorithmNames_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MacAlgorithmNames_Static
    };

    // ----- MacAlgorithmProvider class --------------------

    static PyObject* _new_MacAlgorithmProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Cryptography::Core::MacAlgorithmProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Cryptography::Core::MacAlgorithmProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_MacAlgorithmProvider(py::wrapper::Windows::Security::Cryptography::Core::MacAlgorithmProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MacAlgorithmProvider_CreateHash(py::wrapper::Windows::Security::Cryptography::Core::MacAlgorithmProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.MacAlgorithmProvider", L"CreateHash", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.CreateHash(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmProvider_CreateKey(py::wrapper::Windows::Security::Cryptography::Core::MacAlgorithmProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.MacAlgorithmProvider", L"CreateKey", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.CreateKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmProvider_OpenAlgorithm(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.MacAlgorithmProvider", L"OpenAlgorithm", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Core::MacAlgorithmProvider::OpenAlgorithm(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmProvider_get_AlgorithmName(py::wrapper::Windows::Security::Cryptography::Core::MacAlgorithmProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.MacAlgorithmProvider", L"AlgorithmName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmProvider_get_MacLength(py::wrapper::Windows::Security::Cryptography::Core::MacAlgorithmProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.MacAlgorithmProvider", L"MacLength"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MacLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MacAlgorithmProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Core::MacAlgorithmProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MacAlgorithmProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::MacAlgorithmProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MacAlgorithmProvider[] = {
        { "create_hash", reinterpret_cast<PyCFunction>(MacAlgorithmProvider_CreateHash), METH_VARARGS, nullptr },
        { "create_key", reinterpret_cast<PyCFunction>(MacAlgorithmProvider_CreateKey), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MacAlgorithmProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MacAlgorithmProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MacAlgorithmProvider[] = {
        { "algorithm_name", reinterpret_cast<getter>(MacAlgorithmProvider_get_AlgorithmName), nullptr, nullptr, nullptr },
        { "mac_length", reinterpret_cast<getter>(MacAlgorithmProvider_get_MacLength), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MacAlgorithmProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MacAlgorithmProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MacAlgorithmProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MacAlgorithmProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MacAlgorithmProvider) },
        { }
    };

    static PyType_Spec type_spec_MacAlgorithmProvider = {
        "winrt._winrt_windows_security_cryptography_core.MacAlgorithmProvider",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::MacAlgorithmProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MacAlgorithmProvider};

    static PyGetSetDef getset_MacAlgorithmProvider_Static[] = {
        { }
    };

    static PyMethodDef methods_MacAlgorithmProvider_Static[] = {
        { "open_algorithm", reinterpret_cast<PyCFunction>(MacAlgorithmProvider_OpenAlgorithm), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_MacAlgorithmProvider_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MacAlgorithmProvider_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MacAlgorithmProvider_Static) },
        { }
    };

    static PyType_Spec type_spec_MacAlgorithmProvider_Static =
    {
        "winrt._winrt_windows_security_cryptography_core.MacAlgorithmProvider_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MacAlgorithmProvider_Static
    };

    // ----- PersistedKeyProvider class --------------------

    static PyObject* _new_PersistedKeyProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Cryptography::Core::PersistedKeyProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Cryptography::Core::PersistedKeyProvider>::type_name);
        return nullptr;
    }

    static PyObject* PersistedKeyProvider_OpenKeyPairFromCertificateAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.PersistedKeyProvider", L"OpenKeyPairFromCertificateAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicPadding>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Core::PersistedKeyProvider::OpenKeyPairFromCertificateAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PersistedKeyProvider_OpenPublicKeyFromCertificate(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.PersistedKeyProvider", L"OpenPublicKeyFromCertificate", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicPadding>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Core::PersistedKeyProvider::OpenPublicKeyFromCertificate(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_PersistedKeyProvider[] = {
        { }
    };

    static PyGetSetDef _getset_PersistedKeyProvider[] = {
        { }
    };

    static PyType_Slot _type_slots_PersistedKeyProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PersistedKeyProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PersistedKeyProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PersistedKeyProvider) },
        { }
    };

    static PyType_Spec type_spec_PersistedKeyProvider = {
        "winrt._winrt_windows_security_cryptography_core.PersistedKeyProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PersistedKeyProvider};

    static PyGetSetDef getset_PersistedKeyProvider_Static[] = {
        { }
    };

    static PyMethodDef methods_PersistedKeyProvider_Static[] = {
        { "open_key_pair_from_certificate_async", reinterpret_cast<PyCFunction>(PersistedKeyProvider_OpenKeyPairFromCertificateAsync), METH_VARARGS, nullptr },
        { "open_public_key_from_certificate", reinterpret_cast<PyCFunction>(PersistedKeyProvider_OpenPublicKeyFromCertificate), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_PersistedKeyProvider_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PersistedKeyProvider_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PersistedKeyProvider_Static) },
        { }
    };

    static PyType_Spec type_spec_PersistedKeyProvider_Static =
    {
        "winrt._winrt_windows_security_cryptography_core.PersistedKeyProvider_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PersistedKeyProvider_Static
    };

    // ----- SymmetricAlgorithmNames class --------------------

    static PyObject* _new_SymmetricAlgorithmNames(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames>::type_name);
        return nullptr;
    }

    static PyObject* SymmetricAlgorithmNames_get_AesCbc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"AesCbc"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::AesCbc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_AesCbcPkcs7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"AesCbcPkcs7"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::AesCbcPkcs7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_AesCcm(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"AesCcm"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::AesCcm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_AesEcb(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"AesEcb"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::AesEcb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_AesEcbPkcs7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"AesEcbPkcs7"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::AesEcbPkcs7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_AesGcm(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"AesGcm"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::AesGcm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_DesCbc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"DesCbc"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::DesCbc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_DesCbcPkcs7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"DesCbcPkcs7"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::DesCbcPkcs7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_DesEcb(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"DesEcb"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::DesEcb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_DesEcbPkcs7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"DesEcbPkcs7"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::DesEcbPkcs7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_Rc2Cbc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"Rc2Cbc"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::Rc2Cbc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_Rc2CbcPkcs7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"Rc2CbcPkcs7"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::Rc2CbcPkcs7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_Rc2Ecb(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"Rc2Ecb"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::Rc2Ecb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_Rc2EcbPkcs7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"Rc2EcbPkcs7"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::Rc2EcbPkcs7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_Rc4(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"Rc4"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::Rc4());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_TripleDesCbc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"TripleDesCbc"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::TripleDesCbc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_TripleDesCbcPkcs7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"TripleDesCbcPkcs7"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::TripleDesCbcPkcs7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_TripleDesEcb(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"TripleDesEcb"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::TripleDesEcb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_TripleDesEcbPkcs7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricAlgorithmNames", L"TripleDesEcbPkcs7"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::TripleDesEcbPkcs7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SymmetricAlgorithmNames[] = {
        { }
    };

    static PyGetSetDef _getset_SymmetricAlgorithmNames[] = {
        { }
    };

    static PyType_Slot _type_slots_SymmetricAlgorithmNames[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SymmetricAlgorithmNames) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SymmetricAlgorithmNames) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SymmetricAlgorithmNames) },
        { }
    };

    static PyType_Spec type_spec_SymmetricAlgorithmNames = {
        "winrt._winrt_windows_security_cryptography_core.SymmetricAlgorithmNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SymmetricAlgorithmNames};

    static PyGetSetDef getset_SymmetricAlgorithmNames_Static[] = {
        { "aes_cbc", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_AesCbc), nullptr, nullptr, nullptr },
        { "aes_cbc_pkcs7", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_AesCbcPkcs7), nullptr, nullptr, nullptr },
        { "aes_ccm", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_AesCcm), nullptr, nullptr, nullptr },
        { "aes_ecb", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_AesEcb), nullptr, nullptr, nullptr },
        { "aes_ecb_pkcs7", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_AesEcbPkcs7), nullptr, nullptr, nullptr },
        { "aes_gcm", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_AesGcm), nullptr, nullptr, nullptr },
        { "des_cbc", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_DesCbc), nullptr, nullptr, nullptr },
        { "des_cbc_pkcs7", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_DesCbcPkcs7), nullptr, nullptr, nullptr },
        { "des_ecb", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_DesEcb), nullptr, nullptr, nullptr },
        { "des_ecb_pkcs7", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_DesEcbPkcs7), nullptr, nullptr, nullptr },
        { "rc2_cbc", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_Rc2Cbc), nullptr, nullptr, nullptr },
        { "rc2_cbc_pkcs7", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_Rc2CbcPkcs7), nullptr, nullptr, nullptr },
        { "rc2_ecb", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_Rc2Ecb), nullptr, nullptr, nullptr },
        { "rc2_ecb_pkcs7", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_Rc2EcbPkcs7), nullptr, nullptr, nullptr },
        { "rc4", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_Rc4), nullptr, nullptr, nullptr },
        { "triple_des_cbc", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_TripleDesCbc), nullptr, nullptr, nullptr },
        { "triple_des_cbc_pkcs7", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_TripleDesCbcPkcs7), nullptr, nullptr, nullptr },
        { "triple_des_ecb", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_TripleDesEcb), nullptr, nullptr, nullptr },
        { "triple_des_ecb_pkcs7", reinterpret_cast<getter>(SymmetricAlgorithmNames_get_TripleDesEcbPkcs7), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_SymmetricAlgorithmNames_Static[] = {
        { }
    };

    static PyType_Slot type_slots_SymmetricAlgorithmNames_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SymmetricAlgorithmNames_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SymmetricAlgorithmNames_Static) },
        { }
    };

    static PyType_Spec type_spec_SymmetricAlgorithmNames_Static =
    {
        "winrt._winrt_windows_security_cryptography_core.SymmetricAlgorithmNames_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SymmetricAlgorithmNames_Static
    };

    // ----- SymmetricKeyAlgorithmProvider class --------------------

    static PyObject* _new_SymmetricKeyAlgorithmProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_SymmetricKeyAlgorithmProvider(py::wrapper::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SymmetricKeyAlgorithmProvider_CreateSymmetricKey(py::wrapper::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.SymmetricKeyAlgorithmProvider", L"CreateSymmetricKey", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.CreateSymmetricKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SymmetricKeyAlgorithmProvider_OpenAlgorithm(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Security.Cryptography.Core.SymmetricKeyAlgorithmProvider", L"OpenAlgorithm", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider::OpenAlgorithm(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SymmetricKeyAlgorithmProvider_get_AlgorithmName(py::wrapper::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricKeyAlgorithmProvider", L"AlgorithmName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricKeyAlgorithmProvider_get_BlockLength(py::wrapper::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Security.Cryptography.Core.SymmetricKeyAlgorithmProvider", L"BlockLength"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BlockLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SymmetricKeyAlgorithmProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SymmetricKeyAlgorithmProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SymmetricKeyAlgorithmProvider[] = {
        { "create_symmetric_key", reinterpret_cast<PyCFunction>(SymmetricKeyAlgorithmProvider_CreateSymmetricKey), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SymmetricKeyAlgorithmProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SymmetricKeyAlgorithmProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SymmetricKeyAlgorithmProvider[] = {
        { "algorithm_name", reinterpret_cast<getter>(SymmetricKeyAlgorithmProvider_get_AlgorithmName), nullptr, nullptr, nullptr },
        { "block_length", reinterpret_cast<getter>(SymmetricKeyAlgorithmProvider_get_BlockLength), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SymmetricKeyAlgorithmProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SymmetricKeyAlgorithmProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SymmetricKeyAlgorithmProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SymmetricKeyAlgorithmProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SymmetricKeyAlgorithmProvider) },
        { }
    };

    static PyType_Spec type_spec_SymmetricKeyAlgorithmProvider = {
        "winrt._winrt_windows_security_cryptography_core.SymmetricKeyAlgorithmProvider",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SymmetricKeyAlgorithmProvider};

    static PyGetSetDef getset_SymmetricKeyAlgorithmProvider_Static[] = {
        { }
    };

    static PyMethodDef methods_SymmetricKeyAlgorithmProvider_Static[] = {
        { "open_algorithm", reinterpret_cast<PyCFunction>(SymmetricKeyAlgorithmProvider_OpenAlgorithm), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_SymmetricKeyAlgorithmProvider_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SymmetricKeyAlgorithmProvider_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SymmetricKeyAlgorithmProvider_Static) },
        { }
    };

    static PyType_Spec type_spec_SymmetricKeyAlgorithmProvider_Static =
    {
        "winrt._winrt_windows_security_cryptography_core.SymmetricKeyAlgorithmProvider_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SymmetricKeyAlgorithmProvider_Static
    };

    // ----- Windows.Security.Cryptography.Core Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Security.Cryptography.Core");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_security_cryptography_core",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Security::Cryptography::Core

PyMODINIT_FUNC PyInit__winrt_windows_security_cryptography_core(void) noexcept
{
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AsymmetricAlgorithmNames_Static{PyType_FromSpec(&type_spec_AsymmetricAlgorithmNames_Static)};
    if (!type_AsymmetricAlgorithmNames_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AsymmetricAlgorithmNames, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AsymmetricAlgorithmNames_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_AsymmetricKeyAlgorithmProvider_Static{PyType_FromSpec(&type_spec_AsymmetricKeyAlgorithmProvider_Static)};
    if (!type_AsymmetricKeyAlgorithmProvider_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AsymmetricKeyAlgorithmProvider, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AsymmetricKeyAlgorithmProvider_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_CryptographicEngine_Static{PyType_FromSpec(&type_spec_CryptographicEngine_Static)};
    if (!type_CryptographicEngine_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CryptographicEngine, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CryptographicEngine_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CryptographicHash, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CryptographicKey, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_EccCurveNames_Static{PyType_FromSpec(&type_spec_EccCurveNames_Static)};
    if (!type_EccCurveNames_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EccCurveNames, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_EccCurveNames_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EncryptedAndAuthenticatedData, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_HashAlgorithmNames_Static{PyType_FromSpec(&type_spec_HashAlgorithmNames_Static)};
    if (!type_HashAlgorithmNames_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HashAlgorithmNames, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HashAlgorithmNames_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_HashAlgorithmProvider_Static{PyType_FromSpec(&type_spec_HashAlgorithmProvider_Static)};
    if (!type_HashAlgorithmProvider_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HashAlgorithmProvider, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HashAlgorithmProvider_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_KeyDerivationAlgorithmNames_Static{PyType_FromSpec(&type_spec_KeyDerivationAlgorithmNames_Static)};
    if (!type_KeyDerivationAlgorithmNames_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_KeyDerivationAlgorithmNames, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KeyDerivationAlgorithmNames_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_KeyDerivationAlgorithmProvider_Static{PyType_FromSpec(&type_spec_KeyDerivationAlgorithmProvider_Static)};
    if (!type_KeyDerivationAlgorithmProvider_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_KeyDerivationAlgorithmProvider, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KeyDerivationAlgorithmProvider_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_KeyDerivationParameters_Static{PyType_FromSpec(&type_spec_KeyDerivationParameters_Static)};
    if (!type_KeyDerivationParameters_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_KeyDerivationParameters, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KeyDerivationParameters_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MacAlgorithmNames_Static{PyType_FromSpec(&type_spec_MacAlgorithmNames_Static)};
    if (!type_MacAlgorithmNames_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MacAlgorithmNames, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MacAlgorithmNames_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MacAlgorithmProvider_Static{PyType_FromSpec(&type_spec_MacAlgorithmProvider_Static)};
    if (!type_MacAlgorithmProvider_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MacAlgorithmProvider, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MacAlgorithmProvider_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_PersistedKeyProvider_Static{PyType_FromSpec(&type_spec_PersistedKeyProvider_Static)};
    if (!type_PersistedKeyProvider_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PersistedKeyProvider, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PersistedKeyProvider_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SymmetricAlgorithmNames_Static{PyType_FromSpec(&type_spec_SymmetricAlgorithmNames_Static)};
    if (!type_SymmetricAlgorithmNames_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SymmetricAlgorithmNames, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SymmetricAlgorithmNames_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SymmetricKeyAlgorithmProvider_Static{PyType_FromSpec(&type_spec_SymmetricKeyAlgorithmProvider_Static)};
    if (!type_SymmetricKeyAlgorithmProvider_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SymmetricKeyAlgorithmProvider, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SymmetricKeyAlgorithmProvider_Static.get())) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
