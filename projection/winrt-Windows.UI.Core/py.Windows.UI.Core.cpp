// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.UI.Core.h"

namespace py::cpp::Windows::UI::Core
{
    // ----- AcceleratorKeyEventArgs class --------------------

    static PyObject* _new_AcceleratorKeyEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::AcceleratorKeyEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::AcceleratorKeyEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AcceleratorKeyEventArgs(py::wrapper::Windows::UI::Core::AcceleratorKeyEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AcceleratorKeyEventArgs_get_EventType(py::wrapper::Windows::UI::Core::AcceleratorKeyEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.AcceleratorKeyEventArgs", L"EventType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EventType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AcceleratorKeyEventArgs_get_KeyStatus(py::wrapper::Windows::UI::Core::AcceleratorKeyEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.AcceleratorKeyEventArgs", L"KeyStatus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AcceleratorKeyEventArgs_get_VirtualKey(py::wrapper::Windows::UI::Core::AcceleratorKeyEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.AcceleratorKeyEventArgs", L"VirtualKey"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VirtualKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AcceleratorKeyEventArgs_get_DeviceId(py::wrapper::Windows::UI::Core::AcceleratorKeyEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.AcceleratorKeyEventArgs", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AcceleratorKeyEventArgs_get_Handled(py::wrapper::Windows::UI::Core::AcceleratorKeyEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.AcceleratorKeyEventArgs", L"Handled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AcceleratorKeyEventArgs_put_Handled(py::wrapper::Windows::UI::Core::AcceleratorKeyEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.AcceleratorKeyEventArgs", L"Handled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AcceleratorKeyEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::AcceleratorKeyEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AcceleratorKeyEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::AcceleratorKeyEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AcceleratorKeyEventArgs[] = {
        { "_assign_array_", _assign_array_AcceleratorKeyEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AcceleratorKeyEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AcceleratorKeyEventArgs[] = {
        { "event_type", reinterpret_cast<getter>(AcceleratorKeyEventArgs_get_EventType), nullptr, nullptr, nullptr },
        { "key_status", reinterpret_cast<getter>(AcceleratorKeyEventArgs_get_KeyStatus), nullptr, nullptr, nullptr },
        { "virtual_key", reinterpret_cast<getter>(AcceleratorKeyEventArgs_get_VirtualKey), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(AcceleratorKeyEventArgs_get_DeviceId), nullptr, nullptr, nullptr },
        { "handled", reinterpret_cast<getter>(AcceleratorKeyEventArgs_get_Handled), reinterpret_cast<setter>(AcceleratorKeyEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AcceleratorKeyEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AcceleratorKeyEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AcceleratorKeyEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AcceleratorKeyEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AcceleratorKeyEventArgs) },
        { }
    };

    static PyType_Spec type_spec_AcceleratorKeyEventArgs = {
        "winrt._winrt_windows_ui_core.AcceleratorKeyEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::AcceleratorKeyEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AcceleratorKeyEventArgs};

    // ----- AutomationProviderRequestedEventArgs class --------------------

    static PyObject* _new_AutomationProviderRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::AutomationProviderRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::AutomationProviderRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AutomationProviderRequestedEventArgs(py::wrapper::Windows::UI::Core::AutomationProviderRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AutomationProviderRequestedEventArgs_get_AutomationProvider(py::wrapper::Windows::UI::Core::AutomationProviderRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.AutomationProviderRequestedEventArgs", L"AutomationProvider"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AutomationProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutomationProviderRequestedEventArgs_put_AutomationProvider(py::wrapper::Windows::UI::Core::AutomationProviderRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.AutomationProviderRequestedEventArgs", L"AutomationProvider"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.AutomationProvider(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutomationProviderRequestedEventArgs_get_Handled(py::wrapper::Windows::UI::Core::AutomationProviderRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.AutomationProviderRequestedEventArgs", L"Handled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutomationProviderRequestedEventArgs_put_Handled(py::wrapper::Windows::UI::Core::AutomationProviderRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.AutomationProviderRequestedEventArgs", L"Handled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AutomationProviderRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::AutomationProviderRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AutomationProviderRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::AutomationProviderRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AutomationProviderRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_AutomationProviderRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AutomationProviderRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AutomationProviderRequestedEventArgs[] = {
        { "automation_provider", reinterpret_cast<getter>(AutomationProviderRequestedEventArgs_get_AutomationProvider), reinterpret_cast<setter>(AutomationProviderRequestedEventArgs_put_AutomationProvider), nullptr, nullptr },
        { "handled", reinterpret_cast<getter>(AutomationProviderRequestedEventArgs_get_Handled), reinterpret_cast<setter>(AutomationProviderRequestedEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AutomationProviderRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AutomationProviderRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AutomationProviderRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AutomationProviderRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AutomationProviderRequestedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_AutomationProviderRequestedEventArgs = {
        "winrt._winrt_windows_ui_core.AutomationProviderRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::AutomationProviderRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutomationProviderRequestedEventArgs};

    // ----- BackRequestedEventArgs class --------------------

    static PyObject* _new_BackRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::BackRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::BackRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_BackRequestedEventArgs(py::wrapper::Windows::UI::Core::BackRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackRequestedEventArgs_get_Handled(py::wrapper::Windows::UI::Core::BackRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.BackRequestedEventArgs", L"Handled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackRequestedEventArgs_put_Handled(py::wrapper::Windows::UI::Core::BackRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.BackRequestedEventArgs", L"Handled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_BackRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::BackRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::BackRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_BackRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackRequestedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(BackRequestedEventArgs_get_Handled), reinterpret_cast<setter>(BackRequestedEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackRequestedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_BackRequestedEventArgs = {
        "winrt._winrt_windows_ui_core.BackRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::BackRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackRequestedEventArgs};

    // ----- CharacterReceivedEventArgs class --------------------

    static PyObject* _new_CharacterReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::CharacterReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::CharacterReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CharacterReceivedEventArgs(py::wrapper::Windows::UI::Core::CharacterReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CharacterReceivedEventArgs_get_KeyCode(py::wrapper::Windows::UI::Core::CharacterReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CharacterReceivedEventArgs", L"KeyCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CharacterReceivedEventArgs_get_KeyStatus(py::wrapper::Windows::UI::Core::CharacterReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CharacterReceivedEventArgs", L"KeyStatus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CharacterReceivedEventArgs_get_Handled(py::wrapper::Windows::UI::Core::CharacterReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CharacterReceivedEventArgs", L"Handled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CharacterReceivedEventArgs_put_Handled(py::wrapper::Windows::UI::Core::CharacterReceivedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CharacterReceivedEventArgs", L"Handled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CharacterReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::CharacterReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CharacterReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::CharacterReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CharacterReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_CharacterReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CharacterReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CharacterReceivedEventArgs[] = {
        { "key_code", reinterpret_cast<getter>(CharacterReceivedEventArgs_get_KeyCode), nullptr, nullptr, nullptr },
        { "key_status", reinterpret_cast<getter>(CharacterReceivedEventArgs_get_KeyStatus), nullptr, nullptr, nullptr },
        { "handled", reinterpret_cast<getter>(CharacterReceivedEventArgs_get_Handled), reinterpret_cast<setter>(CharacterReceivedEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CharacterReceivedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CharacterReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CharacterReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CharacterReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CharacterReceivedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_CharacterReceivedEventArgs = {
        "winrt._winrt_windows_ui_core.CharacterReceivedEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::CharacterReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CharacterReceivedEventArgs};

    // ----- ClosestInteractiveBoundsRequestedEventArgs class --------------------

    static PyObject* _new_ClosestInteractiveBoundsRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::ClosestInteractiveBoundsRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::ClosestInteractiveBoundsRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ClosestInteractiveBoundsRequestedEventArgs(py::wrapper::Windows::UI::Core::ClosestInteractiveBoundsRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ClosestInteractiveBoundsRequestedEventArgs_get_ClosestInteractiveBounds(py::wrapper::Windows::UI::Core::ClosestInteractiveBoundsRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ClosestInteractiveBoundsRequestedEventArgs", L"ClosestInteractiveBounds"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ClosestInteractiveBounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClosestInteractiveBoundsRequestedEventArgs_put_ClosestInteractiveBounds(py::wrapper::Windows::UI::Core::ClosestInteractiveBoundsRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ClosestInteractiveBoundsRequestedEventArgs", L"ClosestInteractiveBounds"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            self->obj.ClosestInteractiveBounds(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClosestInteractiveBoundsRequestedEventArgs_get_PointerPosition(py::wrapper::Windows::UI::Core::ClosestInteractiveBoundsRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ClosestInteractiveBoundsRequestedEventArgs", L"PointerPosition"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PointerPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClosestInteractiveBoundsRequestedEventArgs_get_SearchBounds(py::wrapper::Windows::UI::Core::ClosestInteractiveBoundsRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ClosestInteractiveBoundsRequestedEventArgs", L"SearchBounds"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SearchBounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ClosestInteractiveBoundsRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::ClosestInteractiveBoundsRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ClosestInteractiveBoundsRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::ClosestInteractiveBoundsRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClosestInteractiveBoundsRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_ClosestInteractiveBoundsRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClosestInteractiveBoundsRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClosestInteractiveBoundsRequestedEventArgs[] = {
        { "closest_interactive_bounds", reinterpret_cast<getter>(ClosestInteractiveBoundsRequestedEventArgs_get_ClosestInteractiveBounds), reinterpret_cast<setter>(ClosestInteractiveBoundsRequestedEventArgs_put_ClosestInteractiveBounds), nullptr, nullptr },
        { "pointer_position", reinterpret_cast<getter>(ClosestInteractiveBoundsRequestedEventArgs_get_PointerPosition), nullptr, nullptr, nullptr },
        { "search_bounds", reinterpret_cast<getter>(ClosestInteractiveBoundsRequestedEventArgs_get_SearchBounds), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ClosestInteractiveBoundsRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClosestInteractiveBoundsRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ClosestInteractiveBoundsRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClosestInteractiveBoundsRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClosestInteractiveBoundsRequestedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ClosestInteractiveBoundsRequestedEventArgs = {
        "winrt._winrt_windows_ui_core.ClosestInteractiveBoundsRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::ClosestInteractiveBoundsRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClosestInteractiveBoundsRequestedEventArgs};

    // ----- CoreAcceleratorKeys class --------------------

    static PyObject* _new_CoreAcceleratorKeys(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::CoreAcceleratorKeys>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::CoreAcceleratorKeys>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreAcceleratorKeys(py::wrapper::Windows::UI::Core::CoreAcceleratorKeys* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreAcceleratorKeys_add_AcceleratorKeyActivated(py::wrapper::Windows::UI::Core::CoreAcceleratorKeys* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreAcceleratorKeys", L"AcceleratorKeyActivated"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreDispatcher, winrt::Windows::UI::Core::AcceleratorKeyEventArgs>>(arg);

            return py::convert(self->obj.AcceleratorKeyActivated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreAcceleratorKeys_remove_AcceleratorKeyActivated(py::wrapper::Windows::UI::Core::CoreAcceleratorKeys* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreAcceleratorKeys", L"AcceleratorKeyActivated"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AcceleratorKeyActivated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreAcceleratorKeys(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::CoreAcceleratorKeys>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreAcceleratorKeys(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::CoreAcceleratorKeys>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreAcceleratorKeys[] = {
        { "add_accelerator_key_activated", reinterpret_cast<PyCFunction>(CoreAcceleratorKeys_add_AcceleratorKeyActivated), METH_O, nullptr },
        { "remove_accelerator_key_activated", reinterpret_cast<PyCFunction>(CoreAcceleratorKeys_remove_AcceleratorKeyActivated), METH_O, nullptr },
        { "_assign_array_", _assign_array_CoreAcceleratorKeys, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreAcceleratorKeys), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreAcceleratorKeys[] = {
        { }
    };

    static PyType_Slot _type_slots_CoreAcceleratorKeys[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreAcceleratorKeys) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreAcceleratorKeys) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreAcceleratorKeys) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreAcceleratorKeys) },
        { }
    };

    static PyType_Spec type_spec_CoreAcceleratorKeys = {
        "winrt._winrt_windows_ui_core.CoreAcceleratorKeys",
        sizeof(py::wrapper::Windows::UI::Core::CoreAcceleratorKeys),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreAcceleratorKeys};

    // ----- CoreComponentInputSource class --------------------

    static PyObject* _new_CoreComponentInputSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::CoreComponentInputSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::CoreComponentInputSource>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreComponentInputSource(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreComponentInputSource_GetCurrentKeyEventDeviceId(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreComponentInputSource", L"GetCurrentKeyEventDeviceId", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetCurrentKeyEventDeviceId());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_GetCurrentKeyState(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreComponentInputSource", L"GetCurrentKeyState", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::VirtualKey>(args, 0);

                return py::convert(self->obj.GetCurrentKeyState(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_ReleasePointerCapture(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreComponentInputSource", L"ReleasePointerCapture", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ReleasePointerCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_SetPointerCapture(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreComponentInputSource", L"SetPointerCapture", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.SetPointerCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_get_HasFocus(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreComponentInputSource", L"HasFocus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HasFocus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_get_IsInputEnabled(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreComponentInputSource", L"IsInputEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsInputEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreComponentInputSource_put_IsInputEnabled(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreComponentInputSource", L"IsInputEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsInputEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreComponentInputSource_get_Dispatcher(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreComponentInputSource", L"Dispatcher"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_get_PointerCursor(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerCursor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PointerCursor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreComponentInputSource_put_PointerCursor(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerCursor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreCursor>(arg);

            self->obj.PointerCursor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreComponentInputSource_get_HasCapture(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreComponentInputSource", L"HasCapture"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HasCapture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_get_PointerPosition(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerPosition"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PointerPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_get_DispatcherQueue(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreComponentInputSource", L"DispatcherQueue"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DispatcherQueue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_add_InputEnabled(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"InputEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::InputEnabledEventArgs>>(arg);

            return py::convert(self->obj.InputEnabled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_remove_InputEnabled(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"InputEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.InputEnabled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_add_PointerCaptureLost(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerCaptureLost"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerCaptureLost(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_remove_PointerCaptureLost(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerCaptureLost"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerCaptureLost(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_add_PointerEntered(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerEntered"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerEntered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_remove_PointerEntered(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerEntered"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerEntered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_add_PointerExited(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerExited"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerExited(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_remove_PointerExited(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerExited"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerExited(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_add_PointerMoved(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerMoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerMoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_remove_PointerMoved(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerMoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerMoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_add_PointerPressed(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerPressed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_remove_PointerPressed(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerPressed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_add_PointerReleased(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerReleased"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerReleased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_remove_PointerReleased(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerReleased"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerReleased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_add_PointerWheelChanged(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerWheelChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerWheelChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_remove_PointerWheelChanged(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"PointerWheelChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerWheelChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_add_CharacterReceived(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"CharacterReceived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::CharacterReceivedEventArgs>>(arg);

            return py::convert(self->obj.CharacterReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_remove_CharacterReceived(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"CharacterReceived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CharacterReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_add_KeyDown(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"KeyDown"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::KeyEventArgs>>(arg);

            return py::convert(self->obj.KeyDown(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_remove_KeyDown(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"KeyDown"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.KeyDown(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_add_KeyUp(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"KeyUp"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::KeyEventArgs>>(arg);

            return py::convert(self->obj.KeyUp(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_remove_KeyUp(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"KeyUp"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.KeyUp(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_add_GotFocus(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"GotFocus"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::CoreWindowEventArgs>>(arg);

            return py::convert(self->obj.GotFocus(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_remove_GotFocus(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"GotFocus"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.GotFocus(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_add_LostFocus(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"LostFocus"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::CoreWindowEventArgs>>(arg);

            return py::convert(self->obj.LostFocus(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_remove_LostFocus(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"LostFocus"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LostFocus(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_add_TouchHitTesting(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"TouchHitTesting"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::TouchHitTestingEventArgs>>(arg);

            return py::convert(self->obj.TouchHitTesting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_remove_TouchHitTesting(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"TouchHitTesting"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TouchHitTesting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_add_ClosestInteractiveBoundsRequested(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"ClosestInteractiveBoundsRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreComponentInputSource, winrt::Windows::UI::Core::ClosestInteractiveBoundsRequestedEventArgs>>(arg);

            return py::convert(self->obj.ClosestInteractiveBoundsRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreComponentInputSource_remove_ClosestInteractiveBoundsRequested(py::wrapper::Windows::UI::Core::CoreComponentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreComponentInputSource", L"ClosestInteractiveBoundsRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ClosestInteractiveBoundsRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreComponentInputSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::CoreComponentInputSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreComponentInputSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::CoreComponentInputSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreComponentInputSource[] = {
        { "get_current_key_event_device_id", reinterpret_cast<PyCFunction>(CoreComponentInputSource_GetCurrentKeyEventDeviceId), METH_VARARGS, nullptr },
        { "get_current_key_state", reinterpret_cast<PyCFunction>(CoreComponentInputSource_GetCurrentKeyState), METH_VARARGS, nullptr },
        { "release_pointer_capture", reinterpret_cast<PyCFunction>(CoreComponentInputSource_ReleasePointerCapture), METH_VARARGS, nullptr },
        { "set_pointer_capture", reinterpret_cast<PyCFunction>(CoreComponentInputSource_SetPointerCapture), METH_VARARGS, nullptr },
        { "add_input_enabled", reinterpret_cast<PyCFunction>(CoreComponentInputSource_add_InputEnabled), METH_O, nullptr },
        { "remove_input_enabled", reinterpret_cast<PyCFunction>(CoreComponentInputSource_remove_InputEnabled), METH_O, nullptr },
        { "add_pointer_capture_lost", reinterpret_cast<PyCFunction>(CoreComponentInputSource_add_PointerCaptureLost), METH_O, nullptr },
        { "remove_pointer_capture_lost", reinterpret_cast<PyCFunction>(CoreComponentInputSource_remove_PointerCaptureLost), METH_O, nullptr },
        { "add_pointer_entered", reinterpret_cast<PyCFunction>(CoreComponentInputSource_add_PointerEntered), METH_O, nullptr },
        { "remove_pointer_entered", reinterpret_cast<PyCFunction>(CoreComponentInputSource_remove_PointerEntered), METH_O, nullptr },
        { "add_pointer_exited", reinterpret_cast<PyCFunction>(CoreComponentInputSource_add_PointerExited), METH_O, nullptr },
        { "remove_pointer_exited", reinterpret_cast<PyCFunction>(CoreComponentInputSource_remove_PointerExited), METH_O, nullptr },
        { "add_pointer_moved", reinterpret_cast<PyCFunction>(CoreComponentInputSource_add_PointerMoved), METH_O, nullptr },
        { "remove_pointer_moved", reinterpret_cast<PyCFunction>(CoreComponentInputSource_remove_PointerMoved), METH_O, nullptr },
        { "add_pointer_pressed", reinterpret_cast<PyCFunction>(CoreComponentInputSource_add_PointerPressed), METH_O, nullptr },
        { "remove_pointer_pressed", reinterpret_cast<PyCFunction>(CoreComponentInputSource_remove_PointerPressed), METH_O, nullptr },
        { "add_pointer_released", reinterpret_cast<PyCFunction>(CoreComponentInputSource_add_PointerReleased), METH_O, nullptr },
        { "remove_pointer_released", reinterpret_cast<PyCFunction>(CoreComponentInputSource_remove_PointerReleased), METH_O, nullptr },
        { "add_pointer_wheel_changed", reinterpret_cast<PyCFunction>(CoreComponentInputSource_add_PointerWheelChanged), METH_O, nullptr },
        { "remove_pointer_wheel_changed", reinterpret_cast<PyCFunction>(CoreComponentInputSource_remove_PointerWheelChanged), METH_O, nullptr },
        { "add_character_received", reinterpret_cast<PyCFunction>(CoreComponentInputSource_add_CharacterReceived), METH_O, nullptr },
        { "remove_character_received", reinterpret_cast<PyCFunction>(CoreComponentInputSource_remove_CharacterReceived), METH_O, nullptr },
        { "add_key_down", reinterpret_cast<PyCFunction>(CoreComponentInputSource_add_KeyDown), METH_O, nullptr },
        { "remove_key_down", reinterpret_cast<PyCFunction>(CoreComponentInputSource_remove_KeyDown), METH_O, nullptr },
        { "add_key_up", reinterpret_cast<PyCFunction>(CoreComponentInputSource_add_KeyUp), METH_O, nullptr },
        { "remove_key_up", reinterpret_cast<PyCFunction>(CoreComponentInputSource_remove_KeyUp), METH_O, nullptr },
        { "add_got_focus", reinterpret_cast<PyCFunction>(CoreComponentInputSource_add_GotFocus), METH_O, nullptr },
        { "remove_got_focus", reinterpret_cast<PyCFunction>(CoreComponentInputSource_remove_GotFocus), METH_O, nullptr },
        { "add_lost_focus", reinterpret_cast<PyCFunction>(CoreComponentInputSource_add_LostFocus), METH_O, nullptr },
        { "remove_lost_focus", reinterpret_cast<PyCFunction>(CoreComponentInputSource_remove_LostFocus), METH_O, nullptr },
        { "add_touch_hit_testing", reinterpret_cast<PyCFunction>(CoreComponentInputSource_add_TouchHitTesting), METH_O, nullptr },
        { "remove_touch_hit_testing", reinterpret_cast<PyCFunction>(CoreComponentInputSource_remove_TouchHitTesting), METH_O, nullptr },
        { "add_closest_interactive_bounds_requested", reinterpret_cast<PyCFunction>(CoreComponentInputSource_add_ClosestInteractiveBoundsRequested), METH_O, nullptr },
        { "remove_closest_interactive_bounds_requested", reinterpret_cast<PyCFunction>(CoreComponentInputSource_remove_ClosestInteractiveBoundsRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_CoreComponentInputSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreComponentInputSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreComponentInputSource[] = {
        { "has_focus", reinterpret_cast<getter>(CoreComponentInputSource_get_HasFocus), nullptr, nullptr, nullptr },
        { "is_input_enabled", reinterpret_cast<getter>(CoreComponentInputSource_get_IsInputEnabled), reinterpret_cast<setter>(CoreComponentInputSource_put_IsInputEnabled), nullptr, nullptr },
        { "dispatcher", reinterpret_cast<getter>(CoreComponentInputSource_get_Dispatcher), nullptr, nullptr, nullptr },
        { "pointer_cursor", reinterpret_cast<getter>(CoreComponentInputSource_get_PointerCursor), reinterpret_cast<setter>(CoreComponentInputSource_put_PointerCursor), nullptr, nullptr },
        { "has_capture", reinterpret_cast<getter>(CoreComponentInputSource_get_HasCapture), nullptr, nullptr, nullptr },
        { "pointer_position", reinterpret_cast<getter>(CoreComponentInputSource_get_PointerPosition), nullptr, nullptr, nullptr },
        { "dispatcher_queue", reinterpret_cast<getter>(CoreComponentInputSource_get_DispatcherQueue), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreComponentInputSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreComponentInputSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreComponentInputSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreComponentInputSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreComponentInputSource) },
        { }
    };

    static PyType_Spec type_spec_CoreComponentInputSource = {
        "winrt._winrt_windows_ui_core.CoreComponentInputSource",
        sizeof(py::wrapper::Windows::UI::Core::CoreComponentInputSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreComponentInputSource};

    // ----- CoreCursor class --------------------

    static PyObject* _new_CoreCursor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreCursorType>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                winrt::Windows::UI::Core::CoreCursor instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CoreCursor(py::wrapper::Windows::UI::Core::CoreCursor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreCursor_get_Id(py::wrapper::Windows::UI::Core::CoreCursor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreCursor", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreCursor_get_Type(py::wrapper::Windows::UI::Core::CoreCursor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreCursor", L"Type"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreCursor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::CoreCursor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreCursor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::CoreCursor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreCursor[] = {
        { "_assign_array_", _assign_array_CoreCursor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreCursor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreCursor[] = {
        { "id", reinterpret_cast<getter>(CoreCursor_get_Id), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(CoreCursor_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreCursor[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreCursor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreCursor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreCursor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreCursor) },
        { }
    };

    static PyType_Spec type_spec_CoreCursor = {
        "winrt._winrt_windows_ui_core.CoreCursor",
        sizeof(py::wrapper::Windows::UI::Core::CoreCursor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreCursor};

    // ----- CoreDispatcher class --------------------

    static PyObject* _new_CoreDispatcher(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::CoreDispatcher>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::CoreDispatcher>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreDispatcher(py::wrapper::Windows::UI::Core::CoreDispatcher* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreDispatcher_ProcessEvents(py::wrapper::Windows::UI::Core::CoreDispatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreDispatcher", L"ProcessEvents", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreProcessEventsOption>(args, 0);

                self->obj.ProcessEvents(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreDispatcher_RunAsync(py::wrapper::Windows::UI::Core::CoreDispatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreDispatcher", L"RunAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreDispatcherPriority>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Core::DispatchedHandler>(args, 1);

                return py::convert(self->obj.RunAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreDispatcher_RunIdleAsync(py::wrapper::Windows::UI::Core::CoreDispatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreDispatcher", L"RunIdleAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Core::IdleDispatchedHandler>(args, 0);

                return py::convert(self->obj.RunIdleAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreDispatcher_ShouldYield(py::wrapper::Windows::UI::Core::CoreDispatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreDispatcher", L"ShouldYield", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ShouldYield());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreDispatcher", L"ShouldYield", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreDispatcherPriority>(args, 0);

                return py::convert(self->obj.ShouldYield(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreDispatcher_StopProcessEvents(py::wrapper::Windows::UI::Core::CoreDispatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreDispatcher", L"StopProcessEvents", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.StopProcessEvents();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreDispatcher_TryRunAsync(py::wrapper::Windows::UI::Core::CoreDispatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreDispatcher", L"TryRunAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreDispatcherPriority>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Core::DispatchedHandler>(args, 1);

                return py::convert(self->obj.TryRunAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreDispatcher_TryRunIdleAsync(py::wrapper::Windows::UI::Core::CoreDispatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreDispatcher", L"TryRunIdleAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Core::IdleDispatchedHandler>(args, 0);

                return py::convert(self->obj.TryRunIdleAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreDispatcher_get_HasThreadAccess(py::wrapper::Windows::UI::Core::CoreDispatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreDispatcher", L"HasThreadAccess"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HasThreadAccess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreDispatcher_get_CurrentPriority(py::wrapper::Windows::UI::Core::CoreDispatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreDispatcher", L"CurrentPriority"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CurrentPriority());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreDispatcher_put_CurrentPriority(py::wrapper::Windows::UI::Core::CoreDispatcher* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreDispatcher", L"CurrentPriority"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreDispatcherPriority>(arg);

            self->obj.CurrentPriority(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreDispatcher_add_AcceleratorKeyActivated(py::wrapper::Windows::UI::Core::CoreDispatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreDispatcher", L"AcceleratorKeyActivated"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreDispatcher, winrt::Windows::UI::Core::AcceleratorKeyEventArgs>>(arg);

            return py::convert(self->obj.AcceleratorKeyActivated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreDispatcher_remove_AcceleratorKeyActivated(py::wrapper::Windows::UI::Core::CoreDispatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreDispatcher", L"AcceleratorKeyActivated"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AcceleratorKeyActivated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreDispatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::CoreDispatcher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreDispatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::CoreDispatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreDispatcher[] = {
        { "process_events", reinterpret_cast<PyCFunction>(CoreDispatcher_ProcessEvents), METH_VARARGS, nullptr },
        { "run_async", reinterpret_cast<PyCFunction>(CoreDispatcher_RunAsync), METH_VARARGS, nullptr },
        { "run_idle_async", reinterpret_cast<PyCFunction>(CoreDispatcher_RunIdleAsync), METH_VARARGS, nullptr },
        { "should_yield", reinterpret_cast<PyCFunction>(CoreDispatcher_ShouldYield), METH_VARARGS, nullptr },
        { "stop_process_events", reinterpret_cast<PyCFunction>(CoreDispatcher_StopProcessEvents), METH_VARARGS, nullptr },
        { "try_run_async", reinterpret_cast<PyCFunction>(CoreDispatcher_TryRunAsync), METH_VARARGS, nullptr },
        { "try_run_idle_async", reinterpret_cast<PyCFunction>(CoreDispatcher_TryRunIdleAsync), METH_VARARGS, nullptr },
        { "add_accelerator_key_activated", reinterpret_cast<PyCFunction>(CoreDispatcher_add_AcceleratorKeyActivated), METH_O, nullptr },
        { "remove_accelerator_key_activated", reinterpret_cast<PyCFunction>(CoreDispatcher_remove_AcceleratorKeyActivated), METH_O, nullptr },
        { "_assign_array_", _assign_array_CoreDispatcher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreDispatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreDispatcher[] = {
        { "has_thread_access", reinterpret_cast<getter>(CoreDispatcher_get_HasThreadAccess), nullptr, nullptr, nullptr },
        { "current_priority", reinterpret_cast<getter>(CoreDispatcher_get_CurrentPriority), reinterpret_cast<setter>(CoreDispatcher_put_CurrentPriority), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreDispatcher[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreDispatcher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreDispatcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreDispatcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreDispatcher) },
        { }
    };

    static PyType_Spec type_spec_CoreDispatcher = {
        "winrt._winrt_windows_ui_core.CoreDispatcher",
        sizeof(py::wrapper::Windows::UI::Core::CoreDispatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreDispatcher};

    // ----- CoreIndependentInputSource class --------------------

    static PyObject* _new_CoreIndependentInputSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::CoreIndependentInputSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::CoreIndependentInputSource>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreIndependentInputSource(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreIndependentInputSource_ReleasePointerCapture(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"ReleasePointerCapture", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ReleasePointerCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_SetPointerCapture(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"SetPointerCapture", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.SetPointerCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_get_IsInputEnabled(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"IsInputEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsInputEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreIndependentInputSource_put_IsInputEnabled(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"IsInputEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsInputEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreIndependentInputSource_get_Dispatcher(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"Dispatcher"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_get_PointerCursor(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerCursor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PointerCursor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreIndependentInputSource_put_PointerCursor(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerCursor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreCursor>(arg);

            self->obj.PointerCursor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreIndependentInputSource_get_HasCapture(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"HasCapture"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HasCapture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_get_PointerPosition(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerPosition"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PointerPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_get_DispatcherQueue(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"DispatcherQueue"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DispatcherQueue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_add_InputEnabled(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"InputEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::InputEnabledEventArgs>>(arg);

            return py::convert(self->obj.InputEnabled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_remove_InputEnabled(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"InputEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.InputEnabled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_add_PointerCaptureLost(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerCaptureLost"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerCaptureLost(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_remove_PointerCaptureLost(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerCaptureLost"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerCaptureLost(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_add_PointerEntered(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerEntered"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerEntered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_remove_PointerEntered(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerEntered"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerEntered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_add_PointerExited(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerExited"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerExited(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_remove_PointerExited(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerExited"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerExited(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_add_PointerMoved(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerMoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerMoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_remove_PointerMoved(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerMoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerMoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_add_PointerPressed(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerPressed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_remove_PointerPressed(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerPressed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_add_PointerReleased(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerReleased"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerReleased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_remove_PointerReleased(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerReleased"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerReleased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_add_PointerWheelChanged(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerWheelChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerWheelChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_remove_PointerWheelChanged(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerWheelChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerWheelChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_add_PointerRoutedAway(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerRoutedAway"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::ICorePointerRedirector, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerRoutedAway(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_remove_PointerRoutedAway(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerRoutedAway"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerRoutedAway(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_add_PointerRoutedReleased(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerRoutedReleased"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::ICorePointerRedirector, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerRoutedReleased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_remove_PointerRoutedReleased(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerRoutedReleased"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerRoutedReleased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_add_PointerRoutedTo(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerRoutedTo"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::ICorePointerRedirector, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerRoutedTo(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSource_remove_PointerRoutedTo(py::wrapper::Windows::UI::Core::CoreIndependentInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreIndependentInputSource", L"PointerRoutedTo"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerRoutedTo(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreIndependentInputSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::CoreIndependentInputSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreIndependentInputSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::CoreIndependentInputSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreIndependentInputSource[] = {
        { "release_pointer_capture", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_ReleasePointerCapture), METH_VARARGS, nullptr },
        { "set_pointer_capture", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_SetPointerCapture), METH_VARARGS, nullptr },
        { "add_input_enabled", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_add_InputEnabled), METH_O, nullptr },
        { "remove_input_enabled", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_remove_InputEnabled), METH_O, nullptr },
        { "add_pointer_capture_lost", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_add_PointerCaptureLost), METH_O, nullptr },
        { "remove_pointer_capture_lost", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_remove_PointerCaptureLost), METH_O, nullptr },
        { "add_pointer_entered", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_add_PointerEntered), METH_O, nullptr },
        { "remove_pointer_entered", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_remove_PointerEntered), METH_O, nullptr },
        { "add_pointer_exited", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_add_PointerExited), METH_O, nullptr },
        { "remove_pointer_exited", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_remove_PointerExited), METH_O, nullptr },
        { "add_pointer_moved", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_add_PointerMoved), METH_O, nullptr },
        { "remove_pointer_moved", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_remove_PointerMoved), METH_O, nullptr },
        { "add_pointer_pressed", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_add_PointerPressed), METH_O, nullptr },
        { "remove_pointer_pressed", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_remove_PointerPressed), METH_O, nullptr },
        { "add_pointer_released", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_add_PointerReleased), METH_O, nullptr },
        { "remove_pointer_released", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_remove_PointerReleased), METH_O, nullptr },
        { "add_pointer_wheel_changed", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_add_PointerWheelChanged), METH_O, nullptr },
        { "remove_pointer_wheel_changed", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_remove_PointerWheelChanged), METH_O, nullptr },
        { "add_pointer_routed_away", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_add_PointerRoutedAway), METH_O, nullptr },
        { "remove_pointer_routed_away", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_remove_PointerRoutedAway), METH_O, nullptr },
        { "add_pointer_routed_released", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_add_PointerRoutedReleased), METH_O, nullptr },
        { "remove_pointer_routed_released", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_remove_PointerRoutedReleased), METH_O, nullptr },
        { "add_pointer_routed_to", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_add_PointerRoutedTo), METH_O, nullptr },
        { "remove_pointer_routed_to", reinterpret_cast<PyCFunction>(CoreIndependentInputSource_remove_PointerRoutedTo), METH_O, nullptr },
        { "_assign_array_", _assign_array_CoreIndependentInputSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreIndependentInputSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreIndependentInputSource[] = {
        { "is_input_enabled", reinterpret_cast<getter>(CoreIndependentInputSource_get_IsInputEnabled), reinterpret_cast<setter>(CoreIndependentInputSource_put_IsInputEnabled), nullptr, nullptr },
        { "dispatcher", reinterpret_cast<getter>(CoreIndependentInputSource_get_Dispatcher), nullptr, nullptr, nullptr },
        { "pointer_cursor", reinterpret_cast<getter>(CoreIndependentInputSource_get_PointerCursor), reinterpret_cast<setter>(CoreIndependentInputSource_put_PointerCursor), nullptr, nullptr },
        { "has_capture", reinterpret_cast<getter>(CoreIndependentInputSource_get_HasCapture), nullptr, nullptr, nullptr },
        { "pointer_position", reinterpret_cast<getter>(CoreIndependentInputSource_get_PointerPosition), nullptr, nullptr, nullptr },
        { "dispatcher_queue", reinterpret_cast<getter>(CoreIndependentInputSource_get_DispatcherQueue), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreIndependentInputSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreIndependentInputSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreIndependentInputSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreIndependentInputSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreIndependentInputSource) },
        { }
    };

    static PyType_Spec type_spec_CoreIndependentInputSource = {
        "winrt._winrt_windows_ui_core.CoreIndependentInputSource",
        sizeof(py::wrapper::Windows::UI::Core::CoreIndependentInputSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreIndependentInputSource};

    // ----- CoreIndependentInputSourceController class --------------------

    static PyObject* _new_CoreIndependentInputSourceController(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::CoreIndependentInputSourceController>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::CoreIndependentInputSourceController>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreIndependentInputSourceController(py::wrapper::Windows::UI::Core::CoreIndependentInputSourceController* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreIndependentInputSourceController_Close(py::wrapper::Windows::UI::Core::CoreIndependentInputSourceController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreIndependentInputSourceController", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSourceController_CreateForIVisualElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreIndependentInputSourceController", L"CreateForIVisualElement", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Composition::IVisualElement>(args, 0);

                return py::convert(winrt::Windows::UI::Core::CoreIndependentInputSourceController::CreateForIVisualElement(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSourceController_CreateForVisual(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreIndependentInputSourceController", L"CreateForVisual", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Visual>(args, 0);

                return py::convert(winrt::Windows::UI::Core::CoreIndependentInputSourceController::CreateForVisual(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSourceController_SetControlledInput(py::wrapper::Windows::UI::Core::CoreIndependentInputSourceController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreIndependentInputSourceController", L"SetControlledInput", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreInputDeviceTypes>(args, 0);

                self->obj.SetControlledInput(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreIndependentInputSourceController", L"SetControlledInput", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreInputDeviceTypes>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Core::CoreIndependentInputFilters>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Core::CoreIndependentInputFilters>(args, 2);

                self->obj.SetControlledInput(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreIndependentInputSourceController_get_IsTransparentForUncontrolledInput(py::wrapper::Windows::UI::Core::CoreIndependentInputSourceController* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreIndependentInputSourceController", L"IsTransparentForUncontrolledInput"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsTransparentForUncontrolledInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreIndependentInputSourceController_put_IsTransparentForUncontrolledInput(py::wrapper::Windows::UI::Core::CoreIndependentInputSourceController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreIndependentInputSourceController", L"IsTransparentForUncontrolledInput"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsTransparentForUncontrolledInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreIndependentInputSourceController_get_IsPalmRejectionEnabled(py::wrapper::Windows::UI::Core::CoreIndependentInputSourceController* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreIndependentInputSourceController", L"IsPalmRejectionEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPalmRejectionEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreIndependentInputSourceController_put_IsPalmRejectionEnabled(py::wrapper::Windows::UI::Core::CoreIndependentInputSourceController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreIndependentInputSourceController", L"IsPalmRejectionEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsPalmRejectionEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreIndependentInputSourceController_get_Source(py::wrapper::Windows::UI::Core::CoreIndependentInputSourceController* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreIndependentInputSourceController", L"Source"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreIndependentInputSourceController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::CoreIndependentInputSourceController>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreIndependentInputSourceController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::CoreIndependentInputSourceController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_CoreIndependentInputSourceController(py::wrapper::Windows::UI::Core::CoreIndependentInputSourceController* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_CoreIndependentInputSourceController(py::wrapper::Windows::UI::Core::CoreIndependentInputSourceController* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreIndependentInputSourceController[] = {
        { "close", reinterpret_cast<PyCFunction>(CoreIndependentInputSourceController_Close), METH_VARARGS, nullptr },
        { "set_controlled_input", reinterpret_cast<PyCFunction>(CoreIndependentInputSourceController_SetControlledInput), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreIndependentInputSourceController, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreIndependentInputSourceController), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_CoreIndependentInputSourceController), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_CoreIndependentInputSourceController), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreIndependentInputSourceController[] = {
        { "is_transparent_for_uncontrolled_input", reinterpret_cast<getter>(CoreIndependentInputSourceController_get_IsTransparentForUncontrolledInput), reinterpret_cast<setter>(CoreIndependentInputSourceController_put_IsTransparentForUncontrolledInput), nullptr, nullptr },
        { "is_palm_rejection_enabled", reinterpret_cast<getter>(CoreIndependentInputSourceController_get_IsPalmRejectionEnabled), reinterpret_cast<setter>(CoreIndependentInputSourceController_put_IsPalmRejectionEnabled), nullptr, nullptr },
        { "source", reinterpret_cast<getter>(CoreIndependentInputSourceController_get_Source), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreIndependentInputSourceController[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreIndependentInputSourceController) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreIndependentInputSourceController) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreIndependentInputSourceController) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreIndependentInputSourceController) },
        { }
    };

    static PyType_Spec type_spec_CoreIndependentInputSourceController = {
        "winrt._winrt_windows_ui_core.CoreIndependentInputSourceController",
        sizeof(py::wrapper::Windows::UI::Core::CoreIndependentInputSourceController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreIndependentInputSourceController};

    static PyGetSetDef getset_CoreIndependentInputSourceController_Static[] = {
        { }
    };

    static PyMethodDef methods_CoreIndependentInputSourceController_Static[] = {
        { "create_for_i_visual_element", reinterpret_cast<PyCFunction>(CoreIndependentInputSourceController_CreateForIVisualElement), METH_VARARGS, nullptr },
        { "create_for_visual", reinterpret_cast<PyCFunction>(CoreIndependentInputSourceController_CreateForVisual), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_CoreIndependentInputSourceController_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CoreIndependentInputSourceController_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CoreIndependentInputSourceController_Static) },
        { }
    };

    static PyType_Spec type_spec_CoreIndependentInputSourceController_Static =
    {
        "winrt._winrt_windows_ui_core.CoreIndependentInputSourceController_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CoreIndependentInputSourceController_Static
    };

    // ----- CoreWindow class --------------------

    static PyObject* _new_CoreWindow(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::CoreWindow>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::CoreWindow>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWindow(py::wrapper::Windows::UI::Core::CoreWindow* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWindow_Activate(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreWindow", L"Activate", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Activate();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWindow_Close(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreWindow", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWindow_GetAsyncKeyState(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreWindow", L"GetAsyncKeyState", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::VirtualKey>(args, 0);

                return py::convert(self->obj.GetAsyncKeyState(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWindow_GetCurrentKeyEventDeviceId(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreWindow", L"GetCurrentKeyEventDeviceId", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetCurrentKeyEventDeviceId());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWindow_GetForCurrentThread(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreWindow", L"GetForCurrentThread", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::UI::Core::CoreWindow::GetForCurrentThread());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWindow_GetKeyState(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreWindow", L"GetKeyState", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::VirtualKey>(args, 0);

                return py::convert(self->obj.GetKeyState(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWindow_ReleasePointerCapture(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreWindow", L"ReleasePointerCapture", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ReleasePointerCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWindow_SetPointerCapture(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreWindow", L"SetPointerCapture", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.SetPointerCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWindow_get_PointerPosition(py::wrapper::Windows::UI::Core::CoreWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindow", L"PointerPosition"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PointerPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWindow_put_PointerPosition(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindow", L"PointerPosition"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.PointerPosition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWindow_get_PointerCursor(py::wrapper::Windows::UI::Core::CoreWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindow", L"PointerCursor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PointerCursor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWindow_put_PointerCursor(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindow", L"PointerCursor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreCursor>(arg);

            self->obj.PointerCursor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWindow_get_FlowDirection(py::wrapper::Windows::UI::Core::CoreWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindow", L"FlowDirection"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FlowDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWindow_put_FlowDirection(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindow", L"FlowDirection"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreWindowFlowDirection>(arg);

            self->obj.FlowDirection(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWindow_get_IsInputEnabled(py::wrapper::Windows::UI::Core::CoreWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindow", L"IsInputEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsInputEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWindow_put_IsInputEnabled(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindow", L"IsInputEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsInputEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWindow_get_Dispatcher(py::wrapper::Windows::UI::Core::CoreWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindow", L"Dispatcher"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_get_AutomationHostProvider(py::wrapper::Windows::UI::Core::CoreWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindow", L"AutomationHostProvider"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AutomationHostProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_get_Bounds(py::wrapper::Windows::UI::Core::CoreWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindow", L"Bounds"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Bounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_get_CustomProperties(py::wrapper::Windows::UI::Core::CoreWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindow", L"CustomProperties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CustomProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_get_Visible(py::wrapper::Windows::UI::Core::CoreWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindow", L"Visible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Visible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_get_ActivationMode(py::wrapper::Windows::UI::Core::CoreWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindow", L"ActivationMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActivationMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_get_DispatcherQueue(py::wrapper::Windows::UI::Core::CoreWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindow", L"DispatcherQueue"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DispatcherQueue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_get_UIContext(py::wrapper::Windows::UI::Core::CoreWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindow", L"UIContext"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UIContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_Activated(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"Activated"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::WindowActivatedEventArgs>>(arg);

            return py::convert(self->obj.Activated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_Activated(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"Activated"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Activated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_AutomationProviderRequested(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"AutomationProviderRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::AutomationProviderRequestedEventArgs>>(arg);

            return py::convert(self->obj.AutomationProviderRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_AutomationProviderRequested(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"AutomationProviderRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AutomationProviderRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_CharacterReceived(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"CharacterReceived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::CharacterReceivedEventArgs>>(arg);

            return py::convert(self->obj.CharacterReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_CharacterReceived(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"CharacterReceived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CharacterReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_Closed(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"Closed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::CoreWindowEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_Closed(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"Closed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_InputEnabled(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"InputEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::InputEnabledEventArgs>>(arg);

            return py::convert(self->obj.InputEnabled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_InputEnabled(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"InputEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.InputEnabled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_KeyDown(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"KeyDown"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::KeyEventArgs>>(arg);

            return py::convert(self->obj.KeyDown(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_KeyDown(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"KeyDown"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.KeyDown(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_KeyUp(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"KeyUp"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::KeyEventArgs>>(arg);

            return py::convert(self->obj.KeyUp(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_KeyUp(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"KeyUp"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.KeyUp(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_PointerCaptureLost(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerCaptureLost"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerCaptureLost(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_PointerCaptureLost(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerCaptureLost"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerCaptureLost(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_PointerEntered(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerEntered"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerEntered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_PointerEntered(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerEntered"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerEntered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_PointerExited(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerExited"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerExited(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_PointerExited(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerExited"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerExited(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_PointerMoved(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerMoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerMoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_PointerMoved(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerMoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerMoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_PointerPressed(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerPressed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_PointerPressed(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerPressed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_PointerReleased(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerReleased"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerReleased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_PointerReleased(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerReleased"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerReleased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_PointerWheelChanged(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerWheelChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerWheelChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_PointerWheelChanged(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerWheelChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerWheelChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_SizeChanged(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"SizeChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::WindowSizeChangedEventArgs>>(arg);

            return py::convert(self->obj.SizeChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_SizeChanged(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"SizeChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SizeChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_TouchHitTesting(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"TouchHitTesting"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::TouchHitTestingEventArgs>>(arg);

            return py::convert(self->obj.TouchHitTesting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_TouchHitTesting(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"TouchHitTesting"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TouchHitTesting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_VisibilityChanged(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"VisibilityChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::VisibilityChangedEventArgs>>(arg);

            return py::convert(self->obj.VisibilityChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_VisibilityChanged(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"VisibilityChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VisibilityChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_PointerRoutedAway(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerRoutedAway"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::ICorePointerRedirector, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerRoutedAway(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_PointerRoutedAway(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerRoutedAway"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerRoutedAway(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_PointerRoutedReleased(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerRoutedReleased"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::ICorePointerRedirector, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerRoutedReleased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_PointerRoutedReleased(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerRoutedReleased"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerRoutedReleased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_PointerRoutedTo(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerRoutedTo"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::ICorePointerRedirector, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerRoutedTo(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_PointerRoutedTo(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"PointerRoutedTo"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerRoutedTo(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_ClosestInteractiveBoundsRequested(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"ClosestInteractiveBoundsRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::ClosestInteractiveBoundsRequestedEventArgs>>(arg);

            return py::convert(self->obj.ClosestInteractiveBoundsRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_ClosestInteractiveBoundsRequested(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"ClosestInteractiveBoundsRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ClosestInteractiveBoundsRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_ResizeCompleted(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"ResizeCompleted"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ResizeCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_ResizeCompleted(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"ResizeCompleted"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ResizeCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_add_ResizeStarted(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"ResizeStarted"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ResizeStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindow_remove_ResizeStarted(py::wrapper::Windows::UI::Core::CoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindow", L"ResizeStarted"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ResizeStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWindow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::CoreWindow>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWindow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::CoreWindow>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWindow[] = {
        { "activate", reinterpret_cast<PyCFunction>(CoreWindow_Activate), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(CoreWindow_Close), METH_VARARGS, nullptr },
        { "get_async_key_state", reinterpret_cast<PyCFunction>(CoreWindow_GetAsyncKeyState), METH_VARARGS, nullptr },
        { "get_current_key_event_device_id", reinterpret_cast<PyCFunction>(CoreWindow_GetCurrentKeyEventDeviceId), METH_VARARGS, nullptr },
        { "get_key_state", reinterpret_cast<PyCFunction>(CoreWindow_GetKeyState), METH_VARARGS, nullptr },
        { "release_pointer_capture", reinterpret_cast<PyCFunction>(CoreWindow_ReleasePointerCapture), METH_VARARGS, nullptr },
        { "set_pointer_capture", reinterpret_cast<PyCFunction>(CoreWindow_SetPointerCapture), METH_VARARGS, nullptr },
        { "add_activated", reinterpret_cast<PyCFunction>(CoreWindow_add_Activated), METH_O, nullptr },
        { "remove_activated", reinterpret_cast<PyCFunction>(CoreWindow_remove_Activated), METH_O, nullptr },
        { "add_automation_provider_requested", reinterpret_cast<PyCFunction>(CoreWindow_add_AutomationProviderRequested), METH_O, nullptr },
        { "remove_automation_provider_requested", reinterpret_cast<PyCFunction>(CoreWindow_remove_AutomationProviderRequested), METH_O, nullptr },
        { "add_character_received", reinterpret_cast<PyCFunction>(CoreWindow_add_CharacterReceived), METH_O, nullptr },
        { "remove_character_received", reinterpret_cast<PyCFunction>(CoreWindow_remove_CharacterReceived), METH_O, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(CoreWindow_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(CoreWindow_remove_Closed), METH_O, nullptr },
        { "add_input_enabled", reinterpret_cast<PyCFunction>(CoreWindow_add_InputEnabled), METH_O, nullptr },
        { "remove_input_enabled", reinterpret_cast<PyCFunction>(CoreWindow_remove_InputEnabled), METH_O, nullptr },
        { "add_key_down", reinterpret_cast<PyCFunction>(CoreWindow_add_KeyDown), METH_O, nullptr },
        { "remove_key_down", reinterpret_cast<PyCFunction>(CoreWindow_remove_KeyDown), METH_O, nullptr },
        { "add_key_up", reinterpret_cast<PyCFunction>(CoreWindow_add_KeyUp), METH_O, nullptr },
        { "remove_key_up", reinterpret_cast<PyCFunction>(CoreWindow_remove_KeyUp), METH_O, nullptr },
        { "add_pointer_capture_lost", reinterpret_cast<PyCFunction>(CoreWindow_add_PointerCaptureLost), METH_O, nullptr },
        { "remove_pointer_capture_lost", reinterpret_cast<PyCFunction>(CoreWindow_remove_PointerCaptureLost), METH_O, nullptr },
        { "add_pointer_entered", reinterpret_cast<PyCFunction>(CoreWindow_add_PointerEntered), METH_O, nullptr },
        { "remove_pointer_entered", reinterpret_cast<PyCFunction>(CoreWindow_remove_PointerEntered), METH_O, nullptr },
        { "add_pointer_exited", reinterpret_cast<PyCFunction>(CoreWindow_add_PointerExited), METH_O, nullptr },
        { "remove_pointer_exited", reinterpret_cast<PyCFunction>(CoreWindow_remove_PointerExited), METH_O, nullptr },
        { "add_pointer_moved", reinterpret_cast<PyCFunction>(CoreWindow_add_PointerMoved), METH_O, nullptr },
        { "remove_pointer_moved", reinterpret_cast<PyCFunction>(CoreWindow_remove_PointerMoved), METH_O, nullptr },
        { "add_pointer_pressed", reinterpret_cast<PyCFunction>(CoreWindow_add_PointerPressed), METH_O, nullptr },
        { "remove_pointer_pressed", reinterpret_cast<PyCFunction>(CoreWindow_remove_PointerPressed), METH_O, nullptr },
        { "add_pointer_released", reinterpret_cast<PyCFunction>(CoreWindow_add_PointerReleased), METH_O, nullptr },
        { "remove_pointer_released", reinterpret_cast<PyCFunction>(CoreWindow_remove_PointerReleased), METH_O, nullptr },
        { "add_pointer_wheel_changed", reinterpret_cast<PyCFunction>(CoreWindow_add_PointerWheelChanged), METH_O, nullptr },
        { "remove_pointer_wheel_changed", reinterpret_cast<PyCFunction>(CoreWindow_remove_PointerWheelChanged), METH_O, nullptr },
        { "add_size_changed", reinterpret_cast<PyCFunction>(CoreWindow_add_SizeChanged), METH_O, nullptr },
        { "remove_size_changed", reinterpret_cast<PyCFunction>(CoreWindow_remove_SizeChanged), METH_O, nullptr },
        { "add_touch_hit_testing", reinterpret_cast<PyCFunction>(CoreWindow_add_TouchHitTesting), METH_O, nullptr },
        { "remove_touch_hit_testing", reinterpret_cast<PyCFunction>(CoreWindow_remove_TouchHitTesting), METH_O, nullptr },
        { "add_visibility_changed", reinterpret_cast<PyCFunction>(CoreWindow_add_VisibilityChanged), METH_O, nullptr },
        { "remove_visibility_changed", reinterpret_cast<PyCFunction>(CoreWindow_remove_VisibilityChanged), METH_O, nullptr },
        { "add_pointer_routed_away", reinterpret_cast<PyCFunction>(CoreWindow_add_PointerRoutedAway), METH_O, nullptr },
        { "remove_pointer_routed_away", reinterpret_cast<PyCFunction>(CoreWindow_remove_PointerRoutedAway), METH_O, nullptr },
        { "add_pointer_routed_released", reinterpret_cast<PyCFunction>(CoreWindow_add_PointerRoutedReleased), METH_O, nullptr },
        { "remove_pointer_routed_released", reinterpret_cast<PyCFunction>(CoreWindow_remove_PointerRoutedReleased), METH_O, nullptr },
        { "add_pointer_routed_to", reinterpret_cast<PyCFunction>(CoreWindow_add_PointerRoutedTo), METH_O, nullptr },
        { "remove_pointer_routed_to", reinterpret_cast<PyCFunction>(CoreWindow_remove_PointerRoutedTo), METH_O, nullptr },
        { "add_closest_interactive_bounds_requested", reinterpret_cast<PyCFunction>(CoreWindow_add_ClosestInteractiveBoundsRequested), METH_O, nullptr },
        { "remove_closest_interactive_bounds_requested", reinterpret_cast<PyCFunction>(CoreWindow_remove_ClosestInteractiveBoundsRequested), METH_O, nullptr },
        { "add_resize_completed", reinterpret_cast<PyCFunction>(CoreWindow_add_ResizeCompleted), METH_O, nullptr },
        { "remove_resize_completed", reinterpret_cast<PyCFunction>(CoreWindow_remove_ResizeCompleted), METH_O, nullptr },
        { "add_resize_started", reinterpret_cast<PyCFunction>(CoreWindow_add_ResizeStarted), METH_O, nullptr },
        { "remove_resize_started", reinterpret_cast<PyCFunction>(CoreWindow_remove_ResizeStarted), METH_O, nullptr },
        { "_assign_array_", _assign_array_CoreWindow, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWindow), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWindow[] = {
        { "pointer_position", reinterpret_cast<getter>(CoreWindow_get_PointerPosition), reinterpret_cast<setter>(CoreWindow_put_PointerPosition), nullptr, nullptr },
        { "pointer_cursor", reinterpret_cast<getter>(CoreWindow_get_PointerCursor), reinterpret_cast<setter>(CoreWindow_put_PointerCursor), nullptr, nullptr },
        { "flow_direction", reinterpret_cast<getter>(CoreWindow_get_FlowDirection), reinterpret_cast<setter>(CoreWindow_put_FlowDirection), nullptr, nullptr },
        { "is_input_enabled", reinterpret_cast<getter>(CoreWindow_get_IsInputEnabled), reinterpret_cast<setter>(CoreWindow_put_IsInputEnabled), nullptr, nullptr },
        { "dispatcher", reinterpret_cast<getter>(CoreWindow_get_Dispatcher), nullptr, nullptr, nullptr },
        { "automation_host_provider", reinterpret_cast<getter>(CoreWindow_get_AutomationHostProvider), nullptr, nullptr, nullptr },
        { "bounds", reinterpret_cast<getter>(CoreWindow_get_Bounds), nullptr, nullptr, nullptr },
        { "custom_properties", reinterpret_cast<getter>(CoreWindow_get_CustomProperties), nullptr, nullptr, nullptr },
        { "visible", reinterpret_cast<getter>(CoreWindow_get_Visible), nullptr, nullptr, nullptr },
        { "activation_mode", reinterpret_cast<getter>(CoreWindow_get_ActivationMode), nullptr, nullptr, nullptr },
        { "dispatcher_queue", reinterpret_cast<getter>(CoreWindow_get_DispatcherQueue), nullptr, nullptr, nullptr },
        { "u_i_context", reinterpret_cast<getter>(CoreWindow_get_UIContext), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWindow[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWindow) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWindow) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWindow) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWindow) },
        { }
    };

    static PyType_Spec type_spec_CoreWindow = {
        "winrt._winrt_windows_ui_core.CoreWindow",
        sizeof(py::wrapper::Windows::UI::Core::CoreWindow),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWindow};

    static PyGetSetDef getset_CoreWindow_Static[] = {
        { }
    };

    static PyMethodDef methods_CoreWindow_Static[] = {
        { "get_for_current_thread", reinterpret_cast<PyCFunction>(CoreWindow_GetForCurrentThread), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_CoreWindow_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CoreWindow_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CoreWindow_Static) },
        { }
    };

    static PyType_Spec type_spec_CoreWindow_Static =
    {
        "winrt._winrt_windows_ui_core.CoreWindow_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CoreWindow_Static
    };

    // ----- CoreWindowDialog class --------------------

    static PyObject* _new_CoreWindowDialog(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::UI::Core::CoreWindowDialog instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Core::CoreWindowDialog instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CoreWindowDialog(py::wrapper::Windows::UI::Core::CoreWindowDialog* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWindowDialog_ShowAsync(py::wrapper::Windows::UI::Core::CoreWindowDialog* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreWindowDialog", L"ShowAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ShowAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWindowDialog_get_Title(py::wrapper::Windows::UI::Core::CoreWindowDialog* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowDialog", L"Title"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWindowDialog_put_Title(py::wrapper::Windows::UI::Core::CoreWindowDialog* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowDialog", L"Title"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWindowDialog_get_IsInteractionDelayed(py::wrapper::Windows::UI::Core::CoreWindowDialog* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowDialog", L"IsInteractionDelayed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsInteractionDelayed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWindowDialog_put_IsInteractionDelayed(py::wrapper::Windows::UI::Core::CoreWindowDialog* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowDialog", L"IsInteractionDelayed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.IsInteractionDelayed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWindowDialog_get_DefaultCommandIndex(py::wrapper::Windows::UI::Core::CoreWindowDialog* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowDialog", L"DefaultCommandIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DefaultCommandIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWindowDialog_put_DefaultCommandIndex(py::wrapper::Windows::UI::Core::CoreWindowDialog* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowDialog", L"DefaultCommandIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.DefaultCommandIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWindowDialog_get_CancelCommandIndex(py::wrapper::Windows::UI::Core::CoreWindowDialog* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowDialog", L"CancelCommandIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CancelCommandIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWindowDialog_put_CancelCommandIndex(py::wrapper::Windows::UI::Core::CoreWindowDialog* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowDialog", L"CancelCommandIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CancelCommandIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWindowDialog_get_BackButtonCommand(py::wrapper::Windows::UI::Core::CoreWindowDialog* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowDialog", L"BackButtonCommand"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BackButtonCommand());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWindowDialog_put_BackButtonCommand(py::wrapper::Windows::UI::Core::CoreWindowDialog* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowDialog", L"BackButtonCommand"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Popups::UICommandInvokedHandler>(arg);

            self->obj.BackButtonCommand(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWindowDialog_get_Commands(py::wrapper::Windows::UI::Core::CoreWindowDialog* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowDialog", L"Commands"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Commands());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindowDialog_get_MaxSize(py::wrapper::Windows::UI::Core::CoreWindowDialog* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowDialog", L"MaxSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindowDialog_get_MinSize(py::wrapper::Windows::UI::Core::CoreWindowDialog* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowDialog", L"MinSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindowDialog_add_Showing(py::wrapper::Windows::UI::Core::CoreWindowDialog* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindowDialog", L"Showing"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::CoreWindowPopupShowingEventArgs>>(arg);

            return py::convert(self->obj.Showing(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindowDialog_remove_Showing(py::wrapper::Windows::UI::Core::CoreWindowDialog* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindowDialog", L"Showing"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Showing(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWindowDialog(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::CoreWindowDialog>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWindowDialog(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::CoreWindowDialog>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWindowDialog[] = {
        { "show_async", reinterpret_cast<PyCFunction>(CoreWindowDialog_ShowAsync), METH_VARARGS, nullptr },
        { "add_showing", reinterpret_cast<PyCFunction>(CoreWindowDialog_add_Showing), METH_O, nullptr },
        { "remove_showing", reinterpret_cast<PyCFunction>(CoreWindowDialog_remove_Showing), METH_O, nullptr },
        { "_assign_array_", _assign_array_CoreWindowDialog, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWindowDialog), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWindowDialog[] = {
        { "title", reinterpret_cast<getter>(CoreWindowDialog_get_Title), reinterpret_cast<setter>(CoreWindowDialog_put_Title), nullptr, nullptr },
        { "is_interaction_delayed", reinterpret_cast<getter>(CoreWindowDialog_get_IsInteractionDelayed), reinterpret_cast<setter>(CoreWindowDialog_put_IsInteractionDelayed), nullptr, nullptr },
        { "default_command_index", reinterpret_cast<getter>(CoreWindowDialog_get_DefaultCommandIndex), reinterpret_cast<setter>(CoreWindowDialog_put_DefaultCommandIndex), nullptr, nullptr },
        { "cancel_command_index", reinterpret_cast<getter>(CoreWindowDialog_get_CancelCommandIndex), reinterpret_cast<setter>(CoreWindowDialog_put_CancelCommandIndex), nullptr, nullptr },
        { "back_button_command", reinterpret_cast<getter>(CoreWindowDialog_get_BackButtonCommand), reinterpret_cast<setter>(CoreWindowDialog_put_BackButtonCommand), nullptr, nullptr },
        { "commands", reinterpret_cast<getter>(CoreWindowDialog_get_Commands), nullptr, nullptr, nullptr },
        { "max_size", reinterpret_cast<getter>(CoreWindowDialog_get_MaxSize), nullptr, nullptr, nullptr },
        { "min_size", reinterpret_cast<getter>(CoreWindowDialog_get_MinSize), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWindowDialog[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWindowDialog) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWindowDialog) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWindowDialog) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWindowDialog) },
        { }
    };

    static PyType_Spec type_spec_CoreWindowDialog = {
        "winrt._winrt_windows_ui_core.CoreWindowDialog",
        sizeof(py::wrapper::Windows::UI::Core::CoreWindowDialog),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWindowDialog};

    // ----- CoreWindowEventArgs class --------------------

    static PyObject* _new_CoreWindowEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::CoreWindowEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::CoreWindowEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWindowEventArgs(py::wrapper::Windows::UI::Core::CoreWindowEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWindowEventArgs_get_Handled(py::wrapper::Windows::UI::Core::CoreWindowEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowEventArgs", L"Handled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWindowEventArgs_put_Handled(py::wrapper::Windows::UI::Core::CoreWindowEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowEventArgs", L"Handled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CoreWindowEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::CoreWindowEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWindowEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::CoreWindowEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWindowEventArgs[] = {
        { "_assign_array_", _assign_array_CoreWindowEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWindowEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWindowEventArgs[] = {
        { "handled", reinterpret_cast<getter>(CoreWindowEventArgs_get_Handled), reinterpret_cast<setter>(CoreWindowEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWindowEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWindowEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWindowEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWindowEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWindowEventArgs) },
        { }
    };

    static PyType_Spec type_spec_CoreWindowEventArgs = {
        "winrt._winrt_windows_ui_core.CoreWindowEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::CoreWindowEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWindowEventArgs};

    // ----- CoreWindowFlyout class --------------------

    static PyObject* _new_CoreWindowFlyout(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                winrt::Windows::UI::Core::CoreWindowFlyout instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::UI::Core::CoreWindowFlyout instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CoreWindowFlyout(py::wrapper::Windows::UI::Core::CoreWindowFlyout* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWindowFlyout_ShowAsync(py::wrapper::Windows::UI::Core::CoreWindowFlyout* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreWindowFlyout", L"ShowAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ShowAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWindowFlyout_get_Title(py::wrapper::Windows::UI::Core::CoreWindowFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowFlyout", L"Title"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWindowFlyout_put_Title(py::wrapper::Windows::UI::Core::CoreWindowFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowFlyout", L"Title"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWindowFlyout_get_IsInteractionDelayed(py::wrapper::Windows::UI::Core::CoreWindowFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowFlyout", L"IsInteractionDelayed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsInteractionDelayed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWindowFlyout_put_IsInteractionDelayed(py::wrapper::Windows::UI::Core::CoreWindowFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowFlyout", L"IsInteractionDelayed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.IsInteractionDelayed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWindowFlyout_get_DefaultCommandIndex(py::wrapper::Windows::UI::Core::CoreWindowFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowFlyout", L"DefaultCommandIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DefaultCommandIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWindowFlyout_put_DefaultCommandIndex(py::wrapper::Windows::UI::Core::CoreWindowFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowFlyout", L"DefaultCommandIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.DefaultCommandIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWindowFlyout_get_BackButtonCommand(py::wrapper::Windows::UI::Core::CoreWindowFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowFlyout", L"BackButtonCommand"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BackButtonCommand());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWindowFlyout_put_BackButtonCommand(py::wrapper::Windows::UI::Core::CoreWindowFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowFlyout", L"BackButtonCommand"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Popups::UICommandInvokedHandler>(arg);

            self->obj.BackButtonCommand(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWindowFlyout_get_Commands(py::wrapper::Windows::UI::Core::CoreWindowFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowFlyout", L"Commands"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Commands());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindowFlyout_get_MaxSize(py::wrapper::Windows::UI::Core::CoreWindowFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowFlyout", L"MaxSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindowFlyout_get_MinSize(py::wrapper::Windows::UI::Core::CoreWindowFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowFlyout", L"MinSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindowFlyout_add_Showing(py::wrapper::Windows::UI::Core::CoreWindowFlyout* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindowFlyout", L"Showing"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::CoreWindowPopupShowingEventArgs>>(arg);

            return py::convert(self->obj.Showing(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWindowFlyout_remove_Showing(py::wrapper::Windows::UI::Core::CoreWindowFlyout* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.CoreWindowFlyout", L"Showing"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Showing(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWindowFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::CoreWindowFlyout>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWindowFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::CoreWindowFlyout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWindowFlyout[] = {
        { "show_async", reinterpret_cast<PyCFunction>(CoreWindowFlyout_ShowAsync), METH_VARARGS, nullptr },
        { "add_showing", reinterpret_cast<PyCFunction>(CoreWindowFlyout_add_Showing), METH_O, nullptr },
        { "remove_showing", reinterpret_cast<PyCFunction>(CoreWindowFlyout_remove_Showing), METH_O, nullptr },
        { "_assign_array_", _assign_array_CoreWindowFlyout, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWindowFlyout), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWindowFlyout[] = {
        { "title", reinterpret_cast<getter>(CoreWindowFlyout_get_Title), reinterpret_cast<setter>(CoreWindowFlyout_put_Title), nullptr, nullptr },
        { "is_interaction_delayed", reinterpret_cast<getter>(CoreWindowFlyout_get_IsInteractionDelayed), reinterpret_cast<setter>(CoreWindowFlyout_put_IsInteractionDelayed), nullptr, nullptr },
        { "default_command_index", reinterpret_cast<getter>(CoreWindowFlyout_get_DefaultCommandIndex), reinterpret_cast<setter>(CoreWindowFlyout_put_DefaultCommandIndex), nullptr, nullptr },
        { "back_button_command", reinterpret_cast<getter>(CoreWindowFlyout_get_BackButtonCommand), reinterpret_cast<setter>(CoreWindowFlyout_put_BackButtonCommand), nullptr, nullptr },
        { "commands", reinterpret_cast<getter>(CoreWindowFlyout_get_Commands), nullptr, nullptr, nullptr },
        { "max_size", reinterpret_cast<getter>(CoreWindowFlyout_get_MaxSize), nullptr, nullptr, nullptr },
        { "min_size", reinterpret_cast<getter>(CoreWindowFlyout_get_MinSize), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWindowFlyout[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWindowFlyout) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWindowFlyout) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWindowFlyout) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWindowFlyout) },
        { }
    };

    static PyType_Spec type_spec_CoreWindowFlyout = {
        "winrt._winrt_windows_ui_core.CoreWindowFlyout",
        sizeof(py::wrapper::Windows::UI::Core::CoreWindowFlyout),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWindowFlyout};

    // ----- CoreWindowPopupShowingEventArgs class --------------------

    static PyObject* _new_CoreWindowPopupShowingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::CoreWindowPopupShowingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::CoreWindowPopupShowingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWindowPopupShowingEventArgs(py::wrapper::Windows::UI::Core::CoreWindowPopupShowingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWindowPopupShowingEventArgs_SetDesiredSize(py::wrapper::Windows::UI::Core::CoreWindowPopupShowingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreWindowPopupShowingEventArgs", L"SetDesiredSize", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(args, 0);

                self->obj.SetDesiredSize(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWindowPopupShowingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::CoreWindowPopupShowingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWindowPopupShowingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::CoreWindowPopupShowingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWindowPopupShowingEventArgs[] = {
        { "set_desired_size", reinterpret_cast<PyCFunction>(CoreWindowPopupShowingEventArgs_SetDesiredSize), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreWindowPopupShowingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWindowPopupShowingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWindowPopupShowingEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_CoreWindowPopupShowingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWindowPopupShowingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWindowPopupShowingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWindowPopupShowingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWindowPopupShowingEventArgs) },
        { }
    };

    static PyType_Spec type_spec_CoreWindowPopupShowingEventArgs = {
        "winrt._winrt_windows_ui_core.CoreWindowPopupShowingEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::CoreWindowPopupShowingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWindowPopupShowingEventArgs};

    // ----- CoreWindowResizeManager class --------------------

    static PyObject* _new_CoreWindowResizeManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::CoreWindowResizeManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::CoreWindowResizeManager>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWindowResizeManager(py::wrapper::Windows::UI::Core::CoreWindowResizeManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWindowResizeManager_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreWindowResizeManager", L"GetForCurrentView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::UI::Core::CoreWindowResizeManager::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWindowResizeManager_NotifyLayoutCompleted(py::wrapper::Windows::UI::Core::CoreWindowResizeManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.CoreWindowResizeManager", L"NotifyLayoutCompleted", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.NotifyLayoutCompleted();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWindowResizeManager_get_ShouldWaitForLayoutCompletion(py::wrapper::Windows::UI::Core::CoreWindowResizeManager* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowResizeManager", L"ShouldWaitForLayoutCompletion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ShouldWaitForLayoutCompletion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWindowResizeManager_put_ShouldWaitForLayoutCompletion(py::wrapper::Windows::UI::Core::CoreWindowResizeManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.CoreWindowResizeManager", L"ShouldWaitForLayoutCompletion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShouldWaitForLayoutCompletion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CoreWindowResizeManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::CoreWindowResizeManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWindowResizeManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::CoreWindowResizeManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWindowResizeManager[] = {
        { "notify_layout_completed", reinterpret_cast<PyCFunction>(CoreWindowResizeManager_NotifyLayoutCompleted), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreWindowResizeManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWindowResizeManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWindowResizeManager[] = {
        { "should_wait_for_layout_completion", reinterpret_cast<getter>(CoreWindowResizeManager_get_ShouldWaitForLayoutCompletion), reinterpret_cast<setter>(CoreWindowResizeManager_put_ShouldWaitForLayoutCompletion), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWindowResizeManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWindowResizeManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWindowResizeManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWindowResizeManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWindowResizeManager) },
        { }
    };

    static PyType_Spec type_spec_CoreWindowResizeManager = {
        "winrt._winrt_windows_ui_core.CoreWindowResizeManager",
        sizeof(py::wrapper::Windows::UI::Core::CoreWindowResizeManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWindowResizeManager};

    static PyGetSetDef getset_CoreWindowResizeManager_Static[] = {
        { }
    };

    static PyMethodDef methods_CoreWindowResizeManager_Static[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(CoreWindowResizeManager_GetForCurrentView), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_CoreWindowResizeManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CoreWindowResizeManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CoreWindowResizeManager_Static) },
        { }
    };

    static PyType_Spec type_spec_CoreWindowResizeManager_Static =
    {
        "winrt._winrt_windows_ui_core.CoreWindowResizeManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CoreWindowResizeManager_Static
    };

    // ----- IdleDispatchedHandlerArgs class --------------------

    static PyObject* _new_IdleDispatchedHandlerArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::IdleDispatchedHandlerArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::IdleDispatchedHandlerArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IdleDispatchedHandlerArgs(py::wrapper::Windows::UI::Core::IdleDispatchedHandlerArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IdleDispatchedHandlerArgs_get_IsDispatcherIdle(py::wrapper::Windows::UI::Core::IdleDispatchedHandlerArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.IdleDispatchedHandlerArgs", L"IsDispatcherIdle"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDispatcherIdle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IdleDispatchedHandlerArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::IdleDispatchedHandlerArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IdleDispatchedHandlerArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::IdleDispatchedHandlerArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IdleDispatchedHandlerArgs[] = {
        { "_assign_array_", _assign_array_IdleDispatchedHandlerArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IdleDispatchedHandlerArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IdleDispatchedHandlerArgs[] = {
        { "is_dispatcher_idle", reinterpret_cast<getter>(IdleDispatchedHandlerArgs_get_IsDispatcherIdle), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IdleDispatchedHandlerArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IdleDispatchedHandlerArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IdleDispatchedHandlerArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IdleDispatchedHandlerArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IdleDispatchedHandlerArgs) },
        { }
    };

    static PyType_Spec type_spec_IdleDispatchedHandlerArgs = {
        "winrt._winrt_windows_ui_core.IdleDispatchedHandlerArgs",
        sizeof(py::wrapper::Windows::UI::Core::IdleDispatchedHandlerArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IdleDispatchedHandlerArgs};

    // ----- InputEnabledEventArgs class --------------------

    static PyObject* _new_InputEnabledEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::InputEnabledEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::InputEnabledEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_InputEnabledEventArgs(py::wrapper::Windows::UI::Core::InputEnabledEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InputEnabledEventArgs_get_Handled(py::wrapper::Windows::UI::Core::InputEnabledEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.InputEnabledEventArgs", L"Handled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InputEnabledEventArgs_put_Handled(py::wrapper::Windows::UI::Core::InputEnabledEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.InputEnabledEventArgs", L"Handled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InputEnabledEventArgs_get_InputEnabled(py::wrapper::Windows::UI::Core::InputEnabledEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.InputEnabledEventArgs", L"InputEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InputEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InputEnabledEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::InputEnabledEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InputEnabledEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::InputEnabledEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputEnabledEventArgs[] = {
        { "_assign_array_", _assign_array_InputEnabledEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InputEnabledEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InputEnabledEventArgs[] = {
        { "handled", reinterpret_cast<getter>(InputEnabledEventArgs_get_Handled), reinterpret_cast<setter>(InputEnabledEventArgs_put_Handled), nullptr, nullptr },
        { "input_enabled", reinterpret_cast<getter>(InputEnabledEventArgs_get_InputEnabled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InputEnabledEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InputEnabledEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InputEnabledEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InputEnabledEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InputEnabledEventArgs) },
        { }
    };

    static PyType_Spec type_spec_InputEnabledEventArgs = {
        "winrt._winrt_windows_ui_core.InputEnabledEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::InputEnabledEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InputEnabledEventArgs};

    // ----- KeyEventArgs class --------------------

    static PyObject* _new_KeyEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::KeyEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::KeyEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_KeyEventArgs(py::wrapper::Windows::UI::Core::KeyEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* KeyEventArgs_get_Handled(py::wrapper::Windows::UI::Core::KeyEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.KeyEventArgs", L"Handled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeyEventArgs_put_Handled(py::wrapper::Windows::UI::Core::KeyEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.KeyEventArgs", L"Handled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* KeyEventArgs_get_KeyStatus(py::wrapper::Windows::UI::Core::KeyEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.KeyEventArgs", L"KeyStatus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyEventArgs_get_VirtualKey(py::wrapper::Windows::UI::Core::KeyEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.KeyEventArgs", L"VirtualKey"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VirtualKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyEventArgs_get_DeviceId(py::wrapper::Windows::UI::Core::KeyEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.KeyEventArgs", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_KeyEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::KeyEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_KeyEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::KeyEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyEventArgs[] = {
        { "_assign_array_", _assign_array_KeyEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_KeyEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KeyEventArgs[] = {
        { "handled", reinterpret_cast<getter>(KeyEventArgs_get_Handled), reinterpret_cast<setter>(KeyEventArgs_put_Handled), nullptr, nullptr },
        { "key_status", reinterpret_cast<getter>(KeyEventArgs_get_KeyStatus), nullptr, nullptr, nullptr },
        { "virtual_key", reinterpret_cast<getter>(KeyEventArgs_get_VirtualKey), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(KeyEventArgs_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_KeyEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_KeyEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_KeyEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KeyEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KeyEventArgs) },
        { }
    };

    static PyType_Spec type_spec_KeyEventArgs = {
        "winrt._winrt_windows_ui_core.KeyEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::KeyEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyEventArgs};

    // ----- PointerEventArgs class --------------------

    static PyObject* _new_PointerEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::PointerEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::PointerEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PointerEventArgs(py::wrapper::Windows::UI::Core::PointerEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PointerEventArgs_GetIntermediatePoints(py::wrapper::Windows::UI::Core::PointerEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.PointerEventArgs", L"GetIntermediatePoints", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetIntermediatePoints());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointerEventArgs_get_Handled(py::wrapper::Windows::UI::Core::PointerEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.PointerEventArgs", L"Handled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerEventArgs_put_Handled(py::wrapper::Windows::UI::Core::PointerEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.PointerEventArgs", L"Handled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointerEventArgs_get_CurrentPoint(py::wrapper::Windows::UI::Core::PointerEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.PointerEventArgs", L"CurrentPoint"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CurrentPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerEventArgs_get_KeyModifiers(py::wrapper::Windows::UI::Core::PointerEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.PointerEventArgs", L"KeyModifiers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyModifiers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PointerEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::PointerEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PointerEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::PointerEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PointerEventArgs[] = {
        { "get_intermediate_points", reinterpret_cast<PyCFunction>(PointerEventArgs_GetIntermediatePoints), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PointerEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PointerEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PointerEventArgs[] = {
        { "handled", reinterpret_cast<getter>(PointerEventArgs_get_Handled), reinterpret_cast<setter>(PointerEventArgs_put_Handled), nullptr, nullptr },
        { "current_point", reinterpret_cast<getter>(PointerEventArgs_get_CurrentPoint), nullptr, nullptr, nullptr },
        { "key_modifiers", reinterpret_cast<getter>(PointerEventArgs_get_KeyModifiers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PointerEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PointerEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PointerEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PointerEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PointerEventArgs) },
        { }
    };

    static PyType_Spec type_spec_PointerEventArgs = {
        "winrt._winrt_windows_ui_core.PointerEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::PointerEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointerEventArgs};

    // ----- SystemNavigationManager class --------------------

    static PyObject* _new_SystemNavigationManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::SystemNavigationManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::SystemNavigationManager>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemNavigationManager(py::wrapper::Windows::UI::Core::SystemNavigationManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemNavigationManager_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.SystemNavigationManager", L"GetForCurrentView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::UI::Core::SystemNavigationManager::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemNavigationManager_get_AppViewBackButtonVisibility(py::wrapper::Windows::UI::Core::SystemNavigationManager* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.SystemNavigationManager", L"AppViewBackButtonVisibility"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppViewBackButtonVisibility());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemNavigationManager_put_AppViewBackButtonVisibility(py::wrapper::Windows::UI::Core::SystemNavigationManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.SystemNavigationManager", L"AppViewBackButtonVisibility"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Core::AppViewBackButtonVisibility>(arg);

            self->obj.AppViewBackButtonVisibility(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemNavigationManager_add_BackRequested(py::wrapper::Windows::UI::Core::SystemNavigationManager* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.SystemNavigationManager", L"BackRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::UI::Core::BackRequestedEventArgs>>(arg);

            return py::convert(self->obj.BackRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemNavigationManager_remove_BackRequested(py::wrapper::Windows::UI::Core::SystemNavigationManager* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.SystemNavigationManager", L"BackRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BackRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemNavigationManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::SystemNavigationManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemNavigationManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::SystemNavigationManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemNavigationManager[] = {
        { "add_back_requested", reinterpret_cast<PyCFunction>(SystemNavigationManager_add_BackRequested), METH_O, nullptr },
        { "remove_back_requested", reinterpret_cast<PyCFunction>(SystemNavigationManager_remove_BackRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_SystemNavigationManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemNavigationManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemNavigationManager[] = {
        { "app_view_back_button_visibility", reinterpret_cast<getter>(SystemNavigationManager_get_AppViewBackButtonVisibility), reinterpret_cast<setter>(SystemNavigationManager_put_AppViewBackButtonVisibility), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemNavigationManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemNavigationManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemNavigationManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemNavigationManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemNavigationManager) },
        { }
    };

    static PyType_Spec type_spec_SystemNavigationManager = {
        "winrt._winrt_windows_ui_core.SystemNavigationManager",
        sizeof(py::wrapper::Windows::UI::Core::SystemNavigationManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemNavigationManager};

    static PyGetSetDef getset_SystemNavigationManager_Static[] = {
        { }
    };

    static PyMethodDef methods_SystemNavigationManager_Static[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(SystemNavigationManager_GetForCurrentView), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_SystemNavigationManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SystemNavigationManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SystemNavigationManager_Static) },
        { }
    };

    static PyType_Spec type_spec_SystemNavigationManager_Static =
    {
        "winrt._winrt_windows_ui_core.SystemNavigationManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SystemNavigationManager_Static
    };

    // ----- TouchHitTestingEventArgs class --------------------

    static PyObject* _new_TouchHitTestingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::TouchHitTestingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::TouchHitTestingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_TouchHitTestingEventArgs(py::wrapper::Windows::UI::Core::TouchHitTestingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TouchHitTestingEventArgs_EvaluateProximity(py::wrapper::Windows::UI::Core::TouchHitTestingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.TouchHitTestingEventArgs", L"EvaluateProximity", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                return py::convert(self->obj.EvaluateProximity(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TouchHitTestingEventArgs_get_Handled(py::wrapper::Windows::UI::Core::TouchHitTestingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.TouchHitTestingEventArgs", L"Handled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TouchHitTestingEventArgs_put_Handled(py::wrapper::Windows::UI::Core::TouchHitTestingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.TouchHitTestingEventArgs", L"Handled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TouchHitTestingEventArgs_get_ProximityEvaluation(py::wrapper::Windows::UI::Core::TouchHitTestingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.TouchHitTestingEventArgs", L"ProximityEvaluation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProximityEvaluation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TouchHitTestingEventArgs_put_ProximityEvaluation(py::wrapper::Windows::UI::Core::TouchHitTestingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.TouchHitTestingEventArgs", L"ProximityEvaluation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreProximityEvaluation>(arg);

            self->obj.ProximityEvaluation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TouchHitTestingEventArgs_get_BoundingBox(py::wrapper::Windows::UI::Core::TouchHitTestingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.TouchHitTestingEventArgs", L"BoundingBox"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BoundingBox());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TouchHitTestingEventArgs_get_Point(py::wrapper::Windows::UI::Core::TouchHitTestingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.TouchHitTestingEventArgs", L"Point"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Point());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TouchHitTestingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::TouchHitTestingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TouchHitTestingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::TouchHitTestingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TouchHitTestingEventArgs[] = {
        { "evaluate_proximity", reinterpret_cast<PyCFunction>(TouchHitTestingEventArgs_EvaluateProximity), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TouchHitTestingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TouchHitTestingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TouchHitTestingEventArgs[] = {
        { "handled", reinterpret_cast<getter>(TouchHitTestingEventArgs_get_Handled), reinterpret_cast<setter>(TouchHitTestingEventArgs_put_Handled), nullptr, nullptr },
        { "proximity_evaluation", reinterpret_cast<getter>(TouchHitTestingEventArgs_get_ProximityEvaluation), reinterpret_cast<setter>(TouchHitTestingEventArgs_put_ProximityEvaluation), nullptr, nullptr },
        { "bounding_box", reinterpret_cast<getter>(TouchHitTestingEventArgs_get_BoundingBox), nullptr, nullptr, nullptr },
        { "point", reinterpret_cast<getter>(TouchHitTestingEventArgs_get_Point), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TouchHitTestingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TouchHitTestingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TouchHitTestingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TouchHitTestingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TouchHitTestingEventArgs) },
        { }
    };

    static PyType_Spec type_spec_TouchHitTestingEventArgs = {
        "winrt._winrt_windows_ui_core.TouchHitTestingEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::TouchHitTestingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TouchHitTestingEventArgs};

    // ----- VisibilityChangedEventArgs class --------------------

    static PyObject* _new_VisibilityChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::VisibilityChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::VisibilityChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_VisibilityChangedEventArgs(py::wrapper::Windows::UI::Core::VisibilityChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VisibilityChangedEventArgs_get_Handled(py::wrapper::Windows::UI::Core::VisibilityChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.VisibilityChangedEventArgs", L"Handled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VisibilityChangedEventArgs_put_Handled(py::wrapper::Windows::UI::Core::VisibilityChangedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.VisibilityChangedEventArgs", L"Handled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VisibilityChangedEventArgs_get_Visible(py::wrapper::Windows::UI::Core::VisibilityChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.VisibilityChangedEventArgs", L"Visible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Visible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VisibilityChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::VisibilityChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VisibilityChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::VisibilityChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VisibilityChangedEventArgs[] = {
        { "_assign_array_", _assign_array_VisibilityChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VisibilityChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VisibilityChangedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(VisibilityChangedEventArgs_get_Handled), reinterpret_cast<setter>(VisibilityChangedEventArgs_put_Handled), nullptr, nullptr },
        { "visible", reinterpret_cast<getter>(VisibilityChangedEventArgs_get_Visible), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VisibilityChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VisibilityChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VisibilityChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VisibilityChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VisibilityChangedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_VisibilityChangedEventArgs = {
        "winrt._winrt_windows_ui_core.VisibilityChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::VisibilityChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VisibilityChangedEventArgs};

    // ----- WindowActivatedEventArgs class --------------------

    static PyObject* _new_WindowActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::WindowActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::WindowActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowActivatedEventArgs(py::wrapper::Windows::UI::Core::WindowActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowActivatedEventArgs_get_Handled(py::wrapper::Windows::UI::Core::WindowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.WindowActivatedEventArgs", L"Handled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowActivatedEventArgs_put_Handled(py::wrapper::Windows::UI::Core::WindowActivatedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.WindowActivatedEventArgs", L"Handled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowActivatedEventArgs_get_WindowActivationState(py::wrapper::Windows::UI::Core::WindowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.WindowActivatedEventArgs", L"WindowActivationState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WindowActivationState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::WindowActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::WindowActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WindowActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WindowActivatedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(WindowActivatedEventArgs_get_Handled), reinterpret_cast<setter>(WindowActivatedEventArgs_put_Handled), nullptr, nullptr },
        { "window_activation_state", reinterpret_cast<getter>(WindowActivatedEventArgs_get_WindowActivationState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WindowActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_WindowActivatedEventArgs = {
        "winrt._winrt_windows_ui_core.WindowActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::WindowActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowActivatedEventArgs};

    // ----- WindowSizeChangedEventArgs class --------------------

    static PyObject* _new_WindowSizeChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::WindowSizeChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::WindowSizeChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowSizeChangedEventArgs(py::wrapper::Windows::UI::Core::WindowSizeChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowSizeChangedEventArgs_get_Handled(py::wrapper::Windows::UI::Core::WindowSizeChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.WindowSizeChangedEventArgs", L"Handled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowSizeChangedEventArgs_put_Handled(py::wrapper::Windows::UI::Core::WindowSizeChangedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.WindowSizeChangedEventArgs", L"Handled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowSizeChangedEventArgs_get_Size(py::wrapper::Windows::UI::Core::WindowSizeChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.WindowSizeChangedEventArgs", L"Size"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowSizeChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::WindowSizeChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowSizeChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::WindowSizeChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowSizeChangedEventArgs[] = {
        { "_assign_array_", _assign_array_WindowSizeChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowSizeChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WindowSizeChangedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(WindowSizeChangedEventArgs_get_Handled), reinterpret_cast<setter>(WindowSizeChangedEventArgs_put_Handled), nullptr, nullptr },
        { "size", reinterpret_cast<getter>(WindowSizeChangedEventArgs_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WindowSizeChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowSizeChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowSizeChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowSizeChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowSizeChangedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_WindowSizeChangedEventArgs = {
        "winrt._winrt_windows_ui_core.WindowSizeChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::WindowSizeChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowSizeChangedEventArgs};

    // ----- ICoreAcceleratorKeys interface --------------------

    static PyObject* _new_ICoreAcceleratorKeys(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::ICoreAcceleratorKeys>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::ICoreAcceleratorKeys>::type_name);
        return nullptr;
    }

    static void _dealloc_ICoreAcceleratorKeys(py::wrapper::Windows::UI::Core::ICoreAcceleratorKeys* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICoreAcceleratorKeys_add_AcceleratorKeyActivated(py::wrapper::Windows::UI::Core::ICoreAcceleratorKeys* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreAcceleratorKeys", L"AcceleratorKeyActivated"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreDispatcher, winrt::Windows::UI::Core::AcceleratorKeyEventArgs>>(arg);

            return py::convert(self->obj.AcceleratorKeyActivated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreAcceleratorKeys_remove_AcceleratorKeyActivated(py::wrapper::Windows::UI::Core::ICoreAcceleratorKeys* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreAcceleratorKeys", L"AcceleratorKeyActivated"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AcceleratorKeyActivated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICoreAcceleratorKeys(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::ICoreAcceleratorKeys>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICoreAcceleratorKeys(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::ICoreAcceleratorKeys>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICoreAcceleratorKeys[] = {
        { "add_accelerator_key_activated", reinterpret_cast<PyCFunction>(ICoreAcceleratorKeys_add_AcceleratorKeyActivated), METH_O, nullptr },
        { "remove_accelerator_key_activated", reinterpret_cast<PyCFunction>(ICoreAcceleratorKeys_remove_AcceleratorKeyActivated), METH_O, nullptr },
        { "_assign_array_", _assign_array_ICoreAcceleratorKeys, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICoreAcceleratorKeys), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICoreAcceleratorKeys[] = {
        { }
    };

    static PyType_Slot _type_slots_ICoreAcceleratorKeys[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICoreAcceleratorKeys) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICoreAcceleratorKeys) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICoreAcceleratorKeys) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICoreAcceleratorKeys) },
        { }
    };

    static PyType_Spec type_spec_ICoreAcceleratorKeys = {
        "winrt._winrt_windows_ui_core.ICoreAcceleratorKeys",
        sizeof(py::wrapper::Windows::UI::Core::ICoreAcceleratorKeys),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICoreAcceleratorKeys};

    // ----- ICoreInputSourceBase interface --------------------

    static PyObject* _new_ICoreInputSourceBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::ICoreInputSourceBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::ICoreInputSourceBase>::type_name);
        return nullptr;
    }

    static void _dealloc_ICoreInputSourceBase(py::wrapper::Windows::UI::Core::ICoreInputSourceBase* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICoreInputSourceBase_get_Dispatcher(py::wrapper::Windows::UI::Core::ICoreInputSourceBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreInputSourceBase", L"Dispatcher"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreInputSourceBase_get_IsInputEnabled(py::wrapper::Windows::UI::Core::ICoreInputSourceBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreInputSourceBase", L"IsInputEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsInputEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICoreInputSourceBase_put_IsInputEnabled(py::wrapper::Windows::UI::Core::ICoreInputSourceBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreInputSourceBase", L"IsInputEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsInputEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ICoreInputSourceBase_add_InputEnabled(py::wrapper::Windows::UI::Core::ICoreInputSourceBase* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreInputSourceBase", L"InputEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::InputEnabledEventArgs>>(arg);

            return py::convert(self->obj.InputEnabled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreInputSourceBase_remove_InputEnabled(py::wrapper::Windows::UI::Core::ICoreInputSourceBase* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreInputSourceBase", L"InputEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.InputEnabled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICoreInputSourceBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::ICoreInputSourceBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICoreInputSourceBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::ICoreInputSourceBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICoreInputSourceBase[] = {
        { "add_input_enabled", reinterpret_cast<PyCFunction>(ICoreInputSourceBase_add_InputEnabled), METH_O, nullptr },
        { "remove_input_enabled", reinterpret_cast<PyCFunction>(ICoreInputSourceBase_remove_InputEnabled), METH_O, nullptr },
        { "_assign_array_", _assign_array_ICoreInputSourceBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICoreInputSourceBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICoreInputSourceBase[] = {
        { "dispatcher", reinterpret_cast<getter>(ICoreInputSourceBase_get_Dispatcher), nullptr, nullptr, nullptr },
        { "is_input_enabled", reinterpret_cast<getter>(ICoreInputSourceBase_get_IsInputEnabled), reinterpret_cast<setter>(ICoreInputSourceBase_put_IsInputEnabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICoreInputSourceBase[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICoreInputSourceBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICoreInputSourceBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICoreInputSourceBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICoreInputSourceBase) },
        { }
    };

    static PyType_Spec type_spec_ICoreInputSourceBase = {
        "winrt._winrt_windows_ui_core.ICoreInputSourceBase",
        sizeof(py::wrapper::Windows::UI::Core::ICoreInputSourceBase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICoreInputSourceBase};

    // ----- ICorePointerInputSource interface --------------------

    static PyObject* _new_ICorePointerInputSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::ICorePointerInputSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::ICorePointerInputSource>::type_name);
        return nullptr;
    }

    static void _dealloc_ICorePointerInputSource(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICorePointerInputSource_ReleasePointerCapture(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.ICorePointerInputSource", L"ReleasePointerCapture", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ReleasePointerCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_SetPointerCapture(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.ICorePointerInputSource", L"SetPointerCapture", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.SetPointerCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_get_HasCapture(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICorePointerInputSource", L"HasCapture"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HasCapture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_get_PointerCursor(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerCursor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PointerCursor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICorePointerInputSource_put_PointerCursor(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerCursor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreCursor>(arg);

            self->obj.PointerCursor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ICorePointerInputSource_get_PointerPosition(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerPosition"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PointerPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_add_PointerCaptureLost(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerCaptureLost"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerCaptureLost(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_remove_PointerCaptureLost(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerCaptureLost"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerCaptureLost(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_add_PointerEntered(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerEntered"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerEntered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_remove_PointerEntered(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerEntered"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerEntered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_add_PointerExited(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerExited"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerExited(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_remove_PointerExited(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerExited"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerExited(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_add_PointerMoved(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerMoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerMoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_remove_PointerMoved(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerMoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerMoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_add_PointerPressed(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerPressed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_remove_PointerPressed(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerPressed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_add_PointerReleased(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerReleased"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerReleased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_remove_PointerReleased(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerReleased"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerReleased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_add_PointerWheelChanged(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerWheelChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerWheelChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource_remove_PointerWheelChanged(py::wrapper::Windows::UI::Core::ICorePointerInputSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerWheelChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerWheelChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICorePointerInputSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::ICorePointerInputSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICorePointerInputSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::ICorePointerInputSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICorePointerInputSource[] = {
        { "release_pointer_capture", reinterpret_cast<PyCFunction>(ICorePointerInputSource_ReleasePointerCapture), METH_VARARGS, nullptr },
        { "set_pointer_capture", reinterpret_cast<PyCFunction>(ICorePointerInputSource_SetPointerCapture), METH_VARARGS, nullptr },
        { "add_pointer_capture_lost", reinterpret_cast<PyCFunction>(ICorePointerInputSource_add_PointerCaptureLost), METH_O, nullptr },
        { "remove_pointer_capture_lost", reinterpret_cast<PyCFunction>(ICorePointerInputSource_remove_PointerCaptureLost), METH_O, nullptr },
        { "add_pointer_entered", reinterpret_cast<PyCFunction>(ICorePointerInputSource_add_PointerEntered), METH_O, nullptr },
        { "remove_pointer_entered", reinterpret_cast<PyCFunction>(ICorePointerInputSource_remove_PointerEntered), METH_O, nullptr },
        { "add_pointer_exited", reinterpret_cast<PyCFunction>(ICorePointerInputSource_add_PointerExited), METH_O, nullptr },
        { "remove_pointer_exited", reinterpret_cast<PyCFunction>(ICorePointerInputSource_remove_PointerExited), METH_O, nullptr },
        { "add_pointer_moved", reinterpret_cast<PyCFunction>(ICorePointerInputSource_add_PointerMoved), METH_O, nullptr },
        { "remove_pointer_moved", reinterpret_cast<PyCFunction>(ICorePointerInputSource_remove_PointerMoved), METH_O, nullptr },
        { "add_pointer_pressed", reinterpret_cast<PyCFunction>(ICorePointerInputSource_add_PointerPressed), METH_O, nullptr },
        { "remove_pointer_pressed", reinterpret_cast<PyCFunction>(ICorePointerInputSource_remove_PointerPressed), METH_O, nullptr },
        { "add_pointer_released", reinterpret_cast<PyCFunction>(ICorePointerInputSource_add_PointerReleased), METH_O, nullptr },
        { "remove_pointer_released", reinterpret_cast<PyCFunction>(ICorePointerInputSource_remove_PointerReleased), METH_O, nullptr },
        { "add_pointer_wheel_changed", reinterpret_cast<PyCFunction>(ICorePointerInputSource_add_PointerWheelChanged), METH_O, nullptr },
        { "remove_pointer_wheel_changed", reinterpret_cast<PyCFunction>(ICorePointerInputSource_remove_PointerWheelChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ICorePointerInputSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICorePointerInputSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICorePointerInputSource[] = {
        { "has_capture", reinterpret_cast<getter>(ICorePointerInputSource_get_HasCapture), nullptr, nullptr, nullptr },
        { "pointer_cursor", reinterpret_cast<getter>(ICorePointerInputSource_get_PointerCursor), reinterpret_cast<setter>(ICorePointerInputSource_put_PointerCursor), nullptr, nullptr },
        { "pointer_position", reinterpret_cast<getter>(ICorePointerInputSource_get_PointerPosition), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICorePointerInputSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICorePointerInputSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICorePointerInputSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICorePointerInputSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICorePointerInputSource) },
        { }
    };

    static PyType_Spec type_spec_ICorePointerInputSource = {
        "winrt._winrt_windows_ui_core.ICorePointerInputSource",
        sizeof(py::wrapper::Windows::UI::Core::ICorePointerInputSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICorePointerInputSource};

    // ----- ICorePointerInputSource2 interface --------------------

    static PyObject* _new_ICorePointerInputSource2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::ICorePointerInputSource2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::ICorePointerInputSource2>::type_name);
        return nullptr;
    }

    static void _dealloc_ICorePointerInputSource2(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICorePointerInputSource2_ReleasePointerCapture(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.ICorePointerInputSource", L"ReleasePointerCapture", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ReleasePointerCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_SetPointerCapture(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.ICorePointerInputSource", L"SetPointerCapture", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.SetPointerCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_get_DispatcherQueue(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICorePointerInputSource2", L"DispatcherQueue"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DispatcherQueue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_get_HasCapture(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICorePointerInputSource", L"HasCapture"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HasCapture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_get_PointerCursor(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerCursor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PointerCursor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICorePointerInputSource2_put_PointerCursor(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerCursor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreCursor>(arg);

            self->obj.PointerCursor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ICorePointerInputSource2_get_PointerPosition(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerPosition"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PointerPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_add_PointerCaptureLost(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerCaptureLost"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerCaptureLost(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_remove_PointerCaptureLost(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerCaptureLost"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerCaptureLost(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_add_PointerEntered(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerEntered"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerEntered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_remove_PointerEntered(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerEntered"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerEntered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_add_PointerExited(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerExited"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerExited(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_remove_PointerExited(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerExited"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerExited(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_add_PointerMoved(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerMoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerMoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_remove_PointerMoved(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerMoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerMoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_add_PointerPressed(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerPressed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_remove_PointerPressed(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerPressed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_add_PointerReleased(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerReleased"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerReleased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_remove_PointerReleased(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerReleased"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerReleased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_add_PointerWheelChanged(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerWheelChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerWheelChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerInputSource2_remove_PointerWheelChanged(py::wrapper::Windows::UI::Core::ICorePointerInputSource2* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerInputSource", L"PointerWheelChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerWheelChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICorePointerInputSource2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::ICorePointerInputSource2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICorePointerInputSource2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::ICorePointerInputSource2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICorePointerInputSource2[] = {
        { "release_pointer_capture", reinterpret_cast<PyCFunction>(ICorePointerInputSource2_ReleasePointerCapture), METH_VARARGS, nullptr },
        { "set_pointer_capture", reinterpret_cast<PyCFunction>(ICorePointerInputSource2_SetPointerCapture), METH_VARARGS, nullptr },
        { "add_pointer_capture_lost", reinterpret_cast<PyCFunction>(ICorePointerInputSource2_add_PointerCaptureLost), METH_O, nullptr },
        { "remove_pointer_capture_lost", reinterpret_cast<PyCFunction>(ICorePointerInputSource2_remove_PointerCaptureLost), METH_O, nullptr },
        { "add_pointer_entered", reinterpret_cast<PyCFunction>(ICorePointerInputSource2_add_PointerEntered), METH_O, nullptr },
        { "remove_pointer_entered", reinterpret_cast<PyCFunction>(ICorePointerInputSource2_remove_PointerEntered), METH_O, nullptr },
        { "add_pointer_exited", reinterpret_cast<PyCFunction>(ICorePointerInputSource2_add_PointerExited), METH_O, nullptr },
        { "remove_pointer_exited", reinterpret_cast<PyCFunction>(ICorePointerInputSource2_remove_PointerExited), METH_O, nullptr },
        { "add_pointer_moved", reinterpret_cast<PyCFunction>(ICorePointerInputSource2_add_PointerMoved), METH_O, nullptr },
        { "remove_pointer_moved", reinterpret_cast<PyCFunction>(ICorePointerInputSource2_remove_PointerMoved), METH_O, nullptr },
        { "add_pointer_pressed", reinterpret_cast<PyCFunction>(ICorePointerInputSource2_add_PointerPressed), METH_O, nullptr },
        { "remove_pointer_pressed", reinterpret_cast<PyCFunction>(ICorePointerInputSource2_remove_PointerPressed), METH_O, nullptr },
        { "add_pointer_released", reinterpret_cast<PyCFunction>(ICorePointerInputSource2_add_PointerReleased), METH_O, nullptr },
        { "remove_pointer_released", reinterpret_cast<PyCFunction>(ICorePointerInputSource2_remove_PointerReleased), METH_O, nullptr },
        { "add_pointer_wheel_changed", reinterpret_cast<PyCFunction>(ICorePointerInputSource2_add_PointerWheelChanged), METH_O, nullptr },
        { "remove_pointer_wheel_changed", reinterpret_cast<PyCFunction>(ICorePointerInputSource2_remove_PointerWheelChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ICorePointerInputSource2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICorePointerInputSource2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICorePointerInputSource2[] = {
        { "dispatcher_queue", reinterpret_cast<getter>(ICorePointerInputSource2_get_DispatcherQueue), nullptr, nullptr, nullptr },
        { "has_capture", reinterpret_cast<getter>(ICorePointerInputSource2_get_HasCapture), nullptr, nullptr, nullptr },
        { "pointer_cursor", reinterpret_cast<getter>(ICorePointerInputSource2_get_PointerCursor), reinterpret_cast<setter>(ICorePointerInputSource2_put_PointerCursor), nullptr, nullptr },
        { "pointer_position", reinterpret_cast<getter>(ICorePointerInputSource2_get_PointerPosition), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICorePointerInputSource2[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICorePointerInputSource2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICorePointerInputSource2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICorePointerInputSource2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICorePointerInputSource2) },
        { }
    };

    static PyType_Spec type_spec_ICorePointerInputSource2 = {
        "winrt._winrt_windows_ui_core.ICorePointerInputSource2",
        sizeof(py::wrapper::Windows::UI::Core::ICorePointerInputSource2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICorePointerInputSource2};

    // ----- ICorePointerRedirector interface --------------------

    static PyObject* _new_ICorePointerRedirector(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::ICorePointerRedirector>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::ICorePointerRedirector>::type_name);
        return nullptr;
    }

    static void _dealloc_ICorePointerRedirector(py::wrapper::Windows::UI::Core::ICorePointerRedirector* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICorePointerRedirector_add_PointerRoutedAway(py::wrapper::Windows::UI::Core::ICorePointerRedirector* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerRedirector", L"PointerRoutedAway"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::ICorePointerRedirector, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerRoutedAway(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerRedirector_remove_PointerRoutedAway(py::wrapper::Windows::UI::Core::ICorePointerRedirector* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerRedirector", L"PointerRoutedAway"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerRoutedAway(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerRedirector_add_PointerRoutedReleased(py::wrapper::Windows::UI::Core::ICorePointerRedirector* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerRedirector", L"PointerRoutedReleased"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::ICorePointerRedirector, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerRoutedReleased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerRedirector_remove_PointerRoutedReleased(py::wrapper::Windows::UI::Core::ICorePointerRedirector* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerRedirector", L"PointerRoutedReleased"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerRoutedReleased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerRedirector_add_PointerRoutedTo(py::wrapper::Windows::UI::Core::ICorePointerRedirector* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerRedirector", L"PointerRoutedTo"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::ICorePointerRedirector, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerRoutedTo(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICorePointerRedirector_remove_PointerRoutedTo(py::wrapper::Windows::UI::Core::ICorePointerRedirector* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICorePointerRedirector", L"PointerRoutedTo"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerRoutedTo(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICorePointerRedirector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::ICorePointerRedirector>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICorePointerRedirector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::ICorePointerRedirector>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICorePointerRedirector[] = {
        { "add_pointer_routed_away", reinterpret_cast<PyCFunction>(ICorePointerRedirector_add_PointerRoutedAway), METH_O, nullptr },
        { "remove_pointer_routed_away", reinterpret_cast<PyCFunction>(ICorePointerRedirector_remove_PointerRoutedAway), METH_O, nullptr },
        { "add_pointer_routed_released", reinterpret_cast<PyCFunction>(ICorePointerRedirector_add_PointerRoutedReleased), METH_O, nullptr },
        { "remove_pointer_routed_released", reinterpret_cast<PyCFunction>(ICorePointerRedirector_remove_PointerRoutedReleased), METH_O, nullptr },
        { "add_pointer_routed_to", reinterpret_cast<PyCFunction>(ICorePointerRedirector_add_PointerRoutedTo), METH_O, nullptr },
        { "remove_pointer_routed_to", reinterpret_cast<PyCFunction>(ICorePointerRedirector_remove_PointerRoutedTo), METH_O, nullptr },
        { "_assign_array_", _assign_array_ICorePointerRedirector, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICorePointerRedirector), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICorePointerRedirector[] = {
        { }
    };

    static PyType_Slot _type_slots_ICorePointerRedirector[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICorePointerRedirector) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICorePointerRedirector) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICorePointerRedirector) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICorePointerRedirector) },
        { }
    };

    static PyType_Spec type_spec_ICorePointerRedirector = {
        "winrt._winrt_windows_ui_core.ICorePointerRedirector",
        sizeof(py::wrapper::Windows::UI::Core::ICorePointerRedirector),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICorePointerRedirector};

    // ----- ICoreWindow interface --------------------

    static PyObject* _new_ICoreWindow(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::ICoreWindow>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::ICoreWindow>::type_name);
        return nullptr;
    }

    static void _dealloc_ICoreWindow(py::wrapper::Windows::UI::Core::ICoreWindow* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICoreWindow_Activate(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.ICoreWindow", L"Activate", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Activate();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_Close(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.ICoreWindow", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_GetAsyncKeyState(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.ICoreWindow", L"GetAsyncKeyState", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::VirtualKey>(args, 0);

                return py::convert(self->obj.GetAsyncKeyState(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_GetKeyState(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.ICoreWindow", L"GetKeyState", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::VirtualKey>(args, 0);

                return py::convert(self->obj.GetKeyState(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_ReleasePointerCapture(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.ICoreWindow", L"ReleasePointerCapture", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ReleasePointerCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_SetPointerCapture(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.ICoreWindow", L"SetPointerCapture", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.SetPointerCapture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_get_AutomationHostProvider(py::wrapper::Windows::UI::Core::ICoreWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreWindow", L"AutomationHostProvider"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AutomationHostProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_get_Bounds(py::wrapper::Windows::UI::Core::ICoreWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreWindow", L"Bounds"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Bounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_get_CustomProperties(py::wrapper::Windows::UI::Core::ICoreWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreWindow", L"CustomProperties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CustomProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_get_Dispatcher(py::wrapper::Windows::UI::Core::ICoreWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreWindow", L"Dispatcher"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_get_FlowDirection(py::wrapper::Windows::UI::Core::ICoreWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreWindow", L"FlowDirection"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FlowDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICoreWindow_put_FlowDirection(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreWindow", L"FlowDirection"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreWindowFlowDirection>(arg);

            self->obj.FlowDirection(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ICoreWindow_get_IsInputEnabled(py::wrapper::Windows::UI::Core::ICoreWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreWindow", L"IsInputEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsInputEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICoreWindow_put_IsInputEnabled(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreWindow", L"IsInputEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsInputEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ICoreWindow_get_PointerCursor(py::wrapper::Windows::UI::Core::ICoreWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreWindow", L"PointerCursor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PointerCursor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICoreWindow_put_PointerCursor(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreWindow", L"PointerCursor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreCursor>(arg);

            self->obj.PointerCursor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ICoreWindow_get_PointerPosition(py::wrapper::Windows::UI::Core::ICoreWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreWindow", L"PointerPosition"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PointerPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_get_Visible(py::wrapper::Windows::UI::Core::ICoreWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreWindow", L"Visible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Visible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_Activated(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"Activated"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::WindowActivatedEventArgs>>(arg);

            return py::convert(self->obj.Activated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_Activated(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"Activated"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Activated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_AutomationProviderRequested(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"AutomationProviderRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::AutomationProviderRequestedEventArgs>>(arg);

            return py::convert(self->obj.AutomationProviderRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_AutomationProviderRequested(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"AutomationProviderRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AutomationProviderRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_CharacterReceived(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"CharacterReceived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::CharacterReceivedEventArgs>>(arg);

            return py::convert(self->obj.CharacterReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_CharacterReceived(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"CharacterReceived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CharacterReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_Closed(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"Closed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::CoreWindowEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_Closed(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"Closed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_InputEnabled(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"InputEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::InputEnabledEventArgs>>(arg);

            return py::convert(self->obj.InputEnabled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_InputEnabled(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"InputEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.InputEnabled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_KeyDown(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"KeyDown"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::KeyEventArgs>>(arg);

            return py::convert(self->obj.KeyDown(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_KeyDown(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"KeyDown"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.KeyDown(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_KeyUp(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"KeyUp"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::KeyEventArgs>>(arg);

            return py::convert(self->obj.KeyUp(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_KeyUp(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"KeyUp"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.KeyUp(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_PointerCaptureLost(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"PointerCaptureLost"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerCaptureLost(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_PointerCaptureLost(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"PointerCaptureLost"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerCaptureLost(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_PointerEntered(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"PointerEntered"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerEntered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_PointerEntered(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"PointerEntered"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerEntered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_PointerExited(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"PointerExited"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerExited(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_PointerExited(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"PointerExited"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerExited(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_PointerMoved(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"PointerMoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerMoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_PointerMoved(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"PointerMoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerMoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_PointerPressed(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"PointerPressed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_PointerPressed(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"PointerPressed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_PointerReleased(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"PointerReleased"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerReleased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_PointerReleased(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"PointerReleased"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerReleased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_PointerWheelChanged(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"PointerWheelChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerWheelChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_PointerWheelChanged(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"PointerWheelChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerWheelChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_SizeChanged(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"SizeChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::WindowSizeChangedEventArgs>>(arg);

            return py::convert(self->obj.SizeChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_SizeChanged(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"SizeChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SizeChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_TouchHitTesting(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"TouchHitTesting"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::TouchHitTestingEventArgs>>(arg);

            return py::convert(self->obj.TouchHitTesting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_TouchHitTesting(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"TouchHitTesting"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TouchHitTesting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_add_VisibilityChanged(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"VisibilityChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::CoreWindow, winrt::Windows::UI::Core::VisibilityChangedEventArgs>>(arg);

            return py::convert(self->obj.VisibilityChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICoreWindow_remove_VisibilityChanged(py::wrapper::Windows::UI::Core::ICoreWindow* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.ICoreWindow", L"VisibilityChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VisibilityChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICoreWindow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::ICoreWindow>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICoreWindow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::ICoreWindow>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICoreWindow[] = {
        { "activate", reinterpret_cast<PyCFunction>(ICoreWindow_Activate), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(ICoreWindow_Close), METH_VARARGS, nullptr },
        { "get_async_key_state", reinterpret_cast<PyCFunction>(ICoreWindow_GetAsyncKeyState), METH_VARARGS, nullptr },
        { "get_key_state", reinterpret_cast<PyCFunction>(ICoreWindow_GetKeyState), METH_VARARGS, nullptr },
        { "release_pointer_capture", reinterpret_cast<PyCFunction>(ICoreWindow_ReleasePointerCapture), METH_VARARGS, nullptr },
        { "set_pointer_capture", reinterpret_cast<PyCFunction>(ICoreWindow_SetPointerCapture), METH_VARARGS, nullptr },
        { "add_activated", reinterpret_cast<PyCFunction>(ICoreWindow_add_Activated), METH_O, nullptr },
        { "remove_activated", reinterpret_cast<PyCFunction>(ICoreWindow_remove_Activated), METH_O, nullptr },
        { "add_automation_provider_requested", reinterpret_cast<PyCFunction>(ICoreWindow_add_AutomationProviderRequested), METH_O, nullptr },
        { "remove_automation_provider_requested", reinterpret_cast<PyCFunction>(ICoreWindow_remove_AutomationProviderRequested), METH_O, nullptr },
        { "add_character_received", reinterpret_cast<PyCFunction>(ICoreWindow_add_CharacterReceived), METH_O, nullptr },
        { "remove_character_received", reinterpret_cast<PyCFunction>(ICoreWindow_remove_CharacterReceived), METH_O, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(ICoreWindow_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(ICoreWindow_remove_Closed), METH_O, nullptr },
        { "add_input_enabled", reinterpret_cast<PyCFunction>(ICoreWindow_add_InputEnabled), METH_O, nullptr },
        { "remove_input_enabled", reinterpret_cast<PyCFunction>(ICoreWindow_remove_InputEnabled), METH_O, nullptr },
        { "add_key_down", reinterpret_cast<PyCFunction>(ICoreWindow_add_KeyDown), METH_O, nullptr },
        { "remove_key_down", reinterpret_cast<PyCFunction>(ICoreWindow_remove_KeyDown), METH_O, nullptr },
        { "add_key_up", reinterpret_cast<PyCFunction>(ICoreWindow_add_KeyUp), METH_O, nullptr },
        { "remove_key_up", reinterpret_cast<PyCFunction>(ICoreWindow_remove_KeyUp), METH_O, nullptr },
        { "add_pointer_capture_lost", reinterpret_cast<PyCFunction>(ICoreWindow_add_PointerCaptureLost), METH_O, nullptr },
        { "remove_pointer_capture_lost", reinterpret_cast<PyCFunction>(ICoreWindow_remove_PointerCaptureLost), METH_O, nullptr },
        { "add_pointer_entered", reinterpret_cast<PyCFunction>(ICoreWindow_add_PointerEntered), METH_O, nullptr },
        { "remove_pointer_entered", reinterpret_cast<PyCFunction>(ICoreWindow_remove_PointerEntered), METH_O, nullptr },
        { "add_pointer_exited", reinterpret_cast<PyCFunction>(ICoreWindow_add_PointerExited), METH_O, nullptr },
        { "remove_pointer_exited", reinterpret_cast<PyCFunction>(ICoreWindow_remove_PointerExited), METH_O, nullptr },
        { "add_pointer_moved", reinterpret_cast<PyCFunction>(ICoreWindow_add_PointerMoved), METH_O, nullptr },
        { "remove_pointer_moved", reinterpret_cast<PyCFunction>(ICoreWindow_remove_PointerMoved), METH_O, nullptr },
        { "add_pointer_pressed", reinterpret_cast<PyCFunction>(ICoreWindow_add_PointerPressed), METH_O, nullptr },
        { "remove_pointer_pressed", reinterpret_cast<PyCFunction>(ICoreWindow_remove_PointerPressed), METH_O, nullptr },
        { "add_pointer_released", reinterpret_cast<PyCFunction>(ICoreWindow_add_PointerReleased), METH_O, nullptr },
        { "remove_pointer_released", reinterpret_cast<PyCFunction>(ICoreWindow_remove_PointerReleased), METH_O, nullptr },
        { "add_pointer_wheel_changed", reinterpret_cast<PyCFunction>(ICoreWindow_add_PointerWheelChanged), METH_O, nullptr },
        { "remove_pointer_wheel_changed", reinterpret_cast<PyCFunction>(ICoreWindow_remove_PointerWheelChanged), METH_O, nullptr },
        { "add_size_changed", reinterpret_cast<PyCFunction>(ICoreWindow_add_SizeChanged), METH_O, nullptr },
        { "remove_size_changed", reinterpret_cast<PyCFunction>(ICoreWindow_remove_SizeChanged), METH_O, nullptr },
        { "add_touch_hit_testing", reinterpret_cast<PyCFunction>(ICoreWindow_add_TouchHitTesting), METH_O, nullptr },
        { "remove_touch_hit_testing", reinterpret_cast<PyCFunction>(ICoreWindow_remove_TouchHitTesting), METH_O, nullptr },
        { "add_visibility_changed", reinterpret_cast<PyCFunction>(ICoreWindow_add_VisibilityChanged), METH_O, nullptr },
        { "remove_visibility_changed", reinterpret_cast<PyCFunction>(ICoreWindow_remove_VisibilityChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ICoreWindow, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICoreWindow), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICoreWindow[] = {
        { "automation_host_provider", reinterpret_cast<getter>(ICoreWindow_get_AutomationHostProvider), nullptr, nullptr, nullptr },
        { "bounds", reinterpret_cast<getter>(ICoreWindow_get_Bounds), nullptr, nullptr, nullptr },
        { "custom_properties", reinterpret_cast<getter>(ICoreWindow_get_CustomProperties), nullptr, nullptr, nullptr },
        { "dispatcher", reinterpret_cast<getter>(ICoreWindow_get_Dispatcher), nullptr, nullptr, nullptr },
        { "flow_direction", reinterpret_cast<getter>(ICoreWindow_get_FlowDirection), reinterpret_cast<setter>(ICoreWindow_put_FlowDirection), nullptr, nullptr },
        { "is_input_enabled", reinterpret_cast<getter>(ICoreWindow_get_IsInputEnabled), reinterpret_cast<setter>(ICoreWindow_put_IsInputEnabled), nullptr, nullptr },
        { "pointer_cursor", reinterpret_cast<getter>(ICoreWindow_get_PointerCursor), reinterpret_cast<setter>(ICoreWindow_put_PointerCursor), nullptr, nullptr },
        { "pointer_position", reinterpret_cast<getter>(ICoreWindow_get_PointerPosition), nullptr, nullptr, nullptr },
        { "visible", reinterpret_cast<getter>(ICoreWindow_get_Visible), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICoreWindow[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICoreWindow) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICoreWindow) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICoreWindow) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICoreWindow) },
        { }
    };

    static PyType_Spec type_spec_ICoreWindow = {
        "winrt._winrt_windows_ui_core.ICoreWindow",
        sizeof(py::wrapper::Windows::UI::Core::ICoreWindow),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICoreWindow};

    // ----- ICoreWindowEventArgs interface --------------------

    static PyObject* _new_ICoreWindowEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::ICoreWindowEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::ICoreWindowEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ICoreWindowEventArgs(py::wrapper::Windows::UI::Core::ICoreWindowEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICoreWindowEventArgs_get_Handled(py::wrapper::Windows::UI::Core::ICoreWindowEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreWindowEventArgs", L"Handled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICoreWindowEventArgs_put_Handled(py::wrapper::Windows::UI::Core::ICoreWindowEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.ICoreWindowEventArgs", L"Handled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ICoreWindowEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::ICoreWindowEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICoreWindowEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::ICoreWindowEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICoreWindowEventArgs[] = {
        { "_assign_array_", _assign_array_ICoreWindowEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICoreWindowEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICoreWindowEventArgs[] = {
        { "handled", reinterpret_cast<getter>(ICoreWindowEventArgs_get_Handled), reinterpret_cast<setter>(ICoreWindowEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICoreWindowEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICoreWindowEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICoreWindowEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICoreWindowEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICoreWindowEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ICoreWindowEventArgs = {
        "winrt._winrt_windows_ui_core.ICoreWindowEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::ICoreWindowEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICoreWindowEventArgs};

    // ----- IInitializeWithCoreWindow interface --------------------

    static PyObject* _new_IInitializeWithCoreWindow(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Core::IInitializeWithCoreWindow>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Core::IInitializeWithCoreWindow>::type_name);
        return nullptr;
    }

    static void _dealloc_IInitializeWithCoreWindow(py::wrapper::Windows::UI::Core::IInitializeWithCoreWindow* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IInitializeWithCoreWindow_Initialize(py::wrapper::Windows::UI::Core::IInitializeWithCoreWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.IInitializeWithCoreWindow", L"Initialize", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreWindow>(args, 0);

                self->obj.Initialize(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IInitializeWithCoreWindow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::IInitializeWithCoreWindow>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IInitializeWithCoreWindow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::IInitializeWithCoreWindow>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IInitializeWithCoreWindow[] = {
        { "initialize", reinterpret_cast<PyCFunction>(IInitializeWithCoreWindow_Initialize), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IInitializeWithCoreWindow, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IInitializeWithCoreWindow), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IInitializeWithCoreWindow[] = {
        { }
    };

    static PyType_Slot _type_slots_IInitializeWithCoreWindow[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IInitializeWithCoreWindow) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IInitializeWithCoreWindow) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IInitializeWithCoreWindow) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IInitializeWithCoreWindow) },
        { }
    };

    static PyType_Spec type_spec_IInitializeWithCoreWindow = {
        "winrt._winrt_windows_ui_core.IInitializeWithCoreWindow",
        sizeof(py::wrapper::Windows::UI::Core::IInitializeWithCoreWindow),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IInitializeWithCoreWindow};

    // ----- CorePhysicalKeyStatus struct --------------------

    winrt_struct_wrapper<winrt::Windows::UI::Core::CorePhysicalKeyStatus>* _new_CorePhysicalKeyStatus(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::UI::Core::CorePhysicalKeyStatus>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_CorePhysicalKeyStatus(winrt_struct_wrapper<winrt::Windows::UI::Core::CorePhysicalKeyStatus>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint32_t _RepeatCount{};
        uint32_t _ScanCode{};
        int _IsExtendedKey{};
        int _IsMenuKeyDown{};
        int _WasKeyDown{};
        int _IsKeyReleased{};

        static const char* kwlist[] = {"repeat_count", "scan_code", "is_extended_key", "is_menu_key_down", "was_key_down", "is_key_released", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "IIpppp", const_cast<char**>(kwlist), &_RepeatCount, &_ScanCode, &_IsExtendedKey, &_IsMenuKeyDown, &_WasKeyDown, &_IsKeyReleased))
        {
            return -1;
        }

        try
        {
            self->obj.RepeatCount = _RepeatCount;
            self->obj.ScanCode = _ScanCode;
            self->obj.IsExtendedKey = _IsExtendedKey;
            self->obj.IsMenuKeyDown = _IsMenuKeyDown;
            self->obj.WasKeyDown = _WasKeyDown;
            self->obj.IsKeyReleased = _IsKeyReleased;

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_CorePhysicalKeyStatus(py::wrapper::Windows::UI::Core::CorePhysicalKeyStatus* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CorePhysicalKeyStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::CorePhysicalKeyStatus>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_CorePhysicalKeyStatus[] = {
        { "_assign_array_", _assign_array_CorePhysicalKeyStatus, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* CorePhysicalKeyStatus_get_RepeatCount(py::wrapper::Windows::UI::Core::CorePhysicalKeyStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RepeatCount);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CorePhysicalKeyStatus_set_RepeatCount(py::wrapper::Windows::UI::Core::CorePhysicalKeyStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.RepeatCount = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CorePhysicalKeyStatus_get_ScanCode(py::wrapper::Windows::UI::Core::CorePhysicalKeyStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ScanCode);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CorePhysicalKeyStatus_set_ScanCode(py::wrapper::Windows::UI::Core::CorePhysicalKeyStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.ScanCode = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CorePhysicalKeyStatus_get_IsExtendedKey(py::wrapper::Windows::UI::Core::CorePhysicalKeyStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsExtendedKey);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CorePhysicalKeyStatus_set_IsExtendedKey(py::wrapper::Windows::UI::Core::CorePhysicalKeyStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.IsExtendedKey = py::converter<bool>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CorePhysicalKeyStatus_get_IsMenuKeyDown(py::wrapper::Windows::UI::Core::CorePhysicalKeyStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsMenuKeyDown);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CorePhysicalKeyStatus_set_IsMenuKeyDown(py::wrapper::Windows::UI::Core::CorePhysicalKeyStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.IsMenuKeyDown = py::converter<bool>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CorePhysicalKeyStatus_get_WasKeyDown(py::wrapper::Windows::UI::Core::CorePhysicalKeyStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WasKeyDown);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CorePhysicalKeyStatus_set_WasKeyDown(py::wrapper::Windows::UI::Core::CorePhysicalKeyStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.WasKeyDown = py::converter<bool>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CorePhysicalKeyStatus_get_IsKeyReleased(py::wrapper::Windows::UI::Core::CorePhysicalKeyStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsKeyReleased);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CorePhysicalKeyStatus_set_IsKeyReleased(py::wrapper::Windows::UI::Core::CorePhysicalKeyStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.IsKeyReleased = py::converter<bool>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_CorePhysicalKeyStatus[] = {
        { "repeat_count", reinterpret_cast<getter>(CorePhysicalKeyStatus_get_RepeatCount), reinterpret_cast<setter>(CorePhysicalKeyStatus_set_RepeatCount), nullptr, nullptr },
        { "scan_code", reinterpret_cast<getter>(CorePhysicalKeyStatus_get_ScanCode), reinterpret_cast<setter>(CorePhysicalKeyStatus_set_ScanCode), nullptr, nullptr },
        { "is_extended_key", reinterpret_cast<getter>(CorePhysicalKeyStatus_get_IsExtendedKey), reinterpret_cast<setter>(CorePhysicalKeyStatus_set_IsExtendedKey), nullptr, nullptr },
        { "is_menu_key_down", reinterpret_cast<getter>(CorePhysicalKeyStatus_get_IsMenuKeyDown), reinterpret_cast<setter>(CorePhysicalKeyStatus_set_IsMenuKeyDown), nullptr, nullptr },
        { "was_key_down", reinterpret_cast<getter>(CorePhysicalKeyStatus_get_WasKeyDown), reinterpret_cast<setter>(CorePhysicalKeyStatus_set_WasKeyDown), nullptr, nullptr },
        { "is_key_released", reinterpret_cast<getter>(CorePhysicalKeyStatus_get_IsKeyReleased), reinterpret_cast<setter>(CorePhysicalKeyStatus_set_IsKeyReleased), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CorePhysicalKeyStatus[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CorePhysicalKeyStatus) },
        { Py_tp_init, reinterpret_cast<void*>(_init_CorePhysicalKeyStatus) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CorePhysicalKeyStatus) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CorePhysicalKeyStatus) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CorePhysicalKeyStatus) },
        { }
    };

    static PyType_Spec type_spec_CorePhysicalKeyStatus = {
        "winrt._winrt_windows_ui_core.CorePhysicalKeyStatus",
        sizeof(py::wrapper::Windows::UI::Core::CorePhysicalKeyStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CorePhysicalKeyStatus};

    // ----- CoreProximityEvaluation struct --------------------

    winrt_struct_wrapper<winrt::Windows::UI::Core::CoreProximityEvaluation>* _new_CoreProximityEvaluation(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::UI::Core::CoreProximityEvaluation>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_CoreProximityEvaluation(winrt_struct_wrapper<winrt::Windows::UI::Core::CoreProximityEvaluation>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        int32_t _Score{};
        PyObject* _AdjustedPoint{};

        static const char* kwlist[] = {"score", "adjusted_point", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "iO", const_cast<char**>(kwlist), &_Score, &_AdjustedPoint))
        {
            return -1;
        }

        try
        {
            self->obj.Score = _Score;
            self->obj.AdjustedPoint = py::converter<winrt::Windows::Foundation::Point>::convert_to(_AdjustedPoint);

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_CoreProximityEvaluation(py::wrapper::Windows::UI::Core::CoreProximityEvaluation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CoreProximityEvaluation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::CoreProximityEvaluation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_CoreProximityEvaluation[] = {
        { "_assign_array_", _assign_array_CoreProximityEvaluation, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* CoreProximityEvaluation_get_Score(py::wrapper::Windows::UI::Core::CoreProximityEvaluation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Score);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreProximityEvaluation_set_Score(py::wrapper::Windows::UI::Core::CoreProximityEvaluation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Score = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreProximityEvaluation_get_AdjustedPoint(py::wrapper::Windows::UI::Core::CoreProximityEvaluation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AdjustedPoint);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreProximityEvaluation_set_AdjustedPoint(py::wrapper::Windows::UI::Core::CoreProximityEvaluation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.AdjustedPoint = py::converter<winrt::Windows::Foundation::Point>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_CoreProximityEvaluation[] = {
        { "score", reinterpret_cast<getter>(CoreProximityEvaluation_get_Score), reinterpret_cast<setter>(CoreProximityEvaluation_set_Score), nullptr, nullptr },
        { "adjusted_point", reinterpret_cast<getter>(CoreProximityEvaluation_get_AdjustedPoint), reinterpret_cast<setter>(CoreProximityEvaluation_set_AdjustedPoint), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreProximityEvaluation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreProximityEvaluation) },
        { Py_tp_init, reinterpret_cast<void*>(_init_CoreProximityEvaluation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreProximityEvaluation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreProximityEvaluation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreProximityEvaluation) },
        { }
    };

    static PyType_Spec type_spec_CoreProximityEvaluation = {
        "winrt._winrt_windows_ui_core.CoreProximityEvaluation",
        sizeof(py::wrapper::Windows::UI::Core::CoreProximityEvaluation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreProximityEvaluation};

    // ----- Windows.UI.Core Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.UI.Core");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_ui_core",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::UI::Core

PyMODINIT_FUNC PyInit__winrt_windows_ui_core(void) noexcept
{
    using namespace py::cpp::Windows::UI::Core;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AcceleratorKeyEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AutomationProviderRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BackRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CharacterReceivedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ClosestInteractiveBoundsRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreAcceleratorKeys, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreComponentInputSource, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreCursor, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreDispatcher, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreIndependentInputSource, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_CoreIndependentInputSourceController_Static{PyType_FromSpec(&type_spec_CoreIndependentInputSourceController_Static)};
    if (!type_CoreIndependentInputSourceController_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreIndependentInputSourceController, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CoreIndependentInputSourceController_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_CoreWindow_Static{PyType_FromSpec(&type_spec_CoreWindow_Static)};
    if (!type_CoreWindow_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWindow, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CoreWindow_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWindowDialog, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWindowEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWindowFlyout, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWindowPopupShowingEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_CoreWindowResizeManager_Static{PyType_FromSpec(&type_spec_CoreWindowResizeManager_Static)};
    if (!type_CoreWindowResizeManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWindowResizeManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CoreWindowResizeManager_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IdleDispatchedHandlerArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InputEnabledEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_KeyEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PointerEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SystemNavigationManager_Static{PyType_FromSpec(&type_spec_SystemNavigationManager_Static)};
    if (!type_SystemNavigationManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SystemNavigationManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SystemNavigationManager_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TouchHitTestingEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VisibilityChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WindowActivatedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WindowSizeChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ICoreAcceleratorKeys, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ICoreInputSourceBase, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ICorePointerInputSource, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ICorePointerInputSource2, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ICorePointerRedirector, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ICoreWindow, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ICoreWindowEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IInitializeWithCoreWindow, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CorePhysicalKeyStatus, nullptr, nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreProximityEvaluation, nullptr, nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
