// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

#include "py.Windows.UI.Xaml.Data.h"


namespace py::cpp::Windows::UI::Xaml::Data
{
    // ----- Binding class --------------------

    static PyObject* _new_Binding(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Data::Binding instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Binding(py::wrapper::Windows::UI::Xaml::Data::Binding* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Binding_get_Source(py::wrapper::Windows::UI::Xaml::Data::Binding* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"Source"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Binding_put_Source(py::wrapper::Windows::UI::Xaml::Data::Binding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"Source"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.Source(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Binding_get_RelativeSource(py::wrapper::Windows::UI::Xaml::Data::Binding* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"RelativeSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RelativeSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Binding_put_RelativeSource(py::wrapper::Windows::UI::Xaml::Data::Binding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"RelativeSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Data::RelativeSource>(arg);

            self->obj.RelativeSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Binding_get_Path(py::wrapper::Windows::UI::Xaml::Data::Binding* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"Path"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Binding_put_Path(py::wrapper::Windows::UI::Xaml::Data::Binding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"Path"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::PropertyPath>(arg);

            self->obj.Path(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Binding_get_Mode(py::wrapper::Windows::UI::Xaml::Data::Binding* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"Mode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Binding_put_Mode(py::wrapper::Windows::UI::Xaml::Data::Binding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"Mode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Data::BindingMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Binding_get_ElementName(py::wrapper::Windows::UI::Xaml::Data::Binding* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"ElementName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ElementName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Binding_put_ElementName(py::wrapper::Windows::UI::Xaml::Data::Binding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"ElementName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ElementName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Binding_get_ConverterParameter(py::wrapper::Windows::UI::Xaml::Data::Binding* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"ConverterParameter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConverterParameter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Binding_put_ConverterParameter(py::wrapper::Windows::UI::Xaml::Data::Binding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"ConverterParameter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.ConverterParameter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Binding_get_ConverterLanguage(py::wrapper::Windows::UI::Xaml::Data::Binding* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"ConverterLanguage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConverterLanguage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Binding_put_ConverterLanguage(py::wrapper::Windows::UI::Xaml::Data::Binding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"ConverterLanguage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ConverterLanguage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Binding_get_Converter(py::wrapper::Windows::UI::Xaml::Data::Binding* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"Converter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Converter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Binding_put_Converter(py::wrapper::Windows::UI::Xaml::Data::Binding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"Converter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Data::IValueConverter>(arg);

            self->obj.Converter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Binding_get_UpdateSourceTrigger(py::wrapper::Windows::UI::Xaml::Data::Binding* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"UpdateSourceTrigger"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UpdateSourceTrigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Binding_put_UpdateSourceTrigger(py::wrapper::Windows::UI::Xaml::Data::Binding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"UpdateSourceTrigger"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Data::UpdateSourceTrigger>(arg);

            self->obj.UpdateSourceTrigger(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Binding_get_TargetNullValue(py::wrapper::Windows::UI::Xaml::Data::Binding* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"TargetNullValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TargetNullValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Binding_put_TargetNullValue(py::wrapper::Windows::UI::Xaml::Data::Binding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"TargetNullValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.TargetNullValue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Binding_get_FallbackValue(py::wrapper::Windows::UI::Xaml::Data::Binding* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"FallbackValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FallbackValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Binding_put_FallbackValue(py::wrapper::Windows::UI::Xaml::Data::Binding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"FallbackValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.FallbackValue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_Binding(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::Binding>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Binding(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::Binding>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Binding[] = {
        { "_assign_array_", _assign_array_Binding, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Binding), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Binding[] = {
        { "source", reinterpret_cast<getter>(Binding_get_Source), reinterpret_cast<setter>(Binding_put_Source), nullptr, nullptr },
        { "relative_source", reinterpret_cast<getter>(Binding_get_RelativeSource), reinterpret_cast<setter>(Binding_put_RelativeSource), nullptr, nullptr },
        { "path", reinterpret_cast<getter>(Binding_get_Path), reinterpret_cast<setter>(Binding_put_Path), nullptr, nullptr },
        { "mode", reinterpret_cast<getter>(Binding_get_Mode), reinterpret_cast<setter>(Binding_put_Mode), nullptr, nullptr },
        { "element_name", reinterpret_cast<getter>(Binding_get_ElementName), reinterpret_cast<setter>(Binding_put_ElementName), nullptr, nullptr },
        { "converter_parameter", reinterpret_cast<getter>(Binding_get_ConverterParameter), reinterpret_cast<setter>(Binding_put_ConverterParameter), nullptr, nullptr },
        { "converter_language", reinterpret_cast<getter>(Binding_get_ConverterLanguage), reinterpret_cast<setter>(Binding_put_ConverterLanguage), nullptr, nullptr },
        { "converter", reinterpret_cast<getter>(Binding_get_Converter), reinterpret_cast<setter>(Binding_put_Converter), nullptr, nullptr },
        { "update_source_trigger", reinterpret_cast<getter>(Binding_get_UpdateSourceTrigger), reinterpret_cast<setter>(Binding_put_UpdateSourceTrigger), nullptr, nullptr },
        { "target_null_value", reinterpret_cast<getter>(Binding_get_TargetNullValue), reinterpret_cast<setter>(Binding_put_TargetNullValue), nullptr, nullptr },
        { "fallback_value", reinterpret_cast<getter>(Binding_get_FallbackValue), reinterpret_cast<setter>(Binding_put_FallbackValue), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Binding[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Binding) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Binding) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Binding) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Binding) },
        { },
    };

    static PyType_Spec type_spec_Binding =
    {
        "winrt._winrt_windows_ui_xaml_data.Binding",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::Binding),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Binding
    };

    // ----- BindingBase class --------------------

    static PyObject* _new_BindingBase(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Data::BindingBase instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BindingBase(py::wrapper::Windows::UI::Xaml::Data::BindingBase* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_BindingBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::BindingBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BindingBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::BindingBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BindingBase[] = {
        { "_assign_array_", _assign_array_BindingBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BindingBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BindingBase[] = {
        { }
    };

    static PyType_Slot _type_slots_BindingBase[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BindingBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BindingBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BindingBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BindingBase) },
        { },
    };

    static PyType_Spec type_spec_BindingBase =
    {
        "winrt._winrt_windows_ui_xaml_data.BindingBase",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::BindingBase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BindingBase
    };

    // ----- BindingExpression class --------------------

    static PyObject* _new_BindingExpression(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Data::BindingExpression>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Data::BindingExpression>::type_name);
        return nullptr;
    }

    static void _dealloc_BindingExpression(py::wrapper::Windows::UI::Xaml::Data::BindingExpression* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BindingExpression_UpdateSource(py::wrapper::Windows::UI::Xaml::Data::BindingExpression* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.BindingExpression", L"UpdateSource", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.UpdateSource();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BindingExpression_get_DataItem(py::wrapper::Windows::UI::Xaml::Data::BindingExpression* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.BindingExpression", L"DataItem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DataItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BindingExpression_get_ParentBinding(py::wrapper::Windows::UI::Xaml::Data::BindingExpression* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.BindingExpression", L"ParentBinding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ParentBinding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BindingExpression(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::BindingExpression>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BindingExpression(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::BindingExpression>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BindingExpression[] = {
        { "update_source", reinterpret_cast<PyCFunction>(BindingExpression_UpdateSource), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BindingExpression, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BindingExpression), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BindingExpression[] = {
        { "data_item", reinterpret_cast<getter>(BindingExpression_get_DataItem), nullptr, nullptr, nullptr },
        { "parent_binding", reinterpret_cast<getter>(BindingExpression_get_ParentBinding), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BindingExpression[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BindingExpression) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BindingExpression) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BindingExpression) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BindingExpression) },
        { },
    };

    static PyType_Spec type_spec_BindingExpression =
    {
        "winrt._winrt_windows_ui_xaml_data.BindingExpression",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::BindingExpression),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BindingExpression
    };

    // ----- BindingExpressionBase class --------------------

    static PyObject* _new_BindingExpressionBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Data::BindingExpressionBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Data::BindingExpressionBase>::type_name);
        return nullptr;
    }

    static void _dealloc_BindingExpressionBase(py::wrapper::Windows::UI::Xaml::Data::BindingExpressionBase* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_BindingExpressionBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::BindingExpressionBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BindingExpressionBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::BindingExpressionBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BindingExpressionBase[] = {
        { "_assign_array_", _assign_array_BindingExpressionBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BindingExpressionBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BindingExpressionBase[] = {
        { }
    };

    static PyType_Slot _type_slots_BindingExpressionBase[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BindingExpressionBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BindingExpressionBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BindingExpressionBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BindingExpressionBase) },
        { },
    };

    static PyType_Spec type_spec_BindingExpressionBase =
    {
        "winrt._winrt_windows_ui_xaml_data.BindingExpressionBase",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::BindingExpressionBase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BindingExpressionBase
    };

    // ----- BindingOperations class --------------------

    static PyObject* _new_BindingOperations(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Data::BindingOperations>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Data::BindingOperations>::type_name);
        return nullptr;
    }

    static void _dealloc_BindingOperations(py::wrapper::Windows::UI::Xaml::Data::BindingOperations* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BindingOperations_SetBinding(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.BindingOperations", L"SetBinding", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Xaml::Data::BindingBase>(args, 2);

                winrt::Windows::UI::Xaml::Data::BindingOperations::SetBinding(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_BindingOperations(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::BindingOperations>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BindingOperations(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::BindingOperations>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BindingOperations[] = {
        { "_assign_array_", _assign_array_BindingOperations, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BindingOperations), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BindingOperations[] = {
        { }
    };

    static PyType_Slot _type_slots_BindingOperations[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BindingOperations) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BindingOperations) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BindingOperations) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BindingOperations) },
        { },
    };

    static PyType_Spec type_spec_BindingOperations =
    {
        "winrt._winrt_windows_ui_xaml_data.BindingOperations",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::BindingOperations),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BindingOperations
    };

    static PyGetSetDef getset_BindingOperations_Static[] = {
        { }
    };

    static PyMethodDef methods_BindingOperations_Static[] = {
        { "set_binding", reinterpret_cast<PyCFunction>(BindingOperations_SetBinding), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_BindingOperations_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BindingOperations_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BindingOperations_Static) },
        { }
    };

    static PyType_Spec type_spec_BindingOperations_Static =
    {
        "winrt._winrt_windows_ui_xaml_data.BindingOperations_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BindingOperations_Static
    };

    // ----- CollectionViewSource class --------------------

    static PyObject* _new_CollectionViewSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Data::CollectionViewSource instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CollectionViewSource(py::wrapper::Windows::UI::Xaml::Data::CollectionViewSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CollectionViewSource_get_Source(py::wrapper::Windows::UI::Xaml::Data::CollectionViewSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.CollectionViewSource", L"Source"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CollectionViewSource_put_Source(py::wrapper::Windows::UI::Xaml::Data::CollectionViewSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.CollectionViewSource", L"Source"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.Source(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CollectionViewSource_get_ItemsPath(py::wrapper::Windows::UI::Xaml::Data::CollectionViewSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.CollectionViewSource", L"ItemsPath"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ItemsPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CollectionViewSource_put_ItemsPath(py::wrapper::Windows::UI::Xaml::Data::CollectionViewSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.CollectionViewSource", L"ItemsPath"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::PropertyPath>(arg);

            self->obj.ItemsPath(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CollectionViewSource_get_IsSourceGrouped(py::wrapper::Windows::UI::Xaml::Data::CollectionViewSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.CollectionViewSource", L"IsSourceGrouped"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSourceGrouped());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CollectionViewSource_put_IsSourceGrouped(py::wrapper::Windows::UI::Xaml::Data::CollectionViewSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.CollectionViewSource", L"IsSourceGrouped"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSourceGrouped(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CollectionViewSource_get_View(py::wrapper::Windows::UI::Xaml::Data::CollectionViewSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.CollectionViewSource", L"View"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.View());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CollectionViewSource_get_IsSourceGroupedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.CollectionViewSource", L"IsSourceGroupedProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Data::CollectionViewSource::IsSourceGroupedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CollectionViewSource_get_ItemsPathProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.CollectionViewSource", L"ItemsPathProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Data::CollectionViewSource::ItemsPathProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CollectionViewSource_get_SourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.CollectionViewSource", L"SourceProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Data::CollectionViewSource::SourceProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CollectionViewSource_get_ViewProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.CollectionViewSource", L"ViewProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Data::CollectionViewSource::ViewProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CollectionViewSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::CollectionViewSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CollectionViewSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::CollectionViewSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CollectionViewSource[] = {
        { "_assign_array_", _assign_array_CollectionViewSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CollectionViewSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CollectionViewSource[] = {
        { "source", reinterpret_cast<getter>(CollectionViewSource_get_Source), reinterpret_cast<setter>(CollectionViewSource_put_Source), nullptr, nullptr },
        { "items_path", reinterpret_cast<getter>(CollectionViewSource_get_ItemsPath), reinterpret_cast<setter>(CollectionViewSource_put_ItemsPath), nullptr, nullptr },
        { "is_source_grouped", reinterpret_cast<getter>(CollectionViewSource_get_IsSourceGrouped), reinterpret_cast<setter>(CollectionViewSource_put_IsSourceGrouped), nullptr, nullptr },
        { "view", reinterpret_cast<getter>(CollectionViewSource_get_View), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CollectionViewSource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CollectionViewSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CollectionViewSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CollectionViewSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CollectionViewSource) },
        { },
    };

    static PyType_Spec type_spec_CollectionViewSource =
    {
        "winrt._winrt_windows_ui_xaml_data.CollectionViewSource",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::CollectionViewSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CollectionViewSource
    };

    static PyGetSetDef getset_CollectionViewSource_Static[] = {
        { "is_source_grouped_property", reinterpret_cast<getter>(CollectionViewSource_get_IsSourceGroupedProperty), nullptr, nullptr, nullptr },
        { "items_path_property", reinterpret_cast<getter>(CollectionViewSource_get_ItemsPathProperty), nullptr, nullptr, nullptr },
        { "source_property", reinterpret_cast<getter>(CollectionViewSource_get_SourceProperty), nullptr, nullptr, nullptr },
        { "view_property", reinterpret_cast<getter>(CollectionViewSource_get_ViewProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_CollectionViewSource_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CollectionViewSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CollectionViewSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CollectionViewSource_Static) },
        { }
    };

    static PyType_Spec type_spec_CollectionViewSource_Static =
    {
        "winrt._winrt_windows_ui_xaml_data.CollectionViewSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CollectionViewSource_Static
    };

    // ----- CurrentChangingEventArgs class --------------------

    static PyObject* _new_CurrentChangingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Data::CurrentChangingEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                winrt::Windows::UI::Xaml::Data::CurrentChangingEventArgs instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CurrentChangingEventArgs(py::wrapper::Windows::UI::Xaml::Data::CurrentChangingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CurrentChangingEventArgs_get_Cancel(py::wrapper::Windows::UI::Xaml::Data::CurrentChangingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.CurrentChangingEventArgs", L"Cancel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Cancel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CurrentChangingEventArgs_put_Cancel(py::wrapper::Windows::UI::Xaml::Data::CurrentChangingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.CurrentChangingEventArgs", L"Cancel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Cancel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CurrentChangingEventArgs_get_IsCancelable(py::wrapper::Windows::UI::Xaml::Data::CurrentChangingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.CurrentChangingEventArgs", L"IsCancelable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCancelable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CurrentChangingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::CurrentChangingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CurrentChangingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::CurrentChangingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CurrentChangingEventArgs[] = {
        { "_assign_array_", _assign_array_CurrentChangingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CurrentChangingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CurrentChangingEventArgs[] = {
        { "cancel", reinterpret_cast<getter>(CurrentChangingEventArgs_get_Cancel), reinterpret_cast<setter>(CurrentChangingEventArgs_put_Cancel), nullptr, nullptr },
        { "is_cancelable", reinterpret_cast<getter>(CurrentChangingEventArgs_get_IsCancelable), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CurrentChangingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CurrentChangingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CurrentChangingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CurrentChangingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CurrentChangingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CurrentChangingEventArgs =
    {
        "winrt._winrt_windows_ui_xaml_data.CurrentChangingEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::CurrentChangingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CurrentChangingEventArgs
    };

    // ----- ItemIndexRange class --------------------

    static PyObject* _new_ItemIndexRange(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                winrt::Windows::UI::Xaml::Data::ItemIndexRange instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ItemIndexRange(py::wrapper::Windows::UI::Xaml::Data::ItemIndexRange* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ItemIndexRange_get_FirstIndex(py::wrapper::Windows::UI::Xaml::Data::ItemIndexRange* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ItemIndexRange", L"FirstIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FirstIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemIndexRange_get_LastIndex(py::wrapper::Windows::UI::Xaml::Data::ItemIndexRange* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ItemIndexRange", L"LastIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LastIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemIndexRange_get_Length(py::wrapper::Windows::UI::Xaml::Data::ItemIndexRange* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ItemIndexRange", L"Length"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ItemIndexRange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::ItemIndexRange>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ItemIndexRange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::ItemIndexRange>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ItemIndexRange[] = {
        { "_assign_array_", _assign_array_ItemIndexRange, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ItemIndexRange), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ItemIndexRange[] = {
        { "first_index", reinterpret_cast<getter>(ItemIndexRange_get_FirstIndex), nullptr, nullptr, nullptr },
        { "last_index", reinterpret_cast<getter>(ItemIndexRange_get_LastIndex), nullptr, nullptr, nullptr },
        { "length", reinterpret_cast<getter>(ItemIndexRange_get_Length), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ItemIndexRange[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ItemIndexRange) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ItemIndexRange) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ItemIndexRange) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ItemIndexRange) },
        { },
    };

    static PyType_Spec type_spec_ItemIndexRange =
    {
        "winrt._winrt_windows_ui_xaml_data.ItemIndexRange",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::ItemIndexRange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ItemIndexRange
    };

    // ----- PropertyChangedEventArgs class --------------------

    static PyObject* _new_PropertyChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::UI::Xaml::Data::PropertyChangedEventArgs instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PropertyChangedEventArgs(py::wrapper::Windows::UI::Xaml::Data::PropertyChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PropertyChangedEventArgs_get_PropertyName(py::wrapper::Windows::UI::Xaml::Data::PropertyChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.PropertyChangedEventArgs", L"PropertyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PropertyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PropertyChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::PropertyChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PropertyChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::PropertyChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PropertyChangedEventArgs[] = {
        { "_assign_array_", _assign_array_PropertyChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PropertyChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PropertyChangedEventArgs[] = {
        { "property_name", reinterpret_cast<getter>(PropertyChangedEventArgs_get_PropertyName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PropertyChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PropertyChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PropertyChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PropertyChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PropertyChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PropertyChangedEventArgs =
    {
        "winrt._winrt_windows_ui_xaml_data.PropertyChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::PropertyChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PropertyChangedEventArgs
    };

    // ----- RelativeSource class --------------------

    static PyObject* _new_RelativeSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Data::RelativeSource instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RelativeSource(py::wrapper::Windows::UI::Xaml::Data::RelativeSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RelativeSource_get_Mode(py::wrapper::Windows::UI::Xaml::Data::RelativeSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.RelativeSource", L"Mode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RelativeSource_put_Mode(py::wrapper::Windows::UI::Xaml::Data::RelativeSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.RelativeSource", L"Mode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Data::RelativeSourceMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_RelativeSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::RelativeSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RelativeSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::RelativeSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RelativeSource[] = {
        { "_assign_array_", _assign_array_RelativeSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RelativeSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RelativeSource[] = {
        { "mode", reinterpret_cast<getter>(RelativeSource_get_Mode), reinterpret_cast<setter>(RelativeSource_put_Mode), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RelativeSource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RelativeSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RelativeSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RelativeSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RelativeSource) },
        { },
    };

    static PyType_Spec type_spec_RelativeSource =
    {
        "winrt._winrt_windows_ui_xaml_data.RelativeSource",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::RelativeSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RelativeSource
    };

    // ----- ICollectionView interface --------------------

    static PyObject* _new_ICollectionView(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Data::ICollectionView>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Data::ICollectionView>::type_name);
        return nullptr;
    }

    static void _dealloc_ICollectionView(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICollectionView_Append(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"Append", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_Clear(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_First(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IIterable`1", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_GetAt(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_GetMany(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"GetMany", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::IInspectable, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_GetView(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"GetView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_IndexOf(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_InsertAt(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"InsertAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_LoadMoreItemsAsync(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"LoadMoreItemsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.LoadMoreItemsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_MoveCurrentTo(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"MoveCurrentTo", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.MoveCurrentTo(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_MoveCurrentToFirst(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"MoveCurrentToFirst", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.MoveCurrentToFirst());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_MoveCurrentToLast(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"MoveCurrentToLast", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.MoveCurrentToLast());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_MoveCurrentToNext(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"MoveCurrentToNext", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.MoveCurrentToNext());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_MoveCurrentToPosition(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"MoveCurrentToPosition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.MoveCurrentToPosition(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_MoveCurrentToPrevious(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"MoveCurrentToPrevious", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.MoveCurrentToPrevious());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_RemoveAt(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"RemoveAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_RemoveAtEnd(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"RemoveAtEnd", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_ReplaceAll(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"ReplaceAll", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::IInspectable, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_SetAt(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"SetAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_get_CollectionGroups(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"CollectionGroups"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CollectionGroups());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICollectionView_get_CurrentItem(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"CurrentItem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICollectionView_get_CurrentPosition(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"CurrentPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICollectionView_get_HasMoreItems(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"HasMoreItems"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasMoreItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICollectionView_get_IsCurrentAfterLast(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"IsCurrentAfterLast"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCurrentAfterLast());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICollectionView_get_IsCurrentBeforeFirst(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"IsCurrentBeforeFirst"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCurrentBeforeFirst());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICollectionView_get_Size(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Collections.IVector`1", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICollectionView_add_CurrentChanged(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"CurrentChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.CurrentChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICollectionView_remove_CurrentChanged(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"CurrentChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CurrentChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICollectionView_add_CurrentChanging(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"CurrentChanging"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Data::CurrentChangingEventHandler>(arg);

            return py::convert(self->obj.CurrentChanging(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICollectionView_remove_CurrentChanging(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"CurrentChanging"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CurrentChanging(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICollectionView_add_VectorChanged(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Foundation.Collections.IObservableVector`1", L"VectorChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::VectorChangedEventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.VectorChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICollectionView_remove_VectorChanged(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Foundation.Collections.IObservableVector`1", L"VectorChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VectorChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICollectionView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::ICollectionView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICollectionView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::ICollectionView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_ICollectionView(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_ICollectionView(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_ICollectionView(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_ICollectionView(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_ICollectionView(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(
                    PyExc_NotImplementedError,
                    "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::Foundation::IInspectable> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::Foundation::IInspectable>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(
                    PyExc_RuntimeError,
                    "returned count %d did not match requested length %zd",
                    count,
                    length);
                return nullptr;
            }

            return convert(items);}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_ICollectionView(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::Foundation::IInspectable>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_ICollectionView[] = {
        { "append", reinterpret_cast<PyCFunction>(ICollectionView_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(ICollectionView_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(ICollectionView_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(ICollectionView_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(ICollectionView_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(ICollectionView_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(ICollectionView_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(ICollectionView_InsertAt), METH_VARARGS, nullptr },
        { "load_more_items_async", reinterpret_cast<PyCFunction>(ICollectionView_LoadMoreItemsAsync), METH_VARARGS, nullptr },
        { "move_current_to", reinterpret_cast<PyCFunction>(ICollectionView_MoveCurrentTo), METH_VARARGS, nullptr },
        { "move_current_to_first", reinterpret_cast<PyCFunction>(ICollectionView_MoveCurrentToFirst), METH_VARARGS, nullptr },
        { "move_current_to_last", reinterpret_cast<PyCFunction>(ICollectionView_MoveCurrentToLast), METH_VARARGS, nullptr },
        { "move_current_to_next", reinterpret_cast<PyCFunction>(ICollectionView_MoveCurrentToNext), METH_VARARGS, nullptr },
        { "move_current_to_position", reinterpret_cast<PyCFunction>(ICollectionView_MoveCurrentToPosition), METH_VARARGS, nullptr },
        { "move_current_to_previous", reinterpret_cast<PyCFunction>(ICollectionView_MoveCurrentToPrevious), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(ICollectionView_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(ICollectionView_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(ICollectionView_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(ICollectionView_SetAt), METH_VARARGS, nullptr },
        { "add_current_changed", reinterpret_cast<PyCFunction>(ICollectionView_add_CurrentChanged), METH_O, nullptr },
        { "remove_current_changed", reinterpret_cast<PyCFunction>(ICollectionView_remove_CurrentChanged), METH_O, nullptr },
        { "add_current_changing", reinterpret_cast<PyCFunction>(ICollectionView_add_CurrentChanging), METH_O, nullptr },
        { "remove_current_changing", reinterpret_cast<PyCFunction>(ICollectionView_remove_CurrentChanging), METH_O, nullptr },
        { "add_vector_changed", reinterpret_cast<PyCFunction>(ICollectionView_add_VectorChanged), METH_O, nullptr },
        { "remove_vector_changed", reinterpret_cast<PyCFunction>(ICollectionView_remove_VectorChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ICollectionView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICollectionView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICollectionView[] = {
        { "collection_groups", reinterpret_cast<getter>(ICollectionView_get_CollectionGroups), nullptr, nullptr, nullptr },
        { "current_item", reinterpret_cast<getter>(ICollectionView_get_CurrentItem), nullptr, nullptr, nullptr },
        { "current_position", reinterpret_cast<getter>(ICollectionView_get_CurrentPosition), nullptr, nullptr, nullptr },
        { "has_more_items", reinterpret_cast<getter>(ICollectionView_get_HasMoreItems), nullptr, nullptr, nullptr },
        { "is_current_after_last", reinterpret_cast<getter>(ICollectionView_get_IsCurrentAfterLast), nullptr, nullptr, nullptr },
        { "is_current_before_first", reinterpret_cast<getter>(ICollectionView_get_IsCurrentBeforeFirst), nullptr, nullptr, nullptr },
        { "size", reinterpret_cast<getter>(ICollectionView_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICollectionView[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICollectionView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICollectionView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICollectionView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICollectionView) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_ICollectionView) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_ICollectionView) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_ICollectionView) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_ICollectionView) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_ICollectionView) },
        { },
    };

    static PyType_Spec type_spec_ICollectionView =
    {
        "winrt._winrt_windows_ui_xaml_data.ICollectionView",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::ICollectionView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICollectionView
    };

    // ----- ICollectionViewFactory interface --------------------

    static PyObject* _new_ICollectionViewFactory(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Data::ICollectionViewFactory>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Data::ICollectionViewFactory>::type_name);
        return nullptr;
    }

    static void _dealloc_ICollectionViewFactory(py::wrapper::Windows::UI::Xaml::Data::ICollectionViewFactory* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICollectionViewFactory_CreateView(py::wrapper::Windows::UI::Xaml::Data::ICollectionViewFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ICollectionViewFactory", L"CreateView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICollectionViewFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::ICollectionViewFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICollectionViewFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::ICollectionViewFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICollectionViewFactory[] = {
        { "create_view", reinterpret_cast<PyCFunction>(ICollectionViewFactory_CreateView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ICollectionViewFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICollectionViewFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICollectionViewFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_ICollectionViewFactory[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICollectionViewFactory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICollectionViewFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICollectionViewFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICollectionViewFactory) },
        { },
    };

    static PyType_Spec type_spec_ICollectionViewFactory =
    {
        "winrt._winrt_windows_ui_xaml_data.ICollectionViewFactory",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::ICollectionViewFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICollectionViewFactory
    };

    // ----- ICollectionViewGroup interface --------------------

    static PyObject* _new_ICollectionViewGroup(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Data::ICollectionViewGroup>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Data::ICollectionViewGroup>::type_name);
        return nullptr;
    }

    static void _dealloc_ICollectionViewGroup(py::wrapper::Windows::UI::Xaml::Data::ICollectionViewGroup* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICollectionViewGroup_get_Group(py::wrapper::Windows::UI::Xaml::Data::ICollectionViewGroup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ICollectionViewGroup", L"Group"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Group());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICollectionViewGroup_get_GroupItems(py::wrapper::Windows::UI::Xaml::Data::ICollectionViewGroup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ICollectionViewGroup", L"GroupItems"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.GroupItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICollectionViewGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::ICollectionViewGroup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICollectionViewGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::ICollectionViewGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICollectionViewGroup[] = {
        { "_assign_array_", _assign_array_ICollectionViewGroup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICollectionViewGroup), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICollectionViewGroup[] = {
        { "group", reinterpret_cast<getter>(ICollectionViewGroup_get_Group), nullptr, nullptr, nullptr },
        { "group_items", reinterpret_cast<getter>(ICollectionViewGroup_get_GroupItems), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICollectionViewGroup[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICollectionViewGroup) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICollectionViewGroup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICollectionViewGroup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICollectionViewGroup) },
        { },
    };

    static PyType_Spec type_spec_ICollectionViewGroup =
    {
        "winrt._winrt_windows_ui_xaml_data.ICollectionViewGroup",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::ICollectionViewGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICollectionViewGroup
    };

    // ----- ICustomProperty interface --------------------

    static PyObject* _new_ICustomProperty(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Data::ICustomProperty>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Data::ICustomProperty>::type_name);
        return nullptr;
    }

    static void _dealloc_ICustomProperty(py::wrapper::Windows::UI::Xaml::Data::ICustomProperty* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICustomProperty_GetIndexedValue(py::wrapper::Windows::UI::Xaml::Data::ICustomProperty* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ICustomProperty", L"GetIndexedValue", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.GetIndexedValue(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICustomProperty_GetValue(py::wrapper::Windows::UI::Xaml::Data::ICustomProperty* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ICustomProperty", L"GetValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.GetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICustomProperty_SetIndexedValue(py::wrapper::Windows::UI::Xaml::Data::ICustomProperty* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ICustomProperty", L"SetIndexedValue", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);

                self->obj.SetIndexedValue(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICustomProperty_SetValue(py::wrapper::Windows::UI::Xaml::Data::ICustomProperty* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ICustomProperty", L"SetValue", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetValue(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICustomProperty_get_CanRead(py::wrapper::Windows::UI::Xaml::Data::ICustomProperty* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ICustomProperty", L"CanRead"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanRead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICustomProperty_get_CanWrite(py::wrapper::Windows::UI::Xaml::Data::ICustomProperty* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ICustomProperty", L"CanWrite"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanWrite());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICustomProperty_get_Name(py::wrapper::Windows::UI::Xaml::Data::ICustomProperty* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ICustomProperty", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICustomProperty_get_Type(py::wrapper::Windows::UI::Xaml::Data::ICustomProperty* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ICustomProperty", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICustomProperty(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::ICustomProperty>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICustomProperty(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::ICustomProperty>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICustomProperty[] = {
        { "get_indexed_value", reinterpret_cast<PyCFunction>(ICustomProperty_GetIndexedValue), METH_VARARGS, nullptr },
        { "get_value", reinterpret_cast<PyCFunction>(ICustomProperty_GetValue), METH_VARARGS, nullptr },
        { "set_indexed_value", reinterpret_cast<PyCFunction>(ICustomProperty_SetIndexedValue), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(ICustomProperty_SetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ICustomProperty, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICustomProperty), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICustomProperty[] = {
        { "can_read", reinterpret_cast<getter>(ICustomProperty_get_CanRead), nullptr, nullptr, nullptr },
        { "can_write", reinterpret_cast<getter>(ICustomProperty_get_CanWrite), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(ICustomProperty_get_Name), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(ICustomProperty_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICustomProperty[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICustomProperty) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICustomProperty) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICustomProperty) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICustomProperty) },
        { },
    };

    static PyType_Spec type_spec_ICustomProperty =
    {
        "winrt._winrt_windows_ui_xaml_data.ICustomProperty",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::ICustomProperty),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICustomProperty
    };

    // ----- ICustomPropertyProvider interface --------------------

    static PyObject* _new_ICustomPropertyProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Data::ICustomPropertyProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Data::ICustomPropertyProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_ICustomPropertyProvider(py::wrapper::Windows::UI::Xaml::Data::ICustomPropertyProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICustomPropertyProvider_GetCustomProperty(py::wrapper::Windows::UI::Xaml::Data::ICustomPropertyProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ICustomPropertyProvider", L"GetCustomProperty", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetCustomProperty(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICustomPropertyProvider_GetIndexedProperty(py::wrapper::Windows::UI::Xaml::Data::ICustomPropertyProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ICustomPropertyProvider", L"GetIndexedProperty", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 1);

                return py::convert(self->obj.GetIndexedProperty(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICustomPropertyProvider_GetStringRepresentation(py::wrapper::Windows::UI::Xaml::Data::ICustomPropertyProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ICustomPropertyProvider", L"GetStringRepresentation", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetStringRepresentation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICustomPropertyProvider_get_Type(py::wrapper::Windows::UI::Xaml::Data::ICustomPropertyProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ICustomPropertyProvider", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICustomPropertyProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::ICustomPropertyProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICustomPropertyProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::ICustomPropertyProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICustomPropertyProvider[] = {
        { "get_custom_property", reinterpret_cast<PyCFunction>(ICustomPropertyProvider_GetCustomProperty), METH_VARARGS, nullptr },
        { "get_indexed_property", reinterpret_cast<PyCFunction>(ICustomPropertyProvider_GetIndexedProperty), METH_VARARGS, nullptr },
        { "get_string_representation", reinterpret_cast<PyCFunction>(ICustomPropertyProvider_GetStringRepresentation), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ICustomPropertyProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICustomPropertyProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICustomPropertyProvider[] = {
        { "type", reinterpret_cast<getter>(ICustomPropertyProvider_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICustomPropertyProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICustomPropertyProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICustomPropertyProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICustomPropertyProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICustomPropertyProvider) },
        { },
    };

    static PyType_Spec type_spec_ICustomPropertyProvider =
    {
        "winrt._winrt_windows_ui_xaml_data.ICustomPropertyProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::ICustomPropertyProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICustomPropertyProvider
    };

    // ----- IItemsRangeInfo interface --------------------

    static PyObject* _new_IItemsRangeInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Data::IItemsRangeInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Data::IItemsRangeInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_IItemsRangeInfo(py::wrapper::Windows::UI::Xaml::Data::IItemsRangeInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IItemsRangeInfo_Close(py::wrapper::Windows::UI::Xaml::Data::IItemsRangeInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IItemsRangeInfo_RangesChanged(py::wrapper::Windows::UI::Xaml::Data::IItemsRangeInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.IItemsRangeInfo", L"RangesChanged", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Data::ItemIndexRange>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::UI::Xaml::Data::ItemIndexRange>>(args, 1);

                self->obj.RangesChanged(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IItemsRangeInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::IItemsRangeInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IItemsRangeInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::IItemsRangeInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IItemsRangeInfo(py::wrapper::Windows::UI::Xaml::Data::IItemsRangeInfo* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_IItemsRangeInfo(py::wrapper::Windows::UI::Xaml::Data::IItemsRangeInfo* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IItemsRangeInfo[] = {
        { "close", reinterpret_cast<PyCFunction>(IItemsRangeInfo_Close), METH_VARARGS, nullptr },
        { "ranges_changed", reinterpret_cast<PyCFunction>(IItemsRangeInfo_RangesChanged), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IItemsRangeInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IItemsRangeInfo), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IItemsRangeInfo), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_IItemsRangeInfo), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IItemsRangeInfo[] = {
        { }
    };

    static PyType_Slot _type_slots_IItemsRangeInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IItemsRangeInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IItemsRangeInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IItemsRangeInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IItemsRangeInfo) },
        { },
    };

    static PyType_Spec type_spec_IItemsRangeInfo =
    {
        "winrt._winrt_windows_ui_xaml_data.IItemsRangeInfo",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::IItemsRangeInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IItemsRangeInfo
    };

    // ----- INotifyPropertyChanged interface --------------------

    static PyObject* _new_INotifyPropertyChanged(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Data::INotifyPropertyChanged>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Data::INotifyPropertyChanged>::type_name);
        return nullptr;
    }

    static void _dealloc_INotifyPropertyChanged(py::wrapper::Windows::UI::Xaml::Data::INotifyPropertyChanged* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INotifyPropertyChanged_add_PropertyChanged(py::wrapper::Windows::UI::Xaml::Data::INotifyPropertyChanged* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Data.INotifyPropertyChanged", L"PropertyChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Data::PropertyChangedEventHandler>(arg);

            return py::convert(self->obj.PropertyChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INotifyPropertyChanged_remove_PropertyChanged(py::wrapper::Windows::UI::Xaml::Data::INotifyPropertyChanged* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Data.INotifyPropertyChanged", L"PropertyChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PropertyChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_INotifyPropertyChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::INotifyPropertyChanged>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INotifyPropertyChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::INotifyPropertyChanged>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INotifyPropertyChanged[] = {
        { "add_property_changed", reinterpret_cast<PyCFunction>(INotifyPropertyChanged_add_PropertyChanged), METH_O, nullptr },
        { "remove_property_changed", reinterpret_cast<PyCFunction>(INotifyPropertyChanged_remove_PropertyChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_INotifyPropertyChanged, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INotifyPropertyChanged), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_INotifyPropertyChanged[] = {
        { }
    };

    static PyType_Slot _type_slots_INotifyPropertyChanged[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_INotifyPropertyChanged) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INotifyPropertyChanged) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INotifyPropertyChanged) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INotifyPropertyChanged) },
        { },
    };

    static PyType_Spec type_spec_INotifyPropertyChanged =
    {
        "winrt._winrt_windows_ui_xaml_data.INotifyPropertyChanged",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::INotifyPropertyChanged),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INotifyPropertyChanged
    };

    // ----- ISelectionInfo interface --------------------

    static PyObject* _new_ISelectionInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Data::ISelectionInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Data::ISelectionInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_ISelectionInfo(py::wrapper::Windows::UI::Xaml::Data::ISelectionInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISelectionInfo_DeselectRange(py::wrapper::Windows::UI::Xaml::Data::ISelectionInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ISelectionInfo", L"DeselectRange", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Data::ItemIndexRange>(args, 0);

                self->obj.DeselectRange(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISelectionInfo_GetSelectedRanges(py::wrapper::Windows::UI::Xaml::Data::ISelectionInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ISelectionInfo", L"GetSelectedRanges", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetSelectedRanges());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISelectionInfo_IsSelected(py::wrapper::Windows::UI::Xaml::Data::ISelectionInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ISelectionInfo", L"IsSelected", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.IsSelected(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISelectionInfo_SelectRange(py::wrapper::Windows::UI::Xaml::Data::ISelectionInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ISelectionInfo", L"SelectRange", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Data::ItemIndexRange>(args, 0);

                self->obj.SelectRange(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ISelectionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::ISelectionInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISelectionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::ISelectionInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISelectionInfo[] = {
        { "deselect_range", reinterpret_cast<PyCFunction>(ISelectionInfo_DeselectRange), METH_VARARGS, nullptr },
        { "get_selected_ranges", reinterpret_cast<PyCFunction>(ISelectionInfo_GetSelectedRanges), METH_VARARGS, nullptr },
        { "is_selected", reinterpret_cast<PyCFunction>(ISelectionInfo_IsSelected), METH_VARARGS, nullptr },
        { "select_range", reinterpret_cast<PyCFunction>(ISelectionInfo_SelectRange), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ISelectionInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISelectionInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISelectionInfo[] = {
        { }
    };

    static PyType_Slot _type_slots_ISelectionInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISelectionInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISelectionInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISelectionInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISelectionInfo) },
        { },
    };

    static PyType_Spec type_spec_ISelectionInfo =
    {
        "winrt._winrt_windows_ui_xaml_data.ISelectionInfo",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::ISelectionInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISelectionInfo
    };

    // ----- ISupportIncrementalLoading interface --------------------

    static PyObject* _new_ISupportIncrementalLoading(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Data::ISupportIncrementalLoading>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Data::ISupportIncrementalLoading>::type_name);
        return nullptr;
    }

    static void _dealloc_ISupportIncrementalLoading(py::wrapper::Windows::UI::Xaml::Data::ISupportIncrementalLoading* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISupportIncrementalLoading_LoadMoreItemsAsync(py::wrapper::Windows::UI::Xaml::Data::ISupportIncrementalLoading* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ISupportIncrementalLoading", L"LoadMoreItemsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.LoadMoreItemsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISupportIncrementalLoading_get_HasMoreItems(py::wrapper::Windows::UI::Xaml::Data::ISupportIncrementalLoading* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ISupportIncrementalLoading", L"HasMoreItems"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasMoreItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ISupportIncrementalLoading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::ISupportIncrementalLoading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISupportIncrementalLoading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::ISupportIncrementalLoading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISupportIncrementalLoading[] = {
        { "load_more_items_async", reinterpret_cast<PyCFunction>(ISupportIncrementalLoading_LoadMoreItemsAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ISupportIncrementalLoading, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISupportIncrementalLoading), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISupportIncrementalLoading[] = {
        { "has_more_items", reinterpret_cast<getter>(ISupportIncrementalLoading_get_HasMoreItems), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ISupportIncrementalLoading[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISupportIncrementalLoading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISupportIncrementalLoading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISupportIncrementalLoading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISupportIncrementalLoading) },
        { },
    };

    static PyType_Spec type_spec_ISupportIncrementalLoading =
    {
        "winrt._winrt_windows_ui_xaml_data.ISupportIncrementalLoading",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::ISupportIncrementalLoading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISupportIncrementalLoading
    };

    // ----- IValueConverter interface --------------------

    static PyObject* _new_IValueConverter(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Data::IValueConverter>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Data::IValueConverter>::type_name);
        return nullptr;
    }

    static void _dealloc_IValueConverter(py::wrapper::Windows::UI::Xaml::Data::IValueConverter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IValueConverter_Convert(py::wrapper::Windows::UI::Xaml::Data::IValueConverter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.IValueConverter", L"Convert", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert(self->obj.Convert(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IValueConverter_ConvertBack(py::wrapper::Windows::UI::Xaml::Data::IValueConverter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.IValueConverter", L"ConvertBack", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert(self->obj.ConvertBack(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IValueConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::IValueConverter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IValueConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::IValueConverter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IValueConverter[] = {
        { "convert", reinterpret_cast<PyCFunction>(IValueConverter_Convert), METH_VARARGS, nullptr },
        { "convert_back", reinterpret_cast<PyCFunction>(IValueConverter_ConvertBack), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IValueConverter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IValueConverter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IValueConverter[] = {
        { }
    };

    static PyType_Slot _type_slots_IValueConverter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IValueConverter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IValueConverter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IValueConverter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IValueConverter) },
        { },
    };

    static PyType_Spec type_spec_IValueConverter =
    {
        "winrt._winrt_windows_ui_xaml_data.IValueConverter",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::IValueConverter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IValueConverter
    };

    // ----- LoadMoreItemsResult struct --------------------

    winrt_struct_wrapper<winrt::Windows::UI::Xaml::Data::LoadMoreItemsResult>* _new_LoadMoreItemsResult(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::UI::Xaml::Data::LoadMoreItemsResult>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_LoadMoreItemsResult(winrt_struct_wrapper<winrt::Windows::UI::Xaml::Data::LoadMoreItemsResult>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint32_t _Count{};

        static const char* kwlist[] = {"count", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "I", const_cast<char**>(kwlist), &_Count))
        {
            return -1;
        }

        try
        {
            self->obj = {_Count};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_LoadMoreItemsResult(py::wrapper::Windows::UI::Xaml::Data::LoadMoreItemsResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_LoadMoreItemsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::LoadMoreItemsResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_LoadMoreItemsResult[] = {
        { "_assign_array_", _assign_array_LoadMoreItemsResult, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* LoadMoreItemsResult_get_Count(py::wrapper::Windows::UI::Xaml::Data::LoadMoreItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Count);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoadMoreItemsResult_set_Count(py::wrapper::Windows::UI::Xaml::Data::LoadMoreItemsResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Count = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_LoadMoreItemsResult[] = {
        { "count", reinterpret_cast<getter>(LoadMoreItemsResult_get_Count), reinterpret_cast<setter>(LoadMoreItemsResult_set_Count), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LoadMoreItemsResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LoadMoreItemsResult) },
        { Py_tp_init, reinterpret_cast<void*>(_init_LoadMoreItemsResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LoadMoreItemsResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LoadMoreItemsResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LoadMoreItemsResult) },
        { },
    };

    static PyType_Spec type_spec_LoadMoreItemsResult =
    {
        "winrt._winrt_windows_ui_xaml_data.LoadMoreItemsResult",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::LoadMoreItemsResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoadMoreItemsResult
    };

    // ----- Windows.UI.Xaml.Data Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::UI::Xaml::Data");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_ui_xaml_data",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::UI::Xaml::Data

PyMODINIT_FUNC PyInit__winrt_windows_ui_xaml_data(void) noexcept
{
    using namespace py::cpp::Windows::UI::Xaml::Data;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Binding, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BindingBase, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BindingExpression, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BindingExpressionBase, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_BindingOperations_Static{PyType_FromSpec(&type_spec_BindingOperations_Static)};
    if (!type_BindingOperations_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BindingOperations, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BindingOperations_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_CollectionViewSource_Static{PyType_FromSpec(&type_spec_CollectionViewSource_Static)};
    if (!type_CollectionViewSource_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CollectionViewSource, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CollectionViewSource_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CurrentChangingEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ItemIndexRange, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PropertyChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RelativeSource, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ICollectionView, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ICollectionViewFactory, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ICollectionViewGroup, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ICustomProperty, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ICustomPropertyProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IItemsRangeInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_INotifyPropertyChanged, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ISelectionInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ISupportIncrementalLoading, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IValueConverter, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LoadMoreItemsResult, nullptr, nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
