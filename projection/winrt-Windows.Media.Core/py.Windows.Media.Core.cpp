// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.Media.Core.h"


namespace py::cpp::Windows::Media::Core
{
    // ----- AudioStreamDescriptor class --------------------
    static constexpr const char* const type_name_AudioStreamDescriptor = "AudioStreamDescriptor";

    static PyObject* _new_AudioStreamDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 0);

                winrt::Windows::Media::Core::AudioStreamDescriptor instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AudioStreamDescriptor(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioStreamDescriptor_Copy(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.AudioStreamDescriptor", L"Copy", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioStreamDescriptor_get_EncodingProperties(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioStreamDescriptor", L"EncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioStreamDescriptor_get_TrailingEncoderPadding(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioStreamDescriptor", L"TrailingEncoderPadding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TrailingEncoderPadding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioStreamDescriptor_put_TrailingEncoderPadding(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioStreamDescriptor", L"TrailingEncoderPadding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.TrailingEncoderPadding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioStreamDescriptor_get_LeadingEncoderPadding(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioStreamDescriptor", L"LeadingEncoderPadding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LeadingEncoderPadding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioStreamDescriptor_put_LeadingEncoderPadding(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioStreamDescriptor", L"LeadingEncoderPadding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.LeadingEncoderPadding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioStreamDescriptor_get_Name(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioStreamDescriptor", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioStreamDescriptor_put_Name(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioStreamDescriptor", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioStreamDescriptor_get_Language(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioStreamDescriptor", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioStreamDescriptor_put_Language(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioStreamDescriptor", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioStreamDescriptor_get_IsSelected(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioStreamDescriptor", L"IsSelected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioStreamDescriptor_get_Label(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioStreamDescriptor", L"Label"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioStreamDescriptor_put_Label(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioStreamDescriptor", L"Label"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AudioStreamDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::AudioStreamDescriptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioStreamDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::AudioStreamDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioStreamDescriptor[] = {
        { "copy", reinterpret_cast<PyCFunction>(AudioStreamDescriptor_Copy), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AudioStreamDescriptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioStreamDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioStreamDescriptor[] = {
        { "encoding_properties", reinterpret_cast<getter>(AudioStreamDescriptor_get_EncodingProperties), nullptr, nullptr, nullptr },
        { "trailing_encoder_padding", reinterpret_cast<getter>(AudioStreamDescriptor_get_TrailingEncoderPadding), reinterpret_cast<setter>(AudioStreamDescriptor_put_TrailingEncoderPadding), nullptr, nullptr },
        { "leading_encoder_padding", reinterpret_cast<getter>(AudioStreamDescriptor_get_LeadingEncoderPadding), reinterpret_cast<setter>(AudioStreamDescriptor_put_LeadingEncoderPadding), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(AudioStreamDescriptor_get_Name), reinterpret_cast<setter>(AudioStreamDescriptor_put_Name), nullptr, nullptr },
        { "language", reinterpret_cast<getter>(AudioStreamDescriptor_get_Language), reinterpret_cast<setter>(AudioStreamDescriptor_put_Language), nullptr, nullptr },
        { "is_selected", reinterpret_cast<getter>(AudioStreamDescriptor_get_IsSelected), nullptr, nullptr, nullptr },
        { "label", reinterpret_cast<getter>(AudioStreamDescriptor_get_Label), reinterpret_cast<setter>(AudioStreamDescriptor_put_Label), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioStreamDescriptor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioStreamDescriptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioStreamDescriptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioStreamDescriptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioStreamDescriptor) },
        { },
    };

    static PyType_Spec type_spec_AudioStreamDescriptor =
    {
        "_winrt_windows_media_core.AudioStreamDescriptor",
        sizeof(py::wrapper::Windows::Media::Core::AudioStreamDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioStreamDescriptor
    };

    // ----- AudioTrack class --------------------
    static constexpr const char* const type_name_AudioTrack = "AudioTrack";

    static PyObject* _new_AudioTrack(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AudioTrack);
        return nullptr;
    }

    static void _dealloc_AudioTrack(py::wrapper::Windows::Media::Core::AudioTrack* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioTrack_GetEncodingProperties(py::wrapper::Windows::Media::Core::AudioTrack* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.AudioTrack", L"GetEncodingProperties", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetEncodingProperties());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioTrack_get_Name(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioTrack", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_get_PlaybackItem(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioTrack", L"PlaybackItem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlaybackItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_get_SupportInfo(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioTrack", L"SupportInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_get_Label(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioTrack", L"Label"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioTrack_put_Label(py::wrapper::Windows::Media::Core::AudioTrack* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioTrack", L"Label"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioTrack_get_Id(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioTrack", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_get_Language(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioTrack", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_get_TrackKind(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioTrack", L"TrackKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TrackKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_add_OpenFailed(py::wrapper::Windows::Media::Core::AudioTrack* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.AudioTrack", L"OpenFailed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::AudioTrack, winrt::Windows::Media::Core::AudioTrackOpenFailedEventArgs>>(arg);

            return py::convert(self->obj.OpenFailed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_remove_OpenFailed(py::wrapper::Windows::Media::Core::AudioTrack* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.AudioTrack", L"OpenFailed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.OpenFailed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioTrack(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::AudioTrack>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioTrack(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::AudioTrack>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioTrack[] = {
        { "get_encoding_properties", reinterpret_cast<PyCFunction>(AudioTrack_GetEncodingProperties), METH_VARARGS, nullptr },
        { "add_open_failed", reinterpret_cast<PyCFunction>(AudioTrack_add_OpenFailed), METH_O, nullptr },
        { "remove_open_failed", reinterpret_cast<PyCFunction>(AudioTrack_remove_OpenFailed), METH_O, nullptr },
        { "_assign_array_", _assign_array_AudioTrack, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioTrack), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioTrack[] = {
        { "name", reinterpret_cast<getter>(AudioTrack_get_Name), nullptr, nullptr, nullptr },
        { "playback_item", reinterpret_cast<getter>(AudioTrack_get_PlaybackItem), nullptr, nullptr, nullptr },
        { "support_info", reinterpret_cast<getter>(AudioTrack_get_SupportInfo), nullptr, nullptr, nullptr },
        { "label", reinterpret_cast<getter>(AudioTrack_get_Label), reinterpret_cast<setter>(AudioTrack_put_Label), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(AudioTrack_get_Id), nullptr, nullptr, nullptr },
        { "language", reinterpret_cast<getter>(AudioTrack_get_Language), nullptr, nullptr, nullptr },
        { "track_kind", reinterpret_cast<getter>(AudioTrack_get_TrackKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioTrack[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioTrack) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioTrack) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioTrack) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioTrack) },
        { },
    };

    static PyType_Spec type_spec_AudioTrack =
    {
        "_winrt_windows_media_core.AudioTrack",
        sizeof(py::wrapper::Windows::Media::Core::AudioTrack),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioTrack
    };

    // ----- AudioTrackOpenFailedEventArgs class --------------------
    static constexpr const char* const type_name_AudioTrackOpenFailedEventArgs = "AudioTrackOpenFailedEventArgs";

    static PyObject* _new_AudioTrackOpenFailedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AudioTrackOpenFailedEventArgs);
        return nullptr;
    }

    static void _dealloc_AudioTrackOpenFailedEventArgs(py::wrapper::Windows::Media::Core::AudioTrackOpenFailedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioTrackOpenFailedEventArgs_get_ExtendedError(py::wrapper::Windows::Media::Core::AudioTrackOpenFailedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioTrackOpenFailedEventArgs", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioTrackOpenFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::AudioTrackOpenFailedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioTrackOpenFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::AudioTrackOpenFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioTrackOpenFailedEventArgs[] = {
        { "_assign_array_", _assign_array_AudioTrackOpenFailedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioTrackOpenFailedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioTrackOpenFailedEventArgs[] = {
        { "extended_error", reinterpret_cast<getter>(AudioTrackOpenFailedEventArgs_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioTrackOpenFailedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioTrackOpenFailedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioTrackOpenFailedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioTrackOpenFailedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioTrackOpenFailedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AudioTrackOpenFailedEventArgs =
    {
        "_winrt_windows_media_core.AudioTrackOpenFailedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::AudioTrackOpenFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioTrackOpenFailedEventArgs
    };

    // ----- AudioTrackSupportInfo class --------------------
    static constexpr const char* const type_name_AudioTrackSupportInfo = "AudioTrackSupportInfo";

    static PyObject* _new_AudioTrackSupportInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AudioTrackSupportInfo);
        return nullptr;
    }

    static void _dealloc_AudioTrackSupportInfo(py::wrapper::Windows::Media::Core::AudioTrackSupportInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioTrackSupportInfo_get_DecoderStatus(py::wrapper::Windows::Media::Core::AudioTrackSupportInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioTrackSupportInfo", L"DecoderStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DecoderStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrackSupportInfo_get_Degradation(py::wrapper::Windows::Media::Core::AudioTrackSupportInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioTrackSupportInfo", L"Degradation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Degradation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrackSupportInfo_get_DegradationReason(py::wrapper::Windows::Media::Core::AudioTrackSupportInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioTrackSupportInfo", L"DegradationReason"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DegradationReason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrackSupportInfo_get_MediaSourceStatus(py::wrapper::Windows::Media::Core::AudioTrackSupportInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioTrackSupportInfo", L"MediaSourceStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MediaSourceStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioTrackSupportInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::AudioTrackSupportInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioTrackSupportInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::AudioTrackSupportInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioTrackSupportInfo[] = {
        { "_assign_array_", _assign_array_AudioTrackSupportInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioTrackSupportInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioTrackSupportInfo[] = {
        { "decoder_status", reinterpret_cast<getter>(AudioTrackSupportInfo_get_DecoderStatus), nullptr, nullptr, nullptr },
        { "degradation", reinterpret_cast<getter>(AudioTrackSupportInfo_get_Degradation), nullptr, nullptr, nullptr },
        { "degradation_reason", reinterpret_cast<getter>(AudioTrackSupportInfo_get_DegradationReason), nullptr, nullptr, nullptr },
        { "media_source_status", reinterpret_cast<getter>(AudioTrackSupportInfo_get_MediaSourceStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioTrackSupportInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioTrackSupportInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioTrackSupportInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioTrackSupportInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioTrackSupportInfo) },
        { },
    };

    static PyType_Spec type_spec_AudioTrackSupportInfo =
    {
        "_winrt_windows_media_core.AudioTrackSupportInfo",
        sizeof(py::wrapper::Windows::Media::Core::AudioTrackSupportInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioTrackSupportInfo
    };

    // ----- ChapterCue class --------------------
    static constexpr const char* const type_name_ChapterCue = "ChapterCue";

    static PyObject* _new_ChapterCue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::ChapterCue instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChapterCue(py::wrapper::Windows::Media::Core::ChapterCue* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChapterCue_get_Title(py::wrapper::Windows::Media::Core::ChapterCue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ChapterCue", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChapterCue_put_Title(py::wrapper::Windows::Media::Core::ChapterCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ChapterCue", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChapterCue_get_StartTime(py::wrapper::Windows::Media::Core::ChapterCue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ChapterCue", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChapterCue_put_StartTime(py::wrapper::Windows::Media::Core::ChapterCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ChapterCue", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChapterCue_get_Id(py::wrapper::Windows::Media::Core::ChapterCue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ChapterCue", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChapterCue_put_Id(py::wrapper::Windows::Media::Core::ChapterCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ChapterCue", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChapterCue_get_Duration(py::wrapper::Windows::Media::Core::ChapterCue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ChapterCue", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChapterCue_put_Duration(py::wrapper::Windows::Media::Core::ChapterCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ChapterCue", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ChapterCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::ChapterCue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChapterCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::ChapterCue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChapterCue[] = {
        { "_assign_array_", _assign_array_ChapterCue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChapterCue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChapterCue[] = {
        { "title", reinterpret_cast<getter>(ChapterCue_get_Title), reinterpret_cast<setter>(ChapterCue_put_Title), nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(ChapterCue_get_StartTime), reinterpret_cast<setter>(ChapterCue_put_StartTime), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ChapterCue_get_Id), reinterpret_cast<setter>(ChapterCue_put_Id), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(ChapterCue_get_Duration), reinterpret_cast<setter>(ChapterCue_put_Duration), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChapterCue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChapterCue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChapterCue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChapterCue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChapterCue) },
        { },
    };

    static PyType_Spec type_spec_ChapterCue =
    {
        "_winrt_windows_media_core.ChapterCue",
        sizeof(py::wrapper::Windows::Media::Core::ChapterCue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChapterCue
    };

    // ----- CodecInfo class --------------------
    static constexpr const char* const type_name_CodecInfo = "CodecInfo";

    static PyObject* _new_CodecInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CodecInfo);
        return nullptr;
    }

    static void _dealloc_CodecInfo(py::wrapper::Windows::Media::Core::CodecInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CodecInfo_get_Category(py::wrapper::Windows::Media::Core::CodecInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecInfo", L"Category"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Category());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecInfo_get_DisplayName(py::wrapper::Windows::Media::Core::CodecInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecInfo", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecInfo_get_IsTrusted(py::wrapper::Windows::Media::Core::CodecInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecInfo", L"IsTrusted"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsTrusted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecInfo_get_Kind(py::wrapper::Windows::Media::Core::CodecInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecInfo", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecInfo_get_Subtypes(py::wrapper::Windows::Media::Core::CodecInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecInfo", L"Subtypes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Subtypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CodecInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::CodecInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CodecInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::CodecInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CodecInfo[] = {
        { "_assign_array_", _assign_array_CodecInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CodecInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CodecInfo[] = {
        { "category", reinterpret_cast<getter>(CodecInfo_get_Category), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(CodecInfo_get_DisplayName), nullptr, nullptr, nullptr },
        { "is_trusted", reinterpret_cast<getter>(CodecInfo_get_IsTrusted), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(CodecInfo_get_Kind), nullptr, nullptr, nullptr },
        { "subtypes", reinterpret_cast<getter>(CodecInfo_get_Subtypes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CodecInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CodecInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CodecInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CodecInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CodecInfo) },
        { },
    };

    static PyType_Spec type_spec_CodecInfo =
    {
        "_winrt_windows_media_core.CodecInfo",
        sizeof(py::wrapper::Windows::Media::Core::CodecInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CodecInfo
    };

    // ----- CodecQuery class --------------------
    static constexpr const char* const type_name_CodecQuery = "CodecQuery";

    static PyObject* _new_CodecQuery(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::CodecQuery instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CodecQuery(py::wrapper::Windows::Media::Core::CodecQuery* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CodecQuery_FindAllAsync(py::wrapper::Windows::Media::Core::CodecQuery* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.CodecQuery", L"FindAllAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::CodecKind>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Core::CodecCategory>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.FindAllAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_CodecQuery(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::CodecQuery>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CodecQuery(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::CodecQuery>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CodecQuery[] = {
        { "find_all_async", reinterpret_cast<PyCFunction>(CodecQuery_FindAllAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CodecQuery, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CodecQuery), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CodecQuery[] = {
        { }
    };

    static PyType_Slot _type_slots_CodecQuery[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CodecQuery) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CodecQuery) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CodecQuery) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CodecQuery) },
        { },
    };

    static PyType_Spec type_spec_CodecQuery =
    {
        "_winrt_windows_media_core.CodecQuery",
        sizeof(py::wrapper::Windows::Media::Core::CodecQuery),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CodecQuery
    };

    // ----- CodecSubtypes class --------------------
    static constexpr const char* const type_name_CodecSubtypes = "CodecSubtypes";

    static PyObject* _new_CodecSubtypes(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CodecSubtypes);
        return nullptr;
    }

    static PyObject* CodecSubtypes_get_AudioFormatAac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatAac"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatAac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatAdts(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatAdts"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatAdts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatAlac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatAlac"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatAlac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatAmrNB(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatAmrNB"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatAmrNB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatAmrWB(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatAmrWB"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatAmrWB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatAmrWP(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatAmrWP"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatAmrWP());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatDolbyAC3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatDolbyAC3"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatDolbyAC3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatDolbyAC3Spdif(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatDolbyAC3Spdif"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatDolbyAC3Spdif());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatDolbyDDPlus(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatDolbyDDPlus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatDolbyDDPlus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatDrm(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatDrm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatDrm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatDts(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatDts"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatDts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatFlac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatFlac"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatFlac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatFloat(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatFloat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatFloat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatMP3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatMP3"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatMP3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatMPeg(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatMPeg"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatMPeg());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatMsp1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatMsp1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatMsp1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatOpus(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatOpus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatOpus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatPcm(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatPcm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatPcm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatWMAudioLossless(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatWMAudioLossless"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatWMAudioLossless());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatWMAudioV8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatWMAudioV8"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatWMAudioV8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatWMAudioV9(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatWMAudioV9"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatWMAudioV9());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatWmaSpdif(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatWmaSpdif"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatWmaSpdif());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormat420O(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormat420O"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormat420O());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDV25(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatDV25"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDV25());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDV50(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatDV50"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDV50());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDvc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatDvc"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDvc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDvh1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatDvh1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDvh1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDvhD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatDvhD"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDvhD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDvsd(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatDvsd"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDvsd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDvsl(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatDvsl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDvsl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatH263(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatH263"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatH263());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatH264(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatH264"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatH264());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatH264ES(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatH264ES"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatH264ES());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatH265(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatH265"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatH265());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatHevc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatHevc"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatHevc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatHevcES(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatHevcES"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatHevcES());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatM4S2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatM4S2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatM4S2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMP43(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatMP43"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMP43());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMP4S(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatMP4S"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMP4S());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMP4V(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatMP4V"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMP4V());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMjpg(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatMjpg"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMjpg());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMpeg2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatMpeg2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMpeg2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMpg1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatMpg1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMpg1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMss1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatMss1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMss1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMss2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatMss2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMss2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatVP80(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatVP80"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatVP80());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatVP90(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatVP90"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatVP90());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatWmv1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatWmv1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatWmv1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatWmv2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatWmv2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatWmv2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatWmv3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatWmv3"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatWmv3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatWvc1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatWvc1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatWvc1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CodecSubtypes[] = {
        { }
    };

    static PyGetSetDef _getset_CodecSubtypes[] = {
        { }
    };

    static PyType_Slot _type_slots_CodecSubtypes[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CodecSubtypes) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CodecSubtypes) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CodecSubtypes) },
        { },
    };

    static PyType_Spec type_spec_CodecSubtypes =
    {
        "_winrt_windows_media_core.CodecSubtypes",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CodecSubtypes
    };

    static PyGetSetDef getset_CodecSubtypes_Meta[] = {
        { "audio_format_aac", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatAac), nullptr, nullptr, nullptr },
        { "audio_format_adts", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatAdts), nullptr, nullptr, nullptr },
        { "audio_format_alac", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatAlac), nullptr, nullptr, nullptr },
        { "audio_format_amr_n_b", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatAmrNB), nullptr, nullptr, nullptr },
        { "audio_format_amr_w_b", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatAmrWB), nullptr, nullptr, nullptr },
        { "audio_format_amr_w_p", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatAmrWP), nullptr, nullptr, nullptr },
        { "audio_format_dolby_a_c3", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatDolbyAC3), nullptr, nullptr, nullptr },
        { "audio_format_dolby_a_c3_spdif", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatDolbyAC3Spdif), nullptr, nullptr, nullptr },
        { "audio_format_dolby_d_d_plus", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatDolbyDDPlus), nullptr, nullptr, nullptr },
        { "audio_format_drm", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatDrm), nullptr, nullptr, nullptr },
        { "audio_format_dts", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatDts), nullptr, nullptr, nullptr },
        { "audio_format_flac", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatFlac), nullptr, nullptr, nullptr },
        { "audio_format_float", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatFloat), nullptr, nullptr, nullptr },
        { "audio_format_m_p3", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatMP3), nullptr, nullptr, nullptr },
        { "audio_format_m_peg", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatMPeg), nullptr, nullptr, nullptr },
        { "audio_format_msp1", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatMsp1), nullptr, nullptr, nullptr },
        { "audio_format_opus", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatOpus), nullptr, nullptr, nullptr },
        { "audio_format_pcm", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatPcm), nullptr, nullptr, nullptr },
        { "audio_format_w_m_audio_lossless", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatWMAudioLossless), nullptr, nullptr, nullptr },
        { "audio_format_w_m_audio_v8", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatWMAudioV8), nullptr, nullptr, nullptr },
        { "audio_format_w_m_audio_v9", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatWMAudioV9), nullptr, nullptr, nullptr },
        { "audio_format_wma_spdif", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatWmaSpdif), nullptr, nullptr, nullptr },
        { "video_format420_o", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormat420O), nullptr, nullptr, nullptr },
        { "video_format_d_v25", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatDV25), nullptr, nullptr, nullptr },
        { "video_format_d_v50", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatDV50), nullptr, nullptr, nullptr },
        { "video_format_dvc", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatDvc), nullptr, nullptr, nullptr },
        { "video_format_dvh1", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatDvh1), nullptr, nullptr, nullptr },
        { "video_format_dvh_d", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatDvhD), nullptr, nullptr, nullptr },
        { "video_format_dvsd", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatDvsd), nullptr, nullptr, nullptr },
        { "video_format_dvsl", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatDvsl), nullptr, nullptr, nullptr },
        { "video_format_h263", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatH263), nullptr, nullptr, nullptr },
        { "video_format_h264", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatH264), nullptr, nullptr, nullptr },
        { "video_format_h264_e_s", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatH264ES), nullptr, nullptr, nullptr },
        { "video_format_h265", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatH265), nullptr, nullptr, nullptr },
        { "video_format_hevc", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatHevc), nullptr, nullptr, nullptr },
        { "video_format_hevc_e_s", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatHevcES), nullptr, nullptr, nullptr },
        { "video_format_m4_s2", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatM4S2), nullptr, nullptr, nullptr },
        { "video_format_m_p43", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatMP43), nullptr, nullptr, nullptr },
        { "video_format_m_p4_s", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatMP4S), nullptr, nullptr, nullptr },
        { "video_format_m_p4_v", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatMP4V), nullptr, nullptr, nullptr },
        { "video_format_mjpg", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatMjpg), nullptr, nullptr, nullptr },
        { "video_format_mpeg2", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatMpeg2), nullptr, nullptr, nullptr },
        { "video_format_mpg1", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatMpg1), nullptr, nullptr, nullptr },
        { "video_format_mss1", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatMss1), nullptr, nullptr, nullptr },
        { "video_format_mss2", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatMss2), nullptr, nullptr, nullptr },
        { "video_format_v_p80", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatVP80), nullptr, nullptr, nullptr },
        { "video_format_v_p90", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatVP90), nullptr, nullptr, nullptr },
        { "video_format_wmv1", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatWmv1), nullptr, nullptr, nullptr },
        { "video_format_wmv2", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatWmv2), nullptr, nullptr, nullptr },
        { "video_format_wmv3", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatWmv3), nullptr, nullptr, nullptr },
        { "video_format_wvc1", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatWvc1), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_CodecSubtypes_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CodecSubtypes_Meta) },
        { }
    };

    static PyType_Spec type_spec_CodecSubtypes_Meta =
    {
        "_winrt_windows_media_core.CodecSubtypes_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CodecSubtypes_Meta
    };

    // ----- DataCue class --------------------
    static constexpr const char* const type_name_DataCue = "DataCue";

    static PyObject* _new_DataCue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::DataCue instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DataCue(py::wrapper::Windows::Media::Core::DataCue* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DataCue_get_Data(py::wrapper::Windows::Media::Core::DataCue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.DataCue", L"Data"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataCue_put_Data(py::wrapper::Windows::Media::Core::DataCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.DataCue", L"Data"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.Data(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataCue_get_Properties(py::wrapper::Windows::Media::Core::DataCue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.DataCue", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataCue_get_StartTime(py::wrapper::Windows::Media::Core::DataCue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.DataCue", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataCue_put_StartTime(py::wrapper::Windows::Media::Core::DataCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.DataCue", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataCue_get_Id(py::wrapper::Windows::Media::Core::DataCue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.DataCue", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataCue_put_Id(py::wrapper::Windows::Media::Core::DataCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.DataCue", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataCue_get_Duration(py::wrapper::Windows::Media::Core::DataCue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.DataCue", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataCue_put_Duration(py::wrapper::Windows::Media::Core::DataCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.DataCue", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DataCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::DataCue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DataCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::DataCue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataCue[] = {
        { "_assign_array_", _assign_array_DataCue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DataCue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataCue[] = {
        { "data", reinterpret_cast<getter>(DataCue_get_Data), reinterpret_cast<setter>(DataCue_put_Data), nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DataCue_get_Properties), nullptr, nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(DataCue_get_StartTime), reinterpret_cast<setter>(DataCue_put_StartTime), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(DataCue_get_Id), reinterpret_cast<setter>(DataCue_put_Id), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(DataCue_get_Duration), reinterpret_cast<setter>(DataCue_put_Duration), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DataCue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DataCue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DataCue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DataCue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DataCue) },
        { },
    };

    static PyType_Spec type_spec_DataCue =
    {
        "_winrt_windows_media_core.DataCue",
        sizeof(py::wrapper::Windows::Media::Core::DataCue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataCue
    };

    // ----- FaceDetectedEventArgs class --------------------
    static constexpr const char* const type_name_FaceDetectedEventArgs = "FaceDetectedEventArgs";

    static PyObject* _new_FaceDetectedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FaceDetectedEventArgs);
        return nullptr;
    }

    static void _dealloc_FaceDetectedEventArgs(py::wrapper::Windows::Media::Core::FaceDetectedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FaceDetectedEventArgs_get_ResultFrame(py::wrapper::Windows::Media::Core::FaceDetectedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectedEventArgs", L"ResultFrame"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ResultFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FaceDetectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::FaceDetectedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FaceDetectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::FaceDetectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FaceDetectedEventArgs[] = {
        { "_assign_array_", _assign_array_FaceDetectedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FaceDetectedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FaceDetectedEventArgs[] = {
        { "result_frame", reinterpret_cast<getter>(FaceDetectedEventArgs_get_ResultFrame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FaceDetectedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FaceDetectedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FaceDetectedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FaceDetectedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FaceDetectedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_FaceDetectedEventArgs =
    {
        "_winrt_windows_media_core.FaceDetectedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::FaceDetectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FaceDetectedEventArgs
    };

    // ----- FaceDetectionEffect class --------------------
    static constexpr const char* const type_name_FaceDetectionEffect = "FaceDetectionEffect";

    static PyObject* _new_FaceDetectionEffect(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FaceDetectionEffect);
        return nullptr;
    }

    static void _dealloc_FaceDetectionEffect(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FaceDetectionEffect_SetProperties(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.FaceDetectionEffect", L"SetProperties", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);

                self->obj.SetProperties(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffect_get_Enabled(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffect", L"Enabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffect_put_Enabled(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffect", L"Enabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffect_get_DesiredDetectionInterval(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffect", L"DesiredDetectionInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredDetectionInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffect_put_DesiredDetectionInterval(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffect", L"DesiredDetectionInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.DesiredDetectionInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffect_add_FaceDetected(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.FaceDetectionEffect", L"FaceDetected"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::FaceDetectionEffect, winrt::Windows::Media::Core::FaceDetectedEventArgs>>(arg);

            return py::convert(self->obj.FaceDetected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffect_remove_FaceDetected(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.FaceDetectionEffect", L"FaceDetected"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FaceDetected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FaceDetectionEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::FaceDetectionEffect>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FaceDetectionEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::FaceDetectionEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FaceDetectionEffect[] = {
        { "set_properties", reinterpret_cast<PyCFunction>(FaceDetectionEffect_SetProperties), METH_VARARGS, nullptr },
        { "add_face_detected", reinterpret_cast<PyCFunction>(FaceDetectionEffect_add_FaceDetected), METH_O, nullptr },
        { "remove_face_detected", reinterpret_cast<PyCFunction>(FaceDetectionEffect_remove_FaceDetected), METH_O, nullptr },
        { "_assign_array_", _assign_array_FaceDetectionEffect, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FaceDetectionEffect), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FaceDetectionEffect[] = {
        { "enabled", reinterpret_cast<getter>(FaceDetectionEffect_get_Enabled), reinterpret_cast<setter>(FaceDetectionEffect_put_Enabled), nullptr, nullptr },
        { "desired_detection_interval", reinterpret_cast<getter>(FaceDetectionEffect_get_DesiredDetectionInterval), reinterpret_cast<setter>(FaceDetectionEffect_put_DesiredDetectionInterval), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FaceDetectionEffect[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FaceDetectionEffect) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FaceDetectionEffect) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FaceDetectionEffect) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FaceDetectionEffect) },
        { },
    };

    static PyType_Spec type_spec_FaceDetectionEffect =
    {
        "_winrt_windows_media_core.FaceDetectionEffect",
        sizeof(py::wrapper::Windows::Media::Core::FaceDetectionEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FaceDetectionEffect
    };

    // ----- FaceDetectionEffectDefinition class --------------------
    static constexpr const char* const type_name_FaceDetectionEffectDefinition = "FaceDetectionEffectDefinition";

    static PyObject* _new_FaceDetectionEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::FaceDetectionEffectDefinition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FaceDetectionEffectDefinition(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FaceDetectionEffectDefinition_get_SynchronousDetectionEnabled(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectDefinition", L"SynchronousDetectionEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SynchronousDetectionEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffectDefinition_put_SynchronousDetectionEnabled(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectDefinition", L"SynchronousDetectionEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.SynchronousDetectionEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffectDefinition_get_DetectionMode(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectDefinition", L"DetectionMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DetectionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffectDefinition_put_DetectionMode(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectDefinition", L"DetectionMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::FaceDetectionMode>(arg);

            self->obj.DetectionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectDefinition", L"ActivatableClassId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffectDefinition_get_Properties(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectDefinition", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FaceDetectionEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::FaceDetectionEffectDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FaceDetectionEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::FaceDetectionEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FaceDetectionEffectDefinition[] = {
        { "_assign_array_", _assign_array_FaceDetectionEffectDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FaceDetectionEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FaceDetectionEffectDefinition[] = {
        { "synchronous_detection_enabled", reinterpret_cast<getter>(FaceDetectionEffectDefinition_get_SynchronousDetectionEnabled), reinterpret_cast<setter>(FaceDetectionEffectDefinition_put_SynchronousDetectionEnabled), nullptr, nullptr },
        { "detection_mode", reinterpret_cast<getter>(FaceDetectionEffectDefinition_get_DetectionMode), reinterpret_cast<setter>(FaceDetectionEffectDefinition_put_DetectionMode), nullptr, nullptr },
        { "activatable_class_id", reinterpret_cast<getter>(FaceDetectionEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(FaceDetectionEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FaceDetectionEffectDefinition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FaceDetectionEffectDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FaceDetectionEffectDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FaceDetectionEffectDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FaceDetectionEffectDefinition) },
        { },
    };

    static PyType_Spec type_spec_FaceDetectionEffectDefinition =
    {
        "_winrt_windows_media_core.FaceDetectionEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FaceDetectionEffectDefinition
    };

    // ----- FaceDetectionEffectFrame class --------------------
    static constexpr const char* const type_name_FaceDetectionEffectFrame = "FaceDetectionEffectFrame";

    static PyObject* _new_FaceDetectionEffectFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FaceDetectionEffectFrame);
        return nullptr;
    }

    static void _dealloc_FaceDetectionEffectFrame(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FaceDetectionEffectFrame_Close(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.FaceDetectionEffectFrame", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_DetectedFaces(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectFrame", L"DetectedFaces"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DetectedFaces());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_SystemRelativeTime(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectFrame", L"SystemRelativeTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SystemRelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffectFrame_put_SystemRelativeTime(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectFrame", L"SystemRelativeTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.SystemRelativeTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_RelativeTime(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectFrame", L"RelativeTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffectFrame_put_RelativeTime(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectFrame", L"RelativeTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.RelativeTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_IsDiscontinuous(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectFrame", L"IsDiscontinuous"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDiscontinuous());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffectFrame_put_IsDiscontinuous(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectFrame", L"IsDiscontinuous"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDiscontinuous(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_Duration(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectFrame", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffectFrame_put_Duration(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectFrame", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_ExtendedProperties(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectFrame", L"ExtendedProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_IsReadOnly(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectFrame", L"IsReadOnly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_Type(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectFrame", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FaceDetectionEffectFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::FaceDetectionEffectFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FaceDetectionEffectFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::FaceDetectionEffectFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_FaceDetectionEffectFrame(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_FaceDetectionEffectFrame(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FaceDetectionEffectFrame[] = {
        { "close", reinterpret_cast<PyCFunction>(FaceDetectionEffectFrame_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_FaceDetectionEffectFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FaceDetectionEffectFrame), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_FaceDetectionEffectFrame), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_FaceDetectionEffectFrame), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_FaceDetectionEffectFrame[] = {
        { "detected_faces", reinterpret_cast<getter>(FaceDetectionEffectFrame_get_DetectedFaces), nullptr, nullptr, nullptr },
        { "system_relative_time", reinterpret_cast<getter>(FaceDetectionEffectFrame_get_SystemRelativeTime), reinterpret_cast<setter>(FaceDetectionEffectFrame_put_SystemRelativeTime), nullptr, nullptr },
        { "relative_time", reinterpret_cast<getter>(FaceDetectionEffectFrame_get_RelativeTime), reinterpret_cast<setter>(FaceDetectionEffectFrame_put_RelativeTime), nullptr, nullptr },
        { "is_discontinuous", reinterpret_cast<getter>(FaceDetectionEffectFrame_get_IsDiscontinuous), reinterpret_cast<setter>(FaceDetectionEffectFrame_put_IsDiscontinuous), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(FaceDetectionEffectFrame_get_Duration), reinterpret_cast<setter>(FaceDetectionEffectFrame_put_Duration), nullptr, nullptr },
        { "extended_properties", reinterpret_cast<getter>(FaceDetectionEffectFrame_get_ExtendedProperties), nullptr, nullptr, nullptr },
        { "is_read_only", reinterpret_cast<getter>(FaceDetectionEffectFrame_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(FaceDetectionEffectFrame_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FaceDetectionEffectFrame[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FaceDetectionEffectFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FaceDetectionEffectFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FaceDetectionEffectFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FaceDetectionEffectFrame) },
        { },
    };

    static PyType_Spec type_spec_FaceDetectionEffectFrame =
    {
        "_winrt_windows_media_core.FaceDetectionEffectFrame",
        sizeof(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FaceDetectionEffectFrame
    };

    // ----- HighDynamicRangeControl class --------------------
    static constexpr const char* const type_name_HighDynamicRangeControl = "HighDynamicRangeControl";

    static PyObject* _new_HighDynamicRangeControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HighDynamicRangeControl);
        return nullptr;
    }

    static void _dealloc_HighDynamicRangeControl(py::wrapper::Windows::Media::Core::HighDynamicRangeControl* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HighDynamicRangeControl_get_Enabled(py::wrapper::Windows::Media::Core::HighDynamicRangeControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.HighDynamicRangeControl", L"Enabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HighDynamicRangeControl_put_Enabled(py::wrapper::Windows::Media::Core::HighDynamicRangeControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.HighDynamicRangeControl", L"Enabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_HighDynamicRangeControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::HighDynamicRangeControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HighDynamicRangeControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::HighDynamicRangeControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HighDynamicRangeControl[] = {
        { "_assign_array_", _assign_array_HighDynamicRangeControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HighDynamicRangeControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HighDynamicRangeControl[] = {
        { "enabled", reinterpret_cast<getter>(HighDynamicRangeControl_get_Enabled), reinterpret_cast<setter>(HighDynamicRangeControl_put_Enabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HighDynamicRangeControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HighDynamicRangeControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HighDynamicRangeControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HighDynamicRangeControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HighDynamicRangeControl) },
        { },
    };

    static PyType_Spec type_spec_HighDynamicRangeControl =
    {
        "_winrt_windows_media_core.HighDynamicRangeControl",
        sizeof(py::wrapper::Windows::Media::Core::HighDynamicRangeControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HighDynamicRangeControl
    };

    // ----- HighDynamicRangeOutput class --------------------
    static constexpr const char* const type_name_HighDynamicRangeOutput = "HighDynamicRangeOutput";

    static PyObject* _new_HighDynamicRangeOutput(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HighDynamicRangeOutput);
        return nullptr;
    }

    static void _dealloc_HighDynamicRangeOutput(py::wrapper::Windows::Media::Core::HighDynamicRangeOutput* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HighDynamicRangeOutput_get_Certainty(py::wrapper::Windows::Media::Core::HighDynamicRangeOutput* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.HighDynamicRangeOutput", L"Certainty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Certainty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HighDynamicRangeOutput_get_FrameControllers(py::wrapper::Windows::Media::Core::HighDynamicRangeOutput* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.HighDynamicRangeOutput", L"FrameControllers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrameControllers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HighDynamicRangeOutput(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::HighDynamicRangeOutput>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HighDynamicRangeOutput(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::HighDynamicRangeOutput>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HighDynamicRangeOutput[] = {
        { "_assign_array_", _assign_array_HighDynamicRangeOutput, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HighDynamicRangeOutput), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HighDynamicRangeOutput[] = {
        { "certainty", reinterpret_cast<getter>(HighDynamicRangeOutput_get_Certainty), nullptr, nullptr, nullptr },
        { "frame_controllers", reinterpret_cast<getter>(HighDynamicRangeOutput_get_FrameControllers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HighDynamicRangeOutput[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HighDynamicRangeOutput) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HighDynamicRangeOutput) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HighDynamicRangeOutput) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HighDynamicRangeOutput) },
        { },
    };

    static PyType_Spec type_spec_HighDynamicRangeOutput =
    {
        "_winrt_windows_media_core.HighDynamicRangeOutput",
        sizeof(py::wrapper::Windows::Media::Core::HighDynamicRangeOutput),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HighDynamicRangeOutput
    };

    // ----- ImageCue class --------------------
    static constexpr const char* const type_name_ImageCue = "ImageCue";

    static PyObject* _new_ImageCue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::ImageCue instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ImageCue(py::wrapper::Windows::Media::Core::ImageCue* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ImageCue_get_SoftwareBitmap(py::wrapper::Windows::Media::Core::ImageCue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ImageCue", L"SoftwareBitmap"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SoftwareBitmap());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageCue_put_SoftwareBitmap(py::wrapper::Windows::Media::Core::ImageCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ImageCue", L"SoftwareBitmap"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(arg);

            self->obj.SoftwareBitmap(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageCue_get_Position(py::wrapper::Windows::Media::Core::ImageCue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ImageCue", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageCue_put_Position(py::wrapper::Windows::Media::Core::ImageCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ImageCue", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextPoint>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageCue_get_Extent(py::wrapper::Windows::Media::Core::ImageCue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ImageCue", L"Extent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Extent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageCue_put_Extent(py::wrapper::Windows::Media::Core::ImageCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ImageCue", L"Extent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextSize>(arg);

            self->obj.Extent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageCue_get_StartTime(py::wrapper::Windows::Media::Core::ImageCue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ImageCue", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageCue_put_StartTime(py::wrapper::Windows::Media::Core::ImageCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ImageCue", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageCue_get_Id(py::wrapper::Windows::Media::Core::ImageCue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ImageCue", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageCue_put_Id(py::wrapper::Windows::Media::Core::ImageCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ImageCue", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageCue_get_Duration(py::wrapper::Windows::Media::Core::ImageCue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ImageCue", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageCue_put_Duration(py::wrapper::Windows::Media::Core::ImageCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ImageCue", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ImageCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::ImageCue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ImageCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::ImageCue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageCue[] = {
        { "_assign_array_", _assign_array_ImageCue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageCue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageCue[] = {
        { "software_bitmap", reinterpret_cast<getter>(ImageCue_get_SoftwareBitmap), reinterpret_cast<setter>(ImageCue_put_SoftwareBitmap), nullptr, nullptr },
        { "position", reinterpret_cast<getter>(ImageCue_get_Position), reinterpret_cast<setter>(ImageCue_put_Position), nullptr, nullptr },
        { "extent", reinterpret_cast<getter>(ImageCue_get_Extent), reinterpret_cast<setter>(ImageCue_put_Extent), nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(ImageCue_get_StartTime), reinterpret_cast<setter>(ImageCue_put_StartTime), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ImageCue_get_Id), reinterpret_cast<setter>(ImageCue_put_Id), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(ImageCue_get_Duration), reinterpret_cast<setter>(ImageCue_put_Duration), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ImageCue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageCue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageCue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImageCue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageCue) },
        { },
    };

    static PyType_Spec type_spec_ImageCue =
    {
        "_winrt_windows_media_core.ImageCue",
        sizeof(py::wrapper::Windows::Media::Core::ImageCue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageCue
    };

    // ----- InitializeMediaStreamSourceRequestedEventArgs class --------------------
    static constexpr const char* const type_name_InitializeMediaStreamSourceRequestedEventArgs = "InitializeMediaStreamSourceRequestedEventArgs";

    static PyObject* _new_InitializeMediaStreamSourceRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_InitializeMediaStreamSourceRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_InitializeMediaStreamSourceRequestedEventArgs(py::wrapper::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InitializeMediaStreamSourceRequestedEventArgs_GetDeferral(py::wrapper::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.InitializeMediaStreamSourceRequestedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InitializeMediaStreamSourceRequestedEventArgs_get_RandomAccessStream(py::wrapper::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.InitializeMediaStreamSourceRequestedEventArgs", L"RandomAccessStream"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RandomAccessStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InitializeMediaStreamSourceRequestedEventArgs_get_Source(py::wrapper::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.InitializeMediaStreamSourceRequestedEventArgs", L"Source"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InitializeMediaStreamSourceRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InitializeMediaStreamSourceRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InitializeMediaStreamSourceRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(InitializeMediaStreamSourceRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_InitializeMediaStreamSourceRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InitializeMediaStreamSourceRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InitializeMediaStreamSourceRequestedEventArgs[] = {
        { "random_access_stream", reinterpret_cast<getter>(InitializeMediaStreamSourceRequestedEventArgs_get_RandomAccessStream), nullptr, nullptr, nullptr },
        { "source", reinterpret_cast<getter>(InitializeMediaStreamSourceRequestedEventArgs_get_Source), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InitializeMediaStreamSourceRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InitializeMediaStreamSourceRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InitializeMediaStreamSourceRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InitializeMediaStreamSourceRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InitializeMediaStreamSourceRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_InitializeMediaStreamSourceRequestedEventArgs =
    {
        "_winrt_windows_media_core.InitializeMediaStreamSourceRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InitializeMediaStreamSourceRequestedEventArgs
    };

    // ----- LowLightFusion class --------------------
    static constexpr const char* const type_name_LowLightFusion = "LowLightFusion";

    static PyObject* _new_LowLightFusion(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LowLightFusion);
        return nullptr;
    }

    static PyObject* LowLightFusion_FuseAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.LowLightFusion", L"FuseAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Graphics::Imaging::SoftwareBitmap>>(args, 0);

                return py::convert(winrt::Windows::Media::Core::LowLightFusion::FuseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLightFusion_get_MaxSupportedFrameCount(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.LowLightFusion", L"MaxSupportedFrameCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::LowLightFusion::MaxSupportedFrameCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LowLightFusion_get_SupportedBitmapPixelFormats(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.LowLightFusion", L"SupportedBitmapPixelFormats"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Core::LowLightFusion::SupportedBitmapPixelFormats());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LowLightFusion[] = {
        { "fuse_async", reinterpret_cast<PyCFunction>(LowLightFusion_FuseAsync), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LowLightFusion[] = {
        { }
    };

    static PyType_Slot _type_slots_LowLightFusion[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LowLightFusion) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LowLightFusion) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LowLightFusion) },
        { },
    };

    static PyType_Spec type_spec_LowLightFusion =
    {
        "_winrt_windows_media_core.LowLightFusion",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LowLightFusion
    };

    static PyGetSetDef getset_LowLightFusion_Meta[] = {
        { "max_supported_frame_count", reinterpret_cast<getter>(LowLightFusion_get_MaxSupportedFrameCount), nullptr, nullptr, nullptr },
        { "supported_bitmap_pixel_formats", reinterpret_cast<getter>(LowLightFusion_get_SupportedBitmapPixelFormats), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_LowLightFusion_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_LowLightFusion_Meta) },
        { }
    };

    static PyType_Spec type_spec_LowLightFusion_Meta =
    {
        "_winrt_windows_media_core.LowLightFusion_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_LowLightFusion_Meta
    };

    // ----- LowLightFusionResult class --------------------
    static constexpr const char* const type_name_LowLightFusionResult = "LowLightFusionResult";

    static PyObject* _new_LowLightFusionResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LowLightFusionResult);
        return nullptr;
    }

    static void _dealloc_LowLightFusionResult(py::wrapper::Windows::Media::Core::LowLightFusionResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LowLightFusionResult_Close(py::wrapper::Windows::Media::Core::LowLightFusionResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.LowLightFusionResult", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLightFusionResult_get_Frame(py::wrapper::Windows::Media::Core::LowLightFusionResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.LowLightFusionResult", L"Frame"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Frame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LowLightFusionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::LowLightFusionResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LowLightFusionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::LowLightFusionResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_LowLightFusionResult(py::wrapper::Windows::Media::Core::LowLightFusionResult* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_LowLightFusionResult(py::wrapper::Windows::Media::Core::LowLightFusionResult* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LowLightFusionResult[] = {
        { "close", reinterpret_cast<PyCFunction>(LowLightFusionResult_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LowLightFusionResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LowLightFusionResult), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_LowLightFusionResult), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_LowLightFusionResult), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_LowLightFusionResult[] = {
        { "frame", reinterpret_cast<getter>(LowLightFusionResult_get_Frame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LowLightFusionResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LowLightFusionResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LowLightFusionResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LowLightFusionResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LowLightFusionResult) },
        { },
    };

    static PyType_Spec type_spec_LowLightFusionResult =
    {
        "_winrt_windows_media_core.LowLightFusionResult",
        sizeof(py::wrapper::Windows::Media::Core::LowLightFusionResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LowLightFusionResult
    };

    // ----- MediaBinder class --------------------
    static constexpr const char* const type_name_MediaBinder = "MediaBinder";

    static PyObject* _new_MediaBinder(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::MediaBinder instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaBinder(py::wrapper::Windows::Media::Core::MediaBinder* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaBinder_get_Token(py::wrapper::Windows::Media::Core::MediaBinder* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaBinder", L"Token"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Token());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaBinder_put_Token(py::wrapper::Windows::Media::Core::MediaBinder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaBinder", L"Token"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Token(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaBinder_get_Source(py::wrapper::Windows::Media::Core::MediaBinder* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaBinder", L"Source"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBinder_add_Binding(py::wrapper::Windows::Media::Core::MediaBinder* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaBinder", L"Binding"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaBinder, winrt::Windows::Media::Core::MediaBindingEventArgs>>(arg);

            return py::convert(self->obj.Binding(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBinder_remove_Binding(py::wrapper::Windows::Media::Core::MediaBinder* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaBinder", L"Binding"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Binding(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaBinder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaBinder>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaBinder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaBinder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaBinder[] = {
        { "add_binding", reinterpret_cast<PyCFunction>(MediaBinder_add_Binding), METH_O, nullptr },
        { "remove_binding", reinterpret_cast<PyCFunction>(MediaBinder_remove_Binding), METH_O, nullptr },
        { "_assign_array_", _assign_array_MediaBinder, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaBinder), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaBinder[] = {
        { "token", reinterpret_cast<getter>(MediaBinder_get_Token), reinterpret_cast<setter>(MediaBinder_put_Token), nullptr, nullptr },
        { "source", reinterpret_cast<getter>(MediaBinder_get_Source), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaBinder[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaBinder) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaBinder) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaBinder) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaBinder) },
        { },
    };

    static PyType_Spec type_spec_MediaBinder =
    {
        "_winrt_windows_media_core.MediaBinder",
        sizeof(py::wrapper::Windows::Media::Core::MediaBinder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaBinder
    };

    // ----- MediaBindingEventArgs class --------------------
    static constexpr const char* const type_name_MediaBindingEventArgs = "MediaBindingEventArgs";

    static PyObject* _new_MediaBindingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaBindingEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaBindingEventArgs(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaBindingEventArgs_GetDeferral(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaBindingEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_SetAdaptiveMediaSource(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaBindingEventArgs", L"SetAdaptiveMediaSource", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource>(args, 0);

                self->obj.SetAdaptiveMediaSource(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_SetDownloadOperation(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaBindingEventArgs", L"SetDownloadOperation", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::DownloadOperation>(args, 0);

                self->obj.SetDownloadOperation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_SetStorageFile(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaBindingEventArgs", L"SetStorageFile", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                self->obj.SetStorageFile(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_SetStream(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaBindingEventArgs", L"SetStream", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetStream(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_SetStreamReference(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaBindingEventArgs", L"SetStreamReference", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetStreamReference(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_SetUri(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaBindingEventArgs", L"SetUri", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                self->obj.SetUri(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_get_MediaBinder(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaBindingEventArgs", L"MediaBinder"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MediaBinder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_add_Canceled(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaBindingEventArgs", L"Canceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaBindingEventArgs, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Canceled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_remove_Canceled(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaBindingEventArgs", L"Canceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Canceled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaBindingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaBindingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaBindingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaBindingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaBindingEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "set_adaptive_media_source", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_SetAdaptiveMediaSource), METH_VARARGS, nullptr },
        { "set_download_operation", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_SetDownloadOperation), METH_VARARGS, nullptr },
        { "set_storage_file", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_SetStorageFile), METH_VARARGS, nullptr },
        { "set_stream", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_SetStream), METH_VARARGS, nullptr },
        { "set_stream_reference", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_SetStreamReference), METH_VARARGS, nullptr },
        { "set_uri", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_SetUri), METH_VARARGS, nullptr },
        { "add_canceled", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_add_Canceled), METH_O, nullptr },
        { "remove_canceled", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_remove_Canceled), METH_O, nullptr },
        { "_assign_array_", _assign_array_MediaBindingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaBindingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaBindingEventArgs[] = {
        { "media_binder", reinterpret_cast<getter>(MediaBindingEventArgs_get_MediaBinder), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaBindingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaBindingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaBindingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaBindingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaBindingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaBindingEventArgs =
    {
        "_winrt_windows_media_core.MediaBindingEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaBindingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaBindingEventArgs
    };

    // ----- MediaCueEventArgs class --------------------
    static constexpr const char* const type_name_MediaCueEventArgs = "MediaCueEventArgs";

    static PyObject* _new_MediaCueEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaCueEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaCueEventArgs(py::wrapper::Windows::Media::Core::MediaCueEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaCueEventArgs_get_Cue(py::wrapper::Windows::Media::Core::MediaCueEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaCueEventArgs", L"Cue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Cue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaCueEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaCueEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaCueEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaCueEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCueEventArgs[] = {
        { "_assign_array_", _assign_array_MediaCueEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCueEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCueEventArgs[] = {
        { "cue", reinterpret_cast<getter>(MediaCueEventArgs_get_Cue), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCueEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaCueEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaCueEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaCueEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaCueEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaCueEventArgs =
    {
        "_winrt_windows_media_core.MediaCueEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaCueEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCueEventArgs
    };

    // ----- MediaSource class --------------------
    static constexpr const char* const type_name_MediaSource = "MediaSource";

    static PyObject* _new_MediaSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaSource);
        return nullptr;
    }

    static void _dealloc_MediaSource(py::wrapper::Windows::Media::Core::MediaSource* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaSource_Close(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaSource", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromAdaptiveMediaSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaSource", L"CreateFromAdaptiveMediaSource", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromAdaptiveMediaSource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromDownloadOperation(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaSource", L"CreateFromDownloadOperation", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::DownloadOperation>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromDownloadOperation(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromIMediaSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaSource", L"CreateFromIMediaSource", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaSource>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromIMediaSource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromMediaBinder(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaSource", L"CreateFromMediaBinder", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaBinder>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromMediaBinder(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromMediaFrameSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaSource", L"CreateFromMediaFrameSource", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::Frames::MediaFrameSource>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromMediaFrameSource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromMediaStreamSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaSource", L"CreateFromMediaStreamSource", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaStreamSource>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromMediaStreamSource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromMseStreamSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaSource", L"CreateFromMseStreamSource", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MseStreamSource>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromMseStreamSource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromStorageFile(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaSource", L"CreateFromStorageFile", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromStorageFile(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromStream(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaSource", L"CreateFromStream", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromStream(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromStreamReference(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaSource", L"CreateFromStreamReference", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromStreamReference(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromUri(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaSource", L"CreateFromUri", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromUri(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_OpenAsync(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaSource", L"OpenAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.OpenAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_Reset(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaSource", L"Reset", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_CustomProperties(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaSource", L"CustomProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CustomProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_Duration(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaSource", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_ExternalTimedMetadataTracks(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaSource", L"ExternalTimedMetadataTracks"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExternalTimedMetadataTracks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_ExternalTimedTextSources(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaSource", L"ExternalTimedTextSources"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExternalTimedTextSources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_IsOpen(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaSource", L"IsOpen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_State(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaSource", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_AdaptiveMediaSource(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaSource", L"AdaptiveMediaSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AdaptiveMediaSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_MediaStreamSource(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaSource", L"MediaStreamSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MediaStreamSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_MseStreamSource(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaSource", L"MseStreamSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MseStreamSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_Uri(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaSource", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_DownloadOperation(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaSource", L"DownloadOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DownloadOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_add_OpenOperationCompleted(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaSource", L"OpenOperationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaSource, winrt::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs>>(arg);

            return py::convert(self->obj.OpenOperationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_remove_OpenOperationCompleted(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaSource", L"OpenOperationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.OpenOperationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_add_StateChanged(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaSource", L"StateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaSource, winrt::Windows::Media::Core::MediaSourceStateChangedEventArgs>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_remove_StateChanged(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaSource", L"StateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MediaSource(py::wrapper::Windows::Media::Core::MediaSource* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_MediaSource(py::wrapper::Windows::Media::Core::MediaSource* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaSource[] = {
        { "close", reinterpret_cast<PyCFunction>(MediaSource_Close), METH_VARARGS, nullptr },
        { "create_from_adaptive_media_source", reinterpret_cast<PyCFunction>(MediaSource_CreateFromAdaptiveMediaSource), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_download_operation", reinterpret_cast<PyCFunction>(MediaSource_CreateFromDownloadOperation), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_i_media_source", reinterpret_cast<PyCFunction>(MediaSource_CreateFromIMediaSource), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_media_binder", reinterpret_cast<PyCFunction>(MediaSource_CreateFromMediaBinder), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_media_frame_source", reinterpret_cast<PyCFunction>(MediaSource_CreateFromMediaFrameSource), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_media_stream_source", reinterpret_cast<PyCFunction>(MediaSource_CreateFromMediaStreamSource), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_mse_stream_source", reinterpret_cast<PyCFunction>(MediaSource_CreateFromMseStreamSource), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_storage_file", reinterpret_cast<PyCFunction>(MediaSource_CreateFromStorageFile), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_stream", reinterpret_cast<PyCFunction>(MediaSource_CreateFromStream), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_stream_reference", reinterpret_cast<PyCFunction>(MediaSource_CreateFromStreamReference), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_uri", reinterpret_cast<PyCFunction>(MediaSource_CreateFromUri), METH_VARARGS | METH_STATIC, nullptr },
        { "open_async", reinterpret_cast<PyCFunction>(MediaSource_OpenAsync), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(MediaSource_Reset), METH_VARARGS, nullptr },
        { "add_open_operation_completed", reinterpret_cast<PyCFunction>(MediaSource_add_OpenOperationCompleted), METH_O, nullptr },
        { "remove_open_operation_completed", reinterpret_cast<PyCFunction>(MediaSource_remove_OpenOperationCompleted), METH_O, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(MediaSource_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(MediaSource_remove_StateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_MediaSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaSource), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MediaSource), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MediaSource), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaSource[] = {
        { "custom_properties", reinterpret_cast<getter>(MediaSource_get_CustomProperties), nullptr, nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(MediaSource_get_Duration), nullptr, nullptr, nullptr },
        { "external_timed_metadata_tracks", reinterpret_cast<getter>(MediaSource_get_ExternalTimedMetadataTracks), nullptr, nullptr, nullptr },
        { "external_timed_text_sources", reinterpret_cast<getter>(MediaSource_get_ExternalTimedTextSources), nullptr, nullptr, nullptr },
        { "is_open", reinterpret_cast<getter>(MediaSource_get_IsOpen), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(MediaSource_get_State), nullptr, nullptr, nullptr },
        { "adaptive_media_source", reinterpret_cast<getter>(MediaSource_get_AdaptiveMediaSource), nullptr, nullptr, nullptr },
        { "media_stream_source", reinterpret_cast<getter>(MediaSource_get_MediaStreamSource), nullptr, nullptr, nullptr },
        { "mse_stream_source", reinterpret_cast<getter>(MediaSource_get_MseStreamSource), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(MediaSource_get_Uri), nullptr, nullptr, nullptr },
        { "download_operation", reinterpret_cast<getter>(MediaSource_get_DownloadOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaSource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaSource) },
        { },
    };

    static PyType_Spec type_spec_MediaSource =
    {
        "_winrt_windows_media_core.MediaSource",
        sizeof(py::wrapper::Windows::Media::Core::MediaSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaSource
    };

    // ----- MediaSourceAppServiceConnection class --------------------
    static constexpr const char* const type_name_MediaSourceAppServiceConnection = "MediaSourceAppServiceConnection";

    static PyObject* _new_MediaSourceAppServiceConnection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::AppService::AppServiceConnection>(args, 0);

                winrt::Windows::Media::Core::MediaSourceAppServiceConnection instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaSourceAppServiceConnection(py::wrapper::Windows::Media::Core::MediaSourceAppServiceConnection* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaSourceAppServiceConnection_Start(py::wrapper::Windows::Media::Core::MediaSourceAppServiceConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaSourceAppServiceConnection", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAppServiceConnection_add_InitializeMediaStreamSourceRequested(py::wrapper::Windows::Media::Core::MediaSourceAppServiceConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaSourceAppServiceConnection", L"InitializeMediaStreamSourceRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaSourceAppServiceConnection, winrt::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs>>(arg);

            return py::convert(self->obj.InitializeMediaStreamSourceRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAppServiceConnection_remove_InitializeMediaStreamSourceRequested(py::wrapper::Windows::Media::Core::MediaSourceAppServiceConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaSourceAppServiceConnection", L"InitializeMediaStreamSourceRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.InitializeMediaStreamSourceRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaSourceAppServiceConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaSourceAppServiceConnection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaSourceAppServiceConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaSourceAppServiceConnection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaSourceAppServiceConnection[] = {
        { "start", reinterpret_cast<PyCFunction>(MediaSourceAppServiceConnection_Start), METH_VARARGS, nullptr },
        { "add_initialize_media_stream_source_requested", reinterpret_cast<PyCFunction>(MediaSourceAppServiceConnection_add_InitializeMediaStreamSourceRequested), METH_O, nullptr },
        { "remove_initialize_media_stream_source_requested", reinterpret_cast<PyCFunction>(MediaSourceAppServiceConnection_remove_InitializeMediaStreamSourceRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_MediaSourceAppServiceConnection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaSourceAppServiceConnection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaSourceAppServiceConnection[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaSourceAppServiceConnection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaSourceAppServiceConnection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaSourceAppServiceConnection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaSourceAppServiceConnection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaSourceAppServiceConnection) },
        { },
    };

    static PyType_Spec type_spec_MediaSourceAppServiceConnection =
    {
        "_winrt_windows_media_core.MediaSourceAppServiceConnection",
        sizeof(py::wrapper::Windows::Media::Core::MediaSourceAppServiceConnection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaSourceAppServiceConnection
    };

    // ----- MediaSourceError class --------------------
    static constexpr const char* const type_name_MediaSourceError = "MediaSourceError";

    static PyObject* _new_MediaSourceError(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaSourceError);
        return nullptr;
    }

    static void _dealloc_MediaSourceError(py::wrapper::Windows::Media::Core::MediaSourceError* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaSourceError_get_ExtendedError(py::wrapper::Windows::Media::Core::MediaSourceError* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaSourceError", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaSourceError(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaSourceError>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaSourceError(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaSourceError>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaSourceError[] = {
        { "_assign_array_", _assign_array_MediaSourceError, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaSourceError), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaSourceError[] = {
        { "extended_error", reinterpret_cast<getter>(MediaSourceError_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaSourceError[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaSourceError) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaSourceError) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaSourceError) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaSourceError) },
        { },
    };

    static PyType_Spec type_spec_MediaSourceError =
    {
        "_winrt_windows_media_core.MediaSourceError",
        sizeof(py::wrapper::Windows::Media::Core::MediaSourceError),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaSourceError
    };

    // ----- MediaSourceOpenOperationCompletedEventArgs class --------------------
    static constexpr const char* const type_name_MediaSourceOpenOperationCompletedEventArgs = "MediaSourceOpenOperationCompletedEventArgs";

    static PyObject* _new_MediaSourceOpenOperationCompletedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaSourceOpenOperationCompletedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaSourceOpenOperationCompletedEventArgs(py::wrapper::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaSourceOpenOperationCompletedEventArgs_get_Error(py::wrapper::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaSourceOpenOperationCompletedEventArgs", L"Error"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaSourceOpenOperationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaSourceOpenOperationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaSourceOpenOperationCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_MediaSourceOpenOperationCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaSourceOpenOperationCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaSourceOpenOperationCompletedEventArgs[] = {
        { "error", reinterpret_cast<getter>(MediaSourceOpenOperationCompletedEventArgs_get_Error), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaSourceOpenOperationCompletedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaSourceOpenOperationCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaSourceOpenOperationCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaSourceOpenOperationCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaSourceOpenOperationCompletedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaSourceOpenOperationCompletedEventArgs =
    {
        "_winrt_windows_media_core.MediaSourceOpenOperationCompletedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaSourceOpenOperationCompletedEventArgs
    };

    // ----- MediaSourceStateChangedEventArgs class --------------------
    static constexpr const char* const type_name_MediaSourceStateChangedEventArgs = "MediaSourceStateChangedEventArgs";

    static PyObject* _new_MediaSourceStateChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaSourceStateChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaSourceStateChangedEventArgs(py::wrapper::Windows::Media::Core::MediaSourceStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaSourceStateChangedEventArgs_get_NewState(py::wrapper::Windows::Media::Core::MediaSourceStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaSourceStateChangedEventArgs", L"NewState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NewState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceStateChangedEventArgs_get_OldState(py::wrapper::Windows::Media::Core::MediaSourceStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaSourceStateChangedEventArgs", L"OldState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OldState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaSourceStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaSourceStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaSourceStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaSourceStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaSourceStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_MediaSourceStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaSourceStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaSourceStateChangedEventArgs[] = {
        { "new_state", reinterpret_cast<getter>(MediaSourceStateChangedEventArgs_get_NewState), nullptr, nullptr, nullptr },
        { "old_state", reinterpret_cast<getter>(MediaSourceStateChangedEventArgs_get_OldState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaSourceStateChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaSourceStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaSourceStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaSourceStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaSourceStateChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaSourceStateChangedEventArgs =
    {
        "_winrt_windows_media_core.MediaSourceStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaSourceStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaSourceStateChangedEventArgs
    };

    // ----- MediaStreamSample class --------------------
    static constexpr const char* const type_name_MediaStreamSample = "MediaStreamSample";

    static PyObject* _new_MediaStreamSample(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaStreamSample);
        return nullptr;
    }

    static void _dealloc_MediaStreamSample(py::wrapper::Windows::Media::Core::MediaStreamSample* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSample_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSample", L"CreateFromBuffer", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(winrt::Windows::Media::Core::MediaStreamSample::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_CreateFromDirect3D11Surface(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSample", L"CreateFromDirect3D11Surface", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(winrt::Windows::Media::Core::MediaStreamSample::CreateFromDirect3D11Surface(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_CreateFromStreamAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSample", L"CreateFromStreamAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 2);

                return py::convert(winrt::Windows::Media::Core::MediaStreamSample::CreateFromStreamAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_get_KeyFrame(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSample", L"KeyFrame"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSample_put_KeyFrame(py::wrapper::Windows::Media::Core::MediaStreamSample* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSample", L"KeyFrame"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.KeyFrame(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSample_get_Duration(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSample", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSample_put_Duration(py::wrapper::Windows::Media::Core::MediaStreamSample* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSample", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSample_get_Discontinuous(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSample", L"Discontinuous"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Discontinuous());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSample_put_Discontinuous(py::wrapper::Windows::Media::Core::MediaStreamSample* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSample", L"Discontinuous"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Discontinuous(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSample_get_DecodeTimestamp(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSample", L"DecodeTimestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DecodeTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSample_put_DecodeTimestamp(py::wrapper::Windows::Media::Core::MediaStreamSample* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSample", L"DecodeTimestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.DecodeTimestamp(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSample_get_Buffer(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSample", L"Buffer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Buffer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_get_ExtendedProperties(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSample", L"ExtendedProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_get_Protection(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSample", L"Protection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Protection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_get_Timestamp(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSample", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_get_Direct3D11Surface(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSample", L"Direct3D11Surface"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Direct3D11Surface());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_add_Processed(py::wrapper::Windows::Media::Core::MediaStreamSample* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaStreamSample", L"Processed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSample, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Processed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_remove_Processed(py::wrapper::Windows::Media::Core::MediaStreamSample* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaStreamSample", L"Processed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Processed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaStreamSample(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaStreamSample>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaStreamSample(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSample>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSample[] = {
        { "create_from_buffer", reinterpret_cast<PyCFunction>(MediaStreamSample_CreateFromBuffer), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_direct3_d11_surface", reinterpret_cast<PyCFunction>(MediaStreamSample_CreateFromDirect3D11Surface), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_stream_async", reinterpret_cast<PyCFunction>(MediaStreamSample_CreateFromStreamAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "add_processed", reinterpret_cast<PyCFunction>(MediaStreamSample_add_Processed), METH_O, nullptr },
        { "remove_processed", reinterpret_cast<PyCFunction>(MediaStreamSample_remove_Processed), METH_O, nullptr },
        { "_assign_array_", _assign_array_MediaStreamSample, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSample), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSample[] = {
        { "key_frame", reinterpret_cast<getter>(MediaStreamSample_get_KeyFrame), reinterpret_cast<setter>(MediaStreamSample_put_KeyFrame), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(MediaStreamSample_get_Duration), reinterpret_cast<setter>(MediaStreamSample_put_Duration), nullptr, nullptr },
        { "discontinuous", reinterpret_cast<getter>(MediaStreamSample_get_Discontinuous), reinterpret_cast<setter>(MediaStreamSample_put_Discontinuous), nullptr, nullptr },
        { "decode_timestamp", reinterpret_cast<getter>(MediaStreamSample_get_DecodeTimestamp), reinterpret_cast<setter>(MediaStreamSample_put_DecodeTimestamp), nullptr, nullptr },
        { "buffer", reinterpret_cast<getter>(MediaStreamSample_get_Buffer), nullptr, nullptr, nullptr },
        { "extended_properties", reinterpret_cast<getter>(MediaStreamSample_get_ExtendedProperties), nullptr, nullptr, nullptr },
        { "protection", reinterpret_cast<getter>(MediaStreamSample_get_Protection), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MediaStreamSample_get_Timestamp), nullptr, nullptr, nullptr },
        { "direct3_d11_surface", reinterpret_cast<getter>(MediaStreamSample_get_Direct3D11Surface), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSample[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaStreamSample) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaStreamSample) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaStreamSample) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaStreamSample) },
        { },
    };

    static PyType_Spec type_spec_MediaStreamSample =
    {
        "_winrt_windows_media_core.MediaStreamSample",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSample),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSample
    };

    // ----- MediaStreamSamplePropertySet class --------------------
    static constexpr const char* const type_name_MediaStreamSamplePropertySet = "MediaStreamSamplePropertySet";

    static PyObject* _new_MediaStreamSamplePropertySet(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaStreamSamplePropertySet);
        return nullptr;
    }

    static void _dealloc_MediaStreamSamplePropertySet(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSamplePropertySet_Clear(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSamplePropertySet", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_First(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSamplePropertySet", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_GetView(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSamplePropertySet", L"GetView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_HasKey(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSamplePropertySet", L"HasKey", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_Insert(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSamplePropertySet", L"Insert", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Insert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_Lookup(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSamplePropertySet", L"Lookup", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_Remove(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSamplePropertySet", L"Remove", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_get_Size(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSamplePropertySet", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaStreamSamplePropertySet(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaStreamSamplePropertySet>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaStreamSamplePropertySet(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSamplePropertySet>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_MediaStreamSamplePropertySet(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self) noexcept
    {
        try
        {
            py::pyobj_handle iter{py::convert(self->obj.First())};
            return py::wrap_mapping_iter(iter.get());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_contains_MediaStreamSamplePropertySet(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* key) noexcept
    {
        try
        {
            return static_cast<int>(self->obj.HasKey(py::convert_to<winrt::guid>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static Py_ssize_t _map_length_MediaStreamSamplePropertySet(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_MediaStreamSamplePropertySet(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* key) noexcept
    {
        try
        {
            auto value = self->obj.TryLookup(py::convert_to<winrt::guid>(key));

            if (!value) {
                PyErr_SetObject(PyExc_KeyError, key);
                return nullptr;
            }

            return py::convert(value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_MediaStreamSamplePropertySet(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::guid>(key);

            if (value == nullptr) {
                if (!self->obj.TryRemove(_key)) {
                    PyErr_SetObject(PyExc_KeyError, key);
                    return -1;
                }

                return 0;
            }

            self->obj.Insert(_key, py::convert_to<winrt::Windows::Foundation::IInspectable>(value));

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_MediaStreamSamplePropertySet[] = {
        { "clear", reinterpret_cast<PyCFunction>(MediaStreamSamplePropertySet_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(MediaStreamSamplePropertySet_First), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(MediaStreamSamplePropertySet_GetView), METH_VARARGS, nullptr },
        { "has_key", reinterpret_cast<PyCFunction>(MediaStreamSamplePropertySet_HasKey), METH_VARARGS, nullptr },
        { "insert", reinterpret_cast<PyCFunction>(MediaStreamSamplePropertySet_Insert), METH_VARARGS, nullptr },
        { "lookup", reinterpret_cast<PyCFunction>(MediaStreamSamplePropertySet_Lookup), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(MediaStreamSamplePropertySet_Remove), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaStreamSamplePropertySet, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSamplePropertySet), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSamplePropertySet[] = {
        { "size", reinterpret_cast<getter>(MediaStreamSamplePropertySet_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSamplePropertySet[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaStreamSamplePropertySet) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaStreamSamplePropertySet) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaStreamSamplePropertySet) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaStreamSamplePropertySet) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_MediaStreamSamplePropertySet) },
        { Py_sq_contains, reinterpret_cast<void*>(_map_contains_MediaStreamSamplePropertySet) },
        { Py_mp_length, reinterpret_cast<void*>(_map_length_MediaStreamSamplePropertySet) },
        { Py_mp_subscript, reinterpret_cast<void*>(_map_subscript_MediaStreamSamplePropertySet) },
        { Py_mp_ass_subscript, reinterpret_cast<void*>(_map_assign_MediaStreamSamplePropertySet) },
        { },
    };

    static PyType_Spec type_spec_MediaStreamSamplePropertySet =
    {
        "_winrt_windows_media_core.MediaStreamSamplePropertySet",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSamplePropertySet
    };

    // ----- MediaStreamSampleProtectionProperties class --------------------
    static constexpr const char* const type_name_MediaStreamSampleProtectionProperties = "MediaStreamSampleProtectionProperties";

    static PyObject* _new_MediaStreamSampleProtectionProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaStreamSampleProtectionProperties);
        return nullptr;
    }

    static void _dealloc_MediaStreamSampleProtectionProperties(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSampleProtectionProperties_GetInitializationVector(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSampleProtectionProperties", L"GetInitializationVector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::com_array<uint8_t> param0 { };

                self->obj.GetInitializationVector(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSampleProtectionProperties_GetKeyIdentifier(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSampleProtectionProperties", L"GetKeyIdentifier", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::com_array<uint8_t> param0 { };

                self->obj.GetKeyIdentifier(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSampleProtectionProperties_GetSubSampleMapping(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSampleProtectionProperties", L"GetSubSampleMapping", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::com_array<uint8_t> param0 { };

                self->obj.GetSubSampleMapping(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSampleProtectionProperties_SetInitializationVector(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSampleProtectionProperties", L"SetInitializationVector", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                self->obj.SetInitializationVector(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSampleProtectionProperties_SetKeyIdentifier(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSampleProtectionProperties", L"SetKeyIdentifier", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                self->obj.SetKeyIdentifier(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSampleProtectionProperties_SetSubSampleMapping(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSampleProtectionProperties", L"SetSubSampleMapping", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                self->obj.SetSubSampleMapping(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaStreamSampleProtectionProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaStreamSampleProtectionProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaStreamSampleProtectionProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSampleProtectionProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSampleProtectionProperties[] = {
        { "get_initialization_vector", reinterpret_cast<PyCFunction>(MediaStreamSampleProtectionProperties_GetInitializationVector), METH_VARARGS, nullptr },
        { "get_key_identifier", reinterpret_cast<PyCFunction>(MediaStreamSampleProtectionProperties_GetKeyIdentifier), METH_VARARGS, nullptr },
        { "get_sub_sample_mapping", reinterpret_cast<PyCFunction>(MediaStreamSampleProtectionProperties_GetSubSampleMapping), METH_VARARGS, nullptr },
        { "set_initialization_vector", reinterpret_cast<PyCFunction>(MediaStreamSampleProtectionProperties_SetInitializationVector), METH_VARARGS, nullptr },
        { "set_key_identifier", reinterpret_cast<PyCFunction>(MediaStreamSampleProtectionProperties_SetKeyIdentifier), METH_VARARGS, nullptr },
        { "set_sub_sample_mapping", reinterpret_cast<PyCFunction>(MediaStreamSampleProtectionProperties_SetSubSampleMapping), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaStreamSampleProtectionProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSampleProtectionProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSampleProtectionProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSampleProtectionProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaStreamSampleProtectionProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaStreamSampleProtectionProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaStreamSampleProtectionProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaStreamSampleProtectionProperties) },
        { },
    };

    static PyType_Spec type_spec_MediaStreamSampleProtectionProperties =
    {
        "_winrt_windows_media_core.MediaStreamSampleProtectionProperties",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSampleProtectionProperties
    };

    // ----- MediaStreamSource class --------------------
    static constexpr const char* const type_name_MediaStreamSource = "MediaStreamSource";

    static PyObject* _new_MediaStreamSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 0);

                winrt::Windows::Media::Core::MediaStreamSource instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 1);

                winrt::Windows::Media::Core::MediaStreamSource instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaStreamSource(py::wrapper::Windows::Media::Core::MediaStreamSource* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSource_AddProtectionKey(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSource", L"AddProtectionKey", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 2);

                self->obj.AddProtectionKey(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_AddStreamDescriptor(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSource", L"AddStreamDescriptor", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 0);

                self->obj.AddStreamDescriptor(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_NotifyError(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSource", L"NotifyError", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaStreamSourceErrorStatus>(args, 0);

                self->obj.NotifyError(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_SetBufferedRange(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSource", L"SetBufferedRange", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                self->obj.SetBufferedRange(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_get_Thumbnail(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSource", L"Thumbnail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_Thumbnail(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSource", L"Thumbnail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.Thumbnail(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_get_MediaProtectionManager(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSource", L"MediaProtectionManager"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MediaProtectionManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_MediaProtectionManager(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSource", L"MediaProtectionManager"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Protection::MediaProtectionManager>(arg);

            self->obj.MediaProtectionManager(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_get_Duration(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSource", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_Duration(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSource", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_get_CanSeek(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSource", L"CanSeek"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanSeek());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_CanSeek(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSource", L"CanSeek"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanSeek(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_get_BufferTime(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSource", L"BufferTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BufferTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_BufferTime(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSource", L"BufferTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.BufferTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_get_MusicProperties(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSource", L"MusicProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MusicProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_get_VideoProperties(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSource", L"VideoProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_get_MaxSupportedPlaybackRate(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSource", L"MaxSupportedPlaybackRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxSupportedPlaybackRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_MaxSupportedPlaybackRate(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSource", L"MaxSupportedPlaybackRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<double>>(arg);

            self->obj.MaxSupportedPlaybackRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_get_IsLive(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSource", L"IsLive"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsLive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_IsLive(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSource", L"IsLive"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLive(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_add_Closed(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaStreamSource", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSource, winrt::Windows::Media::Core::MediaStreamSourceClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_remove_Closed(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaStreamSource", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_add_Paused(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaStreamSource", L"Paused"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Paused(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_remove_Paused(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaStreamSource", L"Paused"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Paused(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_add_SampleRequested(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaStreamSource", L"SampleRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSource, winrt::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs>>(arg);

            return py::convert(self->obj.SampleRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_remove_SampleRequested(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaStreamSource", L"SampleRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SampleRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_add_Starting(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaStreamSource", L"Starting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSource, winrt::Windows::Media::Core::MediaStreamSourceStartingEventArgs>>(arg);

            return py::convert(self->obj.Starting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_remove_Starting(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaStreamSource", L"Starting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Starting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_add_SwitchStreamsRequested(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaStreamSource", L"SwitchStreamsRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSource, winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs>>(arg);

            return py::convert(self->obj.SwitchStreamsRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_remove_SwitchStreamsRequested(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaStreamSource", L"SwitchStreamsRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SwitchStreamsRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_add_SampleRendered(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaStreamSource", L"SampleRendered"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSource, winrt::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs>>(arg);

            return py::convert(self->obj.SampleRendered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_remove_SampleRendered(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaStreamSource", L"SampleRendered"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SampleRendered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaStreamSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaStreamSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaStreamSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSource[] = {
        { "add_protection_key", reinterpret_cast<PyCFunction>(MediaStreamSource_AddProtectionKey), METH_VARARGS, nullptr },
        { "add_stream_descriptor", reinterpret_cast<PyCFunction>(MediaStreamSource_AddStreamDescriptor), METH_VARARGS, nullptr },
        { "notify_error", reinterpret_cast<PyCFunction>(MediaStreamSource_NotifyError), METH_VARARGS, nullptr },
        { "set_buffered_range", reinterpret_cast<PyCFunction>(MediaStreamSource_SetBufferedRange), METH_VARARGS, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(MediaStreamSource_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(MediaStreamSource_remove_Closed), METH_O, nullptr },
        { "add_paused", reinterpret_cast<PyCFunction>(MediaStreamSource_add_Paused), METH_O, nullptr },
        { "remove_paused", reinterpret_cast<PyCFunction>(MediaStreamSource_remove_Paused), METH_O, nullptr },
        { "add_sample_requested", reinterpret_cast<PyCFunction>(MediaStreamSource_add_SampleRequested), METH_O, nullptr },
        { "remove_sample_requested", reinterpret_cast<PyCFunction>(MediaStreamSource_remove_SampleRequested), METH_O, nullptr },
        { "add_starting", reinterpret_cast<PyCFunction>(MediaStreamSource_add_Starting), METH_O, nullptr },
        { "remove_starting", reinterpret_cast<PyCFunction>(MediaStreamSource_remove_Starting), METH_O, nullptr },
        { "add_switch_streams_requested", reinterpret_cast<PyCFunction>(MediaStreamSource_add_SwitchStreamsRequested), METH_O, nullptr },
        { "remove_switch_streams_requested", reinterpret_cast<PyCFunction>(MediaStreamSource_remove_SwitchStreamsRequested), METH_O, nullptr },
        { "add_sample_rendered", reinterpret_cast<PyCFunction>(MediaStreamSource_add_SampleRendered), METH_O, nullptr },
        { "remove_sample_rendered", reinterpret_cast<PyCFunction>(MediaStreamSource_remove_SampleRendered), METH_O, nullptr },
        { "_assign_array_", _assign_array_MediaStreamSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSource[] = {
        { "thumbnail", reinterpret_cast<getter>(MediaStreamSource_get_Thumbnail), reinterpret_cast<setter>(MediaStreamSource_put_Thumbnail), nullptr, nullptr },
        { "media_protection_manager", reinterpret_cast<getter>(MediaStreamSource_get_MediaProtectionManager), reinterpret_cast<setter>(MediaStreamSource_put_MediaProtectionManager), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(MediaStreamSource_get_Duration), reinterpret_cast<setter>(MediaStreamSource_put_Duration), nullptr, nullptr },
        { "can_seek", reinterpret_cast<getter>(MediaStreamSource_get_CanSeek), reinterpret_cast<setter>(MediaStreamSource_put_CanSeek), nullptr, nullptr },
        { "buffer_time", reinterpret_cast<getter>(MediaStreamSource_get_BufferTime), reinterpret_cast<setter>(MediaStreamSource_put_BufferTime), nullptr, nullptr },
        { "music_properties", reinterpret_cast<getter>(MediaStreamSource_get_MusicProperties), nullptr, nullptr, nullptr },
        { "video_properties", reinterpret_cast<getter>(MediaStreamSource_get_VideoProperties), nullptr, nullptr, nullptr },
        { "max_supported_playback_rate", reinterpret_cast<getter>(MediaStreamSource_get_MaxSupportedPlaybackRate), reinterpret_cast<setter>(MediaStreamSource_put_MaxSupportedPlaybackRate), nullptr, nullptr },
        { "is_live", reinterpret_cast<getter>(MediaStreamSource_get_IsLive), reinterpret_cast<setter>(MediaStreamSource_put_IsLive), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaStreamSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaStreamSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaStreamSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaStreamSource) },
        { },
    };

    static PyType_Spec type_spec_MediaStreamSource =
    {
        "_winrt_windows_media_core.MediaStreamSource",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSource
    };

    // ----- MediaStreamSourceClosedEventArgs class --------------------
    static constexpr const char* const type_name_MediaStreamSourceClosedEventArgs = "MediaStreamSourceClosedEventArgs";

    static PyObject* _new_MediaStreamSourceClosedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaStreamSourceClosedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceClosedEventArgs(py::wrapper::Windows::Media::Core::MediaStreamSourceClosedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceClosedEventArgs_get_Request(py::wrapper::Windows::Media::Core::MediaStreamSourceClosedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSourceClosedEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaStreamSourceClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaStreamSourceClosedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaStreamSourceClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceClosedEventArgs[] = {
        { "_assign_array_", _assign_array_MediaStreamSourceClosedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceClosedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceClosedEventArgs[] = {
        { "request", reinterpret_cast<getter>(MediaStreamSourceClosedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceClosedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaStreamSourceClosedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaStreamSourceClosedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaStreamSourceClosedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaStreamSourceClosedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaStreamSourceClosedEventArgs =
    {
        "_winrt_windows_media_core.MediaStreamSourceClosedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceClosedEventArgs
    };

    // ----- MediaStreamSourceClosedRequest class --------------------
    static constexpr const char* const type_name_MediaStreamSourceClosedRequest = "MediaStreamSourceClosedRequest";

    static PyObject* _new_MediaStreamSourceClosedRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaStreamSourceClosedRequest);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceClosedRequest(py::wrapper::Windows::Media::Core::MediaStreamSourceClosedRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceClosedRequest_get_Reason(py::wrapper::Windows::Media::Core::MediaStreamSourceClosedRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSourceClosedRequest", L"Reason"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaStreamSourceClosedRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaStreamSourceClosedRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaStreamSourceClosedRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceClosedRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceClosedRequest[] = {
        { "_assign_array_", _assign_array_MediaStreamSourceClosedRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceClosedRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceClosedRequest[] = {
        { "reason", reinterpret_cast<getter>(MediaStreamSourceClosedRequest_get_Reason), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceClosedRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaStreamSourceClosedRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaStreamSourceClosedRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaStreamSourceClosedRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaStreamSourceClosedRequest) },
        { },
    };

    static PyType_Spec type_spec_MediaStreamSourceClosedRequest =
    {
        "_winrt_windows_media_core.MediaStreamSourceClosedRequest",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceClosedRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceClosedRequest
    };

    // ----- MediaStreamSourceSampleRenderedEventArgs class --------------------
    static constexpr const char* const type_name_MediaStreamSourceSampleRenderedEventArgs = "MediaStreamSourceSampleRenderedEventArgs";

    static PyObject* _new_MediaStreamSourceSampleRenderedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaStreamSourceSampleRenderedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSampleRenderedEventArgs(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceSampleRenderedEventArgs_get_SampleLag(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSourceSampleRenderedEventArgs", L"SampleLag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SampleLag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaStreamSourceSampleRenderedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaStreamSourceSampleRenderedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSampleRenderedEventArgs[] = {
        { "_assign_array_", _assign_array_MediaStreamSourceSampleRenderedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceSampleRenderedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceSampleRenderedEventArgs[] = {
        { "sample_lag", reinterpret_cast<getter>(MediaStreamSourceSampleRenderedEventArgs_get_SampleLag), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSampleRenderedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaStreamSourceSampleRenderedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaStreamSourceSampleRenderedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaStreamSourceSampleRenderedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaStreamSourceSampleRenderedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaStreamSourceSampleRenderedEventArgs =
    {
        "_winrt_windows_media_core.MediaStreamSourceSampleRenderedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSampleRenderedEventArgs
    };

    // ----- MediaStreamSourceSampleRequest class --------------------
    static constexpr const char* const type_name_MediaStreamSourceSampleRequest = "MediaStreamSourceSampleRequest";

    static PyObject* _new_MediaStreamSourceSampleRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaStreamSourceSampleRequest);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSampleRequest(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceSampleRequest_GetDeferral(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSourceSampleRequest", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSourceSampleRequest_ReportSampleProgress(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSourceSampleRequest", L"ReportSampleProgress", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.ReportSampleProgress(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSourceSampleRequest_get_Sample(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSourceSampleRequest", L"Sample"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Sample());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSourceSampleRequest_put_Sample(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSourceSampleRequest", L"Sample"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaStreamSample>(arg);

            self->obj.Sample(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSourceSampleRequest_get_StreamDescriptor(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSourceSampleRequest", L"StreamDescriptor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StreamDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaStreamSourceSampleRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaStreamSourceSampleRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaStreamSourceSampleRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSampleRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSampleRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MediaStreamSourceSampleRequest_GetDeferral), METH_VARARGS, nullptr },
        { "report_sample_progress", reinterpret_cast<PyCFunction>(MediaStreamSourceSampleRequest_ReportSampleProgress), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaStreamSourceSampleRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceSampleRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceSampleRequest[] = {
        { "sample", reinterpret_cast<getter>(MediaStreamSourceSampleRequest_get_Sample), reinterpret_cast<setter>(MediaStreamSourceSampleRequest_put_Sample), nullptr, nullptr },
        { "stream_descriptor", reinterpret_cast<getter>(MediaStreamSourceSampleRequest_get_StreamDescriptor), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSampleRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaStreamSourceSampleRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaStreamSourceSampleRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaStreamSourceSampleRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaStreamSourceSampleRequest) },
        { },
    };

    static PyType_Spec type_spec_MediaStreamSourceSampleRequest =
    {
        "_winrt_windows_media_core.MediaStreamSourceSampleRequest",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSampleRequest
    };

    // ----- MediaStreamSourceSampleRequestDeferral class --------------------
    static constexpr const char* const type_name_MediaStreamSourceSampleRequestDeferral = "MediaStreamSourceSampleRequestDeferral";

    static PyObject* _new_MediaStreamSourceSampleRequestDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaStreamSourceSampleRequestDeferral);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSampleRequestDeferral(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequestDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceSampleRequestDeferral_Complete(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequestDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSourceSampleRequestDeferral", L"Complete", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaStreamSourceSampleRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaStreamSourceSampleRequestDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaStreamSourceSampleRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSampleRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSampleRequestDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(MediaStreamSourceSampleRequestDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaStreamSourceSampleRequestDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceSampleRequestDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceSampleRequestDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSampleRequestDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaStreamSourceSampleRequestDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaStreamSourceSampleRequestDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaStreamSourceSampleRequestDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaStreamSourceSampleRequestDeferral) },
        { },
    };

    static PyType_Spec type_spec_MediaStreamSourceSampleRequestDeferral =
    {
        "_winrt_windows_media_core.MediaStreamSourceSampleRequestDeferral",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSampleRequestDeferral
    };

    // ----- MediaStreamSourceSampleRequestedEventArgs class --------------------
    static constexpr const char* const type_name_MediaStreamSourceSampleRequestedEventArgs = "MediaStreamSourceSampleRequestedEventArgs";

    static PyObject* _new_MediaStreamSourceSampleRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaStreamSourceSampleRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSampleRequestedEventArgs(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceSampleRequestedEventArgs_get_Request(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSourceSampleRequestedEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaStreamSourceSampleRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaStreamSourceSampleRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSampleRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_MediaStreamSourceSampleRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceSampleRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceSampleRequestedEventArgs[] = {
        { "request", reinterpret_cast<getter>(MediaStreamSourceSampleRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSampleRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaStreamSourceSampleRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaStreamSourceSampleRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaStreamSourceSampleRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaStreamSourceSampleRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaStreamSourceSampleRequestedEventArgs =
    {
        "_winrt_windows_media_core.MediaStreamSourceSampleRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSampleRequestedEventArgs
    };

    // ----- MediaStreamSourceStartingEventArgs class --------------------
    static constexpr const char* const type_name_MediaStreamSourceStartingEventArgs = "MediaStreamSourceStartingEventArgs";

    static PyObject* _new_MediaStreamSourceStartingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaStreamSourceStartingEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceStartingEventArgs(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceStartingEventArgs_get_Request(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSourceStartingEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaStreamSourceStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaStreamSourceStartingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaStreamSourceStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceStartingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceStartingEventArgs[] = {
        { "_assign_array_", _assign_array_MediaStreamSourceStartingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceStartingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceStartingEventArgs[] = {
        { "request", reinterpret_cast<getter>(MediaStreamSourceStartingEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceStartingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaStreamSourceStartingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaStreamSourceStartingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaStreamSourceStartingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaStreamSourceStartingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaStreamSourceStartingEventArgs =
    {
        "_winrt_windows_media_core.MediaStreamSourceStartingEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceStartingEventArgs
    };

    // ----- MediaStreamSourceStartingRequest class --------------------
    static constexpr const char* const type_name_MediaStreamSourceStartingRequest = "MediaStreamSourceStartingRequest";

    static PyObject* _new_MediaStreamSourceStartingRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaStreamSourceStartingRequest);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceStartingRequest(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceStartingRequest_GetDeferral(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSourceStartingRequest", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSourceStartingRequest_SetActualStartPosition(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSourceStartingRequest", L"SetActualStartPosition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                self->obj.SetActualStartPosition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSourceStartingRequest_get_StartPosition(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSourceStartingRequest", L"StartPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaStreamSourceStartingRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaStreamSourceStartingRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaStreamSourceStartingRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceStartingRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceStartingRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MediaStreamSourceStartingRequest_GetDeferral), METH_VARARGS, nullptr },
        { "set_actual_start_position", reinterpret_cast<PyCFunction>(MediaStreamSourceStartingRequest_SetActualStartPosition), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaStreamSourceStartingRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceStartingRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceStartingRequest[] = {
        { "start_position", reinterpret_cast<getter>(MediaStreamSourceStartingRequest_get_StartPosition), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceStartingRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaStreamSourceStartingRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaStreamSourceStartingRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaStreamSourceStartingRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaStreamSourceStartingRequest) },
        { },
    };

    static PyType_Spec type_spec_MediaStreamSourceStartingRequest =
    {
        "_winrt_windows_media_core.MediaStreamSourceStartingRequest",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceStartingRequest
    };

    // ----- MediaStreamSourceStartingRequestDeferral class --------------------
    static constexpr const char* const type_name_MediaStreamSourceStartingRequestDeferral = "MediaStreamSourceStartingRequestDeferral";

    static PyObject* _new_MediaStreamSourceStartingRequestDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaStreamSourceStartingRequestDeferral);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceStartingRequestDeferral(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequestDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceStartingRequestDeferral_Complete(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequestDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSourceStartingRequestDeferral", L"Complete", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaStreamSourceStartingRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaStreamSourceStartingRequestDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaStreamSourceStartingRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceStartingRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceStartingRequestDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(MediaStreamSourceStartingRequestDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaStreamSourceStartingRequestDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceStartingRequestDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceStartingRequestDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceStartingRequestDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaStreamSourceStartingRequestDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaStreamSourceStartingRequestDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaStreamSourceStartingRequestDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaStreamSourceStartingRequestDeferral) },
        { },
    };

    static PyType_Spec type_spec_MediaStreamSourceStartingRequestDeferral =
    {
        "_winrt_windows_media_core.MediaStreamSourceStartingRequestDeferral",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceStartingRequestDeferral
    };

    // ----- MediaStreamSourceSwitchStreamsRequest class --------------------
    static constexpr const char* const type_name_MediaStreamSourceSwitchStreamsRequest = "MediaStreamSourceSwitchStreamsRequest";

    static PyObject* _new_MediaStreamSourceSwitchStreamsRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaStreamSourceSwitchStreamsRequest);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSwitchStreamsRequest(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceSwitchStreamsRequest_GetDeferral(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSourceSwitchStreamsRequest", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSourceSwitchStreamsRequest_get_NewStreamDescriptor(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSourceSwitchStreamsRequest", L"NewStreamDescriptor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NewStreamDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSourceSwitchStreamsRequest_get_OldStreamDescriptor(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSourceSwitchStreamsRequest", L"OldStreamDescriptor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OldStreamDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaStreamSourceSwitchStreamsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaStreamSourceSwitchStreamsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSwitchStreamsRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MediaStreamSourceSwitchStreamsRequest_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaStreamSourceSwitchStreamsRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceSwitchStreamsRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceSwitchStreamsRequest[] = {
        { "new_stream_descriptor", reinterpret_cast<getter>(MediaStreamSourceSwitchStreamsRequest_get_NewStreamDescriptor), nullptr, nullptr, nullptr },
        { "old_stream_descriptor", reinterpret_cast<getter>(MediaStreamSourceSwitchStreamsRequest_get_OldStreamDescriptor), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSwitchStreamsRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaStreamSourceSwitchStreamsRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaStreamSourceSwitchStreamsRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaStreamSourceSwitchStreamsRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaStreamSourceSwitchStreamsRequest) },
        { },
    };

    static PyType_Spec type_spec_MediaStreamSourceSwitchStreamsRequest =
    {
        "_winrt_windows_media_core.MediaStreamSourceSwitchStreamsRequest",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSwitchStreamsRequest
    };

    // ----- MediaStreamSourceSwitchStreamsRequestDeferral class --------------------
    static constexpr const char* const type_name_MediaStreamSourceSwitchStreamsRequestDeferral = "MediaStreamSourceSwitchStreamsRequestDeferral";

    static PyObject* _new_MediaStreamSourceSwitchStreamsRequestDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaStreamSourceSwitchStreamsRequestDeferral);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSwitchStreamsRequestDeferral(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceSwitchStreamsRequestDeferral_Complete(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSourceSwitchStreamsRequestDeferral", L"Complete", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaStreamSourceSwitchStreamsRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaStreamSourceSwitchStreamsRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSwitchStreamsRequestDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(MediaStreamSourceSwitchStreamsRequestDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaStreamSourceSwitchStreamsRequestDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceSwitchStreamsRequestDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceSwitchStreamsRequestDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSwitchStreamsRequestDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaStreamSourceSwitchStreamsRequestDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaStreamSourceSwitchStreamsRequestDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaStreamSourceSwitchStreamsRequestDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaStreamSourceSwitchStreamsRequestDeferral) },
        { },
    };

    static PyType_Spec type_spec_MediaStreamSourceSwitchStreamsRequestDeferral =
    {
        "_winrt_windows_media_core.MediaStreamSourceSwitchStreamsRequestDeferral",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSwitchStreamsRequestDeferral
    };

    // ----- MediaStreamSourceSwitchStreamsRequestedEventArgs class --------------------
    static constexpr const char* const type_name_MediaStreamSourceSwitchStreamsRequestedEventArgs = "MediaStreamSourceSwitchStreamsRequestedEventArgs";

    static PyObject* _new_MediaStreamSourceSwitchStreamsRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaStreamSourceSwitchStreamsRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSwitchStreamsRequestedEventArgs(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceSwitchStreamsRequestedEventArgs_get_Request(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSourceSwitchStreamsRequestedEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaStreamSourceSwitchStreamsRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaStreamSourceSwitchStreamsRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSwitchStreamsRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_MediaStreamSourceSwitchStreamsRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceSwitchStreamsRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceSwitchStreamsRequestedEventArgs[] = {
        { "request", reinterpret_cast<getter>(MediaStreamSourceSwitchStreamsRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSwitchStreamsRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaStreamSourceSwitchStreamsRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaStreamSourceSwitchStreamsRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaStreamSourceSwitchStreamsRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaStreamSourceSwitchStreamsRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaStreamSourceSwitchStreamsRequestedEventArgs =
    {
        "_winrt_windows_media_core.MediaStreamSourceSwitchStreamsRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSwitchStreamsRequestedEventArgs
    };

    // ----- MseSourceBuffer class --------------------
    static constexpr const char* const type_name_MseSourceBuffer = "MseSourceBuffer";

    static PyObject* _new_MseSourceBuffer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MseSourceBuffer);
        return nullptr;
    }

    static void _dealloc_MseSourceBuffer(py::wrapper::Windows::Media::Core::MseSourceBuffer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MseSourceBuffer_Abort(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MseSourceBuffer", L"Abort", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Abort();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_AppendBuffer(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MseSourceBuffer", L"AppendBuffer", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.AppendBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_AppendStream(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MseSourceBuffer", L"AppendStream", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                self->obj.AppendStream(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MseSourceBuffer", L"AppendStream", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);
                auto param1 = py::convert_to<uint64_t>(args, 1);

                self->obj.AppendStream(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_Remove(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MseSourceBuffer", L"Remove", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(args, 1);

                self->obj.Remove(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_get_TimestampOffset(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseSourceBuffer", L"TimestampOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimestampOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseSourceBuffer_put_TimestampOffset(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseSourceBuffer", L"TimestampOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.TimestampOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseSourceBuffer_get_Mode(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseSourceBuffer", L"Mode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseSourceBuffer_put_Mode(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseSourceBuffer", L"Mode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::MseAppendMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseSourceBuffer_get_AppendWindowStart(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseSourceBuffer", L"AppendWindowStart"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppendWindowStart());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseSourceBuffer_put_AppendWindowStart(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseSourceBuffer", L"AppendWindowStart"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.AppendWindowStart(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseSourceBuffer_get_AppendWindowEnd(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseSourceBuffer", L"AppendWindowEnd"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppendWindowEnd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseSourceBuffer_put_AppendWindowEnd(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseSourceBuffer", L"AppendWindowEnd"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.AppendWindowEnd(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseSourceBuffer_get_Buffered(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseSourceBuffer", L"Buffered"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Buffered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_get_IsUpdating(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseSourceBuffer", L"IsUpdating"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsUpdating());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_add_Aborted(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseSourceBuffer", L"Aborted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBuffer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Aborted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_remove_Aborted(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseSourceBuffer", L"Aborted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Aborted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_add_ErrorOccurred(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseSourceBuffer", L"ErrorOccurred"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBuffer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ErrorOccurred(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_remove_ErrorOccurred(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseSourceBuffer", L"ErrorOccurred"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ErrorOccurred(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_add_UpdateEnded(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseSourceBuffer", L"UpdateEnded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBuffer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.UpdateEnded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_remove_UpdateEnded(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseSourceBuffer", L"UpdateEnded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UpdateEnded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_add_UpdateStarting(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseSourceBuffer", L"UpdateStarting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBuffer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.UpdateStarting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_remove_UpdateStarting(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseSourceBuffer", L"UpdateStarting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UpdateStarting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_add_Updated(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseSourceBuffer", L"Updated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBuffer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Updated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_remove_Updated(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseSourceBuffer", L"Updated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Updated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MseSourceBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MseSourceBuffer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MseSourceBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MseSourceBuffer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MseSourceBuffer[] = {
        { "abort", reinterpret_cast<PyCFunction>(MseSourceBuffer_Abort), METH_VARARGS, nullptr },
        { "append_buffer", reinterpret_cast<PyCFunction>(MseSourceBuffer_AppendBuffer), METH_VARARGS, nullptr },
        { "append_stream", reinterpret_cast<PyCFunction>(MseSourceBuffer_AppendStream), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(MseSourceBuffer_Remove), METH_VARARGS, nullptr },
        { "add_aborted", reinterpret_cast<PyCFunction>(MseSourceBuffer_add_Aborted), METH_O, nullptr },
        { "remove_aborted", reinterpret_cast<PyCFunction>(MseSourceBuffer_remove_Aborted), METH_O, nullptr },
        { "add_error_occurred", reinterpret_cast<PyCFunction>(MseSourceBuffer_add_ErrorOccurred), METH_O, nullptr },
        { "remove_error_occurred", reinterpret_cast<PyCFunction>(MseSourceBuffer_remove_ErrorOccurred), METH_O, nullptr },
        { "add_update_ended", reinterpret_cast<PyCFunction>(MseSourceBuffer_add_UpdateEnded), METH_O, nullptr },
        { "remove_update_ended", reinterpret_cast<PyCFunction>(MseSourceBuffer_remove_UpdateEnded), METH_O, nullptr },
        { "add_update_starting", reinterpret_cast<PyCFunction>(MseSourceBuffer_add_UpdateStarting), METH_O, nullptr },
        { "remove_update_starting", reinterpret_cast<PyCFunction>(MseSourceBuffer_remove_UpdateStarting), METH_O, nullptr },
        { "add_updated", reinterpret_cast<PyCFunction>(MseSourceBuffer_add_Updated), METH_O, nullptr },
        { "remove_updated", reinterpret_cast<PyCFunction>(MseSourceBuffer_remove_Updated), METH_O, nullptr },
        { "_assign_array_", _assign_array_MseSourceBuffer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MseSourceBuffer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MseSourceBuffer[] = {
        { "timestamp_offset", reinterpret_cast<getter>(MseSourceBuffer_get_TimestampOffset), reinterpret_cast<setter>(MseSourceBuffer_put_TimestampOffset), nullptr, nullptr },
        { "mode", reinterpret_cast<getter>(MseSourceBuffer_get_Mode), reinterpret_cast<setter>(MseSourceBuffer_put_Mode), nullptr, nullptr },
        { "append_window_start", reinterpret_cast<getter>(MseSourceBuffer_get_AppendWindowStart), reinterpret_cast<setter>(MseSourceBuffer_put_AppendWindowStart), nullptr, nullptr },
        { "append_window_end", reinterpret_cast<getter>(MseSourceBuffer_get_AppendWindowEnd), reinterpret_cast<setter>(MseSourceBuffer_put_AppendWindowEnd), nullptr, nullptr },
        { "buffered", reinterpret_cast<getter>(MseSourceBuffer_get_Buffered), nullptr, nullptr, nullptr },
        { "is_updating", reinterpret_cast<getter>(MseSourceBuffer_get_IsUpdating), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MseSourceBuffer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MseSourceBuffer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MseSourceBuffer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MseSourceBuffer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MseSourceBuffer) },
        { },
    };

    static PyType_Spec type_spec_MseSourceBuffer =
    {
        "_winrt_windows_media_core.MseSourceBuffer",
        sizeof(py::wrapper::Windows::Media::Core::MseSourceBuffer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MseSourceBuffer
    };

    // ----- MseSourceBufferList class --------------------
    static constexpr const char* const type_name_MseSourceBufferList = "MseSourceBufferList";

    static PyObject* _new_MseSourceBufferList(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MseSourceBufferList);
        return nullptr;
    }

    static void _dealloc_MseSourceBufferList(py::wrapper::Windows::Media::Core::MseSourceBufferList* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MseSourceBufferList_get_Buffers(py::wrapper::Windows::Media::Core::MseSourceBufferList* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseSourceBufferList", L"Buffers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Buffers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBufferList_add_SourceBufferAdded(py::wrapper::Windows::Media::Core::MseSourceBufferList* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseSourceBufferList", L"SourceBufferAdded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBufferList, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SourceBufferAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBufferList_remove_SourceBufferAdded(py::wrapper::Windows::Media::Core::MseSourceBufferList* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseSourceBufferList", L"SourceBufferAdded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceBufferAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBufferList_add_SourceBufferRemoved(py::wrapper::Windows::Media::Core::MseSourceBufferList* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseSourceBufferList", L"SourceBufferRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBufferList, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SourceBufferRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBufferList_remove_SourceBufferRemoved(py::wrapper::Windows::Media::Core::MseSourceBufferList* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseSourceBufferList", L"SourceBufferRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceBufferRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MseSourceBufferList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MseSourceBufferList>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MseSourceBufferList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MseSourceBufferList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MseSourceBufferList[] = {
        { "add_source_buffer_added", reinterpret_cast<PyCFunction>(MseSourceBufferList_add_SourceBufferAdded), METH_O, nullptr },
        { "remove_source_buffer_added", reinterpret_cast<PyCFunction>(MseSourceBufferList_remove_SourceBufferAdded), METH_O, nullptr },
        { "add_source_buffer_removed", reinterpret_cast<PyCFunction>(MseSourceBufferList_add_SourceBufferRemoved), METH_O, nullptr },
        { "remove_source_buffer_removed", reinterpret_cast<PyCFunction>(MseSourceBufferList_remove_SourceBufferRemoved), METH_O, nullptr },
        { "_assign_array_", _assign_array_MseSourceBufferList, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MseSourceBufferList), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MseSourceBufferList[] = {
        { "buffers", reinterpret_cast<getter>(MseSourceBufferList_get_Buffers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MseSourceBufferList[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MseSourceBufferList) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MseSourceBufferList) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MseSourceBufferList) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MseSourceBufferList) },
        { },
    };

    static PyType_Spec type_spec_MseSourceBufferList =
    {
        "_winrt_windows_media_core.MseSourceBufferList",
        sizeof(py::wrapper::Windows::Media::Core::MseSourceBufferList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MseSourceBufferList
    };

    // ----- MseStreamSource class --------------------
    static constexpr const char* const type_name_MseStreamSource = "MseStreamSource";

    static PyObject* _new_MseStreamSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::MseStreamSource instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MseStreamSource(py::wrapper::Windows::Media::Core::MseStreamSource* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MseStreamSource_AddSourceBuffer(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MseStreamSource", L"AddSourceBuffer", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.AddSourceBuffer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_EndOfStream(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MseStreamSource", L"EndOfStream", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MseEndOfStreamStatus>(args, 0);

                self->obj.EndOfStream(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_IsContentTypeSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MseStreamSource", L"IsContentTypeSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MseStreamSource::IsContentTypeSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_RemoveSourceBuffer(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MseStreamSource", L"RemoveSourceBuffer", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MseSourceBuffer>(args, 0);

                self->obj.RemoveSourceBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_get_Duration(py::wrapper::Windows::Media::Core::MseStreamSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseStreamSource", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseStreamSource_put_Duration(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseStreamSource", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseStreamSource_get_ActiveSourceBuffers(py::wrapper::Windows::Media::Core::MseStreamSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseStreamSource", L"ActiveSourceBuffers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActiveSourceBuffers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_get_ReadyState(py::wrapper::Windows::Media::Core::MseStreamSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseStreamSource", L"ReadyState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReadyState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_get_SourceBuffers(py::wrapper::Windows::Media::Core::MseStreamSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseStreamSource", L"SourceBuffers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceBuffers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_get_LiveSeekableRange(py::wrapper::Windows::Media::Core::MseStreamSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseStreamSource", L"LiveSeekableRange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LiveSeekableRange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseStreamSource_put_LiveSeekableRange(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseStreamSource", L"LiveSeekableRange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Media::Core::MseTimeRange>>(arg);

            self->obj.LiveSeekableRange(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseStreamSource_add_Closed(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseStreamSource", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseStreamSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_remove_Closed(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseStreamSource", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_add_Ended(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseStreamSource", L"Ended"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseStreamSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Ended(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_remove_Ended(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseStreamSource", L"Ended"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Ended(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_add_Opened(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseStreamSource", L"Opened"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseStreamSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Opened(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_remove_Opened(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseStreamSource", L"Opened"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Opened(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MseStreamSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MseStreamSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MseStreamSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MseStreamSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MseStreamSource[] = {
        { "add_source_buffer", reinterpret_cast<PyCFunction>(MseStreamSource_AddSourceBuffer), METH_VARARGS, nullptr },
        { "end_of_stream", reinterpret_cast<PyCFunction>(MseStreamSource_EndOfStream), METH_VARARGS, nullptr },
        { "is_content_type_supported", reinterpret_cast<PyCFunction>(MseStreamSource_IsContentTypeSupported), METH_VARARGS | METH_STATIC, nullptr },
        { "remove_source_buffer", reinterpret_cast<PyCFunction>(MseStreamSource_RemoveSourceBuffer), METH_VARARGS, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(MseStreamSource_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(MseStreamSource_remove_Closed), METH_O, nullptr },
        { "add_ended", reinterpret_cast<PyCFunction>(MseStreamSource_add_Ended), METH_O, nullptr },
        { "remove_ended", reinterpret_cast<PyCFunction>(MseStreamSource_remove_Ended), METH_O, nullptr },
        { "add_opened", reinterpret_cast<PyCFunction>(MseStreamSource_add_Opened), METH_O, nullptr },
        { "remove_opened", reinterpret_cast<PyCFunction>(MseStreamSource_remove_Opened), METH_O, nullptr },
        { "_assign_array_", _assign_array_MseStreamSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MseStreamSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MseStreamSource[] = {
        { "duration", reinterpret_cast<getter>(MseStreamSource_get_Duration), reinterpret_cast<setter>(MseStreamSource_put_Duration), nullptr, nullptr },
        { "active_source_buffers", reinterpret_cast<getter>(MseStreamSource_get_ActiveSourceBuffers), nullptr, nullptr, nullptr },
        { "ready_state", reinterpret_cast<getter>(MseStreamSource_get_ReadyState), nullptr, nullptr, nullptr },
        { "source_buffers", reinterpret_cast<getter>(MseStreamSource_get_SourceBuffers), nullptr, nullptr, nullptr },
        { "live_seekable_range", reinterpret_cast<getter>(MseStreamSource_get_LiveSeekableRange), reinterpret_cast<setter>(MseStreamSource_put_LiveSeekableRange), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MseStreamSource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MseStreamSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MseStreamSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MseStreamSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MseStreamSource) },
        { },
    };

    static PyType_Spec type_spec_MseStreamSource =
    {
        "_winrt_windows_media_core.MseStreamSource",
        sizeof(py::wrapper::Windows::Media::Core::MseStreamSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MseStreamSource
    };

    // ----- SceneAnalysisEffect class --------------------
    static constexpr const char* const type_name_SceneAnalysisEffect = "SceneAnalysisEffect";

    static PyObject* _new_SceneAnalysisEffect(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SceneAnalysisEffect);
        return nullptr;
    }

    static void _dealloc_SceneAnalysisEffect(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneAnalysisEffect_SetProperties(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.SceneAnalysisEffect", L"SetProperties", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);

                self->obj.SetProperties(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffect_get_DesiredAnalysisInterval(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffect", L"DesiredAnalysisInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredAnalysisInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneAnalysisEffect_put_DesiredAnalysisInterval(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffect", L"DesiredAnalysisInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.DesiredAnalysisInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneAnalysisEffect_get_HighDynamicRangeAnalyzer(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffect", L"HighDynamicRangeAnalyzer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HighDynamicRangeAnalyzer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffect_add_SceneAnalyzed(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.SceneAnalysisEffect", L"SceneAnalyzed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::SceneAnalysisEffect, winrt::Windows::Media::Core::SceneAnalyzedEventArgs>>(arg);

            return py::convert(self->obj.SceneAnalyzed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffect_remove_SceneAnalyzed(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.SceneAnalysisEffect", L"SceneAnalyzed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SceneAnalyzed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SceneAnalysisEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::SceneAnalysisEffect>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneAnalysisEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::SceneAnalysisEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneAnalysisEffect[] = {
        { "set_properties", reinterpret_cast<PyCFunction>(SceneAnalysisEffect_SetProperties), METH_VARARGS, nullptr },
        { "add_scene_analyzed", reinterpret_cast<PyCFunction>(SceneAnalysisEffect_add_SceneAnalyzed), METH_O, nullptr },
        { "remove_scene_analyzed", reinterpret_cast<PyCFunction>(SceneAnalysisEffect_remove_SceneAnalyzed), METH_O, nullptr },
        { "_assign_array_", _assign_array_SceneAnalysisEffect, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneAnalysisEffect), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneAnalysisEffect[] = {
        { "desired_analysis_interval", reinterpret_cast<getter>(SceneAnalysisEffect_get_DesiredAnalysisInterval), reinterpret_cast<setter>(SceneAnalysisEffect_put_DesiredAnalysisInterval), nullptr, nullptr },
        { "high_dynamic_range_analyzer", reinterpret_cast<getter>(SceneAnalysisEffect_get_HighDynamicRangeAnalyzer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SceneAnalysisEffect[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneAnalysisEffect) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneAnalysisEffect) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneAnalysisEffect) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneAnalysisEffect) },
        { },
    };

    static PyType_Spec type_spec_SceneAnalysisEffect =
    {
        "_winrt_windows_media_core.SceneAnalysisEffect",
        sizeof(py::wrapper::Windows::Media::Core::SceneAnalysisEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneAnalysisEffect
    };

    // ----- SceneAnalysisEffectDefinition class --------------------
    static constexpr const char* const type_name_SceneAnalysisEffectDefinition = "SceneAnalysisEffectDefinition";

    static PyObject* _new_SceneAnalysisEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::SceneAnalysisEffectDefinition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SceneAnalysisEffectDefinition(py::wrapper::Windows::Media::Core::SceneAnalysisEffectDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneAnalysisEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Core::SceneAnalysisEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffectDefinition", L"ActivatableClassId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectDefinition_get_Properties(py::wrapper::Windows::Media::Core::SceneAnalysisEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffectDefinition", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SceneAnalysisEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::SceneAnalysisEffectDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneAnalysisEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::SceneAnalysisEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneAnalysisEffectDefinition[] = {
        { "_assign_array_", _assign_array_SceneAnalysisEffectDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneAnalysisEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneAnalysisEffectDefinition[] = {
        { "activatable_class_id", reinterpret_cast<getter>(SceneAnalysisEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(SceneAnalysisEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SceneAnalysisEffectDefinition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneAnalysisEffectDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneAnalysisEffectDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneAnalysisEffectDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneAnalysisEffectDefinition) },
        { },
    };

    static PyType_Spec type_spec_SceneAnalysisEffectDefinition =
    {
        "_winrt_windows_media_core.SceneAnalysisEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Core::SceneAnalysisEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneAnalysisEffectDefinition
    };

    // ----- SceneAnalysisEffectFrame class --------------------
    static constexpr const char* const type_name_SceneAnalysisEffectFrame = "SceneAnalysisEffectFrame";

    static PyObject* _new_SceneAnalysisEffectFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SceneAnalysisEffectFrame);
        return nullptr;
    }

    static void _dealloc_SceneAnalysisEffectFrame(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneAnalysisEffectFrame_Close(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.SceneAnalysisEffectFrame", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_FrameControlValues(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffectFrame", L"FrameControlValues"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrameControlValues());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_HighDynamicRange(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffectFrame", L"HighDynamicRange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HighDynamicRange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_AnalysisRecommendation(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffectFrame", L"AnalysisRecommendation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AnalysisRecommendation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_SystemRelativeTime(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffectFrame", L"SystemRelativeTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SystemRelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneAnalysisEffectFrame_put_SystemRelativeTime(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffectFrame", L"SystemRelativeTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.SystemRelativeTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_RelativeTime(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffectFrame", L"RelativeTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneAnalysisEffectFrame_put_RelativeTime(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffectFrame", L"RelativeTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.RelativeTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_IsDiscontinuous(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffectFrame", L"IsDiscontinuous"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDiscontinuous());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneAnalysisEffectFrame_put_IsDiscontinuous(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffectFrame", L"IsDiscontinuous"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDiscontinuous(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_Duration(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffectFrame", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneAnalysisEffectFrame_put_Duration(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffectFrame", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_ExtendedProperties(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffectFrame", L"ExtendedProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_IsReadOnly(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffectFrame", L"IsReadOnly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_Type(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffectFrame", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SceneAnalysisEffectFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::SceneAnalysisEffectFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneAnalysisEffectFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::SceneAnalysisEffectFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_SceneAnalysisEffectFrame(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_SceneAnalysisEffectFrame(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneAnalysisEffectFrame[] = {
        { "close", reinterpret_cast<PyCFunction>(SceneAnalysisEffectFrame_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SceneAnalysisEffectFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneAnalysisEffectFrame), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_SceneAnalysisEffectFrame), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_SceneAnalysisEffectFrame), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneAnalysisEffectFrame[] = {
        { "frame_control_values", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_FrameControlValues), nullptr, nullptr, nullptr },
        { "high_dynamic_range", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_HighDynamicRange), nullptr, nullptr, nullptr },
        { "analysis_recommendation", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_AnalysisRecommendation), nullptr, nullptr, nullptr },
        { "system_relative_time", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_SystemRelativeTime), reinterpret_cast<setter>(SceneAnalysisEffectFrame_put_SystemRelativeTime), nullptr, nullptr },
        { "relative_time", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_RelativeTime), reinterpret_cast<setter>(SceneAnalysisEffectFrame_put_RelativeTime), nullptr, nullptr },
        { "is_discontinuous", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_IsDiscontinuous), reinterpret_cast<setter>(SceneAnalysisEffectFrame_put_IsDiscontinuous), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_Duration), reinterpret_cast<setter>(SceneAnalysisEffectFrame_put_Duration), nullptr, nullptr },
        { "extended_properties", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_ExtendedProperties), nullptr, nullptr, nullptr },
        { "is_read_only", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SceneAnalysisEffectFrame[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneAnalysisEffectFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneAnalysisEffectFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneAnalysisEffectFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneAnalysisEffectFrame) },
        { },
    };

    static PyType_Spec type_spec_SceneAnalysisEffectFrame =
    {
        "_winrt_windows_media_core.SceneAnalysisEffectFrame",
        sizeof(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneAnalysisEffectFrame
    };

    // ----- SceneAnalyzedEventArgs class --------------------
    static constexpr const char* const type_name_SceneAnalyzedEventArgs = "SceneAnalyzedEventArgs";

    static PyObject* _new_SceneAnalyzedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SceneAnalyzedEventArgs);
        return nullptr;
    }

    static void _dealloc_SceneAnalyzedEventArgs(py::wrapper::Windows::Media::Core::SceneAnalyzedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneAnalyzedEventArgs_get_ResultFrame(py::wrapper::Windows::Media::Core::SceneAnalyzedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalyzedEventArgs", L"ResultFrame"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ResultFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SceneAnalyzedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::SceneAnalyzedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneAnalyzedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::SceneAnalyzedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneAnalyzedEventArgs[] = {
        { "_assign_array_", _assign_array_SceneAnalyzedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneAnalyzedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneAnalyzedEventArgs[] = {
        { "result_frame", reinterpret_cast<getter>(SceneAnalyzedEventArgs_get_ResultFrame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SceneAnalyzedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneAnalyzedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneAnalyzedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneAnalyzedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneAnalyzedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SceneAnalyzedEventArgs =
    {
        "_winrt_windows_media_core.SceneAnalyzedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::SceneAnalyzedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneAnalyzedEventArgs
    };

    // ----- SpeechCue class --------------------
    static constexpr const char* const type_name_SpeechCue = "SpeechCue";

    static PyObject* _new_SpeechCue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::SpeechCue instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SpeechCue(py::wrapper::Windows::Media::Core::SpeechCue* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechCue_get_StartTime(py::wrapper::Windows::Media::Core::SpeechCue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SpeechCue", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechCue_put_StartTime(py::wrapper::Windows::Media::Core::SpeechCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SpeechCue", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechCue_get_Id(py::wrapper::Windows::Media::Core::SpeechCue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SpeechCue", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechCue_put_Id(py::wrapper::Windows::Media::Core::SpeechCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SpeechCue", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechCue_get_Duration(py::wrapper::Windows::Media::Core::SpeechCue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SpeechCue", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechCue_put_Duration(py::wrapper::Windows::Media::Core::SpeechCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SpeechCue", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechCue_get_Text(py::wrapper::Windows::Media::Core::SpeechCue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SpeechCue", L"Text"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechCue_put_Text(py::wrapper::Windows::Media::Core::SpeechCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SpeechCue", L"Text"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechCue_get_StartPositionInInput(py::wrapper::Windows::Media::Core::SpeechCue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SpeechCue", L"StartPositionInInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartPositionInInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechCue_put_StartPositionInInput(py::wrapper::Windows::Media::Core::SpeechCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SpeechCue", L"StartPositionInInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.StartPositionInInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechCue_get_EndPositionInInput(py::wrapper::Windows::Media::Core::SpeechCue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SpeechCue", L"EndPositionInInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndPositionInInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechCue_put_EndPositionInInput(py::wrapper::Windows::Media::Core::SpeechCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SpeechCue", L"EndPositionInInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.EndPositionInInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_SpeechCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::SpeechCue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::SpeechCue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechCue[] = {
        { "_assign_array_", _assign_array_SpeechCue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechCue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechCue[] = {
        { "start_time", reinterpret_cast<getter>(SpeechCue_get_StartTime), reinterpret_cast<setter>(SpeechCue_put_StartTime), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(SpeechCue_get_Id), reinterpret_cast<setter>(SpeechCue_put_Id), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(SpeechCue_get_Duration), reinterpret_cast<setter>(SpeechCue_put_Duration), nullptr, nullptr },
        { "text", reinterpret_cast<getter>(SpeechCue_get_Text), reinterpret_cast<setter>(SpeechCue_put_Text), nullptr, nullptr },
        { "start_position_in_input", reinterpret_cast<getter>(SpeechCue_get_StartPositionInInput), reinterpret_cast<setter>(SpeechCue_put_StartPositionInInput), nullptr, nullptr },
        { "end_position_in_input", reinterpret_cast<getter>(SpeechCue_get_EndPositionInInput), reinterpret_cast<setter>(SpeechCue_put_EndPositionInInput), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechCue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechCue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechCue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechCue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechCue) },
        { },
    };

    static PyType_Spec type_spec_SpeechCue =
    {
        "_winrt_windows_media_core.SpeechCue",
        sizeof(py::wrapper::Windows::Media::Core::SpeechCue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechCue
    };

    // ----- TimedMetadataStreamDescriptor class --------------------
    static constexpr const char* const type_name_TimedMetadataStreamDescriptor = "TimedMetadataStreamDescriptor";

    static PyObject* _new_TimedMetadataStreamDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties>(args, 0);

                winrt::Windows::Media::Core::TimedMetadataStreamDescriptor instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedMetadataStreamDescriptor(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedMetadataStreamDescriptor_Copy(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.TimedMetadataStreamDescriptor", L"Copy", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataStreamDescriptor_get_Name(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataStreamDescriptor", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedMetadataStreamDescriptor_put_Name(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataStreamDescriptor", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedMetadataStreamDescriptor_get_Language(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataStreamDescriptor", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedMetadataStreamDescriptor_put_Language(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataStreamDescriptor", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedMetadataStreamDescriptor_get_IsSelected(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataStreamDescriptor", L"IsSelected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataStreamDescriptor_get_Label(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataStreamDescriptor", L"Label"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedMetadataStreamDescriptor_put_Label(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataStreamDescriptor", L"Label"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedMetadataStreamDescriptor_get_EncodingProperties(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataStreamDescriptor", L"EncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TimedMetadataStreamDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::TimedMetadataStreamDescriptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimedMetadataStreamDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedMetadataStreamDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedMetadataStreamDescriptor[] = {
        { "copy", reinterpret_cast<PyCFunction>(TimedMetadataStreamDescriptor_Copy), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TimedMetadataStreamDescriptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedMetadataStreamDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedMetadataStreamDescriptor[] = {
        { "name", reinterpret_cast<getter>(TimedMetadataStreamDescriptor_get_Name), reinterpret_cast<setter>(TimedMetadataStreamDescriptor_put_Name), nullptr, nullptr },
        { "language", reinterpret_cast<getter>(TimedMetadataStreamDescriptor_get_Language), reinterpret_cast<setter>(TimedMetadataStreamDescriptor_put_Language), nullptr, nullptr },
        { "is_selected", reinterpret_cast<getter>(TimedMetadataStreamDescriptor_get_IsSelected), nullptr, nullptr, nullptr },
        { "label", reinterpret_cast<getter>(TimedMetadataStreamDescriptor_get_Label), reinterpret_cast<setter>(TimedMetadataStreamDescriptor_put_Label), nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(TimedMetadataStreamDescriptor_get_EncodingProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedMetadataStreamDescriptor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedMetadataStreamDescriptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedMetadataStreamDescriptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimedMetadataStreamDescriptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedMetadataStreamDescriptor) },
        { },
    };

    static PyType_Spec type_spec_TimedMetadataStreamDescriptor =
    {
        "_winrt_windows_media_core.TimedMetadataStreamDescriptor",
        sizeof(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedMetadataStreamDescriptor
    };

    // ----- TimedMetadataTrack class --------------------
    static constexpr const char* const type_name_TimedMetadataTrack = "TimedMetadataTrack";

    static PyObject* _new_TimedMetadataTrack(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Core::TimedMetadataKind>(args, 2);

                winrt::Windows::Media::Core::TimedMetadataTrack instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedMetadataTrack(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedMetadataTrack_AddCue(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.TimedMetadataTrack", L"AddCue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaCue>(args, 0);

                self->obj.AddCue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_RemoveCue(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.TimedMetadataTrack", L"RemoveCue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaCue>(args, 0);

                self->obj.RemoveCue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_Label(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataTrack", L"Label"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedMetadataTrack_put_Label(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataTrack", L"Label"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedMetadataTrack_get_Id(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataTrack", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_Language(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataTrack", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_TrackKind(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataTrack", L"TrackKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TrackKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_ActiveCues(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataTrack", L"ActiveCues"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActiveCues());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_Cues(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataTrack", L"Cues"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Cues());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_DispatchType(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataTrack", L"DispatchType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DispatchType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_TimedMetadataKind(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataTrack", L"TimedMetadataKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimedMetadataKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_Name(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataTrack", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_PlaybackItem(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataTrack", L"PlaybackItem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlaybackItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_add_CueEntered(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.TimedMetadataTrack", L"CueEntered"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::TimedMetadataTrack, winrt::Windows::Media::Core::MediaCueEventArgs>>(arg);

            return py::convert(self->obj.CueEntered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_remove_CueEntered(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.TimedMetadataTrack", L"CueEntered"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CueEntered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_add_CueExited(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.TimedMetadataTrack", L"CueExited"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::TimedMetadataTrack, winrt::Windows::Media::Core::MediaCueEventArgs>>(arg);

            return py::convert(self->obj.CueExited(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_remove_CueExited(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.TimedMetadataTrack", L"CueExited"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CueExited(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_add_TrackFailed(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.TimedMetadataTrack", L"TrackFailed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::TimedMetadataTrack, winrt::Windows::Media::Core::TimedMetadataTrackFailedEventArgs>>(arg);

            return py::convert(self->obj.TrackFailed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_remove_TrackFailed(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.TimedMetadataTrack", L"TrackFailed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TrackFailed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TimedMetadataTrack(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::TimedMetadataTrack>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimedMetadataTrack(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedMetadataTrack>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedMetadataTrack[] = {
        { "add_cue", reinterpret_cast<PyCFunction>(TimedMetadataTrack_AddCue), METH_VARARGS, nullptr },
        { "remove_cue", reinterpret_cast<PyCFunction>(TimedMetadataTrack_RemoveCue), METH_VARARGS, nullptr },
        { "add_cue_entered", reinterpret_cast<PyCFunction>(TimedMetadataTrack_add_CueEntered), METH_O, nullptr },
        { "remove_cue_entered", reinterpret_cast<PyCFunction>(TimedMetadataTrack_remove_CueEntered), METH_O, nullptr },
        { "add_cue_exited", reinterpret_cast<PyCFunction>(TimedMetadataTrack_add_CueExited), METH_O, nullptr },
        { "remove_cue_exited", reinterpret_cast<PyCFunction>(TimedMetadataTrack_remove_CueExited), METH_O, nullptr },
        { "add_track_failed", reinterpret_cast<PyCFunction>(TimedMetadataTrack_add_TrackFailed), METH_O, nullptr },
        { "remove_track_failed", reinterpret_cast<PyCFunction>(TimedMetadataTrack_remove_TrackFailed), METH_O, nullptr },
        { "_assign_array_", _assign_array_TimedMetadataTrack, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedMetadataTrack), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedMetadataTrack[] = {
        { "label", reinterpret_cast<getter>(TimedMetadataTrack_get_Label), reinterpret_cast<setter>(TimedMetadataTrack_put_Label), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(TimedMetadataTrack_get_Id), nullptr, nullptr, nullptr },
        { "language", reinterpret_cast<getter>(TimedMetadataTrack_get_Language), nullptr, nullptr, nullptr },
        { "track_kind", reinterpret_cast<getter>(TimedMetadataTrack_get_TrackKind), nullptr, nullptr, nullptr },
        { "active_cues", reinterpret_cast<getter>(TimedMetadataTrack_get_ActiveCues), nullptr, nullptr, nullptr },
        { "cues", reinterpret_cast<getter>(TimedMetadataTrack_get_Cues), nullptr, nullptr, nullptr },
        { "dispatch_type", reinterpret_cast<getter>(TimedMetadataTrack_get_DispatchType), nullptr, nullptr, nullptr },
        { "timed_metadata_kind", reinterpret_cast<getter>(TimedMetadataTrack_get_TimedMetadataKind), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(TimedMetadataTrack_get_Name), nullptr, nullptr, nullptr },
        { "playback_item", reinterpret_cast<getter>(TimedMetadataTrack_get_PlaybackItem), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedMetadataTrack[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedMetadataTrack) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedMetadataTrack) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimedMetadataTrack) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedMetadataTrack) },
        { },
    };

    static PyType_Spec type_spec_TimedMetadataTrack =
    {
        "_winrt_windows_media_core.TimedMetadataTrack",
        sizeof(py::wrapper::Windows::Media::Core::TimedMetadataTrack),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedMetadataTrack
    };

    // ----- TimedMetadataTrackError class --------------------
    static constexpr const char* const type_name_TimedMetadataTrackError = "TimedMetadataTrackError";

    static PyObject* _new_TimedMetadataTrackError(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TimedMetadataTrackError);
        return nullptr;
    }

    static void _dealloc_TimedMetadataTrackError(py::wrapper::Windows::Media::Core::TimedMetadataTrackError* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedMetadataTrackError_get_ErrorCode(py::wrapper::Windows::Media::Core::TimedMetadataTrackError* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataTrackError", L"ErrorCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrackError_get_ExtendedError(py::wrapper::Windows::Media::Core::TimedMetadataTrackError* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataTrackError", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TimedMetadataTrackError(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::TimedMetadataTrackError>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimedMetadataTrackError(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedMetadataTrackError>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedMetadataTrackError[] = {
        { "_assign_array_", _assign_array_TimedMetadataTrackError, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedMetadataTrackError), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedMetadataTrackError[] = {
        { "error_code", reinterpret_cast<getter>(TimedMetadataTrackError_get_ErrorCode), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(TimedMetadataTrackError_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedMetadataTrackError[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedMetadataTrackError) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedMetadataTrackError) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimedMetadataTrackError) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedMetadataTrackError) },
        { },
    };

    static PyType_Spec type_spec_TimedMetadataTrackError =
    {
        "_winrt_windows_media_core.TimedMetadataTrackError",
        sizeof(py::wrapper::Windows::Media::Core::TimedMetadataTrackError),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedMetadataTrackError
    };

    // ----- TimedMetadataTrackFailedEventArgs class --------------------
    static constexpr const char* const type_name_TimedMetadataTrackFailedEventArgs = "TimedMetadataTrackFailedEventArgs";

    static PyObject* _new_TimedMetadataTrackFailedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TimedMetadataTrackFailedEventArgs);
        return nullptr;
    }

    static void _dealloc_TimedMetadataTrackFailedEventArgs(py::wrapper::Windows::Media::Core::TimedMetadataTrackFailedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedMetadataTrackFailedEventArgs_get_Error(py::wrapper::Windows::Media::Core::TimedMetadataTrackFailedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataTrackFailedEventArgs", L"Error"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TimedMetadataTrackFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::TimedMetadataTrackFailedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimedMetadataTrackFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedMetadataTrackFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedMetadataTrackFailedEventArgs[] = {
        { "_assign_array_", _assign_array_TimedMetadataTrackFailedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedMetadataTrackFailedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedMetadataTrackFailedEventArgs[] = {
        { "error", reinterpret_cast<getter>(TimedMetadataTrackFailedEventArgs_get_Error), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedMetadataTrackFailedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedMetadataTrackFailedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedMetadataTrackFailedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimedMetadataTrackFailedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedMetadataTrackFailedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_TimedMetadataTrackFailedEventArgs =
    {
        "_winrt_windows_media_core.TimedMetadataTrackFailedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::TimedMetadataTrackFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedMetadataTrackFailedEventArgs
    };

    // ----- TimedTextBouten class --------------------
    static constexpr const char* const type_name_TimedTextBouten = "TimedTextBouten";

    static PyObject* _new_TimedTextBouten(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TimedTextBouten);
        return nullptr;
    }

    static void _dealloc_TimedTextBouten(py::wrapper::Windows::Media::Core::TimedTextBouten* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedTextBouten_get_Type(py::wrapper::Windows::Media::Core::TimedTextBouten* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextBouten", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextBouten_put_Type(py::wrapper::Windows::Media::Core::TimedTextBouten* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextBouten", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextBoutenType>(arg);

            self->obj.Type(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextBouten_get_Position(py::wrapper::Windows::Media::Core::TimedTextBouten* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextBouten", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextBouten_put_Position(py::wrapper::Windows::Media::Core::TimedTextBouten* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextBouten", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextBoutenPosition>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextBouten_get_Color(py::wrapper::Windows::Media::Core::TimedTextBouten* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextBouten", L"Color"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Color());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextBouten_put_Color(py::wrapper::Windows::Media::Core::TimedTextBouten* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextBouten", L"Color"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Color(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_TimedTextBouten(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::TimedTextBouten>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimedTextBouten(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextBouten>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextBouten[] = {
        { "_assign_array_", _assign_array_TimedTextBouten, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextBouten), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextBouten[] = {
        { "type", reinterpret_cast<getter>(TimedTextBouten_get_Type), reinterpret_cast<setter>(TimedTextBouten_put_Type), nullptr, nullptr },
        { "position", reinterpret_cast<getter>(TimedTextBouten_get_Position), reinterpret_cast<setter>(TimedTextBouten_put_Position), nullptr, nullptr },
        { "color", reinterpret_cast<getter>(TimedTextBouten_get_Color), reinterpret_cast<setter>(TimedTextBouten_put_Color), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextBouten[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedTextBouten) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedTextBouten) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimedTextBouten) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedTextBouten) },
        { },
    };

    static PyType_Spec type_spec_TimedTextBouten =
    {
        "_winrt_windows_media_core.TimedTextBouten",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextBouten),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextBouten
    };

    // ----- TimedTextCue class --------------------
    static constexpr const char* const type_name_TimedTextCue = "TimedTextCue";

    static PyObject* _new_TimedTextCue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextCue instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedTextCue(py::wrapper::Windows::Media::Core::TimedTextCue* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedTextCue_get_StartTime(py::wrapper::Windows::Media::Core::TimedTextCue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextCue", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextCue_put_StartTime(py::wrapper::Windows::Media::Core::TimedTextCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextCue", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextCue_get_Id(py::wrapper::Windows::Media::Core::TimedTextCue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextCue", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextCue_put_Id(py::wrapper::Windows::Media::Core::TimedTextCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextCue", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextCue_get_Duration(py::wrapper::Windows::Media::Core::TimedTextCue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextCue", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextCue_put_Duration(py::wrapper::Windows::Media::Core::TimedTextCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextCue", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextCue_get_CueStyle(py::wrapper::Windows::Media::Core::TimedTextCue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextCue", L"CueStyle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CueStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextCue_put_CueStyle(py::wrapper::Windows::Media::Core::TimedTextCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextCue", L"CueStyle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextStyle>(arg);

            self->obj.CueStyle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextCue_get_CueRegion(py::wrapper::Windows::Media::Core::TimedTextCue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextCue", L"CueRegion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CueRegion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextCue_put_CueRegion(py::wrapper::Windows::Media::Core::TimedTextCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextCue", L"CueRegion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextRegion>(arg);

            self->obj.CueRegion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextCue_get_Lines(py::wrapper::Windows::Media::Core::TimedTextCue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextCue", L"Lines"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Lines());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TimedTextCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::TimedTextCue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimedTextCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextCue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextCue[] = {
        { "_assign_array_", _assign_array_TimedTextCue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextCue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextCue[] = {
        { "start_time", reinterpret_cast<getter>(TimedTextCue_get_StartTime), reinterpret_cast<setter>(TimedTextCue_put_StartTime), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(TimedTextCue_get_Id), reinterpret_cast<setter>(TimedTextCue_put_Id), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(TimedTextCue_get_Duration), reinterpret_cast<setter>(TimedTextCue_put_Duration), nullptr, nullptr },
        { "cue_style", reinterpret_cast<getter>(TimedTextCue_get_CueStyle), reinterpret_cast<setter>(TimedTextCue_put_CueStyle), nullptr, nullptr },
        { "cue_region", reinterpret_cast<getter>(TimedTextCue_get_CueRegion), reinterpret_cast<setter>(TimedTextCue_put_CueRegion), nullptr, nullptr },
        { "lines", reinterpret_cast<getter>(TimedTextCue_get_Lines), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextCue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedTextCue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedTextCue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimedTextCue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedTextCue) },
        { },
    };

    static PyType_Spec type_spec_TimedTextCue =
    {
        "_winrt_windows_media_core.TimedTextCue",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextCue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextCue
    };

    // ----- TimedTextLine class --------------------
    static constexpr const char* const type_name_TimedTextLine = "TimedTextLine";

    static PyObject* _new_TimedTextLine(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextLine instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedTextLine(py::wrapper::Windows::Media::Core::TimedTextLine* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedTextLine_get_Text(py::wrapper::Windows::Media::Core::TimedTextLine* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextLine", L"Text"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextLine_put_Text(py::wrapper::Windows::Media::Core::TimedTextLine* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextLine", L"Text"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextLine_get_Subformats(py::wrapper::Windows::Media::Core::TimedTextLine* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextLine", L"Subformats"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Subformats());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TimedTextLine(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::TimedTextLine>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimedTextLine(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextLine>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextLine[] = {
        { "_assign_array_", _assign_array_TimedTextLine, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextLine), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextLine[] = {
        { "text", reinterpret_cast<getter>(TimedTextLine_get_Text), reinterpret_cast<setter>(TimedTextLine_put_Text), nullptr, nullptr },
        { "subformats", reinterpret_cast<getter>(TimedTextLine_get_Subformats), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextLine[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedTextLine) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedTextLine) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimedTextLine) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedTextLine) },
        { },
    };

    static PyType_Spec type_spec_TimedTextLine =
    {
        "_winrt_windows_media_core.TimedTextLine",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextLine),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextLine
    };

    // ----- TimedTextRegion class --------------------
    static constexpr const char* const type_name_TimedTextRegion = "TimedTextRegion";

    static PyObject* _new_TimedTextRegion(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextRegion instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedTextRegion(py::wrapper::Windows::Media::Core::TimedTextRegion* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedTextRegion_get_Name(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_Name(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_LineHeight(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"LineHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LineHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_LineHeight(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"LineHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextDouble>(arg);

            self->obj.LineHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_IsOverflowClipped(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"IsOverflowClipped"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsOverflowClipped());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_IsOverflowClipped(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"IsOverflowClipped"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsOverflowClipped(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_Extent(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"Extent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Extent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_Extent(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"Extent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextSize>(arg);

            self->obj.Extent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_DisplayAlignment(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"DisplayAlignment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_DisplayAlignment(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"DisplayAlignment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextDisplayAlignment>(arg);

            self->obj.DisplayAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_Padding(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"Padding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Padding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_Padding(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"Padding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextPadding>(arg);

            self->obj.Padding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_Background(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"Background"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Background());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_Background(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"Background"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Background(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_ZIndex(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"ZIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_ZIndex(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"ZIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_WritingMode(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"WritingMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WritingMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_WritingMode(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"WritingMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextWritingMode>(arg);

            self->obj.WritingMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_TextWrapping(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"TextWrapping"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TextWrapping());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_TextWrapping(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"TextWrapping"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextWrapping>(arg);

            self->obj.TextWrapping(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_ScrollMode(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"ScrollMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScrollMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_ScrollMode(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"ScrollMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextScrollMode>(arg);

            self->obj.ScrollMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_Position(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_Position(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextPoint>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_TimedTextRegion(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::TimedTextRegion>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimedTextRegion(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextRegion>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextRegion[] = {
        { "_assign_array_", _assign_array_TimedTextRegion, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextRegion), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextRegion[] = {
        { "name", reinterpret_cast<getter>(TimedTextRegion_get_Name), reinterpret_cast<setter>(TimedTextRegion_put_Name), nullptr, nullptr },
        { "line_height", reinterpret_cast<getter>(TimedTextRegion_get_LineHeight), reinterpret_cast<setter>(TimedTextRegion_put_LineHeight), nullptr, nullptr },
        { "is_overflow_clipped", reinterpret_cast<getter>(TimedTextRegion_get_IsOverflowClipped), reinterpret_cast<setter>(TimedTextRegion_put_IsOverflowClipped), nullptr, nullptr },
        { "extent", reinterpret_cast<getter>(TimedTextRegion_get_Extent), reinterpret_cast<setter>(TimedTextRegion_put_Extent), nullptr, nullptr },
        { "display_alignment", reinterpret_cast<getter>(TimedTextRegion_get_DisplayAlignment), reinterpret_cast<setter>(TimedTextRegion_put_DisplayAlignment), nullptr, nullptr },
        { "padding", reinterpret_cast<getter>(TimedTextRegion_get_Padding), reinterpret_cast<setter>(TimedTextRegion_put_Padding), nullptr, nullptr },
        { "background", reinterpret_cast<getter>(TimedTextRegion_get_Background), reinterpret_cast<setter>(TimedTextRegion_put_Background), nullptr, nullptr },
        { "z_index", reinterpret_cast<getter>(TimedTextRegion_get_ZIndex), reinterpret_cast<setter>(TimedTextRegion_put_ZIndex), nullptr, nullptr },
        { "writing_mode", reinterpret_cast<getter>(TimedTextRegion_get_WritingMode), reinterpret_cast<setter>(TimedTextRegion_put_WritingMode), nullptr, nullptr },
        { "text_wrapping", reinterpret_cast<getter>(TimedTextRegion_get_TextWrapping), reinterpret_cast<setter>(TimedTextRegion_put_TextWrapping), nullptr, nullptr },
        { "scroll_mode", reinterpret_cast<getter>(TimedTextRegion_get_ScrollMode), reinterpret_cast<setter>(TimedTextRegion_put_ScrollMode), nullptr, nullptr },
        { "position", reinterpret_cast<getter>(TimedTextRegion_get_Position), reinterpret_cast<setter>(TimedTextRegion_put_Position), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextRegion[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedTextRegion) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedTextRegion) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimedTextRegion) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedTextRegion) },
        { },
    };

    static PyType_Spec type_spec_TimedTextRegion =
    {
        "_winrt_windows_media_core.TimedTextRegion",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextRegion),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextRegion
    };

    // ----- TimedTextRuby class --------------------
    static constexpr const char* const type_name_TimedTextRuby = "TimedTextRuby";

    static PyObject* _new_TimedTextRuby(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TimedTextRuby);
        return nullptr;
    }

    static void _dealloc_TimedTextRuby(py::wrapper::Windows::Media::Core::TimedTextRuby* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedTextRuby_get_Text(py::wrapper::Windows::Media::Core::TimedTextRuby* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRuby", L"Text"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRuby_put_Text(py::wrapper::Windows::Media::Core::TimedTextRuby* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRuby", L"Text"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRuby_get_Reserve(py::wrapper::Windows::Media::Core::TimedTextRuby* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRuby", L"Reserve"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reserve());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRuby_put_Reserve(py::wrapper::Windows::Media::Core::TimedTextRuby* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRuby", L"Reserve"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextRubyReserve>(arg);

            self->obj.Reserve(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRuby_get_Position(py::wrapper::Windows::Media::Core::TimedTextRuby* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRuby", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRuby_put_Position(py::wrapper::Windows::Media::Core::TimedTextRuby* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRuby", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextRubyPosition>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRuby_get_Align(py::wrapper::Windows::Media::Core::TimedTextRuby* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRuby", L"Align"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Align());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRuby_put_Align(py::wrapper::Windows::Media::Core::TimedTextRuby* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRuby", L"Align"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextRubyAlign>(arg);

            self->obj.Align(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_TimedTextRuby(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::TimedTextRuby>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimedTextRuby(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextRuby>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextRuby[] = {
        { "_assign_array_", _assign_array_TimedTextRuby, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextRuby), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextRuby[] = {
        { "text", reinterpret_cast<getter>(TimedTextRuby_get_Text), reinterpret_cast<setter>(TimedTextRuby_put_Text), nullptr, nullptr },
        { "reserve", reinterpret_cast<getter>(TimedTextRuby_get_Reserve), reinterpret_cast<setter>(TimedTextRuby_put_Reserve), nullptr, nullptr },
        { "position", reinterpret_cast<getter>(TimedTextRuby_get_Position), reinterpret_cast<setter>(TimedTextRuby_put_Position), nullptr, nullptr },
        { "align", reinterpret_cast<getter>(TimedTextRuby_get_Align), reinterpret_cast<setter>(TimedTextRuby_put_Align), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextRuby[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedTextRuby) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedTextRuby) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimedTextRuby) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedTextRuby) },
        { },
    };

    static PyType_Spec type_spec_TimedTextRuby =
    {
        "_winrt_windows_media_core.TimedTextRuby",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextRuby),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextRuby
    };

    // ----- TimedTextSource class --------------------
    static constexpr const char* const type_name_TimedTextSource = "TimedTextSource";

    static PyObject* _new_TimedTextSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TimedTextSource);
        return nullptr;
    }

    static void _dealloc_TimedTextSource(py::wrapper::Windows::Media::Core::TimedTextSource* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedTextSource_CreateFromStream(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.TimedTextSource", L"CreateFromStream", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromStream(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.TimedTextSource", L"CreateFromStream", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromStream(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedTextSource_CreateFromStreamWithIndex(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.TimedTextSource", L"CreateFromStreamWithIndex", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromStreamWithIndex(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.TimedTextSource", L"CreateFromStreamWithIndex", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromStreamWithIndex(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedTextSource_CreateFromUri(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.TimedTextSource", L"CreateFromUri", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromUri(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.TimedTextSource", L"CreateFromUri", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromUri(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedTextSource_CreateFromUriWithIndex(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.TimedTextSource", L"CreateFromUriWithIndex", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromUriWithIndex(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.TimedTextSource", L"CreateFromUriWithIndex", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromUriWithIndex(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedTextSource_add_Resolved(py::wrapper::Windows::Media::Core::TimedTextSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.TimedTextSource", L"Resolved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::TimedTextSource, winrt::Windows::Media::Core::TimedTextSourceResolveResultEventArgs>>(arg);

            return py::convert(self->obj.Resolved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedTextSource_remove_Resolved(py::wrapper::Windows::Media::Core::TimedTextSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.TimedTextSource", L"Resolved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Resolved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TimedTextSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::TimedTextSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimedTextSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextSource[] = {
        { "create_from_stream", reinterpret_cast<PyCFunction>(TimedTextSource_CreateFromStream), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_stream_with_index", reinterpret_cast<PyCFunction>(TimedTextSource_CreateFromStreamWithIndex), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_uri", reinterpret_cast<PyCFunction>(TimedTextSource_CreateFromUri), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_uri_with_index", reinterpret_cast<PyCFunction>(TimedTextSource_CreateFromUriWithIndex), METH_VARARGS | METH_STATIC, nullptr },
        { "add_resolved", reinterpret_cast<PyCFunction>(TimedTextSource_add_Resolved), METH_O, nullptr },
        { "remove_resolved", reinterpret_cast<PyCFunction>(TimedTextSource_remove_Resolved), METH_O, nullptr },
        { "_assign_array_", _assign_array_TimedTextSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextSource[] = {
        { }
    };

    static PyType_Slot _type_slots_TimedTextSource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedTextSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedTextSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimedTextSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedTextSource) },
        { },
    };

    static PyType_Spec type_spec_TimedTextSource =
    {
        "_winrt_windows_media_core.TimedTextSource",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextSource
    };

    // ----- TimedTextSourceResolveResultEventArgs class --------------------
    static constexpr const char* const type_name_TimedTextSourceResolveResultEventArgs = "TimedTextSourceResolveResultEventArgs";

    static PyObject* _new_TimedTextSourceResolveResultEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TimedTextSourceResolveResultEventArgs);
        return nullptr;
    }

    static void _dealloc_TimedTextSourceResolveResultEventArgs(py::wrapper::Windows::Media::Core::TimedTextSourceResolveResultEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedTextSourceResolveResultEventArgs_get_Error(py::wrapper::Windows::Media::Core::TimedTextSourceResolveResultEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextSourceResolveResultEventArgs", L"Error"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedTextSourceResolveResultEventArgs_get_Tracks(py::wrapper::Windows::Media::Core::TimedTextSourceResolveResultEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextSourceResolveResultEventArgs", L"Tracks"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Tracks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TimedTextSourceResolveResultEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::TimedTextSourceResolveResultEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimedTextSourceResolveResultEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextSourceResolveResultEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextSourceResolveResultEventArgs[] = {
        { "_assign_array_", _assign_array_TimedTextSourceResolveResultEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextSourceResolveResultEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextSourceResolveResultEventArgs[] = {
        { "error", reinterpret_cast<getter>(TimedTextSourceResolveResultEventArgs_get_Error), nullptr, nullptr, nullptr },
        { "tracks", reinterpret_cast<getter>(TimedTextSourceResolveResultEventArgs_get_Tracks), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextSourceResolveResultEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedTextSourceResolveResultEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedTextSourceResolveResultEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimedTextSourceResolveResultEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedTextSourceResolveResultEventArgs) },
        { },
    };

    static PyType_Spec type_spec_TimedTextSourceResolveResultEventArgs =
    {
        "_winrt_windows_media_core.TimedTextSourceResolveResultEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextSourceResolveResultEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextSourceResolveResultEventArgs
    };

    // ----- TimedTextStyle class --------------------
    static constexpr const char* const type_name_TimedTextStyle = "TimedTextStyle";

    static PyObject* _new_TimedTextStyle(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextStyle instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedTextStyle(py::wrapper::Windows::Media::Core::TimedTextStyle* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedTextStyle_get_LineAlignment(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"LineAlignment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LineAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_LineAlignment(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"LineAlignment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextLineAlignment>(arg);

            self->obj.LineAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_IsBackgroundAlwaysShown(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"IsBackgroundAlwaysShown"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsBackgroundAlwaysShown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_IsBackgroundAlwaysShown(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"IsBackgroundAlwaysShown"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsBackgroundAlwaysShown(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_OutlineColor(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"OutlineColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutlineColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_OutlineColor(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"OutlineColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.OutlineColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_Foreground(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"Foreground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Foreground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_Foreground(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"Foreground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Foreground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_FontWeight(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"FontWeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FontWeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_FontWeight(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"FontWeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextWeight>(arg);

            self->obj.FontWeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_Background(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"Background"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Background());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_Background(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"Background"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Background(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_FontSize(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"FontSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FontSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_FontSize(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"FontSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextDouble>(arg);

            self->obj.FontSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_FontFamily(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"FontFamily"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FontFamily());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_FontFamily(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"FontFamily"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FontFamily(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_FlowDirection(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"FlowDirection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FlowDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_FlowDirection(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"FlowDirection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextFlowDirection>(arg);

            self->obj.FlowDirection(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_OutlineThickness(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"OutlineThickness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutlineThickness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_OutlineThickness(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"OutlineThickness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextDouble>(arg);

            self->obj.OutlineThickness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_OutlineRadius(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"OutlineRadius"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutlineRadius());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_OutlineRadius(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"OutlineRadius"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextDouble>(arg);

            self->obj.OutlineRadius(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_Name(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_Name(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_IsUnderlineEnabled(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"IsUnderlineEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsUnderlineEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_IsUnderlineEnabled(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"IsUnderlineEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsUnderlineEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_IsOverlineEnabled(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"IsOverlineEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsOverlineEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_IsOverlineEnabled(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"IsOverlineEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsOverlineEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_IsLineThroughEnabled(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"IsLineThroughEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsLineThroughEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_IsLineThroughEnabled(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"IsLineThroughEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLineThroughEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_FontStyle(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"FontStyle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FontStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_FontStyle(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"FontStyle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextFontStyle>(arg);

            self->obj.FontStyle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_IsTextCombined(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"IsTextCombined"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsTextCombined());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_IsTextCombined(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"IsTextCombined"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsTextCombined(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_FontAngleInDegrees(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"FontAngleInDegrees"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FontAngleInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_FontAngleInDegrees(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"FontAngleInDegrees"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.FontAngleInDegrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_Bouten(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"Bouten"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Bouten());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedTextStyle_get_Ruby(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"Ruby"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Ruby());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TimedTextStyle(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::TimedTextStyle>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimedTextStyle(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextStyle>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextStyle[] = {
        { "_assign_array_", _assign_array_TimedTextStyle, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextStyle), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextStyle[] = {
        { "line_alignment", reinterpret_cast<getter>(TimedTextStyle_get_LineAlignment), reinterpret_cast<setter>(TimedTextStyle_put_LineAlignment), nullptr, nullptr },
        { "is_background_always_shown", reinterpret_cast<getter>(TimedTextStyle_get_IsBackgroundAlwaysShown), reinterpret_cast<setter>(TimedTextStyle_put_IsBackgroundAlwaysShown), nullptr, nullptr },
        { "outline_color", reinterpret_cast<getter>(TimedTextStyle_get_OutlineColor), reinterpret_cast<setter>(TimedTextStyle_put_OutlineColor), nullptr, nullptr },
        { "foreground", reinterpret_cast<getter>(TimedTextStyle_get_Foreground), reinterpret_cast<setter>(TimedTextStyle_put_Foreground), nullptr, nullptr },
        { "font_weight", reinterpret_cast<getter>(TimedTextStyle_get_FontWeight), reinterpret_cast<setter>(TimedTextStyle_put_FontWeight), nullptr, nullptr },
        { "background", reinterpret_cast<getter>(TimedTextStyle_get_Background), reinterpret_cast<setter>(TimedTextStyle_put_Background), nullptr, nullptr },
        { "font_size", reinterpret_cast<getter>(TimedTextStyle_get_FontSize), reinterpret_cast<setter>(TimedTextStyle_put_FontSize), nullptr, nullptr },
        { "font_family", reinterpret_cast<getter>(TimedTextStyle_get_FontFamily), reinterpret_cast<setter>(TimedTextStyle_put_FontFamily), nullptr, nullptr },
        { "flow_direction", reinterpret_cast<getter>(TimedTextStyle_get_FlowDirection), reinterpret_cast<setter>(TimedTextStyle_put_FlowDirection), nullptr, nullptr },
        { "outline_thickness", reinterpret_cast<getter>(TimedTextStyle_get_OutlineThickness), reinterpret_cast<setter>(TimedTextStyle_put_OutlineThickness), nullptr, nullptr },
        { "outline_radius", reinterpret_cast<getter>(TimedTextStyle_get_OutlineRadius), reinterpret_cast<setter>(TimedTextStyle_put_OutlineRadius), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(TimedTextStyle_get_Name), reinterpret_cast<setter>(TimedTextStyle_put_Name), nullptr, nullptr },
        { "is_underline_enabled", reinterpret_cast<getter>(TimedTextStyle_get_IsUnderlineEnabled), reinterpret_cast<setter>(TimedTextStyle_put_IsUnderlineEnabled), nullptr, nullptr },
        { "is_overline_enabled", reinterpret_cast<getter>(TimedTextStyle_get_IsOverlineEnabled), reinterpret_cast<setter>(TimedTextStyle_put_IsOverlineEnabled), nullptr, nullptr },
        { "is_line_through_enabled", reinterpret_cast<getter>(TimedTextStyle_get_IsLineThroughEnabled), reinterpret_cast<setter>(TimedTextStyle_put_IsLineThroughEnabled), nullptr, nullptr },
        { "font_style", reinterpret_cast<getter>(TimedTextStyle_get_FontStyle), reinterpret_cast<setter>(TimedTextStyle_put_FontStyle), nullptr, nullptr },
        { "is_text_combined", reinterpret_cast<getter>(TimedTextStyle_get_IsTextCombined), reinterpret_cast<setter>(TimedTextStyle_put_IsTextCombined), nullptr, nullptr },
        { "font_angle_in_degrees", reinterpret_cast<getter>(TimedTextStyle_get_FontAngleInDegrees), reinterpret_cast<setter>(TimedTextStyle_put_FontAngleInDegrees), nullptr, nullptr },
        { "bouten", reinterpret_cast<getter>(TimedTextStyle_get_Bouten), nullptr, nullptr, nullptr },
        { "ruby", reinterpret_cast<getter>(TimedTextStyle_get_Ruby), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextStyle[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedTextStyle) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedTextStyle) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimedTextStyle) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedTextStyle) },
        { },
    };

    static PyType_Spec type_spec_TimedTextStyle =
    {
        "_winrt_windows_media_core.TimedTextStyle",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextStyle),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextStyle
    };

    // ----- TimedTextSubformat class --------------------
    static constexpr const char* const type_name_TimedTextSubformat = "TimedTextSubformat";

    static PyObject* _new_TimedTextSubformat(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextSubformat instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedTextSubformat(py::wrapper::Windows::Media::Core::TimedTextSubformat* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedTextSubformat_get_SubformatStyle(py::wrapper::Windows::Media::Core::TimedTextSubformat* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextSubformat", L"SubformatStyle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SubformatStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextSubformat_put_SubformatStyle(py::wrapper::Windows::Media::Core::TimedTextSubformat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextSubformat", L"SubformatStyle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextStyle>(arg);

            self->obj.SubformatStyle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextSubformat_get_StartIndex(py::wrapper::Windows::Media::Core::TimedTextSubformat* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextSubformat", L"StartIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextSubformat_put_StartIndex(py::wrapper::Windows::Media::Core::TimedTextSubformat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextSubformat", L"StartIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.StartIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextSubformat_get_Length(py::wrapper::Windows::Media::Core::TimedTextSubformat* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextSubformat", L"Length"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextSubformat_put_Length(py::wrapper::Windows::Media::Core::TimedTextSubformat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextSubformat", L"Length"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Length(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_TimedTextSubformat(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::TimedTextSubformat>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimedTextSubformat(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextSubformat>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextSubformat[] = {
        { "_assign_array_", _assign_array_TimedTextSubformat, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextSubformat), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextSubformat[] = {
        { "subformat_style", reinterpret_cast<getter>(TimedTextSubformat_get_SubformatStyle), reinterpret_cast<setter>(TimedTextSubformat_put_SubformatStyle), nullptr, nullptr },
        { "start_index", reinterpret_cast<getter>(TimedTextSubformat_get_StartIndex), reinterpret_cast<setter>(TimedTextSubformat_put_StartIndex), nullptr, nullptr },
        { "length", reinterpret_cast<getter>(TimedTextSubformat_get_Length), reinterpret_cast<setter>(TimedTextSubformat_put_Length), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextSubformat[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedTextSubformat) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedTextSubformat) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimedTextSubformat) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedTextSubformat) },
        { },
    };

    static PyType_Spec type_spec_TimedTextSubformat =
    {
        "_winrt_windows_media_core.TimedTextSubformat",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextSubformat),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextSubformat
    };

    // ----- VideoStabilizationEffect class --------------------
    static constexpr const char* const type_name_VideoStabilizationEffect = "VideoStabilizationEffect";

    static PyObject* _new_VideoStabilizationEffect(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_VideoStabilizationEffect);
        return nullptr;
    }

    static void _dealloc_VideoStabilizationEffect(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoStabilizationEffect_GetRecommendedStreamConfiguration(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.VideoStabilizationEffect", L"GetRecommendedStreamConfiguration", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::VideoDeviceController>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingProperties>(args, 1);

                return py::convert(self->obj.GetRecommendedStreamConfiguration(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoStabilizationEffect_SetProperties(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.VideoStabilizationEffect", L"SetProperties", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);

                self->obj.SetProperties(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoStabilizationEffect_get_Enabled(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoStabilizationEffect", L"Enabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoStabilizationEffect_put_Enabled(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoStabilizationEffect", L"Enabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoStabilizationEffect_add_EnabledChanged(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.VideoStabilizationEffect", L"EnabledChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::VideoStabilizationEffect, winrt::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs>>(arg);

            return py::convert(self->obj.EnabledChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoStabilizationEffect_remove_EnabledChanged(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.VideoStabilizationEffect", L"EnabledChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnabledChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VideoStabilizationEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::VideoStabilizationEffect>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VideoStabilizationEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoStabilizationEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoStabilizationEffect[] = {
        { "get_recommended_stream_configuration", reinterpret_cast<PyCFunction>(VideoStabilizationEffect_GetRecommendedStreamConfiguration), METH_VARARGS, nullptr },
        { "set_properties", reinterpret_cast<PyCFunction>(VideoStabilizationEffect_SetProperties), METH_VARARGS, nullptr },
        { "add_enabled_changed", reinterpret_cast<PyCFunction>(VideoStabilizationEffect_add_EnabledChanged), METH_O, nullptr },
        { "remove_enabled_changed", reinterpret_cast<PyCFunction>(VideoStabilizationEffect_remove_EnabledChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_VideoStabilizationEffect, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoStabilizationEffect), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoStabilizationEffect[] = {
        { "enabled", reinterpret_cast<getter>(VideoStabilizationEffect_get_Enabled), reinterpret_cast<setter>(VideoStabilizationEffect_put_Enabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoStabilizationEffect[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VideoStabilizationEffect) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VideoStabilizationEffect) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VideoStabilizationEffect) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VideoStabilizationEffect) },
        { },
    };

    static PyType_Spec type_spec_VideoStabilizationEffect =
    {
        "_winrt_windows_media_core.VideoStabilizationEffect",
        sizeof(py::wrapper::Windows::Media::Core::VideoStabilizationEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoStabilizationEffect
    };

    // ----- VideoStabilizationEffectDefinition class --------------------
    static constexpr const char* const type_name_VideoStabilizationEffectDefinition = "VideoStabilizationEffectDefinition";

    static PyObject* _new_VideoStabilizationEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::VideoStabilizationEffectDefinition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VideoStabilizationEffectDefinition(py::wrapper::Windows::Media::Core::VideoStabilizationEffectDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoStabilizationEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Core::VideoStabilizationEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoStabilizationEffectDefinition", L"ActivatableClassId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoStabilizationEffectDefinition_get_Properties(py::wrapper::Windows::Media::Core::VideoStabilizationEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoStabilizationEffectDefinition", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VideoStabilizationEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::VideoStabilizationEffectDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VideoStabilizationEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoStabilizationEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoStabilizationEffectDefinition[] = {
        { "_assign_array_", _assign_array_VideoStabilizationEffectDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoStabilizationEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoStabilizationEffectDefinition[] = {
        { "activatable_class_id", reinterpret_cast<getter>(VideoStabilizationEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(VideoStabilizationEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoStabilizationEffectDefinition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VideoStabilizationEffectDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VideoStabilizationEffectDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VideoStabilizationEffectDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VideoStabilizationEffectDefinition) },
        { },
    };

    static PyType_Spec type_spec_VideoStabilizationEffectDefinition =
    {
        "_winrt_windows_media_core.VideoStabilizationEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Core::VideoStabilizationEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoStabilizationEffectDefinition
    };

    // ----- VideoStabilizationEffectEnabledChangedEventArgs class --------------------
    static constexpr const char* const type_name_VideoStabilizationEffectEnabledChangedEventArgs = "VideoStabilizationEffectEnabledChangedEventArgs";

    static PyObject* _new_VideoStabilizationEffectEnabledChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_VideoStabilizationEffectEnabledChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_VideoStabilizationEffectEnabledChangedEventArgs(py::wrapper::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoStabilizationEffectEnabledChangedEventArgs_get_Reason(py::wrapper::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoStabilizationEffectEnabledChangedEventArgs", L"Reason"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VideoStabilizationEffectEnabledChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VideoStabilizationEffectEnabledChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoStabilizationEffectEnabledChangedEventArgs[] = {
        { "_assign_array_", _assign_array_VideoStabilizationEffectEnabledChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoStabilizationEffectEnabledChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoStabilizationEffectEnabledChangedEventArgs[] = {
        { "reason", reinterpret_cast<getter>(VideoStabilizationEffectEnabledChangedEventArgs_get_Reason), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoStabilizationEffectEnabledChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VideoStabilizationEffectEnabledChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VideoStabilizationEffectEnabledChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VideoStabilizationEffectEnabledChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VideoStabilizationEffectEnabledChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_VideoStabilizationEffectEnabledChangedEventArgs =
    {
        "_winrt_windows_media_core.VideoStabilizationEffectEnabledChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoStabilizationEffectEnabledChangedEventArgs
    };

    // ----- VideoStreamDescriptor class --------------------
    static constexpr const char* const type_name_VideoStreamDescriptor = "VideoStreamDescriptor";

    static PyObject* _new_VideoStreamDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingProperties>(args, 0);

                winrt::Windows::Media::Core::VideoStreamDescriptor instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VideoStreamDescriptor(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoStreamDescriptor_Copy(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.VideoStreamDescriptor", L"Copy", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoStreamDescriptor_get_Name(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoStreamDescriptor", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoStreamDescriptor_put_Name(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoStreamDescriptor", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoStreamDescriptor_get_Language(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoStreamDescriptor", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoStreamDescriptor_put_Language(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoStreamDescriptor", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoStreamDescriptor_get_IsSelected(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoStreamDescriptor", L"IsSelected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoStreamDescriptor_get_Label(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoStreamDescriptor", L"Label"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoStreamDescriptor_put_Label(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoStreamDescriptor", L"Label"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoStreamDescriptor_get_EncodingProperties(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoStreamDescriptor", L"EncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VideoStreamDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::VideoStreamDescriptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VideoStreamDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoStreamDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoStreamDescriptor[] = {
        { "copy", reinterpret_cast<PyCFunction>(VideoStreamDescriptor_Copy), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_VideoStreamDescriptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoStreamDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoStreamDescriptor[] = {
        { "name", reinterpret_cast<getter>(VideoStreamDescriptor_get_Name), reinterpret_cast<setter>(VideoStreamDescriptor_put_Name), nullptr, nullptr },
        { "language", reinterpret_cast<getter>(VideoStreamDescriptor_get_Language), reinterpret_cast<setter>(VideoStreamDescriptor_put_Language), nullptr, nullptr },
        { "is_selected", reinterpret_cast<getter>(VideoStreamDescriptor_get_IsSelected), nullptr, nullptr, nullptr },
        { "label", reinterpret_cast<getter>(VideoStreamDescriptor_get_Label), reinterpret_cast<setter>(VideoStreamDescriptor_put_Label), nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(VideoStreamDescriptor_get_EncodingProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoStreamDescriptor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VideoStreamDescriptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VideoStreamDescriptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VideoStreamDescriptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VideoStreamDescriptor) },
        { },
    };

    static PyType_Spec type_spec_VideoStreamDescriptor =
    {
        "_winrt_windows_media_core.VideoStreamDescriptor",
        sizeof(py::wrapper::Windows::Media::Core::VideoStreamDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoStreamDescriptor
    };

    // ----- VideoTrack class --------------------
    static constexpr const char* const type_name_VideoTrack = "VideoTrack";

    static PyObject* _new_VideoTrack(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_VideoTrack);
        return nullptr;
    }

    static void _dealloc_VideoTrack(py::wrapper::Windows::Media::Core::VideoTrack* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoTrack_GetEncodingProperties(py::wrapper::Windows::Media::Core::VideoTrack* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.VideoTrack", L"GetEncodingProperties", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetEncodingProperties());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoTrack_get_Label(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoTrack", L"Label"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTrack_put_Label(py::wrapper::Windows::Media::Core::VideoTrack* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoTrack", L"Label"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTrack_get_Id(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoTrack", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_get_Language(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoTrack", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_get_TrackKind(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoTrack", L"TrackKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TrackKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_get_Name(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoTrack", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_get_PlaybackItem(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoTrack", L"PlaybackItem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlaybackItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_get_SupportInfo(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoTrack", L"SupportInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_add_OpenFailed(py::wrapper::Windows::Media::Core::VideoTrack* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.VideoTrack", L"OpenFailed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::VideoTrack, winrt::Windows::Media::Core::VideoTrackOpenFailedEventArgs>>(arg);

            return py::convert(self->obj.OpenFailed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_remove_OpenFailed(py::wrapper::Windows::Media::Core::VideoTrack* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.VideoTrack", L"OpenFailed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.OpenFailed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VideoTrack(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::VideoTrack>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VideoTrack(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoTrack>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoTrack[] = {
        { "get_encoding_properties", reinterpret_cast<PyCFunction>(VideoTrack_GetEncodingProperties), METH_VARARGS, nullptr },
        { "add_open_failed", reinterpret_cast<PyCFunction>(VideoTrack_add_OpenFailed), METH_O, nullptr },
        { "remove_open_failed", reinterpret_cast<PyCFunction>(VideoTrack_remove_OpenFailed), METH_O, nullptr },
        { "_assign_array_", _assign_array_VideoTrack, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoTrack), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoTrack[] = {
        { "label", reinterpret_cast<getter>(VideoTrack_get_Label), reinterpret_cast<setter>(VideoTrack_put_Label), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(VideoTrack_get_Id), nullptr, nullptr, nullptr },
        { "language", reinterpret_cast<getter>(VideoTrack_get_Language), nullptr, nullptr, nullptr },
        { "track_kind", reinterpret_cast<getter>(VideoTrack_get_TrackKind), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(VideoTrack_get_Name), nullptr, nullptr, nullptr },
        { "playback_item", reinterpret_cast<getter>(VideoTrack_get_PlaybackItem), nullptr, nullptr, nullptr },
        { "support_info", reinterpret_cast<getter>(VideoTrack_get_SupportInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoTrack[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VideoTrack) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VideoTrack) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VideoTrack) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VideoTrack) },
        { },
    };

    static PyType_Spec type_spec_VideoTrack =
    {
        "_winrt_windows_media_core.VideoTrack",
        sizeof(py::wrapper::Windows::Media::Core::VideoTrack),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoTrack
    };

    // ----- VideoTrackOpenFailedEventArgs class --------------------
    static constexpr const char* const type_name_VideoTrackOpenFailedEventArgs = "VideoTrackOpenFailedEventArgs";

    static PyObject* _new_VideoTrackOpenFailedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_VideoTrackOpenFailedEventArgs);
        return nullptr;
    }

    static void _dealloc_VideoTrackOpenFailedEventArgs(py::wrapper::Windows::Media::Core::VideoTrackOpenFailedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoTrackOpenFailedEventArgs_get_ExtendedError(py::wrapper::Windows::Media::Core::VideoTrackOpenFailedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoTrackOpenFailedEventArgs", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VideoTrackOpenFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::VideoTrackOpenFailedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VideoTrackOpenFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoTrackOpenFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoTrackOpenFailedEventArgs[] = {
        { "_assign_array_", _assign_array_VideoTrackOpenFailedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoTrackOpenFailedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoTrackOpenFailedEventArgs[] = {
        { "extended_error", reinterpret_cast<getter>(VideoTrackOpenFailedEventArgs_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoTrackOpenFailedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VideoTrackOpenFailedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VideoTrackOpenFailedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VideoTrackOpenFailedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VideoTrackOpenFailedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_VideoTrackOpenFailedEventArgs =
    {
        "_winrt_windows_media_core.VideoTrackOpenFailedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::VideoTrackOpenFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoTrackOpenFailedEventArgs
    };

    // ----- VideoTrackSupportInfo class --------------------
    static constexpr const char* const type_name_VideoTrackSupportInfo = "VideoTrackSupportInfo";

    static PyObject* _new_VideoTrackSupportInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_VideoTrackSupportInfo);
        return nullptr;
    }

    static void _dealloc_VideoTrackSupportInfo(py::wrapper::Windows::Media::Core::VideoTrackSupportInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoTrackSupportInfo_get_DecoderStatus(py::wrapper::Windows::Media::Core::VideoTrackSupportInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoTrackSupportInfo", L"DecoderStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DecoderStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrackSupportInfo_get_MediaSourceStatus(py::wrapper::Windows::Media::Core::VideoTrackSupportInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoTrackSupportInfo", L"MediaSourceStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MediaSourceStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VideoTrackSupportInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::VideoTrackSupportInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VideoTrackSupportInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoTrackSupportInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoTrackSupportInfo[] = {
        { "_assign_array_", _assign_array_VideoTrackSupportInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoTrackSupportInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoTrackSupportInfo[] = {
        { "decoder_status", reinterpret_cast<getter>(VideoTrackSupportInfo_get_DecoderStatus), nullptr, nullptr, nullptr },
        { "media_source_status", reinterpret_cast<getter>(VideoTrackSupportInfo_get_MediaSourceStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoTrackSupportInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VideoTrackSupportInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VideoTrackSupportInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VideoTrackSupportInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VideoTrackSupportInfo) },
        { },
    };

    static PyType_Spec type_spec_VideoTrackSupportInfo =
    {
        "_winrt_windows_media_core.VideoTrackSupportInfo",
        sizeof(py::wrapper::Windows::Media::Core::VideoTrackSupportInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoTrackSupportInfo
    };

    // ----- IMediaCue interface --------------------
    static constexpr const char* const type_name_IMediaCue = "IMediaCue";

    static PyObject* _new_IMediaCue(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IMediaCue);
        return nullptr;
    }

    static void _dealloc_IMediaCue(py::wrapper::Windows::Media::Core::IMediaCue* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMediaCue_get_Duration(py::wrapper::Windows::Media::Core::IMediaCue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaCue", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaCue_put_Duration(py::wrapper::Windows::Media::Core::IMediaCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaCue", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaCue_get_Id(py::wrapper::Windows::Media::Core::IMediaCue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaCue", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaCue_put_Id(py::wrapper::Windows::Media::Core::IMediaCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaCue", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaCue_get_StartTime(py::wrapper::Windows::Media::Core::IMediaCue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaCue", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaCue_put_StartTime(py::wrapper::Windows::Media::Core::IMediaCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaCue", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IMediaCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::IMediaCue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IMediaCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::IMediaCue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaCue[] = {
        { "_assign_array_", _assign_array_IMediaCue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IMediaCue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMediaCue[] = {
        { "duration", reinterpret_cast<getter>(IMediaCue_get_Duration), reinterpret_cast<setter>(IMediaCue_put_Duration), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(IMediaCue_get_Id), reinterpret_cast<setter>(IMediaCue_put_Id), nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(IMediaCue_get_StartTime), reinterpret_cast<setter>(IMediaCue_put_StartTime), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IMediaCue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IMediaCue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IMediaCue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IMediaCue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IMediaCue) },
        { },
    };

    static PyType_Spec type_spec_IMediaCue =
    {
        "_winrt_windows_media_core.IMediaCue",
        sizeof(py::wrapper::Windows::Media::Core::IMediaCue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaCue
    };

    // ----- IMediaSource interface --------------------
    static constexpr const char* const type_name_IMediaSource = "IMediaSource";

    static PyObject* _new_IMediaSource(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IMediaSource);
        return nullptr;
    }

    static void _dealloc_IMediaSource(py::wrapper::Windows::Media::Core::IMediaSource* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_IMediaSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::IMediaSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IMediaSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::IMediaSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaSource[] = {
        { "_assign_array_", _assign_array_IMediaSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IMediaSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMediaSource[] = {
        { }
    };

    static PyType_Slot _type_slots_IMediaSource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IMediaSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IMediaSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IMediaSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IMediaSource) },
        { },
    };

    static PyType_Spec type_spec_IMediaSource =
    {
        "_winrt_windows_media_core.IMediaSource",
        sizeof(py::wrapper::Windows::Media::Core::IMediaSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaSource
    };

    // ----- IMediaStreamDescriptor interface --------------------
    static constexpr const char* const type_name_IMediaStreamDescriptor = "IMediaStreamDescriptor";

    static PyObject* _new_IMediaStreamDescriptor(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IMediaStreamDescriptor);
        return nullptr;
    }

    static void _dealloc_IMediaStreamDescriptor(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMediaStreamDescriptor_get_IsSelected(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaStreamDescriptor", L"IsSelected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMediaStreamDescriptor_get_Language(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaStreamDescriptor", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaStreamDescriptor_put_Language(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaStreamDescriptor", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaStreamDescriptor_get_Name(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaStreamDescriptor", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaStreamDescriptor_put_Name(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaStreamDescriptor", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IMediaStreamDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::IMediaStreamDescriptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IMediaStreamDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::IMediaStreamDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaStreamDescriptor[] = {
        { "_assign_array_", _assign_array_IMediaStreamDescriptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IMediaStreamDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMediaStreamDescriptor[] = {
        { "is_selected", reinterpret_cast<getter>(IMediaStreamDescriptor_get_IsSelected), nullptr, nullptr, nullptr },
        { "language", reinterpret_cast<getter>(IMediaStreamDescriptor_get_Language), reinterpret_cast<setter>(IMediaStreamDescriptor_put_Language), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(IMediaStreamDescriptor_get_Name), reinterpret_cast<setter>(IMediaStreamDescriptor_put_Name), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IMediaStreamDescriptor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IMediaStreamDescriptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IMediaStreamDescriptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IMediaStreamDescriptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IMediaStreamDescriptor) },
        { },
    };

    static PyType_Spec type_spec_IMediaStreamDescriptor =
    {
        "_winrt_windows_media_core.IMediaStreamDescriptor",
        sizeof(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaStreamDescriptor
    };

    // ----- IMediaStreamDescriptor2 interface --------------------
    static constexpr const char* const type_name_IMediaStreamDescriptor2 = "IMediaStreamDescriptor2";

    static PyObject* _new_IMediaStreamDescriptor2(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IMediaStreamDescriptor2);
        return nullptr;
    }

    static void _dealloc_IMediaStreamDescriptor2(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMediaStreamDescriptor2_get_Label(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaStreamDescriptor2", L"Label"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaStreamDescriptor2_put_Label(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaStreamDescriptor2", L"Label"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaStreamDescriptor2_get_IsSelected(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaStreamDescriptor", L"IsSelected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMediaStreamDescriptor2_get_Language(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaStreamDescriptor", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaStreamDescriptor2_put_Language(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaStreamDescriptor", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaStreamDescriptor2_get_Name(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaStreamDescriptor", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaStreamDescriptor2_put_Name(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaStreamDescriptor", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IMediaStreamDescriptor2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::IMediaStreamDescriptor2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IMediaStreamDescriptor2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::IMediaStreamDescriptor2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaStreamDescriptor2[] = {
        { "_assign_array_", _assign_array_IMediaStreamDescriptor2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IMediaStreamDescriptor2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMediaStreamDescriptor2[] = {
        { "label", reinterpret_cast<getter>(IMediaStreamDescriptor2_get_Label), reinterpret_cast<setter>(IMediaStreamDescriptor2_put_Label), nullptr, nullptr },
        { "is_selected", reinterpret_cast<getter>(IMediaStreamDescriptor2_get_IsSelected), nullptr, nullptr, nullptr },
        { "language", reinterpret_cast<getter>(IMediaStreamDescriptor2_get_Language), reinterpret_cast<setter>(IMediaStreamDescriptor2_put_Language), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(IMediaStreamDescriptor2_get_Name), reinterpret_cast<setter>(IMediaStreamDescriptor2_put_Name), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IMediaStreamDescriptor2[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IMediaStreamDescriptor2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IMediaStreamDescriptor2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IMediaStreamDescriptor2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IMediaStreamDescriptor2) },
        { },
    };

    static PyType_Spec type_spec_IMediaStreamDescriptor2 =
    {
        "_winrt_windows_media_core.IMediaStreamDescriptor2",
        sizeof(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaStreamDescriptor2
    };

    // ----- IMediaTrack interface --------------------
    static constexpr const char* const type_name_IMediaTrack = "IMediaTrack";

    static PyObject* _new_IMediaTrack(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IMediaTrack);
        return nullptr;
    }

    static void _dealloc_IMediaTrack(py::wrapper::Windows::Media::Core::IMediaTrack* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMediaTrack_get_Id(py::wrapper::Windows::Media::Core::IMediaTrack* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaTrack", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMediaTrack_get_Label(py::wrapper::Windows::Media::Core::IMediaTrack* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaTrack", L"Label"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaTrack_put_Label(py::wrapper::Windows::Media::Core::IMediaTrack* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaTrack", L"Label"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaTrack_get_Language(py::wrapper::Windows::Media::Core::IMediaTrack* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaTrack", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMediaTrack_get_TrackKind(py::wrapper::Windows::Media::Core::IMediaTrack* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaTrack", L"TrackKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TrackKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IMediaTrack(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::IMediaTrack>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IMediaTrack(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::IMediaTrack>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaTrack[] = {
        { "_assign_array_", _assign_array_IMediaTrack, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IMediaTrack), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMediaTrack[] = {
        { "id", reinterpret_cast<getter>(IMediaTrack_get_Id), nullptr, nullptr, nullptr },
        { "label", reinterpret_cast<getter>(IMediaTrack_get_Label), reinterpret_cast<setter>(IMediaTrack_put_Label), nullptr, nullptr },
        { "language", reinterpret_cast<getter>(IMediaTrack_get_Language), nullptr, nullptr, nullptr },
        { "track_kind", reinterpret_cast<getter>(IMediaTrack_get_TrackKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IMediaTrack[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IMediaTrack) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IMediaTrack) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IMediaTrack) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IMediaTrack) },
        { },
    };

    static PyType_Spec type_spec_IMediaTrack =
    {
        "_winrt_windows_media_core.IMediaTrack",
        sizeof(py::wrapper::Windows::Media::Core::IMediaTrack),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaTrack
    };

    // ----- ISingleSelectMediaTrackList interface --------------------
    static constexpr const char* const type_name_ISingleSelectMediaTrackList = "ISingleSelectMediaTrackList";

    static PyObject* _new_ISingleSelectMediaTrackList(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_ISingleSelectMediaTrackList);
        return nullptr;
    }

    static void _dealloc_ISingleSelectMediaTrackList(py::wrapper::Windows::Media::Core::ISingleSelectMediaTrackList* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISingleSelectMediaTrackList_get_SelectedIndex(py::wrapper::Windows::Media::Core::ISingleSelectMediaTrackList* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ISingleSelectMediaTrackList", L"SelectedIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISingleSelectMediaTrackList_put_SelectedIndex(py::wrapper::Windows::Media::Core::ISingleSelectMediaTrackList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ISingleSelectMediaTrackList", L"SelectedIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.SelectedIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ISingleSelectMediaTrackList_add_SelectedIndexChanged(py::wrapper::Windows::Media::Core::ISingleSelectMediaTrackList* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.ISingleSelectMediaTrackList", L"SelectedIndexChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::ISingleSelectMediaTrackList, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SelectedIndexChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISingleSelectMediaTrackList_remove_SelectedIndexChanged(py::wrapper::Windows::Media::Core::ISingleSelectMediaTrackList* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.ISingleSelectMediaTrackList", L"SelectedIndexChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SelectedIndexChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ISingleSelectMediaTrackList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::ISingleSelectMediaTrackList>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISingleSelectMediaTrackList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::ISingleSelectMediaTrackList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISingleSelectMediaTrackList[] = {
        { "add_selected_index_changed", reinterpret_cast<PyCFunction>(ISingleSelectMediaTrackList_add_SelectedIndexChanged), METH_O, nullptr },
        { "remove_selected_index_changed", reinterpret_cast<PyCFunction>(ISingleSelectMediaTrackList_remove_SelectedIndexChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ISingleSelectMediaTrackList, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISingleSelectMediaTrackList), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISingleSelectMediaTrackList[] = {
        { "selected_index", reinterpret_cast<getter>(ISingleSelectMediaTrackList_get_SelectedIndex), reinterpret_cast<setter>(ISingleSelectMediaTrackList_put_SelectedIndex), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ISingleSelectMediaTrackList[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISingleSelectMediaTrackList) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISingleSelectMediaTrackList) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISingleSelectMediaTrackList) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISingleSelectMediaTrackList) },
        { },
    };

    static PyType_Spec type_spec_ISingleSelectMediaTrackList =
    {
        "_winrt_windows_media_core.ISingleSelectMediaTrackList",
        sizeof(py::wrapper::Windows::Media::Core::ISingleSelectMediaTrackList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISingleSelectMediaTrackList
    };

    // ----- ITimedMetadataTrackProvider interface --------------------
    static constexpr const char* const type_name_ITimedMetadataTrackProvider = "ITimedMetadataTrackProvider";

    static PyObject* _new_ITimedMetadataTrackProvider(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_ITimedMetadataTrackProvider);
        return nullptr;
    }

    static void _dealloc_ITimedMetadataTrackProvider(py::wrapper::Windows::Media::Core::ITimedMetadataTrackProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ITimedMetadataTrackProvider_get_TimedMetadataTracks(py::wrapper::Windows::Media::Core::ITimedMetadataTrackProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ITimedMetadataTrackProvider", L"TimedMetadataTracks"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimedMetadataTracks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ITimedMetadataTrackProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::ITimedMetadataTrackProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ITimedMetadataTrackProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::ITimedMetadataTrackProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITimedMetadataTrackProvider[] = {
        { "_assign_array_", _assign_array_ITimedMetadataTrackProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ITimedMetadataTrackProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ITimedMetadataTrackProvider[] = {
        { "timed_metadata_tracks", reinterpret_cast<getter>(ITimedMetadataTrackProvider_get_TimedMetadataTracks), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ITimedMetadataTrackProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ITimedMetadataTrackProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ITimedMetadataTrackProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ITimedMetadataTrackProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ITimedMetadataTrackProvider) },
        { },
    };

    static PyType_Spec type_spec_ITimedMetadataTrackProvider =
    {
        "_winrt_windows_media_core.ITimedMetadataTrackProvider",
        sizeof(py::wrapper::Windows::Media::Core::ITimedMetadataTrackProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITimedMetadataTrackProvider
    };

    // ----- MseTimeRange struct --------------------
    static constexpr const char* const type_name_MseTimeRange = "MseTimeRange";

    PyObject* _new_MseTimeRange(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Media::Core::MseTimeRange return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        PyObject* _Start{};
        PyObject* _End{};

        static const char* kwlist[] = {"start", "end", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "OO", const_cast<char**>(kwlist), &_Start, &_End))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Media::Core::MseTimeRange return_value{ py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(_Start), py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(_End) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_MseTimeRange(py::wrapper::Windows::Media::Core::MseTimeRange* self) noexcept
    {
    }

    static PyObject* MseTimeRange_get_Start(py::wrapper::Windows::Media::Core::MseTimeRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Start);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseTimeRange_set_Start(py::wrapper::Windows::Media::Core::MseTimeRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Start = py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseTimeRange_get_End(py::wrapper::Windows::Media::Core::MseTimeRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.End);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseTimeRange_set_End(py::wrapper::Windows::Media::Core::MseTimeRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.End = py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_MseTimeRange[] = {
        { "start", reinterpret_cast<getter>(MseTimeRange_get_Start), reinterpret_cast<setter>(MseTimeRange_set_Start), nullptr, nullptr },
        { "end", reinterpret_cast<getter>(MseTimeRange_get_End), reinterpret_cast<setter>(MseTimeRange_set_End), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MseTimeRange[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MseTimeRange) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MseTimeRange) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MseTimeRange) },
        { },
    };

    static PyType_Spec type_spec_MseTimeRange =
    {
        "_winrt_windows_media_core.MseTimeRange",
        sizeof(py::wrapper::Windows::Media::Core::MseTimeRange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MseTimeRange
    };

    // ----- TimedTextDouble struct --------------------
    static constexpr const char* const type_name_TimedTextDouble = "TimedTextDouble";

    PyObject* _new_TimedTextDouble(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextDouble return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        double _Value{};
        int32_t _Unit{};

        static const char* kwlist[] = {"value", "unit", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "di", const_cast<char**>(kwlist), &_Value, &_Unit))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Media::Core::TimedTextDouble return_value{ _Value, static_cast<winrt::Windows::Media::Core::TimedTextUnit>(_Unit) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_TimedTextDouble(py::wrapper::Windows::Media::Core::TimedTextDouble* self) noexcept
    {
    }

    static PyObject* TimedTextDouble_get_Value(py::wrapper::Windows::Media::Core::TimedTextDouble* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextDouble_set_Value(py::wrapper::Windows::Media::Core::TimedTextDouble* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Value = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextDouble_get_Unit(py::wrapper::Windows::Media::Core::TimedTextDouble* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Unit);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextDouble_set_Unit(py::wrapper::Windows::Media::Core::TimedTextDouble* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Unit = py::converter<winrt::Windows::Media::Core::TimedTextUnit>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_TimedTextDouble[] = {
        { "value", reinterpret_cast<getter>(TimedTextDouble_get_Value), reinterpret_cast<setter>(TimedTextDouble_set_Value), nullptr, nullptr },
        { "unit", reinterpret_cast<getter>(TimedTextDouble_get_Unit), reinterpret_cast<setter>(TimedTextDouble_set_Unit), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextDouble[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedTextDouble) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedTextDouble) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedTextDouble) },
        { },
    };

    static PyType_Spec type_spec_TimedTextDouble =
    {
        "_winrt_windows_media_core.TimedTextDouble",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextDouble),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextDouble
    };

    // ----- TimedTextPadding struct --------------------
    static constexpr const char* const type_name_TimedTextPadding = "TimedTextPadding";

    PyObject* _new_TimedTextPadding(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextPadding return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        double _Before{};
        double _After{};
        double _Start{};
        double _End{};
        int32_t _Unit{};

        static const char* kwlist[] = {"before", "after", "start", "end", "unit", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ddddi", const_cast<char**>(kwlist), &_Before, &_After, &_Start, &_End, &_Unit))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Media::Core::TimedTextPadding return_value{ _Before, _After, _Start, _End, static_cast<winrt::Windows::Media::Core::TimedTextUnit>(_Unit) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_TimedTextPadding(py::wrapper::Windows::Media::Core::TimedTextPadding* self) noexcept
    {
    }

    static PyObject* TimedTextPadding_get_Before(py::wrapper::Windows::Media::Core::TimedTextPadding* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Before);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPadding_set_Before(py::wrapper::Windows::Media::Core::TimedTextPadding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Before = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextPadding_get_After(py::wrapper::Windows::Media::Core::TimedTextPadding* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.After);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPadding_set_After(py::wrapper::Windows::Media::Core::TimedTextPadding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.After = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextPadding_get_Start(py::wrapper::Windows::Media::Core::TimedTextPadding* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Start);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPadding_set_Start(py::wrapper::Windows::Media::Core::TimedTextPadding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Start = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextPadding_get_End(py::wrapper::Windows::Media::Core::TimedTextPadding* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.End);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPadding_set_End(py::wrapper::Windows::Media::Core::TimedTextPadding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.End = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextPadding_get_Unit(py::wrapper::Windows::Media::Core::TimedTextPadding* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Unit);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPadding_set_Unit(py::wrapper::Windows::Media::Core::TimedTextPadding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Unit = py::converter<winrt::Windows::Media::Core::TimedTextUnit>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_TimedTextPadding[] = {
        { "before", reinterpret_cast<getter>(TimedTextPadding_get_Before), reinterpret_cast<setter>(TimedTextPadding_set_Before), nullptr, nullptr },
        { "after", reinterpret_cast<getter>(TimedTextPadding_get_After), reinterpret_cast<setter>(TimedTextPadding_set_After), nullptr, nullptr },
        { "start", reinterpret_cast<getter>(TimedTextPadding_get_Start), reinterpret_cast<setter>(TimedTextPadding_set_Start), nullptr, nullptr },
        { "end", reinterpret_cast<getter>(TimedTextPadding_get_End), reinterpret_cast<setter>(TimedTextPadding_set_End), nullptr, nullptr },
        { "unit", reinterpret_cast<getter>(TimedTextPadding_get_Unit), reinterpret_cast<setter>(TimedTextPadding_set_Unit), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextPadding[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedTextPadding) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedTextPadding) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedTextPadding) },
        { },
    };

    static PyType_Spec type_spec_TimedTextPadding =
    {
        "_winrt_windows_media_core.TimedTextPadding",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextPadding),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextPadding
    };

    // ----- TimedTextPoint struct --------------------
    static constexpr const char* const type_name_TimedTextPoint = "TimedTextPoint";

    PyObject* _new_TimedTextPoint(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextPoint return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        double _X{};
        double _Y{};
        int32_t _Unit{};

        static const char* kwlist[] = {"x", "y", "unit", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ddi", const_cast<char**>(kwlist), &_X, &_Y, &_Unit))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Media::Core::TimedTextPoint return_value{ _X, _Y, static_cast<winrt::Windows::Media::Core::TimedTextUnit>(_Unit) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_TimedTextPoint(py::wrapper::Windows::Media::Core::TimedTextPoint* self) noexcept
    {
    }

    static PyObject* TimedTextPoint_get_X(py::wrapper::Windows::Media::Core::TimedTextPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.X);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPoint_set_X(py::wrapper::Windows::Media::Core::TimedTextPoint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.X = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextPoint_get_Y(py::wrapper::Windows::Media::Core::TimedTextPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPoint_set_Y(py::wrapper::Windows::Media::Core::TimedTextPoint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Y = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextPoint_get_Unit(py::wrapper::Windows::Media::Core::TimedTextPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Unit);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPoint_set_Unit(py::wrapper::Windows::Media::Core::TimedTextPoint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Unit = py::converter<winrt::Windows::Media::Core::TimedTextUnit>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_TimedTextPoint[] = {
        { "x", reinterpret_cast<getter>(TimedTextPoint_get_X), reinterpret_cast<setter>(TimedTextPoint_set_X), nullptr, nullptr },
        { "y", reinterpret_cast<getter>(TimedTextPoint_get_Y), reinterpret_cast<setter>(TimedTextPoint_set_Y), nullptr, nullptr },
        { "unit", reinterpret_cast<getter>(TimedTextPoint_get_Unit), reinterpret_cast<setter>(TimedTextPoint_set_Unit), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextPoint[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedTextPoint) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedTextPoint) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedTextPoint) },
        { },
    };

    static PyType_Spec type_spec_TimedTextPoint =
    {
        "_winrt_windows_media_core.TimedTextPoint",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextPoint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextPoint
    };

    // ----- TimedTextSize struct --------------------
    static constexpr const char* const type_name_TimedTextSize = "TimedTextSize";

    PyObject* _new_TimedTextSize(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextSize return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        double _Height{};
        double _Width{};
        int32_t _Unit{};

        static const char* kwlist[] = {"height", "width", "unit", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ddi", const_cast<char**>(kwlist), &_Height, &_Width, &_Unit))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Media::Core::TimedTextSize return_value{ _Height, _Width, static_cast<winrt::Windows::Media::Core::TimedTextUnit>(_Unit) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_TimedTextSize(py::wrapper::Windows::Media::Core::TimedTextSize* self) noexcept
    {
    }

    static PyObject* TimedTextSize_get_Height(py::wrapper::Windows::Media::Core::TimedTextSize* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextSize_set_Height(py::wrapper::Windows::Media::Core::TimedTextSize* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Height = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextSize_get_Width(py::wrapper::Windows::Media::Core::TimedTextSize* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextSize_set_Width(py::wrapper::Windows::Media::Core::TimedTextSize* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Width = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextSize_get_Unit(py::wrapper::Windows::Media::Core::TimedTextSize* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Unit);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextSize_set_Unit(py::wrapper::Windows::Media::Core::TimedTextSize* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Unit = py::converter<winrt::Windows::Media::Core::TimedTextUnit>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_TimedTextSize[] = {
        { "height", reinterpret_cast<getter>(TimedTextSize_get_Height), reinterpret_cast<setter>(TimedTextSize_set_Height), nullptr, nullptr },
        { "width", reinterpret_cast<getter>(TimedTextSize_get_Width), reinterpret_cast<setter>(TimedTextSize_set_Width), nullptr, nullptr },
        { "unit", reinterpret_cast<getter>(TimedTextSize_get_Unit), reinterpret_cast<setter>(TimedTextSize_set_Unit), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextSize[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedTextSize) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedTextSize) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedTextSize) },
        { },
    };

    static PyType_Spec type_spec_TimedTextSize =
    {
        "_winrt_windows_media_core.TimedTextSize",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextSize),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextSize
    };

    // ----- Windows.Media.Core Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Media::Core");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_media_core",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Media::Core

PyMODINIT_FUNC PyInit__winrt_windows_media_core(void) noexcept
{
    using namespace py::cpp::Windows::Media::Core;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_AudioStreamDescriptor, &type_spec_AudioStreamDescriptor, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_AudioStreamDescriptor, &type_spec_AudioStreamDescriptor, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_AudioTrack, &type_spec_AudioTrack, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_AudioTrack, &type_spec_AudioTrack, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_AudioTrackOpenFailedEventArgs, &type_spec_AudioTrackOpenFailedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_AudioTrackOpenFailedEventArgs, &type_spec_AudioTrackOpenFailedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_AudioTrackSupportInfo, &type_spec_AudioTrackSupportInfo, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_AudioTrackSupportInfo, &type_spec_AudioTrackSupportInfo, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ChapterCue, &type_spec_ChapterCue, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ChapterCue, &type_spec_ChapterCue, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_CodecInfo, &type_spec_CodecInfo, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_CodecInfo, &type_spec_CodecInfo, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_CodecQuery, &type_spec_CodecQuery, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_CodecQuery, &type_spec_CodecQuery, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_CodecSubtypes_Meta{PyType_FromSpec(&type_spec_CodecSubtypes_Meta)};
    if (!type_CodecSubtypes_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_CodecSubtypes, &type_spec_CodecSubtypes, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CodecSubtypes_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_CodecSubtypes, &type_spec_CodecSubtypes, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CodecSubtypes_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_DataCue, &type_spec_DataCue, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_DataCue, &type_spec_DataCue, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_FaceDetectedEventArgs, &type_spec_FaceDetectedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_FaceDetectedEventArgs, &type_spec_FaceDetectedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_FaceDetectionEffect, &type_spec_FaceDetectionEffect, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_FaceDetectionEffect, &type_spec_FaceDetectionEffect, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_FaceDetectionEffectDefinition, &type_spec_FaceDetectionEffectDefinition, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_FaceDetectionEffectDefinition, &type_spec_FaceDetectionEffectDefinition, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_FaceDetectionEffectFrame, &type_spec_FaceDetectionEffectFrame, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_FaceDetectionEffectFrame, &type_spec_FaceDetectionEffectFrame, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_HighDynamicRangeControl, &type_spec_HighDynamicRangeControl, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_HighDynamicRangeControl, &type_spec_HighDynamicRangeControl, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_HighDynamicRangeOutput, &type_spec_HighDynamicRangeOutput, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_HighDynamicRangeOutput, &type_spec_HighDynamicRangeOutput, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ImageCue, &type_spec_ImageCue, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ImageCue, &type_spec_ImageCue, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_InitializeMediaStreamSourceRequestedEventArgs, &type_spec_InitializeMediaStreamSourceRequestedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_InitializeMediaStreamSourceRequestedEventArgs, &type_spec_InitializeMediaStreamSourceRequestedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_LowLightFusion_Meta{PyType_FromSpec(&type_spec_LowLightFusion_Meta)};
    if (!type_LowLightFusion_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_LowLightFusion, &type_spec_LowLightFusion, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_LowLightFusion_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_LowLightFusion, &type_spec_LowLightFusion, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_LowLightFusion_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_LowLightFusionResult, &type_spec_LowLightFusionResult, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_LowLightFusionResult, &type_spec_LowLightFusionResult, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MediaBinder, &type_spec_MediaBinder, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MediaBinder, &type_spec_MediaBinder, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MediaBindingEventArgs, &type_spec_MediaBindingEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MediaBindingEventArgs, &type_spec_MediaBindingEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MediaCueEventArgs, &type_spec_MediaCueEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MediaCueEventArgs, &type_spec_MediaCueEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MediaSource, &type_spec_MediaSource, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MediaSource, &type_spec_MediaSource, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MediaSourceAppServiceConnection, &type_spec_MediaSourceAppServiceConnection, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MediaSourceAppServiceConnection, &type_spec_MediaSourceAppServiceConnection, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MediaSourceError, &type_spec_MediaSourceError, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MediaSourceError, &type_spec_MediaSourceError, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MediaSourceOpenOperationCompletedEventArgs, &type_spec_MediaSourceOpenOperationCompletedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MediaSourceOpenOperationCompletedEventArgs, &type_spec_MediaSourceOpenOperationCompletedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MediaSourceStateChangedEventArgs, &type_spec_MediaSourceStateChangedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MediaSourceStateChangedEventArgs, &type_spec_MediaSourceStateChangedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MediaStreamSample, &type_spec_MediaStreamSample, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MediaStreamSample, &type_spec_MediaStreamSample, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MediaStreamSamplePropertySet, &type_spec_MediaStreamSamplePropertySet, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MediaStreamSamplePropertySet, &type_spec_MediaStreamSamplePropertySet, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MediaStreamSampleProtectionProperties, &type_spec_MediaStreamSampleProtectionProperties, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MediaStreamSampleProtectionProperties, &type_spec_MediaStreamSampleProtectionProperties, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MediaStreamSource, &type_spec_MediaStreamSource, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MediaStreamSource, &type_spec_MediaStreamSource, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MediaStreamSourceClosedEventArgs, &type_spec_MediaStreamSourceClosedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MediaStreamSourceClosedEventArgs, &type_spec_MediaStreamSourceClosedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MediaStreamSourceClosedRequest, &type_spec_MediaStreamSourceClosedRequest, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MediaStreamSourceClosedRequest, &type_spec_MediaStreamSourceClosedRequest, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MediaStreamSourceSampleRenderedEventArgs, &type_spec_MediaStreamSourceSampleRenderedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MediaStreamSourceSampleRenderedEventArgs, &type_spec_MediaStreamSourceSampleRenderedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MediaStreamSourceSampleRequest, &type_spec_MediaStreamSourceSampleRequest, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MediaStreamSourceSampleRequest, &type_spec_MediaStreamSourceSampleRequest, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MediaStreamSourceSampleRequestDeferral, &type_spec_MediaStreamSourceSampleRequestDeferral, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MediaStreamSourceSampleRequestDeferral, &type_spec_MediaStreamSourceSampleRequestDeferral, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MediaStreamSourceSampleRequestedEventArgs, &type_spec_MediaStreamSourceSampleRequestedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MediaStreamSourceSampleRequestedEventArgs, &type_spec_MediaStreamSourceSampleRequestedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MediaStreamSourceStartingEventArgs, &type_spec_MediaStreamSourceStartingEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MediaStreamSourceStartingEventArgs, &type_spec_MediaStreamSourceStartingEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MediaStreamSourceStartingRequest, &type_spec_MediaStreamSourceStartingRequest, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MediaStreamSourceStartingRequest, &type_spec_MediaStreamSourceStartingRequest, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MediaStreamSourceStartingRequestDeferral, &type_spec_MediaStreamSourceStartingRequestDeferral, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MediaStreamSourceStartingRequestDeferral, &type_spec_MediaStreamSourceStartingRequestDeferral, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MediaStreamSourceSwitchStreamsRequest, &type_spec_MediaStreamSourceSwitchStreamsRequest, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MediaStreamSourceSwitchStreamsRequest, &type_spec_MediaStreamSourceSwitchStreamsRequest, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MediaStreamSourceSwitchStreamsRequestDeferral, &type_spec_MediaStreamSourceSwitchStreamsRequestDeferral, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MediaStreamSourceSwitchStreamsRequestDeferral, &type_spec_MediaStreamSourceSwitchStreamsRequestDeferral, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MediaStreamSourceSwitchStreamsRequestedEventArgs, &type_spec_MediaStreamSourceSwitchStreamsRequestedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MediaStreamSourceSwitchStreamsRequestedEventArgs, &type_spec_MediaStreamSourceSwitchStreamsRequestedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MseSourceBuffer, &type_spec_MseSourceBuffer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MseSourceBuffer, &type_spec_MseSourceBuffer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MseSourceBufferList, &type_spec_MseSourceBufferList, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MseSourceBufferList, &type_spec_MseSourceBufferList, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MseStreamSource, &type_spec_MseStreamSource, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MseStreamSource, &type_spec_MseStreamSource, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_SceneAnalysisEffect, &type_spec_SceneAnalysisEffect, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_SceneAnalysisEffect, &type_spec_SceneAnalysisEffect, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_SceneAnalysisEffectDefinition, &type_spec_SceneAnalysisEffectDefinition, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_SceneAnalysisEffectDefinition, &type_spec_SceneAnalysisEffectDefinition, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_SceneAnalysisEffectFrame, &type_spec_SceneAnalysisEffectFrame, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_SceneAnalysisEffectFrame, &type_spec_SceneAnalysisEffectFrame, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_SceneAnalyzedEventArgs, &type_spec_SceneAnalyzedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_SceneAnalyzedEventArgs, &type_spec_SceneAnalyzedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_SpeechCue, &type_spec_SpeechCue, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_SpeechCue, &type_spec_SpeechCue, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_TimedMetadataStreamDescriptor, &type_spec_TimedMetadataStreamDescriptor, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_TimedMetadataStreamDescriptor, &type_spec_TimedMetadataStreamDescriptor, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_TimedMetadataTrack, &type_spec_TimedMetadataTrack, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_TimedMetadataTrack, &type_spec_TimedMetadataTrack, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_TimedMetadataTrackError, &type_spec_TimedMetadataTrackError, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_TimedMetadataTrackError, &type_spec_TimedMetadataTrackError, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_TimedMetadataTrackFailedEventArgs, &type_spec_TimedMetadataTrackFailedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_TimedMetadataTrackFailedEventArgs, &type_spec_TimedMetadataTrackFailedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_TimedTextBouten, &type_spec_TimedTextBouten, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_TimedTextBouten, &type_spec_TimedTextBouten, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_TimedTextCue, &type_spec_TimedTextCue, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_TimedTextCue, &type_spec_TimedTextCue, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_TimedTextLine, &type_spec_TimedTextLine, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_TimedTextLine, &type_spec_TimedTextLine, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_TimedTextRegion, &type_spec_TimedTextRegion, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_TimedTextRegion, &type_spec_TimedTextRegion, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_TimedTextRuby, &type_spec_TimedTextRuby, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_TimedTextRuby, &type_spec_TimedTextRuby, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_TimedTextSource, &type_spec_TimedTextSource, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_TimedTextSource, &type_spec_TimedTextSource, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_TimedTextSourceResolveResultEventArgs, &type_spec_TimedTextSourceResolveResultEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_TimedTextSourceResolveResultEventArgs, &type_spec_TimedTextSourceResolveResultEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_TimedTextStyle, &type_spec_TimedTextStyle, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_TimedTextStyle, &type_spec_TimedTextStyle, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_TimedTextSubformat, &type_spec_TimedTextSubformat, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_TimedTextSubformat, &type_spec_TimedTextSubformat, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_VideoStabilizationEffect, &type_spec_VideoStabilizationEffect, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_VideoStabilizationEffect, &type_spec_VideoStabilizationEffect, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_VideoStabilizationEffectDefinition, &type_spec_VideoStabilizationEffectDefinition, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_VideoStabilizationEffectDefinition, &type_spec_VideoStabilizationEffectDefinition, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_VideoStabilizationEffectEnabledChangedEventArgs, &type_spec_VideoStabilizationEffectEnabledChangedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_VideoStabilizationEffectEnabledChangedEventArgs, &type_spec_VideoStabilizationEffectEnabledChangedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_VideoStreamDescriptor, &type_spec_VideoStreamDescriptor, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_VideoStreamDescriptor, &type_spec_VideoStreamDescriptor, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_VideoTrack, &type_spec_VideoTrack, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_VideoTrack, &type_spec_VideoTrack, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_VideoTrackOpenFailedEventArgs, &type_spec_VideoTrackOpenFailedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_VideoTrackOpenFailedEventArgs, &type_spec_VideoTrackOpenFailedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_VideoTrackSupportInfo, &type_spec_VideoTrackSupportInfo, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_VideoTrackSupportInfo, &type_spec_VideoTrackSupportInfo, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_IMediaCue, &type_spec_IMediaCue, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_IMediaCue, &type_spec_IMediaCue, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_IMediaSource, &type_spec_IMediaSource, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_IMediaSource, &type_spec_IMediaSource, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_IMediaStreamDescriptor, &type_spec_IMediaStreamDescriptor, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_IMediaStreamDescriptor, &type_spec_IMediaStreamDescriptor, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_IMediaStreamDescriptor2, &type_spec_IMediaStreamDescriptor2, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_IMediaStreamDescriptor2, &type_spec_IMediaStreamDescriptor2, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_IMediaTrack, &type_spec_IMediaTrack, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_IMediaTrack, &type_spec_IMediaTrack, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ISingleSelectMediaTrackList, &type_spec_ISingleSelectMediaTrackList, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ISingleSelectMediaTrackList, &type_spec_ISingleSelectMediaTrackList, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ITimedMetadataTrackProvider, &type_spec_ITimedMetadataTrackProvider, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ITimedMetadataTrackProvider, &type_spec_ITimedMetadataTrackProvider, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MseTimeRange, &type_spec_MseTimeRange, nullptr, nullptr, nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MseTimeRange, &type_spec_MseTimeRange, nullptr, nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_TimedTextDouble, &type_spec_TimedTextDouble, nullptr, nullptr, nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_TimedTextDouble, &type_spec_TimedTextDouble, nullptr, nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_TimedTextPadding, &type_spec_TimedTextPadding, nullptr, nullptr, nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_TimedTextPadding, &type_spec_TimedTextPadding, nullptr, nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_TimedTextPoint, &type_spec_TimedTextPoint, nullptr, nullptr, nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_TimedTextPoint, &type_spec_TimedTextPoint, nullptr, nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_TimedTextSize, &type_spec_TimedTextSize, nullptr, nullptr, nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_TimedTextSize, &type_spec_TimedTextSize, nullptr, nullptr) == -1)
    #endif
    {
        return nullptr;
    }


    return module.detach();
}
