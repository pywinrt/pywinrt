// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Media.Core.h"

namespace py::cpp::Windows::Media::Core
{
    // ----- AudioStreamDescriptor class --------------------

    static PyObject* _new_AudioStreamDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 0);

                winrt::Windows::Media::Core::AudioStreamDescriptor instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AudioStreamDescriptor(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioStreamDescriptor_Copy(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.AudioStreamDescriptor", L"Copy", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioStreamDescriptor_get_EncodingProperties(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioStreamDescriptor", L"EncodingProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioStreamDescriptor_get_TrailingEncoderPadding(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioStreamDescriptor", L"TrailingEncoderPadding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TrailingEncoderPadding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioStreamDescriptor_put_TrailingEncoderPadding(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioStreamDescriptor", L"TrailingEncoderPadding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.TrailingEncoderPadding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioStreamDescriptor_get_LeadingEncoderPadding(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioStreamDescriptor", L"LeadingEncoderPadding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LeadingEncoderPadding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioStreamDescriptor_put_LeadingEncoderPadding(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioStreamDescriptor", L"LeadingEncoderPadding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.LeadingEncoderPadding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioStreamDescriptor_get_Name(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioStreamDescriptor", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioStreamDescriptor_put_Name(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioStreamDescriptor", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioStreamDescriptor_get_Language(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioStreamDescriptor", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioStreamDescriptor_put_Language(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioStreamDescriptor", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioStreamDescriptor_get_IsSelected(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioStreamDescriptor", L"IsSelected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioStreamDescriptor_get_Label(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioStreamDescriptor", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioStreamDescriptor_put_Label(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioStreamDescriptor", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AudioStreamDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::AudioStreamDescriptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioStreamDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::AudioStreamDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioStreamDescriptor[] = {
        { "copy", reinterpret_cast<PyCFunction>(AudioStreamDescriptor_Copy), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AudioStreamDescriptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioStreamDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioStreamDescriptor[] = {
        { "encoding_properties", reinterpret_cast<getter>(AudioStreamDescriptor_get_EncodingProperties), nullptr, nullptr, nullptr },
        { "trailing_encoder_padding", reinterpret_cast<getter>(AudioStreamDescriptor_get_TrailingEncoderPadding), reinterpret_cast<setter>(AudioStreamDescriptor_put_TrailingEncoderPadding), nullptr, nullptr },
        { "leading_encoder_padding", reinterpret_cast<getter>(AudioStreamDescriptor_get_LeadingEncoderPadding), reinterpret_cast<setter>(AudioStreamDescriptor_put_LeadingEncoderPadding), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(AudioStreamDescriptor_get_Name), reinterpret_cast<setter>(AudioStreamDescriptor_put_Name), nullptr, nullptr },
        { "language", reinterpret_cast<getter>(AudioStreamDescriptor_get_Language), reinterpret_cast<setter>(AudioStreamDescriptor_put_Language), nullptr, nullptr },
        { "is_selected", reinterpret_cast<getter>(AudioStreamDescriptor_get_IsSelected), nullptr, nullptr, nullptr },
        { "label", reinterpret_cast<getter>(AudioStreamDescriptor_get_Label), reinterpret_cast<setter>(AudioStreamDescriptor_put_Label), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioStreamDescriptor[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioStreamDescriptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioStreamDescriptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioStreamDescriptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioStreamDescriptor) },
        { }
    };

    static PyType_Spec type_spec_AudioStreamDescriptor = {
        "winrt._winrt_windows_media_core.AudioStreamDescriptor",
        sizeof(py::wrapper::Windows::Media::Core::AudioStreamDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioStreamDescriptor};

    // ----- AudioTrack class --------------------

    static PyObject* _new_AudioTrack(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::AudioTrack>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::AudioTrack>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioTrack(py::wrapper::Windows::Media::Core::AudioTrack* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioTrack_GetEncodingProperties(py::wrapper::Windows::Media::Core::AudioTrack* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.AudioTrack", L"GetEncodingProperties", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetEncodingProperties());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioTrack_get_Name(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioTrack", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_get_PlaybackItem(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioTrack", L"PlaybackItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PlaybackItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_get_SupportInfo(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioTrack", L"SupportInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_get_Label(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioTrack", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioTrack_put_Label(py::wrapper::Windows::Media::Core::AudioTrack* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioTrack", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioTrack_get_Id(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioTrack", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_get_Language(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioTrack", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_get_TrackKind(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioTrack", L"TrackKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TrackKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_add_OpenFailed(py::wrapper::Windows::Media::Core::AudioTrack* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.AudioTrack", L"OpenFailed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::AudioTrack, winrt::Windows::Media::Core::AudioTrackOpenFailedEventArgs>>(arg);

            return py::convert(self->obj.OpenFailed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_remove_OpenFailed(py::wrapper::Windows::Media::Core::AudioTrack* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.AudioTrack", L"OpenFailed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.OpenFailed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioTrack(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::AudioTrack>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioTrack(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::AudioTrack>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioTrack[] = {
        { "get_encoding_properties", reinterpret_cast<PyCFunction>(AudioTrack_GetEncodingProperties), METH_VARARGS, nullptr },
        { "add_open_failed", reinterpret_cast<PyCFunction>(AudioTrack_add_OpenFailed), METH_O, nullptr },
        { "remove_open_failed", reinterpret_cast<PyCFunction>(AudioTrack_remove_OpenFailed), METH_O, nullptr },
        { "_assign_array_", _assign_array_AudioTrack, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioTrack), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioTrack[] = {
        { "name", reinterpret_cast<getter>(AudioTrack_get_Name), nullptr, nullptr, nullptr },
        { "playback_item", reinterpret_cast<getter>(AudioTrack_get_PlaybackItem), nullptr, nullptr, nullptr },
        { "support_info", reinterpret_cast<getter>(AudioTrack_get_SupportInfo), nullptr, nullptr, nullptr },
        { "label", reinterpret_cast<getter>(AudioTrack_get_Label), reinterpret_cast<setter>(AudioTrack_put_Label), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(AudioTrack_get_Id), nullptr, nullptr, nullptr },
        { "language", reinterpret_cast<getter>(AudioTrack_get_Language), nullptr, nullptr, nullptr },
        { "track_kind", reinterpret_cast<getter>(AudioTrack_get_TrackKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioTrack[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioTrack) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioTrack) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioTrack) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioTrack) },
        { }
    };

    static PyType_Spec type_spec_AudioTrack = {
        "winrt._winrt_windows_media_core.AudioTrack",
        sizeof(py::wrapper::Windows::Media::Core::AudioTrack),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioTrack};

    // ----- AudioTrackOpenFailedEventArgs class --------------------

    static PyObject* _new_AudioTrackOpenFailedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::AudioTrackOpenFailedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::AudioTrackOpenFailedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioTrackOpenFailedEventArgs(py::wrapper::Windows::Media::Core::AudioTrackOpenFailedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioTrackOpenFailedEventArgs_get_ExtendedError(py::wrapper::Windows::Media::Core::AudioTrackOpenFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioTrackOpenFailedEventArgs", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioTrackOpenFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::AudioTrackOpenFailedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioTrackOpenFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::AudioTrackOpenFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioTrackOpenFailedEventArgs[] = {
        { "_assign_array_", _assign_array_AudioTrackOpenFailedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioTrackOpenFailedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioTrackOpenFailedEventArgs[] = {
        { "extended_error", reinterpret_cast<getter>(AudioTrackOpenFailedEventArgs_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioTrackOpenFailedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioTrackOpenFailedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioTrackOpenFailedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioTrackOpenFailedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioTrackOpenFailedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_AudioTrackOpenFailedEventArgs = {
        "winrt._winrt_windows_media_core.AudioTrackOpenFailedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::AudioTrackOpenFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioTrackOpenFailedEventArgs};

    // ----- AudioTrackSupportInfo class --------------------

    static PyObject* _new_AudioTrackSupportInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::AudioTrackSupportInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::AudioTrackSupportInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioTrackSupportInfo(py::wrapper::Windows::Media::Core::AudioTrackSupportInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioTrackSupportInfo_get_DecoderStatus(py::wrapper::Windows::Media::Core::AudioTrackSupportInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioTrackSupportInfo", L"DecoderStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DecoderStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrackSupportInfo_get_Degradation(py::wrapper::Windows::Media::Core::AudioTrackSupportInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioTrackSupportInfo", L"Degradation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Degradation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrackSupportInfo_get_DegradationReason(py::wrapper::Windows::Media::Core::AudioTrackSupportInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioTrackSupportInfo", L"DegradationReason");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DegradationReason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrackSupportInfo_get_MediaSourceStatus(py::wrapper::Windows::Media::Core::AudioTrackSupportInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.AudioTrackSupportInfo", L"MediaSourceStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MediaSourceStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioTrackSupportInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::AudioTrackSupportInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioTrackSupportInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::AudioTrackSupportInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioTrackSupportInfo[] = {
        { "_assign_array_", _assign_array_AudioTrackSupportInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioTrackSupportInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioTrackSupportInfo[] = {
        { "decoder_status", reinterpret_cast<getter>(AudioTrackSupportInfo_get_DecoderStatus), nullptr, nullptr, nullptr },
        { "degradation", reinterpret_cast<getter>(AudioTrackSupportInfo_get_Degradation), nullptr, nullptr, nullptr },
        { "degradation_reason", reinterpret_cast<getter>(AudioTrackSupportInfo_get_DegradationReason), nullptr, nullptr, nullptr },
        { "media_source_status", reinterpret_cast<getter>(AudioTrackSupportInfo_get_MediaSourceStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioTrackSupportInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioTrackSupportInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioTrackSupportInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioTrackSupportInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioTrackSupportInfo) },
        { }
    };

    static PyType_Spec type_spec_AudioTrackSupportInfo = {
        "winrt._winrt_windows_media_core.AudioTrackSupportInfo",
        sizeof(py::wrapper::Windows::Media::Core::AudioTrackSupportInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioTrackSupportInfo};

    // ----- ChapterCue class --------------------

    static PyObject* _new_ChapterCue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::ChapterCue instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChapterCue(py::wrapper::Windows::Media::Core::ChapterCue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChapterCue_get_Title(py::wrapper::Windows::Media::Core::ChapterCue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ChapterCue", L"Title");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChapterCue_put_Title(py::wrapper::Windows::Media::Core::ChapterCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ChapterCue", L"Title");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChapterCue_get_StartTime(py::wrapper::Windows::Media::Core::ChapterCue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ChapterCue", L"StartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChapterCue_put_StartTime(py::wrapper::Windows::Media::Core::ChapterCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ChapterCue", L"StartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChapterCue_get_Id(py::wrapper::Windows::Media::Core::ChapterCue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ChapterCue", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChapterCue_put_Id(py::wrapper::Windows::Media::Core::ChapterCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ChapterCue", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChapterCue_get_Duration(py::wrapper::Windows::Media::Core::ChapterCue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ChapterCue", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChapterCue_put_Duration(py::wrapper::Windows::Media::Core::ChapterCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ChapterCue", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ChapterCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::ChapterCue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChapterCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::ChapterCue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChapterCue[] = {
        { "_assign_array_", _assign_array_ChapterCue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChapterCue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChapterCue[] = {
        { "title", reinterpret_cast<getter>(ChapterCue_get_Title), reinterpret_cast<setter>(ChapterCue_put_Title), nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(ChapterCue_get_StartTime), reinterpret_cast<setter>(ChapterCue_put_StartTime), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ChapterCue_get_Id), reinterpret_cast<setter>(ChapterCue_put_Id), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(ChapterCue_get_Duration), reinterpret_cast<setter>(ChapterCue_put_Duration), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChapterCue[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChapterCue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChapterCue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChapterCue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChapterCue) },
        { }
    };

    static PyType_Spec type_spec_ChapterCue = {
        "winrt._winrt_windows_media_core.ChapterCue",
        sizeof(py::wrapper::Windows::Media::Core::ChapterCue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChapterCue};

    // ----- CodecInfo class --------------------

    static PyObject* _new_CodecInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::CodecInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::CodecInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_CodecInfo(py::wrapper::Windows::Media::Core::CodecInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CodecInfo_get_Category(py::wrapper::Windows::Media::Core::CodecInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecInfo", L"Category");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Category());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecInfo_get_DisplayName(py::wrapper::Windows::Media::Core::CodecInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecInfo", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecInfo_get_IsTrusted(py::wrapper::Windows::Media::Core::CodecInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecInfo", L"IsTrusted");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsTrusted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecInfo_get_Kind(py::wrapper::Windows::Media::Core::CodecInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecInfo", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecInfo_get_Subtypes(py::wrapper::Windows::Media::Core::CodecInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecInfo", L"Subtypes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Subtypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CodecInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::CodecInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CodecInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::CodecInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CodecInfo[] = {
        { "_assign_array_", _assign_array_CodecInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CodecInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CodecInfo[] = {
        { "category", reinterpret_cast<getter>(CodecInfo_get_Category), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(CodecInfo_get_DisplayName), nullptr, nullptr, nullptr },
        { "is_trusted", reinterpret_cast<getter>(CodecInfo_get_IsTrusted), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(CodecInfo_get_Kind), nullptr, nullptr, nullptr },
        { "subtypes", reinterpret_cast<getter>(CodecInfo_get_Subtypes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CodecInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CodecInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CodecInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CodecInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CodecInfo) },
        { }
    };

    static PyType_Spec type_spec_CodecInfo = {
        "winrt._winrt_windows_media_core.CodecInfo",
        sizeof(py::wrapper::Windows::Media::Core::CodecInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CodecInfo};

    // ----- CodecQuery class --------------------

    static PyObject* _new_CodecQuery(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::CodecQuery instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CodecQuery(py::wrapper::Windows::Media::Core::CodecQuery* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CodecQuery_FindAllAsync(py::wrapper::Windows::Media::Core::CodecQuery* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.CodecQuery", L"FindAllAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Core::CodecKind>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Core::CodecCategory>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.FindAllAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_CodecQuery(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::CodecQuery>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CodecQuery(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::CodecQuery>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CodecQuery[] = {
        { "find_all_async", reinterpret_cast<PyCFunction>(CodecQuery_FindAllAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CodecQuery, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CodecQuery), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CodecQuery[] = {
        { }
    };

    static PyType_Slot _type_slots_CodecQuery[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CodecQuery) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CodecQuery) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CodecQuery) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CodecQuery) },
        { }
    };

    static PyType_Spec type_spec_CodecQuery = {
        "winrt._winrt_windows_media_core.CodecQuery",
        sizeof(py::wrapper::Windows::Media::Core::CodecQuery),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CodecQuery};

    // ----- CodecSubtypes class --------------------

    static PyObject* _new_CodecSubtypes(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::CodecSubtypes>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::CodecSubtypes>::type_name);
        return nullptr;
    }

    static PyObject* CodecSubtypes_get_AudioFormatAac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatAac");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatAac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatAdts(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatAdts");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatAdts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatAlac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatAlac");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatAlac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatAmrNB(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatAmrNB");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatAmrNB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatAmrWB(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatAmrWB");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatAmrWB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatAmrWP(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatAmrWP");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatAmrWP());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatDolbyAC3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatDolbyAC3");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatDolbyAC3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatDolbyAC3Spdif(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatDolbyAC3Spdif");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatDolbyAC3Spdif());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatDolbyDDPlus(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatDolbyDDPlus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatDolbyDDPlus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatDrm(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatDrm");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatDrm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatDts(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatDts");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatDts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatFlac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatFlac");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatFlac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatFloat(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatFloat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatFloat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatMP3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatMP3");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatMP3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatMPeg(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatMPeg");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatMPeg());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatMsp1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatMsp1");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatMsp1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatOpus(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatOpus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatOpus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatPcm(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatPcm");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatPcm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatWMAudioLossless(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatWMAudioLossless");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatWMAudioLossless());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatWMAudioV8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatWMAudioV8");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatWMAudioV8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatWMAudioV9(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatWMAudioV9");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatWMAudioV9());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatWmaSpdif(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"AudioFormatWmaSpdif");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatWmaSpdif());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormat420O(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormat420O");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormat420O());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDV25(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatDV25");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDV25());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDV50(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatDV50");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDV50());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDvc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatDvc");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDvc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDvh1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatDvh1");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDvh1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDvhD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatDvhD");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDvhD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDvsd(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatDvsd");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDvsd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDvsl(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatDvsl");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDvsl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatH263(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatH263");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatH263());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatH264(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatH264");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatH264());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatH264ES(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatH264ES");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatH264ES());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatH265(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatH265");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatH265());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatHevc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatHevc");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatHevc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatHevcES(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatHevcES");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatHevcES());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatM4S2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatM4S2");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatM4S2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMP43(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatMP43");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMP43());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMP4S(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatMP4S");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMP4S());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMP4V(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatMP4V");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMP4V());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMjpg(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatMjpg");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMjpg());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMpeg2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatMpeg2");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMpeg2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMpg1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatMpg1");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMpg1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMss1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatMss1");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMss1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMss2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatMss2");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMss2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatVP80(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatVP80");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatVP80());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatVP90(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatVP90");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatVP90());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatWmv1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatWmv1");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatWmv1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatWmv2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatWmv2");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatWmv2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatWmv3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatWmv3");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatWmv3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatWvc1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.CodecSubtypes", L"VideoFormatWvc1");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatWvc1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CodecSubtypes[] = {
        { }
    };

    static PyGetSetDef _getset_CodecSubtypes[] = {
        { }
    };

    static PyType_Slot _type_slots_CodecSubtypes[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CodecSubtypes) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CodecSubtypes) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CodecSubtypes) },
        { }
    };

    static PyType_Spec type_spec_CodecSubtypes = {
        "winrt._winrt_windows_media_core.CodecSubtypes",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CodecSubtypes};

    static PyGetSetDef getset_CodecSubtypes_Static[] = {
        { "audio_format_aac", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatAac), nullptr, nullptr, nullptr },
        { "audio_format_adts", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatAdts), nullptr, nullptr, nullptr },
        { "audio_format_alac", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatAlac), nullptr, nullptr, nullptr },
        { "audio_format_amr_n_b", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatAmrNB), nullptr, nullptr, nullptr },
        { "audio_format_amr_w_b", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatAmrWB), nullptr, nullptr, nullptr },
        { "audio_format_amr_w_p", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatAmrWP), nullptr, nullptr, nullptr },
        { "audio_format_dolby_a_c3", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatDolbyAC3), nullptr, nullptr, nullptr },
        { "audio_format_dolby_a_c3_spdif", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatDolbyAC3Spdif), nullptr, nullptr, nullptr },
        { "audio_format_dolby_d_d_plus", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatDolbyDDPlus), nullptr, nullptr, nullptr },
        { "audio_format_drm", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatDrm), nullptr, nullptr, nullptr },
        { "audio_format_dts", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatDts), nullptr, nullptr, nullptr },
        { "audio_format_flac", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatFlac), nullptr, nullptr, nullptr },
        { "audio_format_float", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatFloat), nullptr, nullptr, nullptr },
        { "audio_format_m_p3", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatMP3), nullptr, nullptr, nullptr },
        { "audio_format_m_peg", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatMPeg), nullptr, nullptr, nullptr },
        { "audio_format_msp1", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatMsp1), nullptr, nullptr, nullptr },
        { "audio_format_opus", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatOpus), nullptr, nullptr, nullptr },
        { "audio_format_pcm", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatPcm), nullptr, nullptr, nullptr },
        { "audio_format_w_m_audio_lossless", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatWMAudioLossless), nullptr, nullptr, nullptr },
        { "audio_format_w_m_audio_v8", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatWMAudioV8), nullptr, nullptr, nullptr },
        { "audio_format_w_m_audio_v9", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatWMAudioV9), nullptr, nullptr, nullptr },
        { "audio_format_wma_spdif", reinterpret_cast<getter>(CodecSubtypes_get_AudioFormatWmaSpdif), nullptr, nullptr, nullptr },
        { "video_format420_o", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormat420O), nullptr, nullptr, nullptr },
        { "video_format_d_v25", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatDV25), nullptr, nullptr, nullptr },
        { "video_format_d_v50", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatDV50), nullptr, nullptr, nullptr },
        { "video_format_dvc", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatDvc), nullptr, nullptr, nullptr },
        { "video_format_dvh1", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatDvh1), nullptr, nullptr, nullptr },
        { "video_format_dvh_d", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatDvhD), nullptr, nullptr, nullptr },
        { "video_format_dvsd", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatDvsd), nullptr, nullptr, nullptr },
        { "video_format_dvsl", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatDvsl), nullptr, nullptr, nullptr },
        { "video_format_h263", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatH263), nullptr, nullptr, nullptr },
        { "video_format_h264", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatH264), nullptr, nullptr, nullptr },
        { "video_format_h264_e_s", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatH264ES), nullptr, nullptr, nullptr },
        { "video_format_h265", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatH265), nullptr, nullptr, nullptr },
        { "video_format_hevc", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatHevc), nullptr, nullptr, nullptr },
        { "video_format_hevc_e_s", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatHevcES), nullptr, nullptr, nullptr },
        { "video_format_m4_s2", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatM4S2), nullptr, nullptr, nullptr },
        { "video_format_m_p43", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatMP43), nullptr, nullptr, nullptr },
        { "video_format_m_p4_s", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatMP4S), nullptr, nullptr, nullptr },
        { "video_format_m_p4_v", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatMP4V), nullptr, nullptr, nullptr },
        { "video_format_mjpg", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatMjpg), nullptr, nullptr, nullptr },
        { "video_format_mpeg2", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatMpeg2), nullptr, nullptr, nullptr },
        { "video_format_mpg1", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatMpg1), nullptr, nullptr, nullptr },
        { "video_format_mss1", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatMss1), nullptr, nullptr, nullptr },
        { "video_format_mss2", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatMss2), nullptr, nullptr, nullptr },
        { "video_format_v_p80", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatVP80), nullptr, nullptr, nullptr },
        { "video_format_v_p90", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatVP90), nullptr, nullptr, nullptr },
        { "video_format_wmv1", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatWmv1), nullptr, nullptr, nullptr },
        { "video_format_wmv2", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatWmv2), nullptr, nullptr, nullptr },
        { "video_format_wmv3", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatWmv3), nullptr, nullptr, nullptr },
        { "video_format_wvc1", reinterpret_cast<getter>(CodecSubtypes_get_VideoFormatWvc1), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_CodecSubtypes_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CodecSubtypes_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CodecSubtypes_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CodecSubtypes_Static) },
        { }
    };

    static PyType_Spec type_spec_CodecSubtypes_Static =
    {
        "winrt._winrt_windows_media_core.CodecSubtypes_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CodecSubtypes_Static
    };

    // ----- DataCue class --------------------

    static PyObject* _new_DataCue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::DataCue instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DataCue(py::wrapper::Windows::Media::Core::DataCue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DataCue_get_Data(py::wrapper::Windows::Media::Core::DataCue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.DataCue", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataCue_put_Data(py::wrapper::Windows::Media::Core::DataCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.DataCue", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.Data(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataCue_get_Properties(py::wrapper::Windows::Media::Core::DataCue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.DataCue", L"Properties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataCue_get_StartTime(py::wrapper::Windows::Media::Core::DataCue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.DataCue", L"StartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataCue_put_StartTime(py::wrapper::Windows::Media::Core::DataCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.DataCue", L"StartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataCue_get_Id(py::wrapper::Windows::Media::Core::DataCue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.DataCue", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataCue_put_Id(py::wrapper::Windows::Media::Core::DataCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.DataCue", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataCue_get_Duration(py::wrapper::Windows::Media::Core::DataCue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.DataCue", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataCue_put_Duration(py::wrapper::Windows::Media::Core::DataCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.DataCue", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DataCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::DataCue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DataCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::DataCue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataCue[] = {
        { "_assign_array_", _assign_array_DataCue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DataCue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataCue[] = {
        { "data", reinterpret_cast<getter>(DataCue_get_Data), reinterpret_cast<setter>(DataCue_put_Data), nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DataCue_get_Properties), nullptr, nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(DataCue_get_StartTime), reinterpret_cast<setter>(DataCue_put_StartTime), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(DataCue_get_Id), reinterpret_cast<setter>(DataCue_put_Id), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(DataCue_get_Duration), reinterpret_cast<setter>(DataCue_put_Duration), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DataCue[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DataCue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DataCue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DataCue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DataCue) },
        { }
    };

    static PyType_Spec type_spec_DataCue = {
        "winrt._winrt_windows_media_core.DataCue",
        sizeof(py::wrapper::Windows::Media::Core::DataCue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataCue};

    // ----- FaceDetectedEventArgs class --------------------

    static PyObject* _new_FaceDetectedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::FaceDetectedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::FaceDetectedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_FaceDetectedEventArgs(py::wrapper::Windows::Media::Core::FaceDetectedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FaceDetectedEventArgs_get_ResultFrame(py::wrapper::Windows::Media::Core::FaceDetectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectedEventArgs", L"ResultFrame");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResultFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FaceDetectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::FaceDetectedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FaceDetectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::FaceDetectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FaceDetectedEventArgs[] = {
        { "_assign_array_", _assign_array_FaceDetectedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FaceDetectedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FaceDetectedEventArgs[] = {
        { "result_frame", reinterpret_cast<getter>(FaceDetectedEventArgs_get_ResultFrame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FaceDetectedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FaceDetectedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FaceDetectedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FaceDetectedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FaceDetectedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_FaceDetectedEventArgs = {
        "winrt._winrt_windows_media_core.FaceDetectedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::FaceDetectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FaceDetectedEventArgs};

    // ----- FaceDetectionEffect class --------------------

    static PyObject* _new_FaceDetectionEffect(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::FaceDetectionEffect>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::FaceDetectionEffect>::type_name);
        return nullptr;
    }

    static void _dealloc_FaceDetectionEffect(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FaceDetectionEffect_SetProperties(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.FaceDetectionEffect", L"SetProperties", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);

                self->obj.SetProperties(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffect_get_Enabled(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffect", L"Enabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffect_put_Enabled(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffect", L"Enabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffect_get_DesiredDetectionInterval(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffect", L"DesiredDetectionInterval");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DesiredDetectionInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffect_put_DesiredDetectionInterval(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffect", L"DesiredDetectionInterval");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.DesiredDetectionInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffect_add_FaceDetected(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.FaceDetectionEffect", L"FaceDetected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::FaceDetectionEffect, winrt::Windows::Media::Core::FaceDetectedEventArgs>>(arg);

            return py::convert(self->obj.FaceDetected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffect_remove_FaceDetected(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.FaceDetectionEffect", L"FaceDetected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FaceDetected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FaceDetectionEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::FaceDetectionEffect>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FaceDetectionEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::FaceDetectionEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FaceDetectionEffect[] = {
        { "set_properties", reinterpret_cast<PyCFunction>(FaceDetectionEffect_SetProperties), METH_VARARGS, nullptr },
        { "add_face_detected", reinterpret_cast<PyCFunction>(FaceDetectionEffect_add_FaceDetected), METH_O, nullptr },
        { "remove_face_detected", reinterpret_cast<PyCFunction>(FaceDetectionEffect_remove_FaceDetected), METH_O, nullptr },
        { "_assign_array_", _assign_array_FaceDetectionEffect, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FaceDetectionEffect), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FaceDetectionEffect[] = {
        { "enabled", reinterpret_cast<getter>(FaceDetectionEffect_get_Enabled), reinterpret_cast<setter>(FaceDetectionEffect_put_Enabled), nullptr, nullptr },
        { "desired_detection_interval", reinterpret_cast<getter>(FaceDetectionEffect_get_DesiredDetectionInterval), reinterpret_cast<setter>(FaceDetectionEffect_put_DesiredDetectionInterval), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FaceDetectionEffect[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FaceDetectionEffect) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FaceDetectionEffect) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FaceDetectionEffect) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FaceDetectionEffect) },
        { }
    };

    static PyType_Spec type_spec_FaceDetectionEffect = {
        "winrt._winrt_windows_media_core.FaceDetectionEffect",
        sizeof(py::wrapper::Windows::Media::Core::FaceDetectionEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FaceDetectionEffect};

    // ----- FaceDetectionEffectDefinition class --------------------

    static PyObject* _new_FaceDetectionEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::FaceDetectionEffectDefinition instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FaceDetectionEffectDefinition(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FaceDetectionEffectDefinition_get_SynchronousDetectionEnabled(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectDefinition", L"SynchronousDetectionEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SynchronousDetectionEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffectDefinition_put_SynchronousDetectionEnabled(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectDefinition", L"SynchronousDetectionEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.SynchronousDetectionEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffectDefinition_get_DetectionMode(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectDefinition", L"DetectionMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DetectionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffectDefinition_put_DetectionMode(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectDefinition", L"DetectionMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Core::FaceDetectionMode>(arg);

            self->obj.DetectionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectDefinition", L"ActivatableClassId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffectDefinition_get_Properties(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectDefinition", L"Properties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FaceDetectionEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::FaceDetectionEffectDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FaceDetectionEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::FaceDetectionEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FaceDetectionEffectDefinition[] = {
        { "_assign_array_", _assign_array_FaceDetectionEffectDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FaceDetectionEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FaceDetectionEffectDefinition[] = {
        { "synchronous_detection_enabled", reinterpret_cast<getter>(FaceDetectionEffectDefinition_get_SynchronousDetectionEnabled), reinterpret_cast<setter>(FaceDetectionEffectDefinition_put_SynchronousDetectionEnabled), nullptr, nullptr },
        { "detection_mode", reinterpret_cast<getter>(FaceDetectionEffectDefinition_get_DetectionMode), reinterpret_cast<setter>(FaceDetectionEffectDefinition_put_DetectionMode), nullptr, nullptr },
        { "activatable_class_id", reinterpret_cast<getter>(FaceDetectionEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(FaceDetectionEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FaceDetectionEffectDefinition[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FaceDetectionEffectDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FaceDetectionEffectDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FaceDetectionEffectDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FaceDetectionEffectDefinition) },
        { }
    };

    static PyType_Spec type_spec_FaceDetectionEffectDefinition = {
        "winrt._winrt_windows_media_core.FaceDetectionEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FaceDetectionEffectDefinition};

    // ----- FaceDetectionEffectFrame class --------------------

    static PyObject* _new_FaceDetectionEffectFrame(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::FaceDetectionEffectFrame>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::FaceDetectionEffectFrame>::type_name);
        return nullptr;
    }

    static void _dealloc_FaceDetectionEffectFrame(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FaceDetectionEffectFrame_Close(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.FaceDetectionEffectFrame", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_DetectedFaces(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectFrame", L"DetectedFaces");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DetectedFaces());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_SystemRelativeTime(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectFrame", L"SystemRelativeTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SystemRelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffectFrame_put_SystemRelativeTime(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectFrame", L"SystemRelativeTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.SystemRelativeTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_RelativeTime(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectFrame", L"RelativeTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffectFrame_put_RelativeTime(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectFrame", L"RelativeTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.RelativeTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_IsDiscontinuous(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectFrame", L"IsDiscontinuous");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDiscontinuous());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffectFrame_put_IsDiscontinuous(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectFrame", L"IsDiscontinuous");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDiscontinuous(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_Duration(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectFrame", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffectFrame_put_Duration(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectFrame", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_ExtendedProperties(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectFrame", L"ExtendedProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_IsReadOnly(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectFrame", L"IsReadOnly");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_Type(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.FaceDetectionEffectFrame", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FaceDetectionEffectFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::FaceDetectionEffectFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FaceDetectionEffectFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::FaceDetectionEffectFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_FaceDetectionEffectFrame(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_FaceDetectionEffectFrame(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FaceDetectionEffectFrame[] = {
        { "close", reinterpret_cast<PyCFunction>(FaceDetectionEffectFrame_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_FaceDetectionEffectFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FaceDetectionEffectFrame), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_FaceDetectionEffectFrame), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_FaceDetectionEffectFrame), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_FaceDetectionEffectFrame[] = {
        { "detected_faces", reinterpret_cast<getter>(FaceDetectionEffectFrame_get_DetectedFaces), nullptr, nullptr, nullptr },
        { "system_relative_time", reinterpret_cast<getter>(FaceDetectionEffectFrame_get_SystemRelativeTime), reinterpret_cast<setter>(FaceDetectionEffectFrame_put_SystemRelativeTime), nullptr, nullptr },
        { "relative_time", reinterpret_cast<getter>(FaceDetectionEffectFrame_get_RelativeTime), reinterpret_cast<setter>(FaceDetectionEffectFrame_put_RelativeTime), nullptr, nullptr },
        { "is_discontinuous", reinterpret_cast<getter>(FaceDetectionEffectFrame_get_IsDiscontinuous), reinterpret_cast<setter>(FaceDetectionEffectFrame_put_IsDiscontinuous), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(FaceDetectionEffectFrame_get_Duration), reinterpret_cast<setter>(FaceDetectionEffectFrame_put_Duration), nullptr, nullptr },
        { "extended_properties", reinterpret_cast<getter>(FaceDetectionEffectFrame_get_ExtendedProperties), nullptr, nullptr, nullptr },
        { "is_read_only", reinterpret_cast<getter>(FaceDetectionEffectFrame_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(FaceDetectionEffectFrame_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FaceDetectionEffectFrame[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FaceDetectionEffectFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FaceDetectionEffectFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FaceDetectionEffectFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FaceDetectionEffectFrame) },
        { }
    };

    static PyType_Spec type_spec_FaceDetectionEffectFrame = {
        "winrt._winrt_windows_media_core.FaceDetectionEffectFrame",
        sizeof(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FaceDetectionEffectFrame};

    // ----- HighDynamicRangeControl class --------------------

    static PyObject* _new_HighDynamicRangeControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::HighDynamicRangeControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::HighDynamicRangeControl>::type_name);
        return nullptr;
    }

    static void _dealloc_HighDynamicRangeControl(py::wrapper::Windows::Media::Core::HighDynamicRangeControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HighDynamicRangeControl_get_Enabled(py::wrapper::Windows::Media::Core::HighDynamicRangeControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.HighDynamicRangeControl", L"Enabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HighDynamicRangeControl_put_Enabled(py::wrapper::Windows::Media::Core::HighDynamicRangeControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.HighDynamicRangeControl", L"Enabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_HighDynamicRangeControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::HighDynamicRangeControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HighDynamicRangeControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::HighDynamicRangeControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HighDynamicRangeControl[] = {
        { "_assign_array_", _assign_array_HighDynamicRangeControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HighDynamicRangeControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HighDynamicRangeControl[] = {
        { "enabled", reinterpret_cast<getter>(HighDynamicRangeControl_get_Enabled), reinterpret_cast<setter>(HighDynamicRangeControl_put_Enabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HighDynamicRangeControl[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HighDynamicRangeControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HighDynamicRangeControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HighDynamicRangeControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HighDynamicRangeControl) },
        { }
    };

    static PyType_Spec type_spec_HighDynamicRangeControl = {
        "winrt._winrt_windows_media_core.HighDynamicRangeControl",
        sizeof(py::wrapper::Windows::Media::Core::HighDynamicRangeControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HighDynamicRangeControl};

    // ----- HighDynamicRangeOutput class --------------------

    static PyObject* _new_HighDynamicRangeOutput(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::HighDynamicRangeOutput>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::HighDynamicRangeOutput>::type_name);
        return nullptr;
    }

    static void _dealloc_HighDynamicRangeOutput(py::wrapper::Windows::Media::Core::HighDynamicRangeOutput* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HighDynamicRangeOutput_get_Certainty(py::wrapper::Windows::Media::Core::HighDynamicRangeOutput* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.HighDynamicRangeOutput", L"Certainty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Certainty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HighDynamicRangeOutput_get_FrameControllers(py::wrapper::Windows::Media::Core::HighDynamicRangeOutput* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.HighDynamicRangeOutput", L"FrameControllers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FrameControllers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HighDynamicRangeOutput(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::HighDynamicRangeOutput>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HighDynamicRangeOutput(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::HighDynamicRangeOutput>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HighDynamicRangeOutput[] = {
        { "_assign_array_", _assign_array_HighDynamicRangeOutput, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HighDynamicRangeOutput), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HighDynamicRangeOutput[] = {
        { "certainty", reinterpret_cast<getter>(HighDynamicRangeOutput_get_Certainty), nullptr, nullptr, nullptr },
        { "frame_controllers", reinterpret_cast<getter>(HighDynamicRangeOutput_get_FrameControllers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HighDynamicRangeOutput[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HighDynamicRangeOutput) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HighDynamicRangeOutput) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HighDynamicRangeOutput) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HighDynamicRangeOutput) },
        { }
    };

    static PyType_Spec type_spec_HighDynamicRangeOutput = {
        "winrt._winrt_windows_media_core.HighDynamicRangeOutput",
        sizeof(py::wrapper::Windows::Media::Core::HighDynamicRangeOutput),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HighDynamicRangeOutput};

    // ----- ImageCue class --------------------

    static PyObject* _new_ImageCue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::ImageCue instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ImageCue(py::wrapper::Windows::Media::Core::ImageCue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ImageCue_get_SoftwareBitmap(py::wrapper::Windows::Media::Core::ImageCue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ImageCue", L"SoftwareBitmap");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SoftwareBitmap());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageCue_put_SoftwareBitmap(py::wrapper::Windows::Media::Core::ImageCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ImageCue", L"SoftwareBitmap");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(arg);

            self->obj.SoftwareBitmap(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageCue_get_Position(py::wrapper::Windows::Media::Core::ImageCue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ImageCue", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageCue_put_Position(py::wrapper::Windows::Media::Core::ImageCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ImageCue", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextPoint>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageCue_get_Extent(py::wrapper::Windows::Media::Core::ImageCue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ImageCue", L"Extent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Extent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageCue_put_Extent(py::wrapper::Windows::Media::Core::ImageCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ImageCue", L"Extent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextSize>(arg);

            self->obj.Extent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageCue_get_StartTime(py::wrapper::Windows::Media::Core::ImageCue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ImageCue", L"StartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageCue_put_StartTime(py::wrapper::Windows::Media::Core::ImageCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ImageCue", L"StartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageCue_get_Id(py::wrapper::Windows::Media::Core::ImageCue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ImageCue", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageCue_put_Id(py::wrapper::Windows::Media::Core::ImageCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ImageCue", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageCue_get_Duration(py::wrapper::Windows::Media::Core::ImageCue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ImageCue", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageCue_put_Duration(py::wrapper::Windows::Media::Core::ImageCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ImageCue", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ImageCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::ImageCue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ImageCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::ImageCue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageCue[] = {
        { "_assign_array_", _assign_array_ImageCue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageCue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageCue[] = {
        { "software_bitmap", reinterpret_cast<getter>(ImageCue_get_SoftwareBitmap), reinterpret_cast<setter>(ImageCue_put_SoftwareBitmap), nullptr, nullptr },
        { "position", reinterpret_cast<getter>(ImageCue_get_Position), reinterpret_cast<setter>(ImageCue_put_Position), nullptr, nullptr },
        { "extent", reinterpret_cast<getter>(ImageCue_get_Extent), reinterpret_cast<setter>(ImageCue_put_Extent), nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(ImageCue_get_StartTime), reinterpret_cast<setter>(ImageCue_put_StartTime), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ImageCue_get_Id), reinterpret_cast<setter>(ImageCue_put_Id), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(ImageCue_get_Duration), reinterpret_cast<setter>(ImageCue_put_Duration), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ImageCue[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageCue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageCue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImageCue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageCue) },
        { }
    };

    static PyType_Spec type_spec_ImageCue = {
        "winrt._winrt_windows_media_core.ImageCue",
        sizeof(py::wrapper::Windows::Media::Core::ImageCue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageCue};

    // ----- InitializeMediaStreamSourceRequestedEventArgs class --------------------

    static PyObject* _new_InitializeMediaStreamSourceRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_InitializeMediaStreamSourceRequestedEventArgs(py::wrapper::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InitializeMediaStreamSourceRequestedEventArgs_GetDeferral(py::wrapper::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.InitializeMediaStreamSourceRequestedEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InitializeMediaStreamSourceRequestedEventArgs_get_RandomAccessStream(py::wrapper::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.InitializeMediaStreamSourceRequestedEventArgs", L"RandomAccessStream");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RandomAccessStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InitializeMediaStreamSourceRequestedEventArgs_get_Source(py::wrapper::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.InitializeMediaStreamSourceRequestedEventArgs", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InitializeMediaStreamSourceRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InitializeMediaStreamSourceRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InitializeMediaStreamSourceRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(InitializeMediaStreamSourceRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_InitializeMediaStreamSourceRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InitializeMediaStreamSourceRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InitializeMediaStreamSourceRequestedEventArgs[] = {
        { "random_access_stream", reinterpret_cast<getter>(InitializeMediaStreamSourceRequestedEventArgs_get_RandomAccessStream), nullptr, nullptr, nullptr },
        { "source", reinterpret_cast<getter>(InitializeMediaStreamSourceRequestedEventArgs_get_Source), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InitializeMediaStreamSourceRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InitializeMediaStreamSourceRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InitializeMediaStreamSourceRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InitializeMediaStreamSourceRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InitializeMediaStreamSourceRequestedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_InitializeMediaStreamSourceRequestedEventArgs = {
        "winrt._winrt_windows_media_core.InitializeMediaStreamSourceRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InitializeMediaStreamSourceRequestedEventArgs};

    // ----- LowLightFusion class --------------------

    static PyObject* _new_LowLightFusion(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::LowLightFusion>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::LowLightFusion>::type_name);
        return nullptr;
    }

    static PyObject* LowLightFusion_FuseAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.LowLightFusion", L"FuseAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Graphics::Imaging::SoftwareBitmap>>(args, 0);

                return py::convert(winrt::Windows::Media::Core::LowLightFusion::FuseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLightFusion_get_MaxSupportedFrameCount(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.LowLightFusion", L"MaxSupportedFrameCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::LowLightFusion::MaxSupportedFrameCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LowLightFusion_get_SupportedBitmapPixelFormats(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.LowLightFusion", L"SupportedBitmapPixelFormats");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::Core::LowLightFusion::SupportedBitmapPixelFormats());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LowLightFusion[] = {
        { }
    };

    static PyGetSetDef _getset_LowLightFusion[] = {
        { }
    };

    static PyType_Slot _type_slots_LowLightFusion[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LowLightFusion) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LowLightFusion) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LowLightFusion) },
        { }
    };

    static PyType_Spec type_spec_LowLightFusion = {
        "winrt._winrt_windows_media_core.LowLightFusion",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LowLightFusion};

    static PyGetSetDef getset_LowLightFusion_Static[] = {
        { "max_supported_frame_count", reinterpret_cast<getter>(LowLightFusion_get_MaxSupportedFrameCount), nullptr, nullptr, nullptr },
        { "supported_bitmap_pixel_formats", reinterpret_cast<getter>(LowLightFusion_get_SupportedBitmapPixelFormats), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_LowLightFusion_Static[] = {
        { "fuse_async", reinterpret_cast<PyCFunction>(LowLightFusion_FuseAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_LowLightFusion_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_LowLightFusion_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_LowLightFusion_Static) },
        { }
    };

    static PyType_Spec type_spec_LowLightFusion_Static =
    {
        "winrt._winrt_windows_media_core.LowLightFusion_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_LowLightFusion_Static
    };

    // ----- LowLightFusionResult class --------------------

    static PyObject* _new_LowLightFusionResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::LowLightFusionResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::LowLightFusionResult>::type_name);
        return nullptr;
    }

    static void _dealloc_LowLightFusionResult(py::wrapper::Windows::Media::Core::LowLightFusionResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LowLightFusionResult_Close(py::wrapper::Windows::Media::Core::LowLightFusionResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.LowLightFusionResult", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLightFusionResult_get_Frame(py::wrapper::Windows::Media::Core::LowLightFusionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.LowLightFusionResult", L"Frame");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Frame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LowLightFusionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::LowLightFusionResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LowLightFusionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::LowLightFusionResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_LowLightFusionResult(py::wrapper::Windows::Media::Core::LowLightFusionResult* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_LowLightFusionResult(py::wrapper::Windows::Media::Core::LowLightFusionResult* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LowLightFusionResult[] = {
        { "close", reinterpret_cast<PyCFunction>(LowLightFusionResult_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LowLightFusionResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LowLightFusionResult), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_LowLightFusionResult), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_LowLightFusionResult), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_LowLightFusionResult[] = {
        { "frame", reinterpret_cast<getter>(LowLightFusionResult_get_Frame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LowLightFusionResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LowLightFusionResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LowLightFusionResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LowLightFusionResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LowLightFusionResult) },
        { }
    };

    static PyType_Spec type_spec_LowLightFusionResult = {
        "winrt._winrt_windows_media_core.LowLightFusionResult",
        sizeof(py::wrapper::Windows::Media::Core::LowLightFusionResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LowLightFusionResult};

    // ----- MediaBinder class --------------------

    static PyObject* _new_MediaBinder(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::MediaBinder instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaBinder(py::wrapper::Windows::Media::Core::MediaBinder* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaBinder_get_Token(py::wrapper::Windows::Media::Core::MediaBinder* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaBinder", L"Token");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Token());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaBinder_put_Token(py::wrapper::Windows::Media::Core::MediaBinder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaBinder", L"Token");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Token(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaBinder_get_Source(py::wrapper::Windows::Media::Core::MediaBinder* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaBinder", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBinder_add_Binding(py::wrapper::Windows::Media::Core::MediaBinder* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaBinder", L"Binding");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaBinder, winrt::Windows::Media::Core::MediaBindingEventArgs>>(arg);

            return py::convert(self->obj.Binding(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBinder_remove_Binding(py::wrapper::Windows::Media::Core::MediaBinder* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaBinder", L"Binding");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Binding(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaBinder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaBinder>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaBinder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaBinder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaBinder[] = {
        { "add_binding", reinterpret_cast<PyCFunction>(MediaBinder_add_Binding), METH_O, nullptr },
        { "remove_binding", reinterpret_cast<PyCFunction>(MediaBinder_remove_Binding), METH_O, nullptr },
        { "_assign_array_", _assign_array_MediaBinder, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaBinder), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaBinder[] = {
        { "token", reinterpret_cast<getter>(MediaBinder_get_Token), reinterpret_cast<setter>(MediaBinder_put_Token), nullptr, nullptr },
        { "source", reinterpret_cast<getter>(MediaBinder_get_Source), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaBinder[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaBinder) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaBinder) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaBinder) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaBinder) },
        { }
    };

    static PyType_Spec type_spec_MediaBinder = {
        "winrt._winrt_windows_media_core.MediaBinder",
        sizeof(py::wrapper::Windows::Media::Core::MediaBinder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaBinder};

    // ----- MediaBindingEventArgs class --------------------

    static PyObject* _new_MediaBindingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::MediaBindingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::MediaBindingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaBindingEventArgs(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaBindingEventArgs_GetDeferral(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaBindingEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_SetAdaptiveMediaSource(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaBindingEventArgs", L"SetAdaptiveMediaSource", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource>(args, 0);

                self->obj.SetAdaptiveMediaSource(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_SetDownloadOperation(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaBindingEventArgs", L"SetDownloadOperation", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::DownloadOperation>(args, 0);

                self->obj.SetDownloadOperation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_SetStorageFile(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaBindingEventArgs", L"SetStorageFile", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                self->obj.SetStorageFile(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_SetStream(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaBindingEventArgs", L"SetStream", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetStream(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_SetStreamReference(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaBindingEventArgs", L"SetStreamReference", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetStreamReference(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_SetUri(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaBindingEventArgs", L"SetUri", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                self->obj.SetUri(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_get_MediaBinder(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaBindingEventArgs", L"MediaBinder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MediaBinder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_add_Canceled(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaBindingEventArgs", L"Canceled");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaBindingEventArgs, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Canceled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_remove_Canceled(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaBindingEventArgs", L"Canceled");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Canceled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaBindingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaBindingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaBindingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaBindingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaBindingEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "set_adaptive_media_source", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_SetAdaptiveMediaSource), METH_VARARGS, nullptr },
        { "set_download_operation", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_SetDownloadOperation), METH_VARARGS, nullptr },
        { "set_storage_file", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_SetStorageFile), METH_VARARGS, nullptr },
        { "set_stream", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_SetStream), METH_VARARGS, nullptr },
        { "set_stream_reference", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_SetStreamReference), METH_VARARGS, nullptr },
        { "set_uri", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_SetUri), METH_VARARGS, nullptr },
        { "add_canceled", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_add_Canceled), METH_O, nullptr },
        { "remove_canceled", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_remove_Canceled), METH_O, nullptr },
        { "_assign_array_", _assign_array_MediaBindingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaBindingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaBindingEventArgs[] = {
        { "media_binder", reinterpret_cast<getter>(MediaBindingEventArgs_get_MediaBinder), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaBindingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaBindingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaBindingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaBindingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaBindingEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MediaBindingEventArgs = {
        "winrt._winrt_windows_media_core.MediaBindingEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaBindingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaBindingEventArgs};

    // ----- MediaCueEventArgs class --------------------

    static PyObject* _new_MediaCueEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::MediaCueEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::MediaCueEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaCueEventArgs(py::wrapper::Windows::Media::Core::MediaCueEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaCueEventArgs_get_Cue(py::wrapper::Windows::Media::Core::MediaCueEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaCueEventArgs", L"Cue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Cue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaCueEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaCueEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaCueEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaCueEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCueEventArgs[] = {
        { "_assign_array_", _assign_array_MediaCueEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCueEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCueEventArgs[] = {
        { "cue", reinterpret_cast<getter>(MediaCueEventArgs_get_Cue), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCueEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaCueEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaCueEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaCueEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaCueEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MediaCueEventArgs = {
        "winrt._winrt_windows_media_core.MediaCueEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaCueEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCueEventArgs};

    // ----- MediaSource class --------------------

    static PyObject* _new_MediaSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::MediaSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::MediaSource>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaSource(py::wrapper::Windows::Media::Core::MediaSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaSource_Close(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaSource", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromAdaptiveMediaSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaSource", L"CreateFromAdaptiveMediaSource", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromAdaptiveMediaSource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromDownloadOperation(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaSource", L"CreateFromDownloadOperation", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::DownloadOperation>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromDownloadOperation(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromIMediaSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaSource", L"CreateFromIMediaSource", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaSource>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromIMediaSource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromMediaBinder(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaSource", L"CreateFromMediaBinder", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaBinder>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromMediaBinder(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromMediaFrameSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaSource", L"CreateFromMediaFrameSource", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Capture::Frames::MediaFrameSource>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromMediaFrameSource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromMediaStreamSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaSource", L"CreateFromMediaStreamSource", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaStreamSource>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromMediaStreamSource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromMseStreamSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaSource", L"CreateFromMseStreamSource", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Core::MseStreamSource>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromMseStreamSource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromStorageFile(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaSource", L"CreateFromStorageFile", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromStorageFile(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromStream(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaSource", L"CreateFromStream", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromStream(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromStreamReference(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaSource", L"CreateFromStreamReference", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromStreamReference(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromUri(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaSource", L"CreateFromUri", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromUri(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_OpenAsync(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaSource", L"OpenAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.OpenAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_Reset(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaSource", L"Reset", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_CustomProperties(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaSource", L"CustomProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CustomProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_Duration(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaSource", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_ExternalTimedMetadataTracks(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaSource", L"ExternalTimedMetadataTracks");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExternalTimedMetadataTracks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_ExternalTimedTextSources(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaSource", L"ExternalTimedTextSources");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExternalTimedTextSources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_IsOpen(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaSource", L"IsOpen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_State(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaSource", L"State");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_AdaptiveMediaSource(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaSource", L"AdaptiveMediaSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AdaptiveMediaSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_MediaStreamSource(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaSource", L"MediaStreamSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MediaStreamSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_MseStreamSource(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaSource", L"MseStreamSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MseStreamSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_Uri(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaSource", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_DownloadOperation(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaSource", L"DownloadOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DownloadOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_add_OpenOperationCompleted(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaSource", L"OpenOperationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaSource, winrt::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs>>(arg);

            return py::convert(self->obj.OpenOperationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_remove_OpenOperationCompleted(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaSource", L"OpenOperationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.OpenOperationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_add_StateChanged(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaSource", L"StateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaSource, winrt::Windows::Media::Core::MediaSourceStateChangedEventArgs>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_remove_StateChanged(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaSource", L"StateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MediaSource(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_MediaSource(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaSource[] = {
        { "close", reinterpret_cast<PyCFunction>(MediaSource_Close), METH_VARARGS, nullptr },
        { "open_async", reinterpret_cast<PyCFunction>(MediaSource_OpenAsync), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(MediaSource_Reset), METH_VARARGS, nullptr },
        { "add_open_operation_completed", reinterpret_cast<PyCFunction>(MediaSource_add_OpenOperationCompleted), METH_O, nullptr },
        { "remove_open_operation_completed", reinterpret_cast<PyCFunction>(MediaSource_remove_OpenOperationCompleted), METH_O, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(MediaSource_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(MediaSource_remove_StateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_MediaSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaSource), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MediaSource), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_MediaSource), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaSource[] = {
        { "custom_properties", reinterpret_cast<getter>(MediaSource_get_CustomProperties), nullptr, nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(MediaSource_get_Duration), nullptr, nullptr, nullptr },
        { "external_timed_metadata_tracks", reinterpret_cast<getter>(MediaSource_get_ExternalTimedMetadataTracks), nullptr, nullptr, nullptr },
        { "external_timed_text_sources", reinterpret_cast<getter>(MediaSource_get_ExternalTimedTextSources), nullptr, nullptr, nullptr },
        { "is_open", reinterpret_cast<getter>(MediaSource_get_IsOpen), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(MediaSource_get_State), nullptr, nullptr, nullptr },
        { "adaptive_media_source", reinterpret_cast<getter>(MediaSource_get_AdaptiveMediaSource), nullptr, nullptr, nullptr },
        { "media_stream_source", reinterpret_cast<getter>(MediaSource_get_MediaStreamSource), nullptr, nullptr, nullptr },
        { "mse_stream_source", reinterpret_cast<getter>(MediaSource_get_MseStreamSource), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(MediaSource_get_Uri), nullptr, nullptr, nullptr },
        { "download_operation", reinterpret_cast<getter>(MediaSource_get_DownloadOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaSource) },
        { }
    };

    static PyType_Spec type_spec_MediaSource = {
        "winrt._winrt_windows_media_core.MediaSource",
        sizeof(py::wrapper::Windows::Media::Core::MediaSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaSource};

    static PyGetSetDef getset_MediaSource_Static[] = {
        { }
    };

    static PyMethodDef methods_MediaSource_Static[] = {
        { "create_from_adaptive_media_source", reinterpret_cast<PyCFunction>(MediaSource_CreateFromAdaptiveMediaSource), METH_VARARGS, nullptr },
        { "create_from_download_operation", reinterpret_cast<PyCFunction>(MediaSource_CreateFromDownloadOperation), METH_VARARGS, nullptr },
        { "create_from_imedia_source", reinterpret_cast<PyCFunction>(MediaSource_CreateFromIMediaSource), METH_VARARGS, nullptr },
        { "create_from_media_binder", reinterpret_cast<PyCFunction>(MediaSource_CreateFromMediaBinder), METH_VARARGS, nullptr },
        { "create_from_media_frame_source", reinterpret_cast<PyCFunction>(MediaSource_CreateFromMediaFrameSource), METH_VARARGS, nullptr },
        { "create_from_media_stream_source", reinterpret_cast<PyCFunction>(MediaSource_CreateFromMediaStreamSource), METH_VARARGS, nullptr },
        { "create_from_mse_stream_source", reinterpret_cast<PyCFunction>(MediaSource_CreateFromMseStreamSource), METH_VARARGS, nullptr },
        { "create_from_storage_file", reinterpret_cast<PyCFunction>(MediaSource_CreateFromStorageFile), METH_VARARGS, nullptr },
        { "create_from_stream", reinterpret_cast<PyCFunction>(MediaSource_CreateFromStream), METH_VARARGS, nullptr },
        { "create_from_stream_reference", reinterpret_cast<PyCFunction>(MediaSource_CreateFromStreamReference), METH_VARARGS, nullptr },
        { "create_from_uri", reinterpret_cast<PyCFunction>(MediaSource_CreateFromUri), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_MediaSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MediaSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MediaSource_Static) },
        { }
    };

    static PyType_Spec type_spec_MediaSource_Static =
    {
        "winrt._winrt_windows_media_core.MediaSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MediaSource_Static
    };

    // ----- MediaSourceAppServiceConnection class --------------------

    static PyObject* _new_MediaSourceAppServiceConnection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::AppService::AppServiceConnection>(args, 0);

                winrt::Windows::Media::Core::MediaSourceAppServiceConnection instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaSourceAppServiceConnection(py::wrapper::Windows::Media::Core::MediaSourceAppServiceConnection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaSourceAppServiceConnection_Start(py::wrapper::Windows::Media::Core::MediaSourceAppServiceConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaSourceAppServiceConnection", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAppServiceConnection_add_InitializeMediaStreamSourceRequested(py::wrapper::Windows::Media::Core::MediaSourceAppServiceConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaSourceAppServiceConnection", L"InitializeMediaStreamSourceRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaSourceAppServiceConnection, winrt::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs>>(arg);

            return py::convert(self->obj.InitializeMediaStreamSourceRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAppServiceConnection_remove_InitializeMediaStreamSourceRequested(py::wrapper::Windows::Media::Core::MediaSourceAppServiceConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaSourceAppServiceConnection", L"InitializeMediaStreamSourceRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.InitializeMediaStreamSourceRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaSourceAppServiceConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaSourceAppServiceConnection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaSourceAppServiceConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaSourceAppServiceConnection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaSourceAppServiceConnection[] = {
        { "start", reinterpret_cast<PyCFunction>(MediaSourceAppServiceConnection_Start), METH_VARARGS, nullptr },
        { "add_initialize_media_stream_source_requested", reinterpret_cast<PyCFunction>(MediaSourceAppServiceConnection_add_InitializeMediaStreamSourceRequested), METH_O, nullptr },
        { "remove_initialize_media_stream_source_requested", reinterpret_cast<PyCFunction>(MediaSourceAppServiceConnection_remove_InitializeMediaStreamSourceRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_MediaSourceAppServiceConnection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaSourceAppServiceConnection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaSourceAppServiceConnection[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaSourceAppServiceConnection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaSourceAppServiceConnection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaSourceAppServiceConnection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaSourceAppServiceConnection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaSourceAppServiceConnection) },
        { }
    };

    static PyType_Spec type_spec_MediaSourceAppServiceConnection = {
        "winrt._winrt_windows_media_core.MediaSourceAppServiceConnection",
        sizeof(py::wrapper::Windows::Media::Core::MediaSourceAppServiceConnection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaSourceAppServiceConnection};

    // ----- MediaSourceError class --------------------

    static PyObject* _new_MediaSourceError(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::MediaSourceError>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::MediaSourceError>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaSourceError(py::wrapper::Windows::Media::Core::MediaSourceError* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaSourceError_get_ExtendedError(py::wrapper::Windows::Media::Core::MediaSourceError* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaSourceError", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaSourceError(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaSourceError>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaSourceError(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaSourceError>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaSourceError[] = {
        { "_assign_array_", _assign_array_MediaSourceError, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaSourceError), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaSourceError[] = {
        { "extended_error", reinterpret_cast<getter>(MediaSourceError_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaSourceError[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaSourceError) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaSourceError) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaSourceError) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaSourceError) },
        { }
    };

    static PyType_Spec type_spec_MediaSourceError = {
        "winrt._winrt_windows_media_core.MediaSourceError",
        sizeof(py::wrapper::Windows::Media::Core::MediaSourceError),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaSourceError};

    // ----- MediaSourceOpenOperationCompletedEventArgs class --------------------

    static PyObject* _new_MediaSourceOpenOperationCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaSourceOpenOperationCompletedEventArgs(py::wrapper::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaSourceOpenOperationCompletedEventArgs_get_Error(py::wrapper::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaSourceOpenOperationCompletedEventArgs", L"Error");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaSourceOpenOperationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaSourceOpenOperationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaSourceOpenOperationCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_MediaSourceOpenOperationCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaSourceOpenOperationCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaSourceOpenOperationCompletedEventArgs[] = {
        { "error", reinterpret_cast<getter>(MediaSourceOpenOperationCompletedEventArgs_get_Error), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaSourceOpenOperationCompletedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaSourceOpenOperationCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaSourceOpenOperationCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaSourceOpenOperationCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaSourceOpenOperationCompletedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MediaSourceOpenOperationCompletedEventArgs = {
        "winrt._winrt_windows_media_core.MediaSourceOpenOperationCompletedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaSourceOpenOperationCompletedEventArgs};

    // ----- MediaSourceStateChangedEventArgs class --------------------

    static PyObject* _new_MediaSourceStateChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::MediaSourceStateChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::MediaSourceStateChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaSourceStateChangedEventArgs(py::wrapper::Windows::Media::Core::MediaSourceStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaSourceStateChangedEventArgs_get_NewState(py::wrapper::Windows::Media::Core::MediaSourceStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaSourceStateChangedEventArgs", L"NewState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NewState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceStateChangedEventArgs_get_OldState(py::wrapper::Windows::Media::Core::MediaSourceStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaSourceStateChangedEventArgs", L"OldState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OldState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaSourceStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaSourceStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaSourceStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaSourceStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaSourceStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_MediaSourceStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaSourceStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaSourceStateChangedEventArgs[] = {
        { "new_state", reinterpret_cast<getter>(MediaSourceStateChangedEventArgs_get_NewState), nullptr, nullptr, nullptr },
        { "old_state", reinterpret_cast<getter>(MediaSourceStateChangedEventArgs_get_OldState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaSourceStateChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaSourceStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaSourceStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaSourceStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaSourceStateChangedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MediaSourceStateChangedEventArgs = {
        "winrt._winrt_windows_media_core.MediaSourceStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaSourceStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaSourceStateChangedEventArgs};

    // ----- MediaStreamSample class --------------------

    static PyObject* _new_MediaStreamSample(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::MediaStreamSample>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::MediaStreamSample>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaStreamSample(py::wrapper::Windows::Media::Core::MediaStreamSample* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSample_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSample", L"CreateFromBuffer", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(winrt::Windows::Media::Core::MediaStreamSample::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_CreateFromDirect3D11Surface(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSample", L"CreateFromDirect3D11Surface", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(winrt::Windows::Media::Core::MediaStreamSample::CreateFromDirect3D11Surface(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_CreateFromStreamAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSample", L"CreateFromStreamAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 2);

                return py::convert(winrt::Windows::Media::Core::MediaStreamSample::CreateFromStreamAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_get_KeyFrame(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSample", L"KeyFrame");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSample_put_KeyFrame(py::wrapper::Windows::Media::Core::MediaStreamSample* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSample", L"KeyFrame");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.KeyFrame(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSample_get_Duration(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSample", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSample_put_Duration(py::wrapper::Windows::Media::Core::MediaStreamSample* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSample", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSample_get_Discontinuous(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSample", L"Discontinuous");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Discontinuous());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSample_put_Discontinuous(py::wrapper::Windows::Media::Core::MediaStreamSample* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSample", L"Discontinuous");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Discontinuous(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSample_get_DecodeTimestamp(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSample", L"DecodeTimestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DecodeTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSample_put_DecodeTimestamp(py::wrapper::Windows::Media::Core::MediaStreamSample* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSample", L"DecodeTimestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.DecodeTimestamp(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSample_get_Buffer(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSample", L"Buffer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Buffer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_get_ExtendedProperties(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSample", L"ExtendedProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_get_Protection(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSample", L"Protection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Protection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_get_Timestamp(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSample", L"Timestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_get_Direct3D11Surface(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSample", L"Direct3D11Surface");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Direct3D11Surface());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_add_Processed(py::wrapper::Windows::Media::Core::MediaStreamSample* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaStreamSample", L"Processed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSample, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Processed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_remove_Processed(py::wrapper::Windows::Media::Core::MediaStreamSample* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaStreamSample", L"Processed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Processed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaStreamSample(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaStreamSample>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaStreamSample(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSample>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSample[] = {
        { "add_processed", reinterpret_cast<PyCFunction>(MediaStreamSample_add_Processed), METH_O, nullptr },
        { "remove_processed", reinterpret_cast<PyCFunction>(MediaStreamSample_remove_Processed), METH_O, nullptr },
        { "_assign_array_", _assign_array_MediaStreamSample, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSample), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSample[] = {
        { "key_frame", reinterpret_cast<getter>(MediaStreamSample_get_KeyFrame), reinterpret_cast<setter>(MediaStreamSample_put_KeyFrame), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(MediaStreamSample_get_Duration), reinterpret_cast<setter>(MediaStreamSample_put_Duration), nullptr, nullptr },
        { "discontinuous", reinterpret_cast<getter>(MediaStreamSample_get_Discontinuous), reinterpret_cast<setter>(MediaStreamSample_put_Discontinuous), nullptr, nullptr },
        { "decode_timestamp", reinterpret_cast<getter>(MediaStreamSample_get_DecodeTimestamp), reinterpret_cast<setter>(MediaStreamSample_put_DecodeTimestamp), nullptr, nullptr },
        { "buffer", reinterpret_cast<getter>(MediaStreamSample_get_Buffer), nullptr, nullptr, nullptr },
        { "extended_properties", reinterpret_cast<getter>(MediaStreamSample_get_ExtendedProperties), nullptr, nullptr, nullptr },
        { "protection", reinterpret_cast<getter>(MediaStreamSample_get_Protection), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MediaStreamSample_get_Timestamp), nullptr, nullptr, nullptr },
        { "direct3d11_surface", reinterpret_cast<getter>(MediaStreamSample_get_Direct3D11Surface), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSample[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaStreamSample) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaStreamSample) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaStreamSample) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaStreamSample) },
        { }
    };

    static PyType_Spec type_spec_MediaStreamSample = {
        "winrt._winrt_windows_media_core.MediaStreamSample",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSample),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSample};

    static PyGetSetDef getset_MediaStreamSample_Static[] = {
        { }
    };

    static PyMethodDef methods_MediaStreamSample_Static[] = {
        { "create_from_buffer", reinterpret_cast<PyCFunction>(MediaStreamSample_CreateFromBuffer), METH_VARARGS, nullptr },
        { "create_from_direct3d11_surface", reinterpret_cast<PyCFunction>(MediaStreamSample_CreateFromDirect3D11Surface), METH_VARARGS, nullptr },
        { "create_from_stream_async", reinterpret_cast<PyCFunction>(MediaStreamSample_CreateFromStreamAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_MediaStreamSample_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MediaStreamSample_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MediaStreamSample_Static) },
        { }
    };

    static PyType_Spec type_spec_MediaStreamSample_Static =
    {
        "winrt._winrt_windows_media_core.MediaStreamSample_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MediaStreamSample_Static
    };

    // ----- MediaStreamSamplePropertySet class --------------------

    static PyObject* _new_MediaStreamSamplePropertySet(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::MediaStreamSamplePropertySet>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::MediaStreamSamplePropertySet>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaStreamSamplePropertySet(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSamplePropertySet_Clear(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSamplePropertySet", L"Clear", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_First(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSamplePropertySet", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_GetView(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSamplePropertySet", L"GetView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_HasKey(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSamplePropertySet", L"HasKey", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_Insert(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSamplePropertySet", L"Insert", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Insert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_Lookup(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSamplePropertySet", L"Lookup", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_Remove(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSamplePropertySet", L"Remove", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_get_Size(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSamplePropertySet", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaStreamSamplePropertySet(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaStreamSamplePropertySet>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaStreamSamplePropertySet(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSamplePropertySet>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_MediaStreamSamplePropertySet(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self) noexcept
    {
        try
        {
            py::pyobj_handle iter{py::convert(self->obj.First())};

            if (!iter)
            {
                return nullptr;
            }

            return py::wrap_mapping_iter(iter.get());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_contains_MediaStreamSamplePropertySet(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* key) noexcept
    {
        try
        {
            return static_cast<int>(self->obj.HasKey(py::convert_to<winrt::guid>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static Py_ssize_t _map_length_MediaStreamSamplePropertySet(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_MediaStreamSamplePropertySet(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* key) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::guid>(key);
            auto value = self->obj.TryLookup(_key);

            if (!value) {
                if constexpr (std::is_base_of_v<winrt::Windows::Foundation::IUnknown, decltype(value)>)
                {
                    if (self->obj.HasKey(_key))
                    {
                        Py_RETURN_NONE;
                    }
                }

                PyErr_SetObject(PyExc_KeyError, key);
                return nullptr;
            }

            return py::convert(value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_MediaStreamSamplePropertySet(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::guid>(key);

            if (value == nullptr) {
                if (!self->obj.TryRemove(_key)) {
                    PyErr_SetObject(PyExc_KeyError, key);
                    return -1;
                }

                return 0;
            }

            self->obj.Insert(_key, py::convert_to<winrt::Windows::Foundation::IInspectable>(value));

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_MediaStreamSamplePropertySet[] = {
        { "clear", reinterpret_cast<PyCFunction>(MediaStreamSamplePropertySet_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(MediaStreamSamplePropertySet_First), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(MediaStreamSamplePropertySet_GetView), METH_VARARGS, nullptr },
        { "has_key", reinterpret_cast<PyCFunction>(MediaStreamSamplePropertySet_HasKey), METH_VARARGS, nullptr },
        { "insert", reinterpret_cast<PyCFunction>(MediaStreamSamplePropertySet_Insert), METH_VARARGS, nullptr },
        { "lookup", reinterpret_cast<PyCFunction>(MediaStreamSamplePropertySet_Lookup), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(MediaStreamSamplePropertySet_Remove), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaStreamSamplePropertySet, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSamplePropertySet), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSamplePropertySet[] = {
        { "size", reinterpret_cast<getter>(MediaStreamSamplePropertySet_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSamplePropertySet[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaStreamSamplePropertySet) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaStreamSamplePropertySet) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaStreamSamplePropertySet) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaStreamSamplePropertySet) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_MediaStreamSamplePropertySet) },
        { Py_sq_contains, reinterpret_cast<void*>(_map_contains_MediaStreamSamplePropertySet) },
        { Py_mp_length, reinterpret_cast<void*>(_map_length_MediaStreamSamplePropertySet) },
        { Py_mp_subscript, reinterpret_cast<void*>(_map_subscript_MediaStreamSamplePropertySet) },
        { Py_mp_ass_subscript, reinterpret_cast<void*>(_map_assign_MediaStreamSamplePropertySet) },
        { }
    };

    static PyType_Spec type_spec_MediaStreamSamplePropertySet = {
        "winrt._winrt_windows_media_core.MediaStreamSamplePropertySet",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSamplePropertySet};

    // ----- MediaStreamSampleProtectionProperties class --------------------

    static PyObject* _new_MediaStreamSampleProtectionProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::MediaStreamSampleProtectionProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::MediaStreamSampleProtectionProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaStreamSampleProtectionProperties(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSampleProtectionProperties_GetInitializationVector(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSampleProtectionProperties", L"GetInitializationVector", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<uint8_t> param0{};

                self->obj.GetInitializationVector(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSampleProtectionProperties_GetKeyIdentifier(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSampleProtectionProperties", L"GetKeyIdentifier", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<uint8_t> param0{};

                self->obj.GetKeyIdentifier(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSampleProtectionProperties_GetSubSampleMapping(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSampleProtectionProperties", L"GetSubSampleMapping", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<uint8_t> param0{};

                self->obj.GetSubSampleMapping(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSampleProtectionProperties_SetInitializationVector(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSampleProtectionProperties", L"SetInitializationVector", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                self->obj.SetInitializationVector(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSampleProtectionProperties_SetKeyIdentifier(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSampleProtectionProperties", L"SetKeyIdentifier", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                self->obj.SetKeyIdentifier(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSampleProtectionProperties_SetSubSampleMapping(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSampleProtectionProperties", L"SetSubSampleMapping", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                self->obj.SetSubSampleMapping(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaStreamSampleProtectionProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaStreamSampleProtectionProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaStreamSampleProtectionProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSampleProtectionProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSampleProtectionProperties[] = {
        { "get_initialization_vector", reinterpret_cast<PyCFunction>(MediaStreamSampleProtectionProperties_GetInitializationVector), METH_VARARGS, nullptr },
        { "get_key_identifier", reinterpret_cast<PyCFunction>(MediaStreamSampleProtectionProperties_GetKeyIdentifier), METH_VARARGS, nullptr },
        { "get_sub_sample_mapping", reinterpret_cast<PyCFunction>(MediaStreamSampleProtectionProperties_GetSubSampleMapping), METH_VARARGS, nullptr },
        { "set_initialization_vector", reinterpret_cast<PyCFunction>(MediaStreamSampleProtectionProperties_SetInitializationVector), METH_VARARGS, nullptr },
        { "set_key_identifier", reinterpret_cast<PyCFunction>(MediaStreamSampleProtectionProperties_SetKeyIdentifier), METH_VARARGS, nullptr },
        { "set_sub_sample_mapping", reinterpret_cast<PyCFunction>(MediaStreamSampleProtectionProperties_SetSubSampleMapping), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaStreamSampleProtectionProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSampleProtectionProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSampleProtectionProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSampleProtectionProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaStreamSampleProtectionProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaStreamSampleProtectionProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaStreamSampleProtectionProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaStreamSampleProtectionProperties) },
        { }
    };

    static PyType_Spec type_spec_MediaStreamSampleProtectionProperties = {
        "winrt._winrt_windows_media_core.MediaStreamSampleProtectionProperties",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSampleProtectionProperties};

    // ----- MediaStreamSource class --------------------

    static PyObject* _new_MediaStreamSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 0);

                winrt::Windows::Media::Core::MediaStreamSource instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 1);

                winrt::Windows::Media::Core::MediaStreamSource instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaStreamSource(py::wrapper::Windows::Media::Core::MediaStreamSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSource_AddProtectionKey(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSource", L"AddProtectionKey", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 2);

                self->obj.AddProtectionKey(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_AddStreamDescriptor(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSource", L"AddStreamDescriptor", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 0);

                self->obj.AddStreamDescriptor(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_NotifyError(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSource", L"NotifyError", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaStreamSourceErrorStatus>(args, 0);

                self->obj.NotifyError(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_SetBufferedRange(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSource", L"SetBufferedRange", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                self->obj.SetBufferedRange(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_get_Thumbnail(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSource", L"Thumbnail");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_Thumbnail(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSource", L"Thumbnail");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.Thumbnail(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_get_MediaProtectionManager(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSource", L"MediaProtectionManager");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MediaProtectionManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_MediaProtectionManager(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSource", L"MediaProtectionManager");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Protection::MediaProtectionManager>(arg);

            self->obj.MediaProtectionManager(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_get_Duration(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSource", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_Duration(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSource", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_get_CanSeek(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSource", L"CanSeek");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanSeek());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_CanSeek(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSource", L"CanSeek");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanSeek(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_get_BufferTime(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSource", L"BufferTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BufferTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_BufferTime(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSource", L"BufferTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.BufferTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_get_MusicProperties(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSource", L"MusicProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MusicProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_get_VideoProperties(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSource", L"VideoProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_get_MaxSupportedPlaybackRate(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSource", L"MaxSupportedPlaybackRate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxSupportedPlaybackRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_MaxSupportedPlaybackRate(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSource", L"MaxSupportedPlaybackRate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<double>>(arg);

            self->obj.MaxSupportedPlaybackRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_get_IsLive(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSource", L"IsLive");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsLive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_IsLive(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSource", L"IsLive");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLive(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_add_Closed(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaStreamSource", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSource, winrt::Windows::Media::Core::MediaStreamSourceClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_remove_Closed(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaStreamSource", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_add_Paused(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaStreamSource", L"Paused");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Paused(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_remove_Paused(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaStreamSource", L"Paused");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Paused(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_add_SampleRequested(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaStreamSource", L"SampleRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSource, winrt::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs>>(arg);

            return py::convert(self->obj.SampleRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_remove_SampleRequested(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaStreamSource", L"SampleRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SampleRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_add_Starting(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaStreamSource", L"Starting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSource, winrt::Windows::Media::Core::MediaStreamSourceStartingEventArgs>>(arg);

            return py::convert(self->obj.Starting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_remove_Starting(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaStreamSource", L"Starting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Starting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_add_SwitchStreamsRequested(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaStreamSource", L"SwitchStreamsRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSource, winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs>>(arg);

            return py::convert(self->obj.SwitchStreamsRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_remove_SwitchStreamsRequested(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaStreamSource", L"SwitchStreamsRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SwitchStreamsRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_add_SampleRendered(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaStreamSource", L"SampleRendered");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSource, winrt::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs>>(arg);

            return py::convert(self->obj.SampleRendered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_remove_SampleRendered(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MediaStreamSource", L"SampleRendered");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SampleRendered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaStreamSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaStreamSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaStreamSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSource[] = {
        { "add_protection_key", reinterpret_cast<PyCFunction>(MediaStreamSource_AddProtectionKey), METH_VARARGS, nullptr },
        { "add_stream_descriptor", reinterpret_cast<PyCFunction>(MediaStreamSource_AddStreamDescriptor), METH_VARARGS, nullptr },
        { "notify_error", reinterpret_cast<PyCFunction>(MediaStreamSource_NotifyError), METH_VARARGS, nullptr },
        { "set_buffered_range", reinterpret_cast<PyCFunction>(MediaStreamSource_SetBufferedRange), METH_VARARGS, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(MediaStreamSource_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(MediaStreamSource_remove_Closed), METH_O, nullptr },
        { "add_paused", reinterpret_cast<PyCFunction>(MediaStreamSource_add_Paused), METH_O, nullptr },
        { "remove_paused", reinterpret_cast<PyCFunction>(MediaStreamSource_remove_Paused), METH_O, nullptr },
        { "add_sample_requested", reinterpret_cast<PyCFunction>(MediaStreamSource_add_SampleRequested), METH_O, nullptr },
        { "remove_sample_requested", reinterpret_cast<PyCFunction>(MediaStreamSource_remove_SampleRequested), METH_O, nullptr },
        { "add_starting", reinterpret_cast<PyCFunction>(MediaStreamSource_add_Starting), METH_O, nullptr },
        { "remove_starting", reinterpret_cast<PyCFunction>(MediaStreamSource_remove_Starting), METH_O, nullptr },
        { "add_switch_streams_requested", reinterpret_cast<PyCFunction>(MediaStreamSource_add_SwitchStreamsRequested), METH_O, nullptr },
        { "remove_switch_streams_requested", reinterpret_cast<PyCFunction>(MediaStreamSource_remove_SwitchStreamsRequested), METH_O, nullptr },
        { "add_sample_rendered", reinterpret_cast<PyCFunction>(MediaStreamSource_add_SampleRendered), METH_O, nullptr },
        { "remove_sample_rendered", reinterpret_cast<PyCFunction>(MediaStreamSource_remove_SampleRendered), METH_O, nullptr },
        { "_assign_array_", _assign_array_MediaStreamSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSource[] = {
        { "thumbnail", reinterpret_cast<getter>(MediaStreamSource_get_Thumbnail), reinterpret_cast<setter>(MediaStreamSource_put_Thumbnail), nullptr, nullptr },
        { "media_protection_manager", reinterpret_cast<getter>(MediaStreamSource_get_MediaProtectionManager), reinterpret_cast<setter>(MediaStreamSource_put_MediaProtectionManager), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(MediaStreamSource_get_Duration), reinterpret_cast<setter>(MediaStreamSource_put_Duration), nullptr, nullptr },
        { "can_seek", reinterpret_cast<getter>(MediaStreamSource_get_CanSeek), reinterpret_cast<setter>(MediaStreamSource_put_CanSeek), nullptr, nullptr },
        { "buffer_time", reinterpret_cast<getter>(MediaStreamSource_get_BufferTime), reinterpret_cast<setter>(MediaStreamSource_put_BufferTime), nullptr, nullptr },
        { "music_properties", reinterpret_cast<getter>(MediaStreamSource_get_MusicProperties), nullptr, nullptr, nullptr },
        { "video_properties", reinterpret_cast<getter>(MediaStreamSource_get_VideoProperties), nullptr, nullptr, nullptr },
        { "max_supported_playback_rate", reinterpret_cast<getter>(MediaStreamSource_get_MaxSupportedPlaybackRate), reinterpret_cast<setter>(MediaStreamSource_put_MaxSupportedPlaybackRate), nullptr, nullptr },
        { "is_live", reinterpret_cast<getter>(MediaStreamSource_get_IsLive), reinterpret_cast<setter>(MediaStreamSource_put_IsLive), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaStreamSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaStreamSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaStreamSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaStreamSource) },
        { }
    };

    static PyType_Spec type_spec_MediaStreamSource = {
        "winrt._winrt_windows_media_core.MediaStreamSource",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSource};

    // ----- MediaStreamSourceClosedEventArgs class --------------------

    static PyObject* _new_MediaStreamSourceClosedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::MediaStreamSourceClosedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::MediaStreamSourceClosedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceClosedEventArgs(py::wrapper::Windows::Media::Core::MediaStreamSourceClosedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceClosedEventArgs_get_Request(py::wrapper::Windows::Media::Core::MediaStreamSourceClosedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSourceClosedEventArgs", L"Request");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaStreamSourceClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaStreamSourceClosedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaStreamSourceClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceClosedEventArgs[] = {
        { "_assign_array_", _assign_array_MediaStreamSourceClosedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceClosedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceClosedEventArgs[] = {
        { "request", reinterpret_cast<getter>(MediaStreamSourceClosedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceClosedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaStreamSourceClosedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaStreamSourceClosedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaStreamSourceClosedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaStreamSourceClosedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MediaStreamSourceClosedEventArgs = {
        "winrt._winrt_windows_media_core.MediaStreamSourceClosedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceClosedEventArgs};

    // ----- MediaStreamSourceClosedRequest class --------------------

    static PyObject* _new_MediaStreamSourceClosedRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::MediaStreamSourceClosedRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::MediaStreamSourceClosedRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceClosedRequest(py::wrapper::Windows::Media::Core::MediaStreamSourceClosedRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceClosedRequest_get_Reason(py::wrapper::Windows::Media::Core::MediaStreamSourceClosedRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSourceClosedRequest", L"Reason");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaStreamSourceClosedRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaStreamSourceClosedRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaStreamSourceClosedRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceClosedRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceClosedRequest[] = {
        { "_assign_array_", _assign_array_MediaStreamSourceClosedRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceClosedRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceClosedRequest[] = {
        { "reason", reinterpret_cast<getter>(MediaStreamSourceClosedRequest_get_Reason), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceClosedRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaStreamSourceClosedRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaStreamSourceClosedRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaStreamSourceClosedRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaStreamSourceClosedRequest) },
        { }
    };

    static PyType_Spec type_spec_MediaStreamSourceClosedRequest = {
        "winrt._winrt_windows_media_core.MediaStreamSourceClosedRequest",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceClosedRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceClosedRequest};

    // ----- MediaStreamSourceSampleRenderedEventArgs class --------------------

    static PyObject* _new_MediaStreamSourceSampleRenderedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSampleRenderedEventArgs(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceSampleRenderedEventArgs_get_SampleLag(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSourceSampleRenderedEventArgs", L"SampleLag");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SampleLag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaStreamSourceSampleRenderedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaStreamSourceSampleRenderedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSampleRenderedEventArgs[] = {
        { "_assign_array_", _assign_array_MediaStreamSourceSampleRenderedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceSampleRenderedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceSampleRenderedEventArgs[] = {
        { "sample_lag", reinterpret_cast<getter>(MediaStreamSourceSampleRenderedEventArgs_get_SampleLag), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSampleRenderedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaStreamSourceSampleRenderedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaStreamSourceSampleRenderedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaStreamSourceSampleRenderedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaStreamSourceSampleRenderedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MediaStreamSourceSampleRenderedEventArgs = {
        "winrt._winrt_windows_media_core.MediaStreamSourceSampleRenderedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSampleRenderedEventArgs};

    // ----- MediaStreamSourceSampleRequest class --------------------

    static PyObject* _new_MediaStreamSourceSampleRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::MediaStreamSourceSampleRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::MediaStreamSourceSampleRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSampleRequest(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceSampleRequest_GetDeferral(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSourceSampleRequest", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSourceSampleRequest_ReportSampleProgress(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSourceSampleRequest", L"ReportSampleProgress", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.ReportSampleProgress(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSourceSampleRequest_get_Sample(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSourceSampleRequest", L"Sample");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Sample());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSourceSampleRequest_put_Sample(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSourceSampleRequest", L"Sample");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaStreamSample>(arg);

            self->obj.Sample(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSourceSampleRequest_get_StreamDescriptor(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSourceSampleRequest", L"StreamDescriptor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StreamDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaStreamSourceSampleRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaStreamSourceSampleRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaStreamSourceSampleRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSampleRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSampleRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MediaStreamSourceSampleRequest_GetDeferral), METH_VARARGS, nullptr },
        { "report_sample_progress", reinterpret_cast<PyCFunction>(MediaStreamSourceSampleRequest_ReportSampleProgress), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaStreamSourceSampleRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceSampleRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceSampleRequest[] = {
        { "sample", reinterpret_cast<getter>(MediaStreamSourceSampleRequest_get_Sample), reinterpret_cast<setter>(MediaStreamSourceSampleRequest_put_Sample), nullptr, nullptr },
        { "stream_descriptor", reinterpret_cast<getter>(MediaStreamSourceSampleRequest_get_StreamDescriptor), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSampleRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaStreamSourceSampleRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaStreamSourceSampleRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaStreamSourceSampleRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaStreamSourceSampleRequest) },
        { }
    };

    static PyType_Spec type_spec_MediaStreamSourceSampleRequest = {
        "winrt._winrt_windows_media_core.MediaStreamSourceSampleRequest",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSampleRequest};

    // ----- MediaStreamSourceSampleRequestDeferral class --------------------

    static PyObject* _new_MediaStreamSourceSampleRequestDeferral(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::MediaStreamSourceSampleRequestDeferral>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::MediaStreamSourceSampleRequestDeferral>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSampleRequestDeferral(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequestDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceSampleRequestDeferral_Complete(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequestDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSourceSampleRequestDeferral", L"Complete", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaStreamSourceSampleRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaStreamSourceSampleRequestDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaStreamSourceSampleRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSampleRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSampleRequestDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(MediaStreamSourceSampleRequestDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaStreamSourceSampleRequestDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceSampleRequestDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceSampleRequestDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSampleRequestDeferral[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaStreamSourceSampleRequestDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaStreamSourceSampleRequestDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaStreamSourceSampleRequestDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaStreamSourceSampleRequestDeferral) },
        { }
    };

    static PyType_Spec type_spec_MediaStreamSourceSampleRequestDeferral = {
        "winrt._winrt_windows_media_core.MediaStreamSourceSampleRequestDeferral",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSampleRequestDeferral};

    // ----- MediaStreamSourceSampleRequestedEventArgs class --------------------

    static PyObject* _new_MediaStreamSourceSampleRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSampleRequestedEventArgs(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceSampleRequestedEventArgs_get_Request(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSourceSampleRequestedEventArgs", L"Request");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaStreamSourceSampleRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaStreamSourceSampleRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSampleRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_MediaStreamSourceSampleRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceSampleRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceSampleRequestedEventArgs[] = {
        { "request", reinterpret_cast<getter>(MediaStreamSourceSampleRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSampleRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaStreamSourceSampleRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaStreamSourceSampleRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaStreamSourceSampleRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaStreamSourceSampleRequestedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MediaStreamSourceSampleRequestedEventArgs = {
        "winrt._winrt_windows_media_core.MediaStreamSourceSampleRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSampleRequestedEventArgs};

    // ----- MediaStreamSourceStartingEventArgs class --------------------

    static PyObject* _new_MediaStreamSourceStartingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::MediaStreamSourceStartingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::MediaStreamSourceStartingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceStartingEventArgs(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceStartingEventArgs_get_Request(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSourceStartingEventArgs", L"Request");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaStreamSourceStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaStreamSourceStartingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaStreamSourceStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceStartingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceStartingEventArgs[] = {
        { "_assign_array_", _assign_array_MediaStreamSourceStartingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceStartingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceStartingEventArgs[] = {
        { "request", reinterpret_cast<getter>(MediaStreamSourceStartingEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceStartingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaStreamSourceStartingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaStreamSourceStartingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaStreamSourceStartingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaStreamSourceStartingEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MediaStreamSourceStartingEventArgs = {
        "winrt._winrt_windows_media_core.MediaStreamSourceStartingEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceStartingEventArgs};

    // ----- MediaStreamSourceStartingRequest class --------------------

    static PyObject* _new_MediaStreamSourceStartingRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::MediaStreamSourceStartingRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::MediaStreamSourceStartingRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceStartingRequest(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceStartingRequest_GetDeferral(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSourceStartingRequest", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSourceStartingRequest_SetActualStartPosition(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSourceStartingRequest", L"SetActualStartPosition", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                self->obj.SetActualStartPosition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSourceStartingRequest_get_StartPosition(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSourceStartingRequest", L"StartPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StartPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaStreamSourceStartingRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaStreamSourceStartingRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaStreamSourceStartingRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceStartingRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceStartingRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MediaStreamSourceStartingRequest_GetDeferral), METH_VARARGS, nullptr },
        { "set_actual_start_position", reinterpret_cast<PyCFunction>(MediaStreamSourceStartingRequest_SetActualStartPosition), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaStreamSourceStartingRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceStartingRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceStartingRequest[] = {
        { "start_position", reinterpret_cast<getter>(MediaStreamSourceStartingRequest_get_StartPosition), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceStartingRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaStreamSourceStartingRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaStreamSourceStartingRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaStreamSourceStartingRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaStreamSourceStartingRequest) },
        { }
    };

    static PyType_Spec type_spec_MediaStreamSourceStartingRequest = {
        "winrt._winrt_windows_media_core.MediaStreamSourceStartingRequest",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceStartingRequest};

    // ----- MediaStreamSourceStartingRequestDeferral class --------------------

    static PyObject* _new_MediaStreamSourceStartingRequestDeferral(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::MediaStreamSourceStartingRequestDeferral>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::MediaStreamSourceStartingRequestDeferral>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceStartingRequestDeferral(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequestDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceStartingRequestDeferral_Complete(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequestDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSourceStartingRequestDeferral", L"Complete", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaStreamSourceStartingRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaStreamSourceStartingRequestDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaStreamSourceStartingRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceStartingRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceStartingRequestDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(MediaStreamSourceStartingRequestDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaStreamSourceStartingRequestDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceStartingRequestDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceStartingRequestDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceStartingRequestDeferral[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaStreamSourceStartingRequestDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaStreamSourceStartingRequestDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaStreamSourceStartingRequestDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaStreamSourceStartingRequestDeferral) },
        { }
    };

    static PyType_Spec type_spec_MediaStreamSourceStartingRequestDeferral = {
        "winrt._winrt_windows_media_core.MediaStreamSourceStartingRequestDeferral",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceStartingRequestDeferral};

    // ----- MediaStreamSourceSwitchStreamsRequest class --------------------

    static PyObject* _new_MediaStreamSourceSwitchStreamsRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSwitchStreamsRequest(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceSwitchStreamsRequest_GetDeferral(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSourceSwitchStreamsRequest", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSourceSwitchStreamsRequest_get_NewStreamDescriptor(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSourceSwitchStreamsRequest", L"NewStreamDescriptor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NewStreamDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSourceSwitchStreamsRequest_get_OldStreamDescriptor(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSourceSwitchStreamsRequest", L"OldStreamDescriptor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OldStreamDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaStreamSourceSwitchStreamsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaStreamSourceSwitchStreamsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSwitchStreamsRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MediaStreamSourceSwitchStreamsRequest_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaStreamSourceSwitchStreamsRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceSwitchStreamsRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceSwitchStreamsRequest[] = {
        { "new_stream_descriptor", reinterpret_cast<getter>(MediaStreamSourceSwitchStreamsRequest_get_NewStreamDescriptor), nullptr, nullptr, nullptr },
        { "old_stream_descriptor", reinterpret_cast<getter>(MediaStreamSourceSwitchStreamsRequest_get_OldStreamDescriptor), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSwitchStreamsRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaStreamSourceSwitchStreamsRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaStreamSourceSwitchStreamsRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaStreamSourceSwitchStreamsRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaStreamSourceSwitchStreamsRequest) },
        { }
    };

    static PyType_Spec type_spec_MediaStreamSourceSwitchStreamsRequest = {
        "winrt._winrt_windows_media_core.MediaStreamSourceSwitchStreamsRequest",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSwitchStreamsRequest};

    // ----- MediaStreamSourceSwitchStreamsRequestDeferral class --------------------

    static PyObject* _new_MediaStreamSourceSwitchStreamsRequestDeferral(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestDeferral>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestDeferral>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSwitchStreamsRequestDeferral(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceSwitchStreamsRequestDeferral_Complete(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MediaStreamSourceSwitchStreamsRequestDeferral", L"Complete", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaStreamSourceSwitchStreamsRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaStreamSourceSwitchStreamsRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSwitchStreamsRequestDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(MediaStreamSourceSwitchStreamsRequestDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaStreamSourceSwitchStreamsRequestDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceSwitchStreamsRequestDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceSwitchStreamsRequestDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSwitchStreamsRequestDeferral[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaStreamSourceSwitchStreamsRequestDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaStreamSourceSwitchStreamsRequestDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaStreamSourceSwitchStreamsRequestDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaStreamSourceSwitchStreamsRequestDeferral) },
        { }
    };

    static PyType_Spec type_spec_MediaStreamSourceSwitchStreamsRequestDeferral = {
        "winrt._winrt_windows_media_core.MediaStreamSourceSwitchStreamsRequestDeferral",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSwitchStreamsRequestDeferral};

    // ----- MediaStreamSourceSwitchStreamsRequestedEventArgs class --------------------

    static PyObject* _new_MediaStreamSourceSwitchStreamsRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSwitchStreamsRequestedEventArgs(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceSwitchStreamsRequestedEventArgs_get_Request(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MediaStreamSourceSwitchStreamsRequestedEventArgs", L"Request");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaStreamSourceSwitchStreamsRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaStreamSourceSwitchStreamsRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSwitchStreamsRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_MediaStreamSourceSwitchStreamsRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceSwitchStreamsRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceSwitchStreamsRequestedEventArgs[] = {
        { "request", reinterpret_cast<getter>(MediaStreamSourceSwitchStreamsRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSwitchStreamsRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaStreamSourceSwitchStreamsRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaStreamSourceSwitchStreamsRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaStreamSourceSwitchStreamsRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaStreamSourceSwitchStreamsRequestedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MediaStreamSourceSwitchStreamsRequestedEventArgs = {
        "winrt._winrt_windows_media_core.MediaStreamSourceSwitchStreamsRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSwitchStreamsRequestedEventArgs};

    // ----- MseSourceBuffer class --------------------

    static PyObject* _new_MseSourceBuffer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::MseSourceBuffer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::MseSourceBuffer>::type_name);
        return nullptr;
    }

    static void _dealloc_MseSourceBuffer(py::wrapper::Windows::Media::Core::MseSourceBuffer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MseSourceBuffer_Abort(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MseSourceBuffer", L"Abort", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Abort();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_AppendBuffer(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MseSourceBuffer", L"AppendBuffer", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.AppendBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_AppendStream(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MseSourceBuffer", L"AppendStream", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                self->obj.AppendStream(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_AppendStreamMaxSize(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MseSourceBuffer", L"AppendStream", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);
                auto param1 = py::convert_to<uint64_t>(args, 1);

                self->obj.AppendStream(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_Remove(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MseSourceBuffer", L"Remove", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(args, 1);

                self->obj.Remove(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_get_TimestampOffset(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseSourceBuffer", L"TimestampOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TimestampOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseSourceBuffer_put_TimestampOffset(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseSourceBuffer", L"TimestampOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.TimestampOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseSourceBuffer_get_Mode(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseSourceBuffer", L"Mode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseSourceBuffer_put_Mode(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseSourceBuffer", L"Mode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Core::MseAppendMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseSourceBuffer_get_AppendWindowStart(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseSourceBuffer", L"AppendWindowStart");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppendWindowStart());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseSourceBuffer_put_AppendWindowStart(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseSourceBuffer", L"AppendWindowStart");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.AppendWindowStart(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseSourceBuffer_get_AppendWindowEnd(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseSourceBuffer", L"AppendWindowEnd");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppendWindowEnd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseSourceBuffer_put_AppendWindowEnd(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseSourceBuffer", L"AppendWindowEnd");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.AppendWindowEnd(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseSourceBuffer_get_Buffered(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseSourceBuffer", L"Buffered");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Buffered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_get_IsUpdating(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseSourceBuffer", L"IsUpdating");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsUpdating());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_add_Aborted(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseSourceBuffer", L"Aborted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBuffer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Aborted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_remove_Aborted(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseSourceBuffer", L"Aborted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Aborted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_add_ErrorOccurred(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseSourceBuffer", L"ErrorOccurred");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBuffer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ErrorOccurred(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_remove_ErrorOccurred(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseSourceBuffer", L"ErrorOccurred");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ErrorOccurred(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_add_UpdateEnded(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseSourceBuffer", L"UpdateEnded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBuffer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.UpdateEnded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_remove_UpdateEnded(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseSourceBuffer", L"UpdateEnded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UpdateEnded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_add_UpdateStarting(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseSourceBuffer", L"UpdateStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBuffer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.UpdateStarting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_remove_UpdateStarting(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseSourceBuffer", L"UpdateStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UpdateStarting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_add_Updated(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseSourceBuffer", L"Updated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBuffer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Updated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_remove_Updated(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseSourceBuffer", L"Updated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Updated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MseSourceBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MseSourceBuffer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MseSourceBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MseSourceBuffer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MseSourceBuffer[] = {
        { "abort", reinterpret_cast<PyCFunction>(MseSourceBuffer_Abort), METH_VARARGS, nullptr },
        { "append_buffer", reinterpret_cast<PyCFunction>(MseSourceBuffer_AppendBuffer), METH_VARARGS, nullptr },
        { "append_stream", reinterpret_cast<PyCFunction>(MseSourceBuffer_AppendStream), METH_VARARGS, nullptr },
        { "append_stream_max_size", reinterpret_cast<PyCFunction>(MseSourceBuffer_AppendStreamMaxSize), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(MseSourceBuffer_Remove), METH_VARARGS, nullptr },
        { "add_aborted", reinterpret_cast<PyCFunction>(MseSourceBuffer_add_Aborted), METH_O, nullptr },
        { "remove_aborted", reinterpret_cast<PyCFunction>(MseSourceBuffer_remove_Aborted), METH_O, nullptr },
        { "add_error_occurred", reinterpret_cast<PyCFunction>(MseSourceBuffer_add_ErrorOccurred), METH_O, nullptr },
        { "remove_error_occurred", reinterpret_cast<PyCFunction>(MseSourceBuffer_remove_ErrorOccurred), METH_O, nullptr },
        { "add_update_ended", reinterpret_cast<PyCFunction>(MseSourceBuffer_add_UpdateEnded), METH_O, nullptr },
        { "remove_update_ended", reinterpret_cast<PyCFunction>(MseSourceBuffer_remove_UpdateEnded), METH_O, nullptr },
        { "add_update_starting", reinterpret_cast<PyCFunction>(MseSourceBuffer_add_UpdateStarting), METH_O, nullptr },
        { "remove_update_starting", reinterpret_cast<PyCFunction>(MseSourceBuffer_remove_UpdateStarting), METH_O, nullptr },
        { "add_updated", reinterpret_cast<PyCFunction>(MseSourceBuffer_add_Updated), METH_O, nullptr },
        { "remove_updated", reinterpret_cast<PyCFunction>(MseSourceBuffer_remove_Updated), METH_O, nullptr },
        { "_assign_array_", _assign_array_MseSourceBuffer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MseSourceBuffer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MseSourceBuffer[] = {
        { "timestamp_offset", reinterpret_cast<getter>(MseSourceBuffer_get_TimestampOffset), reinterpret_cast<setter>(MseSourceBuffer_put_TimestampOffset), nullptr, nullptr },
        { "mode", reinterpret_cast<getter>(MseSourceBuffer_get_Mode), reinterpret_cast<setter>(MseSourceBuffer_put_Mode), nullptr, nullptr },
        { "append_window_start", reinterpret_cast<getter>(MseSourceBuffer_get_AppendWindowStart), reinterpret_cast<setter>(MseSourceBuffer_put_AppendWindowStart), nullptr, nullptr },
        { "append_window_end", reinterpret_cast<getter>(MseSourceBuffer_get_AppendWindowEnd), reinterpret_cast<setter>(MseSourceBuffer_put_AppendWindowEnd), nullptr, nullptr },
        { "buffered", reinterpret_cast<getter>(MseSourceBuffer_get_Buffered), nullptr, nullptr, nullptr },
        { "is_updating", reinterpret_cast<getter>(MseSourceBuffer_get_IsUpdating), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MseSourceBuffer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MseSourceBuffer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MseSourceBuffer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MseSourceBuffer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MseSourceBuffer) },
        { }
    };

    static PyType_Spec type_spec_MseSourceBuffer = {
        "winrt._winrt_windows_media_core.MseSourceBuffer",
        sizeof(py::wrapper::Windows::Media::Core::MseSourceBuffer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MseSourceBuffer};

    // ----- MseSourceBufferList class --------------------

    static PyObject* _new_MseSourceBufferList(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::MseSourceBufferList>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::MseSourceBufferList>::type_name);
        return nullptr;
    }

    static void _dealloc_MseSourceBufferList(py::wrapper::Windows::Media::Core::MseSourceBufferList* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MseSourceBufferList_get_Buffers(py::wrapper::Windows::Media::Core::MseSourceBufferList* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseSourceBufferList", L"Buffers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Buffers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBufferList_add_SourceBufferAdded(py::wrapper::Windows::Media::Core::MseSourceBufferList* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseSourceBufferList", L"SourceBufferAdded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBufferList, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SourceBufferAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBufferList_remove_SourceBufferAdded(py::wrapper::Windows::Media::Core::MseSourceBufferList* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseSourceBufferList", L"SourceBufferAdded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceBufferAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBufferList_add_SourceBufferRemoved(py::wrapper::Windows::Media::Core::MseSourceBufferList* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseSourceBufferList", L"SourceBufferRemoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBufferList, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SourceBufferRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBufferList_remove_SourceBufferRemoved(py::wrapper::Windows::Media::Core::MseSourceBufferList* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseSourceBufferList", L"SourceBufferRemoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceBufferRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MseSourceBufferList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MseSourceBufferList>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MseSourceBufferList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MseSourceBufferList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MseSourceBufferList[] = {
        { "add_source_buffer_added", reinterpret_cast<PyCFunction>(MseSourceBufferList_add_SourceBufferAdded), METH_O, nullptr },
        { "remove_source_buffer_added", reinterpret_cast<PyCFunction>(MseSourceBufferList_remove_SourceBufferAdded), METH_O, nullptr },
        { "add_source_buffer_removed", reinterpret_cast<PyCFunction>(MseSourceBufferList_add_SourceBufferRemoved), METH_O, nullptr },
        { "remove_source_buffer_removed", reinterpret_cast<PyCFunction>(MseSourceBufferList_remove_SourceBufferRemoved), METH_O, nullptr },
        { "_assign_array_", _assign_array_MseSourceBufferList, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MseSourceBufferList), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MseSourceBufferList[] = {
        { "buffers", reinterpret_cast<getter>(MseSourceBufferList_get_Buffers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MseSourceBufferList[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MseSourceBufferList) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MseSourceBufferList) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MseSourceBufferList) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MseSourceBufferList) },
        { }
    };

    static PyType_Spec type_spec_MseSourceBufferList = {
        "winrt._winrt_windows_media_core.MseSourceBufferList",
        sizeof(py::wrapper::Windows::Media::Core::MseSourceBufferList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MseSourceBufferList};

    // ----- MseStreamSource class --------------------

    static PyObject* _new_MseStreamSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::MseStreamSource instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MseStreamSource(py::wrapper::Windows::Media::Core::MseStreamSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MseStreamSource_AddSourceBuffer(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MseStreamSource", L"AddSourceBuffer", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.AddSourceBuffer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_EndOfStream(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MseStreamSource", L"EndOfStream", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Core::MseEndOfStreamStatus>(args, 0);

                self->obj.EndOfStream(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_IsContentTypeSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MseStreamSource", L"IsContentTypeSupported", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MseStreamSource::IsContentTypeSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_RemoveSourceBuffer(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.MseStreamSource", L"RemoveSourceBuffer", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Core::MseSourceBuffer>(args, 0);

                self->obj.RemoveSourceBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_get_Duration(py::wrapper::Windows::Media::Core::MseStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseStreamSource", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseStreamSource_put_Duration(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseStreamSource", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseStreamSource_get_ActiveSourceBuffers(py::wrapper::Windows::Media::Core::MseStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseStreamSource", L"ActiveSourceBuffers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActiveSourceBuffers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_get_ReadyState(py::wrapper::Windows::Media::Core::MseStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseStreamSource", L"ReadyState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReadyState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_get_SourceBuffers(py::wrapper::Windows::Media::Core::MseStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseStreamSource", L"SourceBuffers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SourceBuffers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_get_LiveSeekableRange(py::wrapper::Windows::Media::Core::MseStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseStreamSource", L"LiveSeekableRange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LiveSeekableRange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseStreamSource_put_LiveSeekableRange(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.MseStreamSource", L"LiveSeekableRange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Media::Core::MseTimeRange>>(arg);

            self->obj.LiveSeekableRange(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseStreamSource_add_Closed(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseStreamSource", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseStreamSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_remove_Closed(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseStreamSource", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_add_Ended(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseStreamSource", L"Ended");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseStreamSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Ended(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_remove_Ended(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseStreamSource", L"Ended");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Ended(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_add_Opened(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseStreamSource", L"Opened");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseStreamSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Opened(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_remove_Opened(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.MseStreamSource", L"Opened");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Opened(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MseStreamSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MseStreamSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MseStreamSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MseStreamSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MseStreamSource[] = {
        { "add_source_buffer", reinterpret_cast<PyCFunction>(MseStreamSource_AddSourceBuffer), METH_VARARGS, nullptr },
        { "end_of_stream", reinterpret_cast<PyCFunction>(MseStreamSource_EndOfStream), METH_VARARGS, nullptr },
        { "remove_source_buffer", reinterpret_cast<PyCFunction>(MseStreamSource_RemoveSourceBuffer), METH_VARARGS, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(MseStreamSource_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(MseStreamSource_remove_Closed), METH_O, nullptr },
        { "add_ended", reinterpret_cast<PyCFunction>(MseStreamSource_add_Ended), METH_O, nullptr },
        { "remove_ended", reinterpret_cast<PyCFunction>(MseStreamSource_remove_Ended), METH_O, nullptr },
        { "add_opened", reinterpret_cast<PyCFunction>(MseStreamSource_add_Opened), METH_O, nullptr },
        { "remove_opened", reinterpret_cast<PyCFunction>(MseStreamSource_remove_Opened), METH_O, nullptr },
        { "_assign_array_", _assign_array_MseStreamSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MseStreamSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MseStreamSource[] = {
        { "duration", reinterpret_cast<getter>(MseStreamSource_get_Duration), reinterpret_cast<setter>(MseStreamSource_put_Duration), nullptr, nullptr },
        { "active_source_buffers", reinterpret_cast<getter>(MseStreamSource_get_ActiveSourceBuffers), nullptr, nullptr, nullptr },
        { "ready_state", reinterpret_cast<getter>(MseStreamSource_get_ReadyState), nullptr, nullptr, nullptr },
        { "source_buffers", reinterpret_cast<getter>(MseStreamSource_get_SourceBuffers), nullptr, nullptr, nullptr },
        { "live_seekable_range", reinterpret_cast<getter>(MseStreamSource_get_LiveSeekableRange), reinterpret_cast<setter>(MseStreamSource_put_LiveSeekableRange), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MseStreamSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MseStreamSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MseStreamSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MseStreamSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MseStreamSource) },
        { }
    };

    static PyType_Spec type_spec_MseStreamSource = {
        "winrt._winrt_windows_media_core.MseStreamSource",
        sizeof(py::wrapper::Windows::Media::Core::MseStreamSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MseStreamSource};

    static PyGetSetDef getset_MseStreamSource_Static[] = {
        { }
    };

    static PyMethodDef methods_MseStreamSource_Static[] = {
        { "is_content_type_supported", reinterpret_cast<PyCFunction>(MseStreamSource_IsContentTypeSupported), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_MseStreamSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MseStreamSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MseStreamSource_Static) },
        { }
    };

    static PyType_Spec type_spec_MseStreamSource_Static =
    {
        "winrt._winrt_windows_media_core.MseStreamSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MseStreamSource_Static
    };

    // ----- SceneAnalysisEffect class --------------------

    static PyObject* _new_SceneAnalysisEffect(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::SceneAnalysisEffect>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::SceneAnalysisEffect>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneAnalysisEffect(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneAnalysisEffect_SetProperties(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.SceneAnalysisEffect", L"SetProperties", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);

                self->obj.SetProperties(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffect_get_DesiredAnalysisInterval(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffect", L"DesiredAnalysisInterval");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DesiredAnalysisInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneAnalysisEffect_put_DesiredAnalysisInterval(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffect", L"DesiredAnalysisInterval");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.DesiredAnalysisInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneAnalysisEffect_get_HighDynamicRangeAnalyzer(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffect", L"HighDynamicRangeAnalyzer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HighDynamicRangeAnalyzer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffect_add_SceneAnalyzed(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.SceneAnalysisEffect", L"SceneAnalyzed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::SceneAnalysisEffect, winrt::Windows::Media::Core::SceneAnalyzedEventArgs>>(arg);

            return py::convert(self->obj.SceneAnalyzed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffect_remove_SceneAnalyzed(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.SceneAnalysisEffect", L"SceneAnalyzed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SceneAnalyzed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SceneAnalysisEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::SceneAnalysisEffect>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneAnalysisEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::SceneAnalysisEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneAnalysisEffect[] = {
        { "set_properties", reinterpret_cast<PyCFunction>(SceneAnalysisEffect_SetProperties), METH_VARARGS, nullptr },
        { "add_scene_analyzed", reinterpret_cast<PyCFunction>(SceneAnalysisEffect_add_SceneAnalyzed), METH_O, nullptr },
        { "remove_scene_analyzed", reinterpret_cast<PyCFunction>(SceneAnalysisEffect_remove_SceneAnalyzed), METH_O, nullptr },
        { "_assign_array_", _assign_array_SceneAnalysisEffect, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneAnalysisEffect), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneAnalysisEffect[] = {
        { "desired_analysis_interval", reinterpret_cast<getter>(SceneAnalysisEffect_get_DesiredAnalysisInterval), reinterpret_cast<setter>(SceneAnalysisEffect_put_DesiredAnalysisInterval), nullptr, nullptr },
        { "high_dynamic_range_analyzer", reinterpret_cast<getter>(SceneAnalysisEffect_get_HighDynamicRangeAnalyzer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SceneAnalysisEffect[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneAnalysisEffect) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneAnalysisEffect) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneAnalysisEffect) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneAnalysisEffect) },
        { }
    };

    static PyType_Spec type_spec_SceneAnalysisEffect = {
        "winrt._winrt_windows_media_core.SceneAnalysisEffect",
        sizeof(py::wrapper::Windows::Media::Core::SceneAnalysisEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneAnalysisEffect};

    // ----- SceneAnalysisEffectDefinition class --------------------

    static PyObject* _new_SceneAnalysisEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::SceneAnalysisEffectDefinition instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SceneAnalysisEffectDefinition(py::wrapper::Windows::Media::Core::SceneAnalysisEffectDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneAnalysisEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Core::SceneAnalysisEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffectDefinition", L"ActivatableClassId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectDefinition_get_Properties(py::wrapper::Windows::Media::Core::SceneAnalysisEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffectDefinition", L"Properties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SceneAnalysisEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::SceneAnalysisEffectDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneAnalysisEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::SceneAnalysisEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneAnalysisEffectDefinition[] = {
        { "_assign_array_", _assign_array_SceneAnalysisEffectDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneAnalysisEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneAnalysisEffectDefinition[] = {
        { "activatable_class_id", reinterpret_cast<getter>(SceneAnalysisEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(SceneAnalysisEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SceneAnalysisEffectDefinition[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneAnalysisEffectDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneAnalysisEffectDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneAnalysisEffectDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneAnalysisEffectDefinition) },
        { }
    };

    static PyType_Spec type_spec_SceneAnalysisEffectDefinition = {
        "winrt._winrt_windows_media_core.SceneAnalysisEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Core::SceneAnalysisEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneAnalysisEffectDefinition};

    // ----- SceneAnalysisEffectFrame class --------------------

    static PyObject* _new_SceneAnalysisEffectFrame(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::SceneAnalysisEffectFrame>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::SceneAnalysisEffectFrame>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneAnalysisEffectFrame(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneAnalysisEffectFrame_Close(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.SceneAnalysisEffectFrame", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_FrameControlValues(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffectFrame", L"FrameControlValues");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FrameControlValues());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_HighDynamicRange(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffectFrame", L"HighDynamicRange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HighDynamicRange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_AnalysisRecommendation(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffectFrame", L"AnalysisRecommendation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AnalysisRecommendation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_SystemRelativeTime(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffectFrame", L"SystemRelativeTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SystemRelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneAnalysisEffectFrame_put_SystemRelativeTime(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffectFrame", L"SystemRelativeTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.SystemRelativeTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_RelativeTime(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffectFrame", L"RelativeTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneAnalysisEffectFrame_put_RelativeTime(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffectFrame", L"RelativeTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.RelativeTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_IsDiscontinuous(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffectFrame", L"IsDiscontinuous");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDiscontinuous());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneAnalysisEffectFrame_put_IsDiscontinuous(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffectFrame", L"IsDiscontinuous");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDiscontinuous(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_Duration(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffectFrame", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneAnalysisEffectFrame_put_Duration(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffectFrame", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_ExtendedProperties(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffectFrame", L"ExtendedProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_IsReadOnly(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffectFrame", L"IsReadOnly");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_Type(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalysisEffectFrame", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SceneAnalysisEffectFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::SceneAnalysisEffectFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneAnalysisEffectFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::SceneAnalysisEffectFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_SceneAnalysisEffectFrame(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_SceneAnalysisEffectFrame(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneAnalysisEffectFrame[] = {
        { "close", reinterpret_cast<PyCFunction>(SceneAnalysisEffectFrame_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SceneAnalysisEffectFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneAnalysisEffectFrame), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_SceneAnalysisEffectFrame), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_SceneAnalysisEffectFrame), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneAnalysisEffectFrame[] = {
        { "frame_control_values", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_FrameControlValues), nullptr, nullptr, nullptr },
        { "high_dynamic_range", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_HighDynamicRange), nullptr, nullptr, nullptr },
        { "analysis_recommendation", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_AnalysisRecommendation), nullptr, nullptr, nullptr },
        { "system_relative_time", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_SystemRelativeTime), reinterpret_cast<setter>(SceneAnalysisEffectFrame_put_SystemRelativeTime), nullptr, nullptr },
        { "relative_time", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_RelativeTime), reinterpret_cast<setter>(SceneAnalysisEffectFrame_put_RelativeTime), nullptr, nullptr },
        { "is_discontinuous", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_IsDiscontinuous), reinterpret_cast<setter>(SceneAnalysisEffectFrame_put_IsDiscontinuous), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_Duration), reinterpret_cast<setter>(SceneAnalysisEffectFrame_put_Duration), nullptr, nullptr },
        { "extended_properties", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_ExtendedProperties), nullptr, nullptr, nullptr },
        { "is_read_only", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SceneAnalysisEffectFrame[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneAnalysisEffectFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneAnalysisEffectFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneAnalysisEffectFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneAnalysisEffectFrame) },
        { }
    };

    static PyType_Spec type_spec_SceneAnalysisEffectFrame = {
        "winrt._winrt_windows_media_core.SceneAnalysisEffectFrame",
        sizeof(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneAnalysisEffectFrame};

    // ----- SceneAnalyzedEventArgs class --------------------

    static PyObject* _new_SceneAnalyzedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::SceneAnalyzedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::SceneAnalyzedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneAnalyzedEventArgs(py::wrapper::Windows::Media::Core::SceneAnalyzedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneAnalyzedEventArgs_get_ResultFrame(py::wrapper::Windows::Media::Core::SceneAnalyzedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SceneAnalyzedEventArgs", L"ResultFrame");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResultFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SceneAnalyzedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::SceneAnalyzedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneAnalyzedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::SceneAnalyzedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneAnalyzedEventArgs[] = {
        { "_assign_array_", _assign_array_SceneAnalyzedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneAnalyzedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneAnalyzedEventArgs[] = {
        { "result_frame", reinterpret_cast<getter>(SceneAnalyzedEventArgs_get_ResultFrame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SceneAnalyzedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneAnalyzedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneAnalyzedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneAnalyzedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneAnalyzedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_SceneAnalyzedEventArgs = {
        "winrt._winrt_windows_media_core.SceneAnalyzedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::SceneAnalyzedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneAnalyzedEventArgs};

    // ----- SpeechCue class --------------------

    static PyObject* _new_SpeechCue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::SpeechCue instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SpeechCue(py::wrapper::Windows::Media::Core::SpeechCue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechCue_get_StartTime(py::wrapper::Windows::Media::Core::SpeechCue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SpeechCue", L"StartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechCue_put_StartTime(py::wrapper::Windows::Media::Core::SpeechCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SpeechCue", L"StartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechCue_get_Id(py::wrapper::Windows::Media::Core::SpeechCue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SpeechCue", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechCue_put_Id(py::wrapper::Windows::Media::Core::SpeechCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SpeechCue", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechCue_get_Duration(py::wrapper::Windows::Media::Core::SpeechCue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SpeechCue", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechCue_put_Duration(py::wrapper::Windows::Media::Core::SpeechCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SpeechCue", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechCue_get_Text(py::wrapper::Windows::Media::Core::SpeechCue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SpeechCue", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechCue_put_Text(py::wrapper::Windows::Media::Core::SpeechCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SpeechCue", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechCue_get_StartPositionInInput(py::wrapper::Windows::Media::Core::SpeechCue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SpeechCue", L"StartPositionInInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StartPositionInInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechCue_put_StartPositionInInput(py::wrapper::Windows::Media::Core::SpeechCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SpeechCue", L"StartPositionInInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.StartPositionInInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechCue_get_EndPositionInInput(py::wrapper::Windows::Media::Core::SpeechCue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SpeechCue", L"EndPositionInInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EndPositionInInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechCue_put_EndPositionInInput(py::wrapper::Windows::Media::Core::SpeechCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.SpeechCue", L"EndPositionInInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.EndPositionInInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_SpeechCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::SpeechCue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::SpeechCue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechCue[] = {
        { "_assign_array_", _assign_array_SpeechCue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechCue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechCue[] = {
        { "start_time", reinterpret_cast<getter>(SpeechCue_get_StartTime), reinterpret_cast<setter>(SpeechCue_put_StartTime), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(SpeechCue_get_Id), reinterpret_cast<setter>(SpeechCue_put_Id), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(SpeechCue_get_Duration), reinterpret_cast<setter>(SpeechCue_put_Duration), nullptr, nullptr },
        { "text", reinterpret_cast<getter>(SpeechCue_get_Text), reinterpret_cast<setter>(SpeechCue_put_Text), nullptr, nullptr },
        { "start_position_in_input", reinterpret_cast<getter>(SpeechCue_get_StartPositionInInput), reinterpret_cast<setter>(SpeechCue_put_StartPositionInInput), nullptr, nullptr },
        { "end_position_in_input", reinterpret_cast<getter>(SpeechCue_get_EndPositionInInput), reinterpret_cast<setter>(SpeechCue_put_EndPositionInInput), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechCue[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechCue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechCue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechCue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechCue) },
        { }
    };

    static PyType_Spec type_spec_SpeechCue = {
        "winrt._winrt_windows_media_core.SpeechCue",
        sizeof(py::wrapper::Windows::Media::Core::SpeechCue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechCue};

    // ----- TimedMetadataStreamDescriptor class --------------------

    static PyObject* _new_TimedMetadataStreamDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties>(args, 0);

                winrt::Windows::Media::Core::TimedMetadataStreamDescriptor instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedMetadataStreamDescriptor(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedMetadataStreamDescriptor_Copy(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.TimedMetadataStreamDescriptor", L"Copy", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataStreamDescriptor_get_Name(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataStreamDescriptor", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedMetadataStreamDescriptor_put_Name(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataStreamDescriptor", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedMetadataStreamDescriptor_get_Language(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataStreamDescriptor", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedMetadataStreamDescriptor_put_Language(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataStreamDescriptor", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedMetadataStreamDescriptor_get_IsSelected(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataStreamDescriptor", L"IsSelected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataStreamDescriptor_get_Label(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataStreamDescriptor", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedMetadataStreamDescriptor_put_Label(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataStreamDescriptor", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedMetadataStreamDescriptor_get_EncodingProperties(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataStreamDescriptor", L"EncodingProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TimedMetadataStreamDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::TimedMetadataStreamDescriptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimedMetadataStreamDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedMetadataStreamDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedMetadataStreamDescriptor[] = {
        { "copy", reinterpret_cast<PyCFunction>(TimedMetadataStreamDescriptor_Copy), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TimedMetadataStreamDescriptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedMetadataStreamDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedMetadataStreamDescriptor[] = {
        { "name", reinterpret_cast<getter>(TimedMetadataStreamDescriptor_get_Name), reinterpret_cast<setter>(TimedMetadataStreamDescriptor_put_Name), nullptr, nullptr },
        { "language", reinterpret_cast<getter>(TimedMetadataStreamDescriptor_get_Language), reinterpret_cast<setter>(TimedMetadataStreamDescriptor_put_Language), nullptr, nullptr },
        { "is_selected", reinterpret_cast<getter>(TimedMetadataStreamDescriptor_get_IsSelected), nullptr, nullptr, nullptr },
        { "label", reinterpret_cast<getter>(TimedMetadataStreamDescriptor_get_Label), reinterpret_cast<setter>(TimedMetadataStreamDescriptor_put_Label), nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(TimedMetadataStreamDescriptor_get_EncodingProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedMetadataStreamDescriptor[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedMetadataStreamDescriptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedMetadataStreamDescriptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimedMetadataStreamDescriptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedMetadataStreamDescriptor) },
        { }
    };

    static PyType_Spec type_spec_TimedMetadataStreamDescriptor = {
        "winrt._winrt_windows_media_core.TimedMetadataStreamDescriptor",
        sizeof(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedMetadataStreamDescriptor};

    // ----- TimedMetadataTrack class --------------------

    static PyObject* _new_TimedMetadataTrack(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Core::TimedMetadataKind>(args, 2);

                winrt::Windows::Media::Core::TimedMetadataTrack instance{param0, param1, param2};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedMetadataTrack(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedMetadataTrack_AddCue(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.TimedMetadataTrack", L"AddCue", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaCue>(args, 0);

                self->obj.AddCue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_RemoveCue(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.TimedMetadataTrack", L"RemoveCue", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaCue>(args, 0);

                self->obj.RemoveCue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_Label(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataTrack", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedMetadataTrack_put_Label(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataTrack", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedMetadataTrack_get_Id(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataTrack", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_Language(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataTrack", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_TrackKind(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataTrack", L"TrackKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TrackKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_ActiveCues(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataTrack", L"ActiveCues");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActiveCues());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_Cues(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataTrack", L"Cues");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Cues());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_DispatchType(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataTrack", L"DispatchType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DispatchType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_TimedMetadataKind(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataTrack", L"TimedMetadataKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TimedMetadataKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_Name(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataTrack", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_PlaybackItem(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataTrack", L"PlaybackItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PlaybackItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_add_CueEntered(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.TimedMetadataTrack", L"CueEntered");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::TimedMetadataTrack, winrt::Windows::Media::Core::MediaCueEventArgs>>(arg);

            return py::convert(self->obj.CueEntered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_remove_CueEntered(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.TimedMetadataTrack", L"CueEntered");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CueEntered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_add_CueExited(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.TimedMetadataTrack", L"CueExited");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::TimedMetadataTrack, winrt::Windows::Media::Core::MediaCueEventArgs>>(arg);

            return py::convert(self->obj.CueExited(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_remove_CueExited(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.TimedMetadataTrack", L"CueExited");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CueExited(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_add_TrackFailed(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.TimedMetadataTrack", L"TrackFailed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::TimedMetadataTrack, winrt::Windows::Media::Core::TimedMetadataTrackFailedEventArgs>>(arg);

            return py::convert(self->obj.TrackFailed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_remove_TrackFailed(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.TimedMetadataTrack", L"TrackFailed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TrackFailed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TimedMetadataTrack(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::TimedMetadataTrack>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimedMetadataTrack(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedMetadataTrack>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedMetadataTrack[] = {
        { "add_cue", reinterpret_cast<PyCFunction>(TimedMetadataTrack_AddCue), METH_VARARGS, nullptr },
        { "remove_cue", reinterpret_cast<PyCFunction>(TimedMetadataTrack_RemoveCue), METH_VARARGS, nullptr },
        { "add_cue_entered", reinterpret_cast<PyCFunction>(TimedMetadataTrack_add_CueEntered), METH_O, nullptr },
        { "remove_cue_entered", reinterpret_cast<PyCFunction>(TimedMetadataTrack_remove_CueEntered), METH_O, nullptr },
        { "add_cue_exited", reinterpret_cast<PyCFunction>(TimedMetadataTrack_add_CueExited), METH_O, nullptr },
        { "remove_cue_exited", reinterpret_cast<PyCFunction>(TimedMetadataTrack_remove_CueExited), METH_O, nullptr },
        { "add_track_failed", reinterpret_cast<PyCFunction>(TimedMetadataTrack_add_TrackFailed), METH_O, nullptr },
        { "remove_track_failed", reinterpret_cast<PyCFunction>(TimedMetadataTrack_remove_TrackFailed), METH_O, nullptr },
        { "_assign_array_", _assign_array_TimedMetadataTrack, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedMetadataTrack), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedMetadataTrack[] = {
        { "label", reinterpret_cast<getter>(TimedMetadataTrack_get_Label), reinterpret_cast<setter>(TimedMetadataTrack_put_Label), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(TimedMetadataTrack_get_Id), nullptr, nullptr, nullptr },
        { "language", reinterpret_cast<getter>(TimedMetadataTrack_get_Language), nullptr, nullptr, nullptr },
        { "track_kind", reinterpret_cast<getter>(TimedMetadataTrack_get_TrackKind), nullptr, nullptr, nullptr },
        { "active_cues", reinterpret_cast<getter>(TimedMetadataTrack_get_ActiveCues), nullptr, nullptr, nullptr },
        { "cues", reinterpret_cast<getter>(TimedMetadataTrack_get_Cues), nullptr, nullptr, nullptr },
        { "dispatch_type", reinterpret_cast<getter>(TimedMetadataTrack_get_DispatchType), nullptr, nullptr, nullptr },
        { "timed_metadata_kind", reinterpret_cast<getter>(TimedMetadataTrack_get_TimedMetadataKind), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(TimedMetadataTrack_get_Name), nullptr, nullptr, nullptr },
        { "playback_item", reinterpret_cast<getter>(TimedMetadataTrack_get_PlaybackItem), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedMetadataTrack[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedMetadataTrack) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedMetadataTrack) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimedMetadataTrack) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedMetadataTrack) },
        { }
    };

    static PyType_Spec type_spec_TimedMetadataTrack = {
        "winrt._winrt_windows_media_core.TimedMetadataTrack",
        sizeof(py::wrapper::Windows::Media::Core::TimedMetadataTrack),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedMetadataTrack};

    // ----- TimedMetadataTrackError class --------------------

    static PyObject* _new_TimedMetadataTrackError(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::TimedMetadataTrackError>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::TimedMetadataTrackError>::type_name);
        return nullptr;
    }

    static void _dealloc_TimedMetadataTrackError(py::wrapper::Windows::Media::Core::TimedMetadataTrackError* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedMetadataTrackError_get_ErrorCode(py::wrapper::Windows::Media::Core::TimedMetadataTrackError* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataTrackError", L"ErrorCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrackError_get_ExtendedError(py::wrapper::Windows::Media::Core::TimedMetadataTrackError* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataTrackError", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TimedMetadataTrackError(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::TimedMetadataTrackError>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimedMetadataTrackError(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedMetadataTrackError>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedMetadataTrackError[] = {
        { "_assign_array_", _assign_array_TimedMetadataTrackError, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedMetadataTrackError), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedMetadataTrackError[] = {
        { "error_code", reinterpret_cast<getter>(TimedMetadataTrackError_get_ErrorCode), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(TimedMetadataTrackError_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedMetadataTrackError[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedMetadataTrackError) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedMetadataTrackError) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimedMetadataTrackError) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedMetadataTrackError) },
        { }
    };

    static PyType_Spec type_spec_TimedMetadataTrackError = {
        "winrt._winrt_windows_media_core.TimedMetadataTrackError",
        sizeof(py::wrapper::Windows::Media::Core::TimedMetadataTrackError),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedMetadataTrackError};

    // ----- TimedMetadataTrackFailedEventArgs class --------------------

    static PyObject* _new_TimedMetadataTrackFailedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::TimedMetadataTrackFailedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::TimedMetadataTrackFailedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_TimedMetadataTrackFailedEventArgs(py::wrapper::Windows::Media::Core::TimedMetadataTrackFailedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedMetadataTrackFailedEventArgs_get_Error(py::wrapper::Windows::Media::Core::TimedMetadataTrackFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedMetadataTrackFailedEventArgs", L"Error");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TimedMetadataTrackFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::TimedMetadataTrackFailedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimedMetadataTrackFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedMetadataTrackFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedMetadataTrackFailedEventArgs[] = {
        { "_assign_array_", _assign_array_TimedMetadataTrackFailedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedMetadataTrackFailedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedMetadataTrackFailedEventArgs[] = {
        { "error", reinterpret_cast<getter>(TimedMetadataTrackFailedEventArgs_get_Error), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedMetadataTrackFailedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedMetadataTrackFailedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedMetadataTrackFailedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimedMetadataTrackFailedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedMetadataTrackFailedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_TimedMetadataTrackFailedEventArgs = {
        "winrt._winrt_windows_media_core.TimedMetadataTrackFailedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::TimedMetadataTrackFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedMetadataTrackFailedEventArgs};

    // ----- TimedTextBouten class --------------------

    static PyObject* _new_TimedTextBouten(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::TimedTextBouten>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::TimedTextBouten>::type_name);
        return nullptr;
    }

    static void _dealloc_TimedTextBouten(py::wrapper::Windows::Media::Core::TimedTextBouten* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedTextBouten_get_Type(py::wrapper::Windows::Media::Core::TimedTextBouten* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextBouten", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextBouten_put_Type(py::wrapper::Windows::Media::Core::TimedTextBouten* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextBouten", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextBoutenType>(arg);

            self->obj.Type(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextBouten_get_Position(py::wrapper::Windows::Media::Core::TimedTextBouten* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextBouten", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextBouten_put_Position(py::wrapper::Windows::Media::Core::TimedTextBouten* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextBouten", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextBoutenPosition>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextBouten_get_Color(py::wrapper::Windows::Media::Core::TimedTextBouten* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextBouten", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Color());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextBouten_put_Color(py::wrapper::Windows::Media::Core::TimedTextBouten* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextBouten", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Color(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_TimedTextBouten(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::TimedTextBouten>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimedTextBouten(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextBouten>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextBouten[] = {
        { "_assign_array_", _assign_array_TimedTextBouten, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextBouten), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextBouten[] = {
        { "type", reinterpret_cast<getter>(TimedTextBouten_get_Type), reinterpret_cast<setter>(TimedTextBouten_put_Type), nullptr, nullptr },
        { "position", reinterpret_cast<getter>(TimedTextBouten_get_Position), reinterpret_cast<setter>(TimedTextBouten_put_Position), nullptr, nullptr },
        { "color", reinterpret_cast<getter>(TimedTextBouten_get_Color), reinterpret_cast<setter>(TimedTextBouten_put_Color), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextBouten[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedTextBouten) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedTextBouten) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimedTextBouten) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedTextBouten) },
        { }
    };

    static PyType_Spec type_spec_TimedTextBouten = {
        "winrt._winrt_windows_media_core.TimedTextBouten",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextBouten),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextBouten};

    // ----- TimedTextCue class --------------------

    static PyObject* _new_TimedTextCue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextCue instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedTextCue(py::wrapper::Windows::Media::Core::TimedTextCue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedTextCue_get_StartTime(py::wrapper::Windows::Media::Core::TimedTextCue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextCue", L"StartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextCue_put_StartTime(py::wrapper::Windows::Media::Core::TimedTextCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextCue", L"StartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextCue_get_Id(py::wrapper::Windows::Media::Core::TimedTextCue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextCue", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextCue_put_Id(py::wrapper::Windows::Media::Core::TimedTextCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextCue", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextCue_get_Duration(py::wrapper::Windows::Media::Core::TimedTextCue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextCue", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextCue_put_Duration(py::wrapper::Windows::Media::Core::TimedTextCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextCue", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextCue_get_CueStyle(py::wrapper::Windows::Media::Core::TimedTextCue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextCue", L"CueStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CueStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextCue_put_CueStyle(py::wrapper::Windows::Media::Core::TimedTextCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextCue", L"CueStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextStyle>(arg);

            self->obj.CueStyle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextCue_get_CueRegion(py::wrapper::Windows::Media::Core::TimedTextCue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextCue", L"CueRegion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CueRegion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextCue_put_CueRegion(py::wrapper::Windows::Media::Core::TimedTextCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextCue", L"CueRegion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextRegion>(arg);

            self->obj.CueRegion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextCue_get_Lines(py::wrapper::Windows::Media::Core::TimedTextCue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextCue", L"Lines");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Lines());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TimedTextCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::TimedTextCue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimedTextCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextCue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextCue[] = {
        { "_assign_array_", _assign_array_TimedTextCue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextCue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextCue[] = {
        { "start_time", reinterpret_cast<getter>(TimedTextCue_get_StartTime), reinterpret_cast<setter>(TimedTextCue_put_StartTime), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(TimedTextCue_get_Id), reinterpret_cast<setter>(TimedTextCue_put_Id), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(TimedTextCue_get_Duration), reinterpret_cast<setter>(TimedTextCue_put_Duration), nullptr, nullptr },
        { "cue_style", reinterpret_cast<getter>(TimedTextCue_get_CueStyle), reinterpret_cast<setter>(TimedTextCue_put_CueStyle), nullptr, nullptr },
        { "cue_region", reinterpret_cast<getter>(TimedTextCue_get_CueRegion), reinterpret_cast<setter>(TimedTextCue_put_CueRegion), nullptr, nullptr },
        { "lines", reinterpret_cast<getter>(TimedTextCue_get_Lines), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextCue[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedTextCue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedTextCue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimedTextCue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedTextCue) },
        { }
    };

    static PyType_Spec type_spec_TimedTextCue = {
        "winrt._winrt_windows_media_core.TimedTextCue",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextCue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextCue};

    // ----- TimedTextLine class --------------------

    static PyObject* _new_TimedTextLine(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextLine instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedTextLine(py::wrapper::Windows::Media::Core::TimedTextLine* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedTextLine_get_Text(py::wrapper::Windows::Media::Core::TimedTextLine* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextLine", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextLine_put_Text(py::wrapper::Windows::Media::Core::TimedTextLine* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextLine", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextLine_get_Subformats(py::wrapper::Windows::Media::Core::TimedTextLine* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextLine", L"Subformats");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Subformats());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TimedTextLine(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::TimedTextLine>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimedTextLine(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextLine>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextLine[] = {
        { "_assign_array_", _assign_array_TimedTextLine, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextLine), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextLine[] = {
        { "text", reinterpret_cast<getter>(TimedTextLine_get_Text), reinterpret_cast<setter>(TimedTextLine_put_Text), nullptr, nullptr },
        { "subformats", reinterpret_cast<getter>(TimedTextLine_get_Subformats), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextLine[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedTextLine) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedTextLine) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimedTextLine) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedTextLine) },
        { }
    };

    static PyType_Spec type_spec_TimedTextLine = {
        "winrt._winrt_windows_media_core.TimedTextLine",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextLine),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextLine};

    // ----- TimedTextRegion class --------------------

    static PyObject* _new_TimedTextRegion(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextRegion instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedTextRegion(py::wrapper::Windows::Media::Core::TimedTextRegion* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedTextRegion_get_Name(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_Name(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_LineHeight(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"LineHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LineHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_LineHeight(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"LineHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextDouble>(arg);

            self->obj.LineHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_IsOverflowClipped(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"IsOverflowClipped");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsOverflowClipped());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_IsOverflowClipped(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"IsOverflowClipped");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsOverflowClipped(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_Extent(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"Extent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Extent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_Extent(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"Extent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextSize>(arg);

            self->obj.Extent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_DisplayAlignment(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"DisplayAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_DisplayAlignment(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"DisplayAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextDisplayAlignment>(arg);

            self->obj.DisplayAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_Padding(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"Padding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Padding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_Padding(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"Padding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextPadding>(arg);

            self->obj.Padding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_Background(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"Background");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Background());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_Background(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"Background");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Background(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_ZIndex(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"ZIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_ZIndex(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"ZIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_WritingMode(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"WritingMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WritingMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_WritingMode(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"WritingMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextWritingMode>(arg);

            self->obj.WritingMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_TextWrapping(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"TextWrapping");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TextWrapping());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_TextWrapping(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"TextWrapping");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextWrapping>(arg);

            self->obj.TextWrapping(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_ScrollMode(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"ScrollMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ScrollMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_ScrollMode(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"ScrollMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextScrollMode>(arg);

            self->obj.ScrollMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_Position(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_Position(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRegion", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextPoint>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_TimedTextRegion(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::TimedTextRegion>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimedTextRegion(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextRegion>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextRegion[] = {
        { "_assign_array_", _assign_array_TimedTextRegion, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextRegion), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextRegion[] = {
        { "name", reinterpret_cast<getter>(TimedTextRegion_get_Name), reinterpret_cast<setter>(TimedTextRegion_put_Name), nullptr, nullptr },
        { "line_height", reinterpret_cast<getter>(TimedTextRegion_get_LineHeight), reinterpret_cast<setter>(TimedTextRegion_put_LineHeight), nullptr, nullptr },
        { "is_overflow_clipped", reinterpret_cast<getter>(TimedTextRegion_get_IsOverflowClipped), reinterpret_cast<setter>(TimedTextRegion_put_IsOverflowClipped), nullptr, nullptr },
        { "extent", reinterpret_cast<getter>(TimedTextRegion_get_Extent), reinterpret_cast<setter>(TimedTextRegion_put_Extent), nullptr, nullptr },
        { "display_alignment", reinterpret_cast<getter>(TimedTextRegion_get_DisplayAlignment), reinterpret_cast<setter>(TimedTextRegion_put_DisplayAlignment), nullptr, nullptr },
        { "padding", reinterpret_cast<getter>(TimedTextRegion_get_Padding), reinterpret_cast<setter>(TimedTextRegion_put_Padding), nullptr, nullptr },
        { "background", reinterpret_cast<getter>(TimedTextRegion_get_Background), reinterpret_cast<setter>(TimedTextRegion_put_Background), nullptr, nullptr },
        { "z_index", reinterpret_cast<getter>(TimedTextRegion_get_ZIndex), reinterpret_cast<setter>(TimedTextRegion_put_ZIndex), nullptr, nullptr },
        { "writing_mode", reinterpret_cast<getter>(TimedTextRegion_get_WritingMode), reinterpret_cast<setter>(TimedTextRegion_put_WritingMode), nullptr, nullptr },
        { "text_wrapping", reinterpret_cast<getter>(TimedTextRegion_get_TextWrapping), reinterpret_cast<setter>(TimedTextRegion_put_TextWrapping), nullptr, nullptr },
        { "scroll_mode", reinterpret_cast<getter>(TimedTextRegion_get_ScrollMode), reinterpret_cast<setter>(TimedTextRegion_put_ScrollMode), nullptr, nullptr },
        { "position", reinterpret_cast<getter>(TimedTextRegion_get_Position), reinterpret_cast<setter>(TimedTextRegion_put_Position), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextRegion[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedTextRegion) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedTextRegion) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimedTextRegion) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedTextRegion) },
        { }
    };

    static PyType_Spec type_spec_TimedTextRegion = {
        "winrt._winrt_windows_media_core.TimedTextRegion",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextRegion),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextRegion};

    // ----- TimedTextRuby class --------------------

    static PyObject* _new_TimedTextRuby(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::TimedTextRuby>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::TimedTextRuby>::type_name);
        return nullptr;
    }

    static void _dealloc_TimedTextRuby(py::wrapper::Windows::Media::Core::TimedTextRuby* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedTextRuby_get_Text(py::wrapper::Windows::Media::Core::TimedTextRuby* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRuby", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRuby_put_Text(py::wrapper::Windows::Media::Core::TimedTextRuby* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRuby", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRuby_get_Reserve(py::wrapper::Windows::Media::Core::TimedTextRuby* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRuby", L"Reserve");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Reserve());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRuby_put_Reserve(py::wrapper::Windows::Media::Core::TimedTextRuby* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRuby", L"Reserve");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextRubyReserve>(arg);

            self->obj.Reserve(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRuby_get_Position(py::wrapper::Windows::Media::Core::TimedTextRuby* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRuby", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRuby_put_Position(py::wrapper::Windows::Media::Core::TimedTextRuby* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRuby", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextRubyPosition>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRuby_get_Align(py::wrapper::Windows::Media::Core::TimedTextRuby* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRuby", L"Align");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Align());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRuby_put_Align(py::wrapper::Windows::Media::Core::TimedTextRuby* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextRuby", L"Align");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextRubyAlign>(arg);

            self->obj.Align(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_TimedTextRuby(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::TimedTextRuby>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimedTextRuby(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextRuby>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextRuby[] = {
        { "_assign_array_", _assign_array_TimedTextRuby, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextRuby), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextRuby[] = {
        { "text", reinterpret_cast<getter>(TimedTextRuby_get_Text), reinterpret_cast<setter>(TimedTextRuby_put_Text), nullptr, nullptr },
        { "reserve", reinterpret_cast<getter>(TimedTextRuby_get_Reserve), reinterpret_cast<setter>(TimedTextRuby_put_Reserve), nullptr, nullptr },
        { "position", reinterpret_cast<getter>(TimedTextRuby_get_Position), reinterpret_cast<setter>(TimedTextRuby_put_Position), nullptr, nullptr },
        { "align", reinterpret_cast<getter>(TimedTextRuby_get_Align), reinterpret_cast<setter>(TimedTextRuby_put_Align), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextRuby[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedTextRuby) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedTextRuby) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimedTextRuby) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedTextRuby) },
        { }
    };

    static PyType_Spec type_spec_TimedTextRuby = {
        "winrt._winrt_windows_media_core.TimedTextRuby",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextRuby),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextRuby};

    // ----- TimedTextSource class --------------------

    static PyObject* _new_TimedTextSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::TimedTextSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::TimedTextSource>::type_name);
        return nullptr;
    }

    static void _dealloc_TimedTextSource(py::wrapper::Windows::Media::Core::TimedTextSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedTextSource_CreateFromStream(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.TimedTextSource", L"CreateFromStream", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromStream(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedTextSource_CreateFromStreamWithIndex(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.TimedTextSource", L"CreateFromStreamWithIndex", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromStreamWithIndex(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedTextSource_CreateFromStreamWithIndexAndLanguage(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.TimedTextSource", L"CreateFromStreamWithIndex", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromStreamWithIndex(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedTextSource_CreateFromStreamWithLanguage(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.TimedTextSource", L"CreateFromStream", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromStream(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedTextSource_CreateFromUri(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.TimedTextSource", L"CreateFromUri", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromUri(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedTextSource_CreateFromUriWithIndex(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.TimedTextSource", L"CreateFromUriWithIndex", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromUriWithIndex(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedTextSource_CreateFromUriWithIndexAndLanguage(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.TimedTextSource", L"CreateFromUriWithIndex", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromUriWithIndex(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedTextSource_CreateFromUriWithLanguage(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.TimedTextSource", L"CreateFromUri", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromUri(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedTextSource_add_Resolved(py::wrapper::Windows::Media::Core::TimedTextSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.TimedTextSource", L"Resolved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::TimedTextSource, winrt::Windows::Media::Core::TimedTextSourceResolveResultEventArgs>>(arg);

            return py::convert(self->obj.Resolved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedTextSource_remove_Resolved(py::wrapper::Windows::Media::Core::TimedTextSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.TimedTextSource", L"Resolved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Resolved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TimedTextSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::TimedTextSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimedTextSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextSource[] = {
        { "add_resolved", reinterpret_cast<PyCFunction>(TimedTextSource_add_Resolved), METH_O, nullptr },
        { "remove_resolved", reinterpret_cast<PyCFunction>(TimedTextSource_remove_Resolved), METH_O, nullptr },
        { "_assign_array_", _assign_array_TimedTextSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextSource[] = {
        { }
    };

    static PyType_Slot _type_slots_TimedTextSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedTextSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedTextSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimedTextSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedTextSource) },
        { }
    };

    static PyType_Spec type_spec_TimedTextSource = {
        "winrt._winrt_windows_media_core.TimedTextSource",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextSource};

    static PyGetSetDef getset_TimedTextSource_Static[] = {
        { }
    };

    static PyMethodDef methods_TimedTextSource_Static[] = {
        { "create_from_stream", reinterpret_cast<PyCFunction>(TimedTextSource_CreateFromStream), METH_VARARGS, nullptr },
        { "create_from_stream_with_index", reinterpret_cast<PyCFunction>(TimedTextSource_CreateFromStreamWithIndex), METH_VARARGS, nullptr },
        { "create_from_stream_with_index_and_language", reinterpret_cast<PyCFunction>(TimedTextSource_CreateFromStreamWithIndexAndLanguage), METH_VARARGS, nullptr },
        { "create_from_stream_with_language", reinterpret_cast<PyCFunction>(TimedTextSource_CreateFromStreamWithLanguage), METH_VARARGS, nullptr },
        { "create_from_uri", reinterpret_cast<PyCFunction>(TimedTextSource_CreateFromUri), METH_VARARGS, nullptr },
        { "create_from_uri_with_index", reinterpret_cast<PyCFunction>(TimedTextSource_CreateFromUriWithIndex), METH_VARARGS, nullptr },
        { "create_from_uri_with_index_and_language", reinterpret_cast<PyCFunction>(TimedTextSource_CreateFromUriWithIndexAndLanguage), METH_VARARGS, nullptr },
        { "create_from_uri_with_language", reinterpret_cast<PyCFunction>(TimedTextSource_CreateFromUriWithLanguage), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_TimedTextSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TimedTextSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TimedTextSource_Static) },
        { }
    };

    static PyType_Spec type_spec_TimedTextSource_Static =
    {
        "winrt._winrt_windows_media_core.TimedTextSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TimedTextSource_Static
    };

    // ----- TimedTextSourceResolveResultEventArgs class --------------------

    static PyObject* _new_TimedTextSourceResolveResultEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::TimedTextSourceResolveResultEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::TimedTextSourceResolveResultEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_TimedTextSourceResolveResultEventArgs(py::wrapper::Windows::Media::Core::TimedTextSourceResolveResultEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedTextSourceResolveResultEventArgs_get_Error(py::wrapper::Windows::Media::Core::TimedTextSourceResolveResultEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextSourceResolveResultEventArgs", L"Error");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedTextSourceResolveResultEventArgs_get_Tracks(py::wrapper::Windows::Media::Core::TimedTextSourceResolveResultEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextSourceResolveResultEventArgs", L"Tracks");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Tracks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TimedTextSourceResolveResultEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::TimedTextSourceResolveResultEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimedTextSourceResolveResultEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextSourceResolveResultEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextSourceResolveResultEventArgs[] = {
        { "_assign_array_", _assign_array_TimedTextSourceResolveResultEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextSourceResolveResultEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextSourceResolveResultEventArgs[] = {
        { "error", reinterpret_cast<getter>(TimedTextSourceResolveResultEventArgs_get_Error), nullptr, nullptr, nullptr },
        { "tracks", reinterpret_cast<getter>(TimedTextSourceResolveResultEventArgs_get_Tracks), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextSourceResolveResultEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedTextSourceResolveResultEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedTextSourceResolveResultEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimedTextSourceResolveResultEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedTextSourceResolveResultEventArgs) },
        { }
    };

    static PyType_Spec type_spec_TimedTextSourceResolveResultEventArgs = {
        "winrt._winrt_windows_media_core.TimedTextSourceResolveResultEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextSourceResolveResultEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextSourceResolveResultEventArgs};

    // ----- TimedTextStyle class --------------------

    static PyObject* _new_TimedTextStyle(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextStyle instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedTextStyle(py::wrapper::Windows::Media::Core::TimedTextStyle* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedTextStyle_get_LineAlignment(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"LineAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LineAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_LineAlignment(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"LineAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextLineAlignment>(arg);

            self->obj.LineAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_IsBackgroundAlwaysShown(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"IsBackgroundAlwaysShown");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsBackgroundAlwaysShown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_IsBackgroundAlwaysShown(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"IsBackgroundAlwaysShown");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsBackgroundAlwaysShown(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_OutlineColor(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"OutlineColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OutlineColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_OutlineColor(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"OutlineColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.OutlineColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_Foreground(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"Foreground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Foreground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_Foreground(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"Foreground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Foreground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_FontWeight(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"FontWeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FontWeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_FontWeight(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"FontWeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextWeight>(arg);

            self->obj.FontWeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_Background(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"Background");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Background());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_Background(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"Background");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Background(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_FontSize(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"FontSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FontSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_FontSize(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"FontSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextDouble>(arg);

            self->obj.FontSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_FontFamily(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"FontFamily");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FontFamily());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_FontFamily(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"FontFamily");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FontFamily(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_FlowDirection(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"FlowDirection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FlowDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_FlowDirection(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"FlowDirection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextFlowDirection>(arg);

            self->obj.FlowDirection(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_OutlineThickness(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"OutlineThickness");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OutlineThickness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_OutlineThickness(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"OutlineThickness");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextDouble>(arg);

            self->obj.OutlineThickness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_OutlineRadius(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"OutlineRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OutlineRadius());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_OutlineRadius(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"OutlineRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextDouble>(arg);

            self->obj.OutlineRadius(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_Name(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_Name(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_IsUnderlineEnabled(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"IsUnderlineEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsUnderlineEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_IsUnderlineEnabled(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"IsUnderlineEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsUnderlineEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_IsOverlineEnabled(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"IsOverlineEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsOverlineEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_IsOverlineEnabled(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"IsOverlineEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsOverlineEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_IsLineThroughEnabled(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"IsLineThroughEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsLineThroughEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_IsLineThroughEnabled(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"IsLineThroughEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLineThroughEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_FontStyle(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"FontStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FontStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_FontStyle(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"FontStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextFontStyle>(arg);

            self->obj.FontStyle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_IsTextCombined(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"IsTextCombined");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsTextCombined());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_IsTextCombined(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"IsTextCombined");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsTextCombined(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_FontAngleInDegrees(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"FontAngleInDegrees");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FontAngleInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_FontAngleInDegrees(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"FontAngleInDegrees");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.FontAngleInDegrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_Bouten(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"Bouten");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Bouten());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedTextStyle_get_Ruby(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextStyle", L"Ruby");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Ruby());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TimedTextStyle(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::TimedTextStyle>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimedTextStyle(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextStyle>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextStyle[] = {
        { "_assign_array_", _assign_array_TimedTextStyle, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextStyle), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextStyle[] = {
        { "line_alignment", reinterpret_cast<getter>(TimedTextStyle_get_LineAlignment), reinterpret_cast<setter>(TimedTextStyle_put_LineAlignment), nullptr, nullptr },
        { "is_background_always_shown", reinterpret_cast<getter>(TimedTextStyle_get_IsBackgroundAlwaysShown), reinterpret_cast<setter>(TimedTextStyle_put_IsBackgroundAlwaysShown), nullptr, nullptr },
        { "outline_color", reinterpret_cast<getter>(TimedTextStyle_get_OutlineColor), reinterpret_cast<setter>(TimedTextStyle_put_OutlineColor), nullptr, nullptr },
        { "foreground", reinterpret_cast<getter>(TimedTextStyle_get_Foreground), reinterpret_cast<setter>(TimedTextStyle_put_Foreground), nullptr, nullptr },
        { "font_weight", reinterpret_cast<getter>(TimedTextStyle_get_FontWeight), reinterpret_cast<setter>(TimedTextStyle_put_FontWeight), nullptr, nullptr },
        { "background", reinterpret_cast<getter>(TimedTextStyle_get_Background), reinterpret_cast<setter>(TimedTextStyle_put_Background), nullptr, nullptr },
        { "font_size", reinterpret_cast<getter>(TimedTextStyle_get_FontSize), reinterpret_cast<setter>(TimedTextStyle_put_FontSize), nullptr, nullptr },
        { "font_family", reinterpret_cast<getter>(TimedTextStyle_get_FontFamily), reinterpret_cast<setter>(TimedTextStyle_put_FontFamily), nullptr, nullptr },
        { "flow_direction", reinterpret_cast<getter>(TimedTextStyle_get_FlowDirection), reinterpret_cast<setter>(TimedTextStyle_put_FlowDirection), nullptr, nullptr },
        { "outline_thickness", reinterpret_cast<getter>(TimedTextStyle_get_OutlineThickness), reinterpret_cast<setter>(TimedTextStyle_put_OutlineThickness), nullptr, nullptr },
        { "outline_radius", reinterpret_cast<getter>(TimedTextStyle_get_OutlineRadius), reinterpret_cast<setter>(TimedTextStyle_put_OutlineRadius), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(TimedTextStyle_get_Name), reinterpret_cast<setter>(TimedTextStyle_put_Name), nullptr, nullptr },
        { "is_underline_enabled", reinterpret_cast<getter>(TimedTextStyle_get_IsUnderlineEnabled), reinterpret_cast<setter>(TimedTextStyle_put_IsUnderlineEnabled), nullptr, nullptr },
        { "is_overline_enabled", reinterpret_cast<getter>(TimedTextStyle_get_IsOverlineEnabled), reinterpret_cast<setter>(TimedTextStyle_put_IsOverlineEnabled), nullptr, nullptr },
        { "is_line_through_enabled", reinterpret_cast<getter>(TimedTextStyle_get_IsLineThroughEnabled), reinterpret_cast<setter>(TimedTextStyle_put_IsLineThroughEnabled), nullptr, nullptr },
        { "font_style", reinterpret_cast<getter>(TimedTextStyle_get_FontStyle), reinterpret_cast<setter>(TimedTextStyle_put_FontStyle), nullptr, nullptr },
        { "is_text_combined", reinterpret_cast<getter>(TimedTextStyle_get_IsTextCombined), reinterpret_cast<setter>(TimedTextStyle_put_IsTextCombined), nullptr, nullptr },
        { "font_angle_in_degrees", reinterpret_cast<getter>(TimedTextStyle_get_FontAngleInDegrees), reinterpret_cast<setter>(TimedTextStyle_put_FontAngleInDegrees), nullptr, nullptr },
        { "bouten", reinterpret_cast<getter>(TimedTextStyle_get_Bouten), nullptr, nullptr, nullptr },
        { "ruby", reinterpret_cast<getter>(TimedTextStyle_get_Ruby), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextStyle[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedTextStyle) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedTextStyle) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimedTextStyle) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedTextStyle) },
        { }
    };

    static PyType_Spec type_spec_TimedTextStyle = {
        "winrt._winrt_windows_media_core.TimedTextStyle",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextStyle),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextStyle};

    // ----- TimedTextSubformat class --------------------

    static PyObject* _new_TimedTextSubformat(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextSubformat instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedTextSubformat(py::wrapper::Windows::Media::Core::TimedTextSubformat* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedTextSubformat_get_SubformatStyle(py::wrapper::Windows::Media::Core::TimedTextSubformat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextSubformat", L"SubformatStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SubformatStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextSubformat_put_SubformatStyle(py::wrapper::Windows::Media::Core::TimedTextSubformat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextSubformat", L"SubformatStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextStyle>(arg);

            self->obj.SubformatStyle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextSubformat_get_StartIndex(py::wrapper::Windows::Media::Core::TimedTextSubformat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextSubformat", L"StartIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StartIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextSubformat_put_StartIndex(py::wrapper::Windows::Media::Core::TimedTextSubformat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextSubformat", L"StartIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.StartIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextSubformat_get_Length(py::wrapper::Windows::Media::Core::TimedTextSubformat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextSubformat", L"Length");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextSubformat_put_Length(py::wrapper::Windows::Media::Core::TimedTextSubformat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.TimedTextSubformat", L"Length");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Length(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_TimedTextSubformat(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::TimedTextSubformat>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimedTextSubformat(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextSubformat>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextSubformat[] = {
        { "_assign_array_", _assign_array_TimedTextSubformat, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextSubformat), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextSubformat[] = {
        { "subformat_style", reinterpret_cast<getter>(TimedTextSubformat_get_SubformatStyle), reinterpret_cast<setter>(TimedTextSubformat_put_SubformatStyle), nullptr, nullptr },
        { "start_index", reinterpret_cast<getter>(TimedTextSubformat_get_StartIndex), reinterpret_cast<setter>(TimedTextSubformat_put_StartIndex), nullptr, nullptr },
        { "length", reinterpret_cast<getter>(TimedTextSubformat_get_Length), reinterpret_cast<setter>(TimedTextSubformat_put_Length), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextSubformat[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedTextSubformat) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedTextSubformat) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimedTextSubformat) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedTextSubformat) },
        { }
    };

    static PyType_Spec type_spec_TimedTextSubformat = {
        "winrt._winrt_windows_media_core.TimedTextSubformat",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextSubformat),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextSubformat};

    // ----- VideoStabilizationEffect class --------------------

    static PyObject* _new_VideoStabilizationEffect(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::VideoStabilizationEffect>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::VideoStabilizationEffect>::type_name);
        return nullptr;
    }

    static void _dealloc_VideoStabilizationEffect(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoStabilizationEffect_GetRecommendedStreamConfiguration(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.VideoStabilizationEffect", L"GetRecommendedStreamConfiguration", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Devices::VideoDeviceController>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingProperties>(args, 1);

                return py::convert(self->obj.GetRecommendedStreamConfiguration(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoStabilizationEffect_SetProperties(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.VideoStabilizationEffect", L"SetProperties", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);

                self->obj.SetProperties(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoStabilizationEffect_get_Enabled(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoStabilizationEffect", L"Enabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoStabilizationEffect_put_Enabled(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoStabilizationEffect", L"Enabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoStabilizationEffect_add_EnabledChanged(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.VideoStabilizationEffect", L"EnabledChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::VideoStabilizationEffect, winrt::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs>>(arg);

            return py::convert(self->obj.EnabledChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoStabilizationEffect_remove_EnabledChanged(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.VideoStabilizationEffect", L"EnabledChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnabledChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VideoStabilizationEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::VideoStabilizationEffect>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VideoStabilizationEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoStabilizationEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoStabilizationEffect[] = {
        { "get_recommended_stream_configuration", reinterpret_cast<PyCFunction>(VideoStabilizationEffect_GetRecommendedStreamConfiguration), METH_VARARGS, nullptr },
        { "set_properties", reinterpret_cast<PyCFunction>(VideoStabilizationEffect_SetProperties), METH_VARARGS, nullptr },
        { "add_enabled_changed", reinterpret_cast<PyCFunction>(VideoStabilizationEffect_add_EnabledChanged), METH_O, nullptr },
        { "remove_enabled_changed", reinterpret_cast<PyCFunction>(VideoStabilizationEffect_remove_EnabledChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_VideoStabilizationEffect, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoStabilizationEffect), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoStabilizationEffect[] = {
        { "enabled", reinterpret_cast<getter>(VideoStabilizationEffect_get_Enabled), reinterpret_cast<setter>(VideoStabilizationEffect_put_Enabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoStabilizationEffect[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VideoStabilizationEffect) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VideoStabilizationEffect) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VideoStabilizationEffect) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VideoStabilizationEffect) },
        { }
    };

    static PyType_Spec type_spec_VideoStabilizationEffect = {
        "winrt._winrt_windows_media_core.VideoStabilizationEffect",
        sizeof(py::wrapper::Windows::Media::Core::VideoStabilizationEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoStabilizationEffect};

    // ----- VideoStabilizationEffectDefinition class --------------------

    static PyObject* _new_VideoStabilizationEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::VideoStabilizationEffectDefinition instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VideoStabilizationEffectDefinition(py::wrapper::Windows::Media::Core::VideoStabilizationEffectDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoStabilizationEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Core::VideoStabilizationEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoStabilizationEffectDefinition", L"ActivatableClassId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoStabilizationEffectDefinition_get_Properties(py::wrapper::Windows::Media::Core::VideoStabilizationEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoStabilizationEffectDefinition", L"Properties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VideoStabilizationEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::VideoStabilizationEffectDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VideoStabilizationEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoStabilizationEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoStabilizationEffectDefinition[] = {
        { "_assign_array_", _assign_array_VideoStabilizationEffectDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoStabilizationEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoStabilizationEffectDefinition[] = {
        { "activatable_class_id", reinterpret_cast<getter>(VideoStabilizationEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(VideoStabilizationEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoStabilizationEffectDefinition[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VideoStabilizationEffectDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VideoStabilizationEffectDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VideoStabilizationEffectDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VideoStabilizationEffectDefinition) },
        { }
    };

    static PyType_Spec type_spec_VideoStabilizationEffectDefinition = {
        "winrt._winrt_windows_media_core.VideoStabilizationEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Core::VideoStabilizationEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoStabilizationEffectDefinition};

    // ----- VideoStabilizationEffectEnabledChangedEventArgs class --------------------

    static PyObject* _new_VideoStabilizationEffectEnabledChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_VideoStabilizationEffectEnabledChangedEventArgs(py::wrapper::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoStabilizationEffectEnabledChangedEventArgs_get_Reason(py::wrapper::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoStabilizationEffectEnabledChangedEventArgs", L"Reason");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VideoStabilizationEffectEnabledChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VideoStabilizationEffectEnabledChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoStabilizationEffectEnabledChangedEventArgs[] = {
        { "_assign_array_", _assign_array_VideoStabilizationEffectEnabledChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoStabilizationEffectEnabledChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoStabilizationEffectEnabledChangedEventArgs[] = {
        { "reason", reinterpret_cast<getter>(VideoStabilizationEffectEnabledChangedEventArgs_get_Reason), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoStabilizationEffectEnabledChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VideoStabilizationEffectEnabledChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VideoStabilizationEffectEnabledChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VideoStabilizationEffectEnabledChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VideoStabilizationEffectEnabledChangedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_VideoStabilizationEffectEnabledChangedEventArgs = {
        "winrt._winrt_windows_media_core.VideoStabilizationEffectEnabledChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoStabilizationEffectEnabledChangedEventArgs};

    // ----- VideoStreamDescriptor class --------------------

    static PyObject* _new_VideoStreamDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingProperties>(args, 0);

                winrt::Windows::Media::Core::VideoStreamDescriptor instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VideoStreamDescriptor(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoStreamDescriptor_Copy(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.VideoStreamDescriptor", L"Copy", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoStreamDescriptor_get_Name(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoStreamDescriptor", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoStreamDescriptor_put_Name(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoStreamDescriptor", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoStreamDescriptor_get_Language(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoStreamDescriptor", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoStreamDescriptor_put_Language(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoStreamDescriptor", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoStreamDescriptor_get_IsSelected(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoStreamDescriptor", L"IsSelected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoStreamDescriptor_get_Label(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoStreamDescriptor", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoStreamDescriptor_put_Label(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoStreamDescriptor", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoStreamDescriptor_get_EncodingProperties(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoStreamDescriptor", L"EncodingProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VideoStreamDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::VideoStreamDescriptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VideoStreamDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoStreamDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoStreamDescriptor[] = {
        { "copy", reinterpret_cast<PyCFunction>(VideoStreamDescriptor_Copy), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_VideoStreamDescriptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoStreamDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoStreamDescriptor[] = {
        { "name", reinterpret_cast<getter>(VideoStreamDescriptor_get_Name), reinterpret_cast<setter>(VideoStreamDescriptor_put_Name), nullptr, nullptr },
        { "language", reinterpret_cast<getter>(VideoStreamDescriptor_get_Language), reinterpret_cast<setter>(VideoStreamDescriptor_put_Language), nullptr, nullptr },
        { "is_selected", reinterpret_cast<getter>(VideoStreamDescriptor_get_IsSelected), nullptr, nullptr, nullptr },
        { "label", reinterpret_cast<getter>(VideoStreamDescriptor_get_Label), reinterpret_cast<setter>(VideoStreamDescriptor_put_Label), nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(VideoStreamDescriptor_get_EncodingProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoStreamDescriptor[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VideoStreamDescriptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VideoStreamDescriptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VideoStreamDescriptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VideoStreamDescriptor) },
        { }
    };

    static PyType_Spec type_spec_VideoStreamDescriptor = {
        "winrt._winrt_windows_media_core.VideoStreamDescriptor",
        sizeof(py::wrapper::Windows::Media::Core::VideoStreamDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoStreamDescriptor};

    // ----- VideoTrack class --------------------

    static PyObject* _new_VideoTrack(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::VideoTrack>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::VideoTrack>::type_name);
        return nullptr;
    }

    static void _dealloc_VideoTrack(py::wrapper::Windows::Media::Core::VideoTrack* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoTrack_GetEncodingProperties(py::wrapper::Windows::Media::Core::VideoTrack* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Core.VideoTrack", L"GetEncodingProperties", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetEncodingProperties());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoTrack_get_Label(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoTrack", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTrack_put_Label(py::wrapper::Windows::Media::Core::VideoTrack* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoTrack", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTrack_get_Id(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoTrack", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_get_Language(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoTrack", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_get_TrackKind(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoTrack", L"TrackKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TrackKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_get_Name(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoTrack", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_get_PlaybackItem(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoTrack", L"PlaybackItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PlaybackItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_get_SupportInfo(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoTrack", L"SupportInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_add_OpenFailed(py::wrapper::Windows::Media::Core::VideoTrack* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.VideoTrack", L"OpenFailed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::VideoTrack, winrt::Windows::Media::Core::VideoTrackOpenFailedEventArgs>>(arg);

            return py::convert(self->obj.OpenFailed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_remove_OpenFailed(py::wrapper::Windows::Media::Core::VideoTrack* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.VideoTrack", L"OpenFailed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.OpenFailed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VideoTrack(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::VideoTrack>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VideoTrack(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoTrack>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoTrack[] = {
        { "get_encoding_properties", reinterpret_cast<PyCFunction>(VideoTrack_GetEncodingProperties), METH_VARARGS, nullptr },
        { "add_open_failed", reinterpret_cast<PyCFunction>(VideoTrack_add_OpenFailed), METH_O, nullptr },
        { "remove_open_failed", reinterpret_cast<PyCFunction>(VideoTrack_remove_OpenFailed), METH_O, nullptr },
        { "_assign_array_", _assign_array_VideoTrack, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoTrack), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoTrack[] = {
        { "label", reinterpret_cast<getter>(VideoTrack_get_Label), reinterpret_cast<setter>(VideoTrack_put_Label), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(VideoTrack_get_Id), nullptr, nullptr, nullptr },
        { "language", reinterpret_cast<getter>(VideoTrack_get_Language), nullptr, nullptr, nullptr },
        { "track_kind", reinterpret_cast<getter>(VideoTrack_get_TrackKind), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(VideoTrack_get_Name), nullptr, nullptr, nullptr },
        { "playback_item", reinterpret_cast<getter>(VideoTrack_get_PlaybackItem), nullptr, nullptr, nullptr },
        { "support_info", reinterpret_cast<getter>(VideoTrack_get_SupportInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoTrack[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VideoTrack) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VideoTrack) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VideoTrack) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VideoTrack) },
        { }
    };

    static PyType_Spec type_spec_VideoTrack = {
        "winrt._winrt_windows_media_core.VideoTrack",
        sizeof(py::wrapper::Windows::Media::Core::VideoTrack),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoTrack};

    // ----- VideoTrackOpenFailedEventArgs class --------------------

    static PyObject* _new_VideoTrackOpenFailedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::VideoTrackOpenFailedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::VideoTrackOpenFailedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_VideoTrackOpenFailedEventArgs(py::wrapper::Windows::Media::Core::VideoTrackOpenFailedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoTrackOpenFailedEventArgs_get_ExtendedError(py::wrapper::Windows::Media::Core::VideoTrackOpenFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoTrackOpenFailedEventArgs", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VideoTrackOpenFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::VideoTrackOpenFailedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VideoTrackOpenFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoTrackOpenFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoTrackOpenFailedEventArgs[] = {
        { "_assign_array_", _assign_array_VideoTrackOpenFailedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoTrackOpenFailedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoTrackOpenFailedEventArgs[] = {
        { "extended_error", reinterpret_cast<getter>(VideoTrackOpenFailedEventArgs_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoTrackOpenFailedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VideoTrackOpenFailedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VideoTrackOpenFailedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VideoTrackOpenFailedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VideoTrackOpenFailedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_VideoTrackOpenFailedEventArgs = {
        "winrt._winrt_windows_media_core.VideoTrackOpenFailedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::VideoTrackOpenFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoTrackOpenFailedEventArgs};

    // ----- VideoTrackSupportInfo class --------------------

    static PyObject* _new_VideoTrackSupportInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::VideoTrackSupportInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::VideoTrackSupportInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_VideoTrackSupportInfo(py::wrapper::Windows::Media::Core::VideoTrackSupportInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoTrackSupportInfo_get_DecoderStatus(py::wrapper::Windows::Media::Core::VideoTrackSupportInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoTrackSupportInfo", L"DecoderStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DecoderStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrackSupportInfo_get_MediaSourceStatus(py::wrapper::Windows::Media::Core::VideoTrackSupportInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.VideoTrackSupportInfo", L"MediaSourceStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MediaSourceStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VideoTrackSupportInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::VideoTrackSupportInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VideoTrackSupportInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoTrackSupportInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoTrackSupportInfo[] = {
        { "_assign_array_", _assign_array_VideoTrackSupportInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoTrackSupportInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoTrackSupportInfo[] = {
        { "decoder_status", reinterpret_cast<getter>(VideoTrackSupportInfo_get_DecoderStatus), nullptr, nullptr, nullptr },
        { "media_source_status", reinterpret_cast<getter>(VideoTrackSupportInfo_get_MediaSourceStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoTrackSupportInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VideoTrackSupportInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VideoTrackSupportInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VideoTrackSupportInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VideoTrackSupportInfo) },
        { }
    };

    static PyType_Spec type_spec_VideoTrackSupportInfo = {
        "winrt._winrt_windows_media_core.VideoTrackSupportInfo",
        sizeof(py::wrapper::Windows::Media::Core::VideoTrackSupportInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoTrackSupportInfo};

    // ----- IMediaCue interface --------------------

    static PyObject* _new_IMediaCue(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::IMediaCue>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::IMediaCue>::type_name);
        return nullptr;
    }

    static void _dealloc_IMediaCue(py::wrapper::Windows::Media::Core::IMediaCue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMediaCue_get_Duration(py::wrapper::Windows::Media::Core::IMediaCue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaCue", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaCue_put_Duration(py::wrapper::Windows::Media::Core::IMediaCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaCue", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaCue_get_Id(py::wrapper::Windows::Media::Core::IMediaCue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaCue", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaCue_put_Id(py::wrapper::Windows::Media::Core::IMediaCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaCue", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaCue_get_StartTime(py::wrapper::Windows::Media::Core::IMediaCue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaCue", L"StartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaCue_put_StartTime(py::wrapper::Windows::Media::Core::IMediaCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaCue", L"StartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IMediaCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::IMediaCue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IMediaCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::IMediaCue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaCue[] = {
        { "_assign_array_", _assign_array_IMediaCue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IMediaCue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMediaCue[] = {
        { "duration", reinterpret_cast<getter>(IMediaCue_get_Duration), reinterpret_cast<setter>(IMediaCue_put_Duration), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(IMediaCue_get_Id), reinterpret_cast<setter>(IMediaCue_put_Id), nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(IMediaCue_get_StartTime), reinterpret_cast<setter>(IMediaCue_put_StartTime), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IMediaCue[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IMediaCue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IMediaCue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IMediaCue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IMediaCue) },
        { }
    };

    static PyType_Spec type_spec_IMediaCue = {
        "winrt._winrt_windows_media_core.IMediaCue",
        sizeof(py::wrapper::Windows::Media::Core::IMediaCue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaCue};

    // ----- IMediaSource interface --------------------

    static PyObject* _new_IMediaSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::IMediaSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::IMediaSource>::type_name);
        return nullptr;
    }

    static void _dealloc_IMediaSource(py::wrapper::Windows::Media::Core::IMediaSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_IMediaSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::IMediaSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IMediaSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::IMediaSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaSource[] = {
        { "_assign_array_", _assign_array_IMediaSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IMediaSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMediaSource[] = {
        { }
    };

    static PyType_Slot _type_slots_IMediaSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IMediaSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IMediaSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IMediaSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IMediaSource) },
        { }
    };

    static PyType_Spec type_spec_IMediaSource = {
        "winrt._winrt_windows_media_core.IMediaSource",
        sizeof(py::wrapper::Windows::Media::Core::IMediaSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaSource};

    // ----- IMediaStreamDescriptor interface --------------------

    static PyObject* _new_IMediaStreamDescriptor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::IMediaStreamDescriptor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::IMediaStreamDescriptor>::type_name);
        return nullptr;
    }

    static void _dealloc_IMediaStreamDescriptor(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMediaStreamDescriptor_get_IsSelected(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaStreamDescriptor", L"IsSelected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMediaStreamDescriptor_get_Language(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaStreamDescriptor", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaStreamDescriptor_put_Language(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaStreamDescriptor", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaStreamDescriptor_get_Name(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaStreamDescriptor", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaStreamDescriptor_put_Name(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaStreamDescriptor", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IMediaStreamDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::IMediaStreamDescriptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IMediaStreamDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::IMediaStreamDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaStreamDescriptor[] = {
        { "_assign_array_", _assign_array_IMediaStreamDescriptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IMediaStreamDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMediaStreamDescriptor[] = {
        { "is_selected", reinterpret_cast<getter>(IMediaStreamDescriptor_get_IsSelected), nullptr, nullptr, nullptr },
        { "language", reinterpret_cast<getter>(IMediaStreamDescriptor_get_Language), reinterpret_cast<setter>(IMediaStreamDescriptor_put_Language), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(IMediaStreamDescriptor_get_Name), reinterpret_cast<setter>(IMediaStreamDescriptor_put_Name), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IMediaStreamDescriptor[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IMediaStreamDescriptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IMediaStreamDescriptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IMediaStreamDescriptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IMediaStreamDescriptor) },
        { }
    };

    static PyType_Spec type_spec_IMediaStreamDescriptor = {
        "winrt._winrt_windows_media_core.IMediaStreamDescriptor",
        sizeof(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaStreamDescriptor};

    // ----- IMediaStreamDescriptor2 interface --------------------

    static PyObject* _new_IMediaStreamDescriptor2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::IMediaStreamDescriptor2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::IMediaStreamDescriptor2>::type_name);
        return nullptr;
    }

    static void _dealloc_IMediaStreamDescriptor2(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMediaStreamDescriptor2_get_Label(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaStreamDescriptor2", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaStreamDescriptor2_put_Label(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaStreamDescriptor2", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaStreamDescriptor2_get_IsSelected(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaStreamDescriptor", L"IsSelected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMediaStreamDescriptor2_get_Language(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaStreamDescriptor", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaStreamDescriptor2_put_Language(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaStreamDescriptor", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaStreamDescriptor2_get_Name(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaStreamDescriptor", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaStreamDescriptor2_put_Name(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaStreamDescriptor", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IMediaStreamDescriptor2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::IMediaStreamDescriptor2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IMediaStreamDescriptor2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::IMediaStreamDescriptor2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaStreamDescriptor2[] = {
        { "_assign_array_", _assign_array_IMediaStreamDescriptor2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IMediaStreamDescriptor2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMediaStreamDescriptor2[] = {
        { "label", reinterpret_cast<getter>(IMediaStreamDescriptor2_get_Label), reinterpret_cast<setter>(IMediaStreamDescriptor2_put_Label), nullptr, nullptr },
        { "is_selected", reinterpret_cast<getter>(IMediaStreamDescriptor2_get_IsSelected), nullptr, nullptr, nullptr },
        { "language", reinterpret_cast<getter>(IMediaStreamDescriptor2_get_Language), reinterpret_cast<setter>(IMediaStreamDescriptor2_put_Language), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(IMediaStreamDescriptor2_get_Name), reinterpret_cast<setter>(IMediaStreamDescriptor2_put_Name), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IMediaStreamDescriptor2[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IMediaStreamDescriptor2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IMediaStreamDescriptor2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IMediaStreamDescriptor2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IMediaStreamDescriptor2) },
        { }
    };

    static PyType_Spec type_spec_IMediaStreamDescriptor2 = {
        "winrt._winrt_windows_media_core.IMediaStreamDescriptor2",
        sizeof(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaStreamDescriptor2};

    // ----- IMediaTrack interface --------------------

    static PyObject* _new_IMediaTrack(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::IMediaTrack>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::IMediaTrack>::type_name);
        return nullptr;
    }

    static void _dealloc_IMediaTrack(py::wrapper::Windows::Media::Core::IMediaTrack* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMediaTrack_get_Id(py::wrapper::Windows::Media::Core::IMediaTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaTrack", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMediaTrack_get_Label(py::wrapper::Windows::Media::Core::IMediaTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaTrack", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaTrack_put_Label(py::wrapper::Windows::Media::Core::IMediaTrack* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaTrack", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaTrack_get_Language(py::wrapper::Windows::Media::Core::IMediaTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaTrack", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMediaTrack_get_TrackKind(py::wrapper::Windows::Media::Core::IMediaTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.IMediaTrack", L"TrackKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TrackKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IMediaTrack(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::IMediaTrack>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IMediaTrack(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::IMediaTrack>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaTrack[] = {
        { "_assign_array_", _assign_array_IMediaTrack, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IMediaTrack), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMediaTrack[] = {
        { "id", reinterpret_cast<getter>(IMediaTrack_get_Id), nullptr, nullptr, nullptr },
        { "label", reinterpret_cast<getter>(IMediaTrack_get_Label), reinterpret_cast<setter>(IMediaTrack_put_Label), nullptr, nullptr },
        { "language", reinterpret_cast<getter>(IMediaTrack_get_Language), nullptr, nullptr, nullptr },
        { "track_kind", reinterpret_cast<getter>(IMediaTrack_get_TrackKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IMediaTrack[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IMediaTrack) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IMediaTrack) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IMediaTrack) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IMediaTrack) },
        { }
    };

    static PyType_Spec type_spec_IMediaTrack = {
        "winrt._winrt_windows_media_core.IMediaTrack",
        sizeof(py::wrapper::Windows::Media::Core::IMediaTrack),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaTrack};

    // ----- ISingleSelectMediaTrackList interface --------------------

    static PyObject* _new_ISingleSelectMediaTrackList(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::ISingleSelectMediaTrackList>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::ISingleSelectMediaTrackList>::type_name);
        return nullptr;
    }

    static void _dealloc_ISingleSelectMediaTrackList(py::wrapper::Windows::Media::Core::ISingleSelectMediaTrackList* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISingleSelectMediaTrackList_get_SelectedIndex(py::wrapper::Windows::Media::Core::ISingleSelectMediaTrackList* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ISingleSelectMediaTrackList", L"SelectedIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISingleSelectMediaTrackList_put_SelectedIndex(py::wrapper::Windows::Media::Core::ISingleSelectMediaTrackList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ISingleSelectMediaTrackList", L"SelectedIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.SelectedIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ISingleSelectMediaTrackList_add_SelectedIndexChanged(py::wrapper::Windows::Media::Core::ISingleSelectMediaTrackList* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.ISingleSelectMediaTrackList", L"SelectedIndexChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::ISingleSelectMediaTrackList, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SelectedIndexChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISingleSelectMediaTrackList_remove_SelectedIndexChanged(py::wrapper::Windows::Media::Core::ISingleSelectMediaTrackList* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Core.ISingleSelectMediaTrackList", L"SelectedIndexChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SelectedIndexChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ISingleSelectMediaTrackList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::ISingleSelectMediaTrackList>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISingleSelectMediaTrackList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::ISingleSelectMediaTrackList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISingleSelectMediaTrackList[] = {
        { "add_selected_index_changed", reinterpret_cast<PyCFunction>(ISingleSelectMediaTrackList_add_SelectedIndexChanged), METH_O, nullptr },
        { "remove_selected_index_changed", reinterpret_cast<PyCFunction>(ISingleSelectMediaTrackList_remove_SelectedIndexChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ISingleSelectMediaTrackList, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISingleSelectMediaTrackList), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISingleSelectMediaTrackList[] = {
        { "selected_index", reinterpret_cast<getter>(ISingleSelectMediaTrackList_get_SelectedIndex), reinterpret_cast<setter>(ISingleSelectMediaTrackList_put_SelectedIndex), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ISingleSelectMediaTrackList[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISingleSelectMediaTrackList) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISingleSelectMediaTrackList) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISingleSelectMediaTrackList) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISingleSelectMediaTrackList) },
        { }
    };

    static PyType_Spec type_spec_ISingleSelectMediaTrackList = {
        "winrt._winrt_windows_media_core.ISingleSelectMediaTrackList",
        sizeof(py::wrapper::Windows::Media::Core::ISingleSelectMediaTrackList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISingleSelectMediaTrackList};

    // ----- ITimedMetadataTrackProvider interface --------------------

    static PyObject* _new_ITimedMetadataTrackProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Core::ITimedMetadataTrackProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Core::ITimedMetadataTrackProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_ITimedMetadataTrackProvider(py::wrapper::Windows::Media::Core::ITimedMetadataTrackProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ITimedMetadataTrackProvider_get_TimedMetadataTracks(py::wrapper::Windows::Media::Core::ITimedMetadataTrackProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Core.ITimedMetadataTrackProvider", L"TimedMetadataTracks");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TimedMetadataTracks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ITimedMetadataTrackProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::ITimedMetadataTrackProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ITimedMetadataTrackProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::ITimedMetadataTrackProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITimedMetadataTrackProvider[] = {
        { "_assign_array_", _assign_array_ITimedMetadataTrackProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ITimedMetadataTrackProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ITimedMetadataTrackProvider[] = {
        { "timed_metadata_tracks", reinterpret_cast<getter>(ITimedMetadataTrackProvider_get_TimedMetadataTracks), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ITimedMetadataTrackProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ITimedMetadataTrackProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ITimedMetadataTrackProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ITimedMetadataTrackProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ITimedMetadataTrackProvider) },
        { }
    };

    static PyType_Spec type_spec_ITimedMetadataTrackProvider = {
        "winrt._winrt_windows_media_core.ITimedMetadataTrackProvider",
        sizeof(py::wrapper::Windows::Media::Core::ITimedMetadataTrackProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITimedMetadataTrackProvider};

    // ----- MseTimeRange struct --------------------

    winrt_struct_wrapper<winrt::Windows::Media::Core::MseTimeRange>* _new_MseTimeRange(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Media::Core::MseTimeRange>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_MseTimeRange(winrt_struct_wrapper<winrt::Windows::Media::Core::MseTimeRange>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        PyObject* _Start{};
        PyObject* _End{};

        static const char* kwlist[] = {"start", "end", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "OO", const_cast<char**>(kwlist), &_Start, &_End))
        {
            return -1;
        }

        try
        {
            self->obj.Start = py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(_Start);
            self->obj.End = py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(_End);

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_MseTimeRange(py::wrapper::Windows::Media::Core::MseTimeRange* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MseTimeRange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::MseTimeRange>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_MseTimeRange[] = {
        { "_assign_array_", _assign_array_MseTimeRange, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* MseTimeRange_get_Start(py::wrapper::Windows::Media::Core::MseTimeRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Start);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseTimeRange_set_Start(py::wrapper::Windows::Media::Core::MseTimeRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Start = py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseTimeRange_get_End(py::wrapper::Windows::Media::Core::MseTimeRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.End);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseTimeRange_set_End(py::wrapper::Windows::Media::Core::MseTimeRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.End = py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_MseTimeRange[] = {
        { "start", reinterpret_cast<getter>(MseTimeRange_get_Start), reinterpret_cast<setter>(MseTimeRange_set_Start), nullptr, nullptr },
        { "end", reinterpret_cast<getter>(MseTimeRange_get_End), reinterpret_cast<setter>(MseTimeRange_set_End), nullptr, nullptr },
        { }
    };

    static PyObject* _richcompare_MseTimeRange(py::wrapper::Windows::Media::Core::MseTimeRange* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::converter<winrt::Windows::Media::Core::MseTimeRange>::convert_to(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_MseTimeRange(PyObject* self) noexcept
    {
        py::pyobj_handle Start{PyObject_GetAttrString(self, "start")};
        if (!Start)
        {
            return nullptr;
        }

        py::pyobj_handle End{PyObject_GetAttrString(self, "end")};
        if (!End)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("MseTimeRange(start=%R, end=%R)", Start.get(), End.get());
    }

    static PyType_Slot _type_slots_MseTimeRange[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MseTimeRange) },
        { Py_tp_init, reinterpret_cast<void*>(_init_MseTimeRange) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MseTimeRange) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MseTimeRange) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MseTimeRange) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_MseTimeRange) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_MseTimeRange) },
        { }
    };

    static PyType_Spec type_spec_MseTimeRange = {
        "winrt._winrt_windows_media_core.MseTimeRange",
        sizeof(py::wrapper::Windows::Media::Core::MseTimeRange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MseTimeRange};

    // ----- TimedTextDouble struct --------------------

    winrt_struct_wrapper<winrt::Windows::Media::Core::TimedTextDouble>* _new_TimedTextDouble(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Media::Core::TimedTextDouble>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_TimedTextDouble(winrt_struct_wrapper<winrt::Windows::Media::Core::TimedTextDouble>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        double _Value{};
        int32_t _Unit{};

        static const char* kwlist[] = {"value", "unit", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "di", const_cast<char**>(kwlist), &_Value, &_Unit))
        {
            return -1;
        }

        try
        {
            self->obj.Value = _Value;
            self->obj.Unit = static_cast<winrt::Windows::Media::Core::TimedTextUnit>(_Unit);

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_TimedTextDouble(py::wrapper::Windows::Media::Core::TimedTextDouble* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TimedTextDouble(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::TimedTextDouble>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_TimedTextDouble[] = {
        { "_assign_array_", _assign_array_TimedTextDouble, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* TimedTextDouble_get_Value(py::wrapper::Windows::Media::Core::TimedTextDouble* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextDouble_set_Value(py::wrapper::Windows::Media::Core::TimedTextDouble* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Value = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextDouble_get_Unit(py::wrapper::Windows::Media::Core::TimedTextDouble* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Unit);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextDouble_set_Unit(py::wrapper::Windows::Media::Core::TimedTextDouble* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Unit = py::converter<winrt::Windows::Media::Core::TimedTextUnit>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_TimedTextDouble[] = {
        { "value", reinterpret_cast<getter>(TimedTextDouble_get_Value), reinterpret_cast<setter>(TimedTextDouble_set_Value), nullptr, nullptr },
        { "unit", reinterpret_cast<getter>(TimedTextDouble_get_Unit), reinterpret_cast<setter>(TimedTextDouble_set_Unit), nullptr, nullptr },
        { }
    };

    static PyObject* _richcompare_TimedTextDouble(py::wrapper::Windows::Media::Core::TimedTextDouble* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::converter<winrt::Windows::Media::Core::TimedTextDouble>::convert_to(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_TimedTextDouble(PyObject* self) noexcept
    {
        py::pyobj_handle Value{PyObject_GetAttrString(self, "value")};
        if (!Value)
        {
            return nullptr;
        }

        py::pyobj_handle Unit{PyObject_GetAttrString(self, "unit")};
        if (!Unit)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("TimedTextDouble(value=%R, unit=%R)", Value.get(), Unit.get());
    }

    static PyType_Slot _type_slots_TimedTextDouble[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedTextDouble) },
        { Py_tp_init, reinterpret_cast<void*>(_init_TimedTextDouble) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedTextDouble) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimedTextDouble) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedTextDouble) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_TimedTextDouble) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_TimedTextDouble) },
        { }
    };

    static PyType_Spec type_spec_TimedTextDouble = {
        "winrt._winrt_windows_media_core.TimedTextDouble",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextDouble),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextDouble};

    // ----- TimedTextPadding struct --------------------

    winrt_struct_wrapper<winrt::Windows::Media::Core::TimedTextPadding>* _new_TimedTextPadding(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Media::Core::TimedTextPadding>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_TimedTextPadding(winrt_struct_wrapper<winrt::Windows::Media::Core::TimedTextPadding>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        double _Before{};
        double _After{};
        double _Start{};
        double _End{};
        int32_t _Unit{};

        static const char* kwlist[] = {"before", "after", "start", "end", "unit", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ddddi", const_cast<char**>(kwlist), &_Before, &_After, &_Start, &_End, &_Unit))
        {
            return -1;
        }

        try
        {
            self->obj.Before = _Before;
            self->obj.After = _After;
            self->obj.Start = _Start;
            self->obj.End = _End;
            self->obj.Unit = static_cast<winrt::Windows::Media::Core::TimedTextUnit>(_Unit);

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_TimedTextPadding(py::wrapper::Windows::Media::Core::TimedTextPadding* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TimedTextPadding(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::TimedTextPadding>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_TimedTextPadding[] = {
        { "_assign_array_", _assign_array_TimedTextPadding, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* TimedTextPadding_get_Before(py::wrapper::Windows::Media::Core::TimedTextPadding* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Before);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPadding_set_Before(py::wrapper::Windows::Media::Core::TimedTextPadding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Before = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextPadding_get_After(py::wrapper::Windows::Media::Core::TimedTextPadding* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.After);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPadding_set_After(py::wrapper::Windows::Media::Core::TimedTextPadding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.After = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextPadding_get_Start(py::wrapper::Windows::Media::Core::TimedTextPadding* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Start);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPadding_set_Start(py::wrapper::Windows::Media::Core::TimedTextPadding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Start = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextPadding_get_End(py::wrapper::Windows::Media::Core::TimedTextPadding* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.End);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPadding_set_End(py::wrapper::Windows::Media::Core::TimedTextPadding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.End = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextPadding_get_Unit(py::wrapper::Windows::Media::Core::TimedTextPadding* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Unit);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPadding_set_Unit(py::wrapper::Windows::Media::Core::TimedTextPadding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Unit = py::converter<winrt::Windows::Media::Core::TimedTextUnit>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_TimedTextPadding[] = {
        { "before", reinterpret_cast<getter>(TimedTextPadding_get_Before), reinterpret_cast<setter>(TimedTextPadding_set_Before), nullptr, nullptr },
        { "after", reinterpret_cast<getter>(TimedTextPadding_get_After), reinterpret_cast<setter>(TimedTextPadding_set_After), nullptr, nullptr },
        { "start", reinterpret_cast<getter>(TimedTextPadding_get_Start), reinterpret_cast<setter>(TimedTextPadding_set_Start), nullptr, nullptr },
        { "end", reinterpret_cast<getter>(TimedTextPadding_get_End), reinterpret_cast<setter>(TimedTextPadding_set_End), nullptr, nullptr },
        { "unit", reinterpret_cast<getter>(TimedTextPadding_get_Unit), reinterpret_cast<setter>(TimedTextPadding_set_Unit), nullptr, nullptr },
        { }
    };

    static PyObject* _richcompare_TimedTextPadding(py::wrapper::Windows::Media::Core::TimedTextPadding* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::converter<winrt::Windows::Media::Core::TimedTextPadding>::convert_to(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_TimedTextPadding(PyObject* self) noexcept
    {
        py::pyobj_handle Before{PyObject_GetAttrString(self, "before")};
        if (!Before)
        {
            return nullptr;
        }

        py::pyobj_handle After{PyObject_GetAttrString(self, "after")};
        if (!After)
        {
            return nullptr;
        }

        py::pyobj_handle Start{PyObject_GetAttrString(self, "start")};
        if (!Start)
        {
            return nullptr;
        }

        py::pyobj_handle End{PyObject_GetAttrString(self, "end")};
        if (!End)
        {
            return nullptr;
        }

        py::pyobj_handle Unit{PyObject_GetAttrString(self, "unit")};
        if (!Unit)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("TimedTextPadding(before=%R, after=%R, start=%R, end=%R, unit=%R)", Before.get(), After.get(), Start.get(), End.get(), Unit.get());
    }

    static PyType_Slot _type_slots_TimedTextPadding[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedTextPadding) },
        { Py_tp_init, reinterpret_cast<void*>(_init_TimedTextPadding) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedTextPadding) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimedTextPadding) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedTextPadding) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_TimedTextPadding) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_TimedTextPadding) },
        { }
    };

    static PyType_Spec type_spec_TimedTextPadding = {
        "winrt._winrt_windows_media_core.TimedTextPadding",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextPadding),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextPadding};

    // ----- TimedTextPoint struct --------------------

    winrt_struct_wrapper<winrt::Windows::Media::Core::TimedTextPoint>* _new_TimedTextPoint(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Media::Core::TimedTextPoint>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_TimedTextPoint(winrt_struct_wrapper<winrt::Windows::Media::Core::TimedTextPoint>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        double _X{};
        double _Y{};
        int32_t _Unit{};

        static const char* kwlist[] = {"x", "y", "unit", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ddi", const_cast<char**>(kwlist), &_X, &_Y, &_Unit))
        {
            return -1;
        }

        try
        {
            self->obj.X = _X;
            self->obj.Y = _Y;
            self->obj.Unit = static_cast<winrt::Windows::Media::Core::TimedTextUnit>(_Unit);

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_TimedTextPoint(py::wrapper::Windows::Media::Core::TimedTextPoint* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TimedTextPoint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::TimedTextPoint>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_TimedTextPoint[] = {
        { "_assign_array_", _assign_array_TimedTextPoint, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* TimedTextPoint_get_X(py::wrapper::Windows::Media::Core::TimedTextPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.X);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPoint_set_X(py::wrapper::Windows::Media::Core::TimedTextPoint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.X = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextPoint_get_Y(py::wrapper::Windows::Media::Core::TimedTextPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPoint_set_Y(py::wrapper::Windows::Media::Core::TimedTextPoint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Y = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextPoint_get_Unit(py::wrapper::Windows::Media::Core::TimedTextPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Unit);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPoint_set_Unit(py::wrapper::Windows::Media::Core::TimedTextPoint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Unit = py::converter<winrt::Windows::Media::Core::TimedTextUnit>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_TimedTextPoint[] = {
        { "x", reinterpret_cast<getter>(TimedTextPoint_get_X), reinterpret_cast<setter>(TimedTextPoint_set_X), nullptr, nullptr },
        { "y", reinterpret_cast<getter>(TimedTextPoint_get_Y), reinterpret_cast<setter>(TimedTextPoint_set_Y), nullptr, nullptr },
        { "unit", reinterpret_cast<getter>(TimedTextPoint_get_Unit), reinterpret_cast<setter>(TimedTextPoint_set_Unit), nullptr, nullptr },
        { }
    };

    static PyObject* _richcompare_TimedTextPoint(py::wrapper::Windows::Media::Core::TimedTextPoint* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::converter<winrt::Windows::Media::Core::TimedTextPoint>::convert_to(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_TimedTextPoint(PyObject* self) noexcept
    {
        py::pyobj_handle X{PyObject_GetAttrString(self, "x")};
        if (!X)
        {
            return nullptr;
        }

        py::pyobj_handle Y{PyObject_GetAttrString(self, "y")};
        if (!Y)
        {
            return nullptr;
        }

        py::pyobj_handle Unit{PyObject_GetAttrString(self, "unit")};
        if (!Unit)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("TimedTextPoint(x=%R, y=%R, unit=%R)", X.get(), Y.get(), Unit.get());
    }

    static PyType_Slot _type_slots_TimedTextPoint[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedTextPoint) },
        { Py_tp_init, reinterpret_cast<void*>(_init_TimedTextPoint) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedTextPoint) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimedTextPoint) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedTextPoint) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_TimedTextPoint) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_TimedTextPoint) },
        { }
    };

    static PyType_Spec type_spec_TimedTextPoint = {
        "winrt._winrt_windows_media_core.TimedTextPoint",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextPoint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextPoint};

    // ----- TimedTextSize struct --------------------

    winrt_struct_wrapper<winrt::Windows::Media::Core::TimedTextSize>* _new_TimedTextSize(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Media::Core::TimedTextSize>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_TimedTextSize(winrt_struct_wrapper<winrt::Windows::Media::Core::TimedTextSize>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        double _Height{};
        double _Width{};
        int32_t _Unit{};

        static const char* kwlist[] = {"height", "width", "unit", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ddi", const_cast<char**>(kwlist), &_Height, &_Width, &_Unit))
        {
            return -1;
        }

        try
        {
            self->obj.Height = _Height;
            self->obj.Width = _Width;
            self->obj.Unit = static_cast<winrt::Windows::Media::Core::TimedTextUnit>(_Unit);

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_TimedTextSize(py::wrapper::Windows::Media::Core::TimedTextSize* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TimedTextSize(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Core::TimedTextSize>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_TimedTextSize[] = {
        { "_assign_array_", _assign_array_TimedTextSize, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* TimedTextSize_get_Height(py::wrapper::Windows::Media::Core::TimedTextSize* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextSize_set_Height(py::wrapper::Windows::Media::Core::TimedTextSize* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Height = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextSize_get_Width(py::wrapper::Windows::Media::Core::TimedTextSize* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextSize_set_Width(py::wrapper::Windows::Media::Core::TimedTextSize* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Width = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextSize_get_Unit(py::wrapper::Windows::Media::Core::TimedTextSize* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Unit);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextSize_set_Unit(py::wrapper::Windows::Media::Core::TimedTextSize* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Unit = py::converter<winrt::Windows::Media::Core::TimedTextUnit>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_TimedTextSize[] = {
        { "height", reinterpret_cast<getter>(TimedTextSize_get_Height), reinterpret_cast<setter>(TimedTextSize_set_Height), nullptr, nullptr },
        { "width", reinterpret_cast<getter>(TimedTextSize_get_Width), reinterpret_cast<setter>(TimedTextSize_set_Width), nullptr, nullptr },
        { "unit", reinterpret_cast<getter>(TimedTextSize_get_Unit), reinterpret_cast<setter>(TimedTextSize_set_Unit), nullptr, nullptr },
        { }
    };

    static PyObject* _richcompare_TimedTextSize(py::wrapper::Windows::Media::Core::TimedTextSize* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::converter<winrt::Windows::Media::Core::TimedTextSize>::convert_to(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_TimedTextSize(PyObject* self) noexcept
    {
        py::pyobj_handle Height{PyObject_GetAttrString(self, "height")};
        if (!Height)
        {
            return nullptr;
        }

        py::pyobj_handle Width{PyObject_GetAttrString(self, "width")};
        if (!Width)
        {
            return nullptr;
        }

        py::pyobj_handle Unit{PyObject_GetAttrString(self, "unit")};
        if (!Unit)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("TimedTextSize(height=%R, width=%R, unit=%R)", Height.get(), Width.get(), Unit.get());
    }

    static PyType_Slot _type_slots_TimedTextSize[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedTextSize) },
        { Py_tp_init, reinterpret_cast<void*>(_init_TimedTextSize) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedTextSize) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimedTextSize) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedTextSize) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_TimedTextSize) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_TimedTextSize) },
        { }
    };

    static PyType_Spec type_spec_TimedTextSize = {
        "winrt._winrt_windows_media_core.TimedTextSize",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextSize),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextSize};

    // ----- Windows.Media.Core Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Media.Core");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_media_core",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Media::Core

PyMODINIT_FUNC PyInit__winrt_windows_media_core(void) noexcept
{
    using namespace py::cpp::Windows::Media::Core;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle AudioStreamDescriptor_type{py::register_python_type(module.get(), &type_spec_AudioStreamDescriptor, object_bases.get(), nullptr)};
    if (!AudioStreamDescriptor_type)
    {
        return nullptr;
    }

    py::pytype_handle AudioTrack_type{py::register_python_type(module.get(), &type_spec_AudioTrack, object_bases.get(), nullptr)};
    if (!AudioTrack_type)
    {
        return nullptr;
    }

    py::pytype_handle AudioTrackOpenFailedEventArgs_type{py::register_python_type(module.get(), &type_spec_AudioTrackOpenFailedEventArgs, object_bases.get(), nullptr)};
    if (!AudioTrackOpenFailedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle AudioTrackSupportInfo_type{py::register_python_type(module.get(), &type_spec_AudioTrackSupportInfo, object_bases.get(), nullptr)};
    if (!AudioTrackSupportInfo_type)
    {
        return nullptr;
    }

    py::pytype_handle ChapterCue_type{py::register_python_type(module.get(), &type_spec_ChapterCue, object_bases.get(), nullptr)};
    if (!ChapterCue_type)
    {
        return nullptr;
    }

    py::pytype_handle CodecInfo_type{py::register_python_type(module.get(), &type_spec_CodecInfo, object_bases.get(), nullptr)};
    if (!CodecInfo_type)
    {
        return nullptr;
    }

    py::pytype_handle CodecQuery_type{py::register_python_type(module.get(), &type_spec_CodecQuery, object_bases.get(), nullptr)};
    if (!CodecQuery_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_CodecSubtypes_Static{PyType_FromSpec(&type_spec_CodecSubtypes_Static)};
    if (!type_CodecSubtypes_Static)
    {
        return nullptr;
    }

    py::pytype_handle CodecSubtypes_type{py::register_python_type(module.get(), &type_spec_CodecSubtypes, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CodecSubtypes_Static.get()))};
    if (!CodecSubtypes_type)
    {
        return nullptr;
    }

    py::pytype_handle DataCue_type{py::register_python_type(module.get(), &type_spec_DataCue, object_bases.get(), nullptr)};
    if (!DataCue_type)
    {
        return nullptr;
    }

    py::pytype_handle FaceDetectedEventArgs_type{py::register_python_type(module.get(), &type_spec_FaceDetectedEventArgs, object_bases.get(), nullptr)};
    if (!FaceDetectedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle FaceDetectionEffect_type{py::register_python_type(module.get(), &type_spec_FaceDetectionEffect, object_bases.get(), nullptr)};
    if (!FaceDetectionEffect_type)
    {
        return nullptr;
    }

    py::pytype_handle FaceDetectionEffectDefinition_type{py::register_python_type(module.get(), &type_spec_FaceDetectionEffectDefinition, object_bases.get(), nullptr)};
    if (!FaceDetectionEffectDefinition_type)
    {
        return nullptr;
    }

    py::pytype_handle FaceDetectionEffectFrame_type{py::register_python_type(module.get(), &type_spec_FaceDetectionEffectFrame, object_bases.get(), nullptr)};
    if (!FaceDetectionEffectFrame_type)
    {
        return nullptr;
    }

    py::pytype_handle HighDynamicRangeControl_type{py::register_python_type(module.get(), &type_spec_HighDynamicRangeControl, object_bases.get(), nullptr)};
    if (!HighDynamicRangeControl_type)
    {
        return nullptr;
    }

    py::pytype_handle HighDynamicRangeOutput_type{py::register_python_type(module.get(), &type_spec_HighDynamicRangeOutput, object_bases.get(), nullptr)};
    if (!HighDynamicRangeOutput_type)
    {
        return nullptr;
    }

    py::pytype_handle ImageCue_type{py::register_python_type(module.get(), &type_spec_ImageCue, object_bases.get(), nullptr)};
    if (!ImageCue_type)
    {
        return nullptr;
    }

    py::pytype_handle InitializeMediaStreamSourceRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_InitializeMediaStreamSourceRequestedEventArgs, object_bases.get(), nullptr)};
    if (!InitializeMediaStreamSourceRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_LowLightFusion_Static{PyType_FromSpec(&type_spec_LowLightFusion_Static)};
    if (!type_LowLightFusion_Static)
    {
        return nullptr;
    }

    py::pytype_handle LowLightFusion_type{py::register_python_type(module.get(), &type_spec_LowLightFusion, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_LowLightFusion_Static.get()))};
    if (!LowLightFusion_type)
    {
        return nullptr;
    }

    py::pytype_handle LowLightFusionResult_type{py::register_python_type(module.get(), &type_spec_LowLightFusionResult, object_bases.get(), nullptr)};
    if (!LowLightFusionResult_type)
    {
        return nullptr;
    }

    py::pytype_handle MediaBinder_type{py::register_python_type(module.get(), &type_spec_MediaBinder, object_bases.get(), nullptr)};
    if (!MediaBinder_type)
    {
        return nullptr;
    }

    py::pytype_handle MediaBindingEventArgs_type{py::register_python_type(module.get(), &type_spec_MediaBindingEventArgs, object_bases.get(), nullptr)};
    if (!MediaBindingEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle MediaCueEventArgs_type{py::register_python_type(module.get(), &type_spec_MediaCueEventArgs, object_bases.get(), nullptr)};
    if (!MediaCueEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_MediaSource_Static{PyType_FromSpec(&type_spec_MediaSource_Static)};
    if (!type_MediaSource_Static)
    {
        return nullptr;
    }

    py::pytype_handle MediaSource_type{py::register_python_type(module.get(), &type_spec_MediaSource, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MediaSource_Static.get()))};
    if (!MediaSource_type)
    {
        return nullptr;
    }

    py::pytype_handle MediaSourceAppServiceConnection_type{py::register_python_type(module.get(), &type_spec_MediaSourceAppServiceConnection, object_bases.get(), nullptr)};
    if (!MediaSourceAppServiceConnection_type)
    {
        return nullptr;
    }

    py::pytype_handle MediaSourceError_type{py::register_python_type(module.get(), &type_spec_MediaSourceError, object_bases.get(), nullptr)};
    if (!MediaSourceError_type)
    {
        return nullptr;
    }

    py::pytype_handle MediaSourceOpenOperationCompletedEventArgs_type{py::register_python_type(module.get(), &type_spec_MediaSourceOpenOperationCompletedEventArgs, object_bases.get(), nullptr)};
    if (!MediaSourceOpenOperationCompletedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle MediaSourceStateChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_MediaSourceStateChangedEventArgs, object_bases.get(), nullptr)};
    if (!MediaSourceStateChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_MediaStreamSample_Static{PyType_FromSpec(&type_spec_MediaStreamSample_Static)};
    if (!type_MediaStreamSample_Static)
    {
        return nullptr;
    }

    py::pytype_handle MediaStreamSample_type{py::register_python_type(module.get(), &type_spec_MediaStreamSample, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MediaStreamSample_Static.get()))};
    if (!MediaStreamSample_type)
    {
        return nullptr;
    }

    py::pytype_handle MediaStreamSamplePropertySet_type{py::register_python_type(module.get(), &type_spec_MediaStreamSamplePropertySet, object_bases.get(), nullptr)};
    if (!MediaStreamSamplePropertySet_type)
    {
        return nullptr;
    }

    py::pytype_handle MediaStreamSampleProtectionProperties_type{py::register_python_type(module.get(), &type_spec_MediaStreamSampleProtectionProperties, object_bases.get(), nullptr)};
    if (!MediaStreamSampleProtectionProperties_type)
    {
        return nullptr;
    }

    py::pytype_handle MediaStreamSource_type{py::register_python_type(module.get(), &type_spec_MediaStreamSource, object_bases.get(), nullptr)};
    if (!MediaStreamSource_type)
    {
        return nullptr;
    }

    py::pytype_handle MediaStreamSourceClosedEventArgs_type{py::register_python_type(module.get(), &type_spec_MediaStreamSourceClosedEventArgs, object_bases.get(), nullptr)};
    if (!MediaStreamSourceClosedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle MediaStreamSourceClosedRequest_type{py::register_python_type(module.get(), &type_spec_MediaStreamSourceClosedRequest, object_bases.get(), nullptr)};
    if (!MediaStreamSourceClosedRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle MediaStreamSourceSampleRenderedEventArgs_type{py::register_python_type(module.get(), &type_spec_MediaStreamSourceSampleRenderedEventArgs, object_bases.get(), nullptr)};
    if (!MediaStreamSourceSampleRenderedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle MediaStreamSourceSampleRequest_type{py::register_python_type(module.get(), &type_spec_MediaStreamSourceSampleRequest, object_bases.get(), nullptr)};
    if (!MediaStreamSourceSampleRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle MediaStreamSourceSampleRequestDeferral_type{py::register_python_type(module.get(), &type_spec_MediaStreamSourceSampleRequestDeferral, object_bases.get(), nullptr)};
    if (!MediaStreamSourceSampleRequestDeferral_type)
    {
        return nullptr;
    }

    py::pytype_handle MediaStreamSourceSampleRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_MediaStreamSourceSampleRequestedEventArgs, object_bases.get(), nullptr)};
    if (!MediaStreamSourceSampleRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle MediaStreamSourceStartingEventArgs_type{py::register_python_type(module.get(), &type_spec_MediaStreamSourceStartingEventArgs, object_bases.get(), nullptr)};
    if (!MediaStreamSourceStartingEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle MediaStreamSourceStartingRequest_type{py::register_python_type(module.get(), &type_spec_MediaStreamSourceStartingRequest, object_bases.get(), nullptr)};
    if (!MediaStreamSourceStartingRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle MediaStreamSourceStartingRequestDeferral_type{py::register_python_type(module.get(), &type_spec_MediaStreamSourceStartingRequestDeferral, object_bases.get(), nullptr)};
    if (!MediaStreamSourceStartingRequestDeferral_type)
    {
        return nullptr;
    }

    py::pytype_handle MediaStreamSourceSwitchStreamsRequest_type{py::register_python_type(module.get(), &type_spec_MediaStreamSourceSwitchStreamsRequest, object_bases.get(), nullptr)};
    if (!MediaStreamSourceSwitchStreamsRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle MediaStreamSourceSwitchStreamsRequestDeferral_type{py::register_python_type(module.get(), &type_spec_MediaStreamSourceSwitchStreamsRequestDeferral, object_bases.get(), nullptr)};
    if (!MediaStreamSourceSwitchStreamsRequestDeferral_type)
    {
        return nullptr;
    }

    py::pytype_handle MediaStreamSourceSwitchStreamsRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_MediaStreamSourceSwitchStreamsRequestedEventArgs, object_bases.get(), nullptr)};
    if (!MediaStreamSourceSwitchStreamsRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle MseSourceBuffer_type{py::register_python_type(module.get(), &type_spec_MseSourceBuffer, object_bases.get(), nullptr)};
    if (!MseSourceBuffer_type)
    {
        return nullptr;
    }

    py::pytype_handle MseSourceBufferList_type{py::register_python_type(module.get(), &type_spec_MseSourceBufferList, object_bases.get(), nullptr)};
    if (!MseSourceBufferList_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_MseStreamSource_Static{PyType_FromSpec(&type_spec_MseStreamSource_Static)};
    if (!type_MseStreamSource_Static)
    {
        return nullptr;
    }

    py::pytype_handle MseStreamSource_type{py::register_python_type(module.get(), &type_spec_MseStreamSource, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MseStreamSource_Static.get()))};
    if (!MseStreamSource_type)
    {
        return nullptr;
    }

    py::pytype_handle SceneAnalysisEffect_type{py::register_python_type(module.get(), &type_spec_SceneAnalysisEffect, object_bases.get(), nullptr)};
    if (!SceneAnalysisEffect_type)
    {
        return nullptr;
    }

    py::pytype_handle SceneAnalysisEffectDefinition_type{py::register_python_type(module.get(), &type_spec_SceneAnalysisEffectDefinition, object_bases.get(), nullptr)};
    if (!SceneAnalysisEffectDefinition_type)
    {
        return nullptr;
    }

    py::pytype_handle SceneAnalysisEffectFrame_type{py::register_python_type(module.get(), &type_spec_SceneAnalysisEffectFrame, object_bases.get(), nullptr)};
    if (!SceneAnalysisEffectFrame_type)
    {
        return nullptr;
    }

    py::pytype_handle SceneAnalyzedEventArgs_type{py::register_python_type(module.get(), &type_spec_SceneAnalyzedEventArgs, object_bases.get(), nullptr)};
    if (!SceneAnalyzedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SpeechCue_type{py::register_python_type(module.get(), &type_spec_SpeechCue, object_bases.get(), nullptr)};
    if (!SpeechCue_type)
    {
        return nullptr;
    }

    py::pytype_handle TimedMetadataStreamDescriptor_type{py::register_python_type(module.get(), &type_spec_TimedMetadataStreamDescriptor, object_bases.get(), nullptr)};
    if (!TimedMetadataStreamDescriptor_type)
    {
        return nullptr;
    }

    py::pytype_handle TimedMetadataTrack_type{py::register_python_type(module.get(), &type_spec_TimedMetadataTrack, object_bases.get(), nullptr)};
    if (!TimedMetadataTrack_type)
    {
        return nullptr;
    }

    py::pytype_handle TimedMetadataTrackError_type{py::register_python_type(module.get(), &type_spec_TimedMetadataTrackError, object_bases.get(), nullptr)};
    if (!TimedMetadataTrackError_type)
    {
        return nullptr;
    }

    py::pytype_handle TimedMetadataTrackFailedEventArgs_type{py::register_python_type(module.get(), &type_spec_TimedMetadataTrackFailedEventArgs, object_bases.get(), nullptr)};
    if (!TimedMetadataTrackFailedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle TimedTextBouten_type{py::register_python_type(module.get(), &type_spec_TimedTextBouten, object_bases.get(), nullptr)};
    if (!TimedTextBouten_type)
    {
        return nullptr;
    }

    py::pytype_handle TimedTextCue_type{py::register_python_type(module.get(), &type_spec_TimedTextCue, object_bases.get(), nullptr)};
    if (!TimedTextCue_type)
    {
        return nullptr;
    }

    py::pytype_handle TimedTextLine_type{py::register_python_type(module.get(), &type_spec_TimedTextLine, object_bases.get(), nullptr)};
    if (!TimedTextLine_type)
    {
        return nullptr;
    }

    py::pytype_handle TimedTextRegion_type{py::register_python_type(module.get(), &type_spec_TimedTextRegion, object_bases.get(), nullptr)};
    if (!TimedTextRegion_type)
    {
        return nullptr;
    }

    py::pytype_handle TimedTextRuby_type{py::register_python_type(module.get(), &type_spec_TimedTextRuby, object_bases.get(), nullptr)};
    if (!TimedTextRuby_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_TimedTextSource_Static{PyType_FromSpec(&type_spec_TimedTextSource_Static)};
    if (!type_TimedTextSource_Static)
    {
        return nullptr;
    }

    py::pytype_handle TimedTextSource_type{py::register_python_type(module.get(), &type_spec_TimedTextSource, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TimedTextSource_Static.get()))};
    if (!TimedTextSource_type)
    {
        return nullptr;
    }

    py::pytype_handle TimedTextSourceResolveResultEventArgs_type{py::register_python_type(module.get(), &type_spec_TimedTextSourceResolveResultEventArgs, object_bases.get(), nullptr)};
    if (!TimedTextSourceResolveResultEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle TimedTextStyle_type{py::register_python_type(module.get(), &type_spec_TimedTextStyle, object_bases.get(), nullptr)};
    if (!TimedTextStyle_type)
    {
        return nullptr;
    }

    py::pytype_handle TimedTextSubformat_type{py::register_python_type(module.get(), &type_spec_TimedTextSubformat, object_bases.get(), nullptr)};
    if (!TimedTextSubformat_type)
    {
        return nullptr;
    }

    py::pytype_handle VideoStabilizationEffect_type{py::register_python_type(module.get(), &type_spec_VideoStabilizationEffect, object_bases.get(), nullptr)};
    if (!VideoStabilizationEffect_type)
    {
        return nullptr;
    }

    py::pytype_handle VideoStabilizationEffectDefinition_type{py::register_python_type(module.get(), &type_spec_VideoStabilizationEffectDefinition, object_bases.get(), nullptr)};
    if (!VideoStabilizationEffectDefinition_type)
    {
        return nullptr;
    }

    py::pytype_handle VideoStabilizationEffectEnabledChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_VideoStabilizationEffectEnabledChangedEventArgs, object_bases.get(), nullptr)};
    if (!VideoStabilizationEffectEnabledChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle VideoStreamDescriptor_type{py::register_python_type(module.get(), &type_spec_VideoStreamDescriptor, object_bases.get(), nullptr)};
    if (!VideoStreamDescriptor_type)
    {
        return nullptr;
    }

    py::pytype_handle VideoTrack_type{py::register_python_type(module.get(), &type_spec_VideoTrack, object_bases.get(), nullptr)};
    if (!VideoTrack_type)
    {
        return nullptr;
    }

    py::pytype_handle VideoTrackOpenFailedEventArgs_type{py::register_python_type(module.get(), &type_spec_VideoTrackOpenFailedEventArgs, object_bases.get(), nullptr)};
    if (!VideoTrackOpenFailedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle VideoTrackSupportInfo_type{py::register_python_type(module.get(), &type_spec_VideoTrackSupportInfo, object_bases.get(), nullptr)};
    if (!VideoTrackSupportInfo_type)
    {
        return nullptr;
    }

    py::pytype_handle IMediaCue_type{py::register_python_type(module.get(), &type_spec_IMediaCue, object_bases.get(), nullptr)};
    if (!IMediaCue_type)
    {
        return nullptr;
    }

    py::pytype_handle IMediaSource_type{py::register_python_type(module.get(), &type_spec_IMediaSource, object_bases.get(), nullptr)};
    if (!IMediaSource_type)
    {
        return nullptr;
    }

    py::pytype_handle IMediaStreamDescriptor_type{py::register_python_type(module.get(), &type_spec_IMediaStreamDescriptor, object_bases.get(), nullptr)};
    if (!IMediaStreamDescriptor_type)
    {
        return nullptr;
    }

    py::pytype_handle IMediaStreamDescriptor2_type{py::register_python_type(module.get(), &type_spec_IMediaStreamDescriptor2, object_bases.get(), nullptr)};
    if (!IMediaStreamDescriptor2_type)
    {
        return nullptr;
    }

    py::pytype_handle IMediaTrack_type{py::register_python_type(module.get(), &type_spec_IMediaTrack, object_bases.get(), nullptr)};
    if (!IMediaTrack_type)
    {
        return nullptr;
    }

    py::pytype_handle ISingleSelectMediaTrackList_type{py::register_python_type(module.get(), &type_spec_ISingleSelectMediaTrackList, object_bases.get(), nullptr)};
    if (!ISingleSelectMediaTrackList_type)
    {
        return nullptr;
    }

    py::pytype_handle ITimedMetadataTrackProvider_type{py::register_python_type(module.get(), &type_spec_ITimedMetadataTrackProvider, object_bases.get(), nullptr)};
    if (!ITimedMetadataTrackProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle MseTimeRange_type{py::register_python_type(module.get(), &type_spec_MseTimeRange, nullptr, nullptr)};
    if (!MseTimeRange_type)
    {
        return nullptr;
    }

    py::pytype_handle TimedTextDouble_type{py::register_python_type(module.get(), &type_spec_TimedTextDouble, nullptr, nullptr)};
    if (!TimedTextDouble_type)
    {
        return nullptr;
    }

    py::pytype_handle TimedTextPadding_type{py::register_python_type(module.get(), &type_spec_TimedTextPadding, nullptr, nullptr)};
    if (!TimedTextPadding_type)
    {
        return nullptr;
    }

    py::pytype_handle TimedTextPoint_type{py::register_python_type(module.get(), &type_spec_TimedTextPoint, nullptr, nullptr)};
    if (!TimedTextPoint_type)
    {
        return nullptr;
    }

    py::pytype_handle TimedTextSize_type{py::register_python_type(module.get(), &type_spec_TimedTextSize, nullptr, nullptr)};
    if (!TimedTextSize_type)
    {
        return nullptr;
    }


    return module.detach();
}
