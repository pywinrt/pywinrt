# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.applicationmodel.appservice
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.graphics.directx.direct3d11
import winrt.windows.graphics.imaging
import winrt.windows.media.capture
import winrt.windows.media.capture.frames
import winrt.windows.media.devices
import winrt.windows.media.devices.core
import winrt.windows.media.faceanalysis
import winrt.windows.media.mediaproperties
import winrt.windows.media.playback
import winrt.windows.media.protection
import winrt.windows.media.streaming.adaptive
import winrt.windows.networking.backgroundtransfer
import winrt.windows.storage
import winrt.windows.storage.fileproperties
import winrt.windows.storage.streams
import winrt.windows.ui

from winrt.windows.media.core import AudioDecoderDegradation, AudioDecoderDegradationReason, CodecCategory, CodecKind, FaceDetectionMode, MediaDecoderStatus, MediaSourceState, MediaSourceStatus, MediaStreamSourceClosedReason, MediaStreamSourceErrorStatus, MediaTrackKind, MseAppendMode, MseEndOfStreamStatus, MseReadyState, SceneAnalysisRecommendation, TimedMetadataKind, TimedMetadataTrackErrorCode, TimedTextBoutenPosition, TimedTextBoutenType, TimedTextDisplayAlignment, TimedTextFlowDirection, TimedTextFontStyle, TimedTextLineAlignment, TimedTextRubyAlign, TimedTextRubyPosition, TimedTextRubyReserve, TimedTextScrollMode, TimedTextUnit, TimedTextWeight, TimedTextWrapping, TimedTextWritingMode, VideoStabilizationEffectEnabledChangedReason

Self = typing.TypeVar('Self')

@typing.final
class MseTimeRange:
    start: datetime.timedelta
    end: datetime.timedelta
    def __init__(self, start: datetime.timedelta, end: datetime.timedelta) -> None: ...

@typing.final
class TimedTextDouble:
    value: winrt.system.Double
    unit: TimedTextUnit
    def __init__(self, value: winrt.system.Double, unit: TimedTextUnit) -> None: ...

@typing.final
class TimedTextPadding:
    before: winrt.system.Double
    after: winrt.system.Double
    start: winrt.system.Double
    end: winrt.system.Double
    unit: TimedTextUnit
    def __init__(self, before: winrt.system.Double, after: winrt.system.Double, start: winrt.system.Double, end: winrt.system.Double, unit: TimedTextUnit) -> None: ...

@typing.final
class TimedTextPoint:
    x: winrt.system.Double
    y: winrt.system.Double
    unit: TimedTextUnit
    def __init__(self, x: winrt.system.Double, y: winrt.system.Double, unit: TimedTextUnit) -> None: ...

@typing.final
class TimedTextSize:
    height: winrt.system.Double
    width: winrt.system.Double
    unit: TimedTextUnit
    def __init__(self, height: winrt.system.Double, width: winrt.system.Double, unit: TimedTextUnit) -> None: ...

@typing.final
class AudioStreamDescriptor(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioStreamDescriptor: ...
    def __new__(cls: typing.Type[AudioStreamDescriptor], encoding_properties: typing.Optional[winrt.windows.media.mediaproperties.AudioEncodingProperties]) -> AudioStreamDescriptor:...
    def copy(self) -> typing.Optional[AudioStreamDescriptor]: ...
    @_property
    def encoding_properties(self) -> typing.Optional[winrt.windows.media.mediaproperties.AudioEncodingProperties]: ...
    @_property
    def trailing_encoder_padding(self) -> typing.Optional[typing.Optional[winrt.system.UInt32]]: ...
    @trailing_encoder_padding.setter
    def trailing_encoder_padding(self, value: typing.Optional[typing.Optional[winrt.system.UInt32]]) -> None: ...
    @_property
    def leading_encoder_padding(self) -> typing.Optional[typing.Optional[winrt.system.UInt32]]: ...
    @leading_encoder_padding.setter
    def leading_encoder_padding(self, value: typing.Optional[typing.Optional[winrt.system.UInt32]]) -> None: ...
    @_property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> None: ...
    @_property
    def language(self) -> str: ...
    @language.setter
    def language(self, value: str) -> None: ...
    @_property
    def is_selected(self) -> bool: ...
    @_property
    def label(self) -> str: ...
    @label.setter
    def label(self, value: str) -> None: ...

@typing.final
class AudioTrack(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioTrack: ...
    def get_encoding_properties(self) -> typing.Optional[winrt.windows.media.mediaproperties.AudioEncodingProperties]: ...
    def add_open_failed(self, handler: winrt.windows.foundation.TypedEventHandler[AudioTrack, AudioTrackOpenFailedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_open_failed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def name(self) -> str: ...
    @_property
    def playback_item(self) -> typing.Optional[winrt.windows.media.playback.MediaPlaybackItem]: ...
    @_property
    def support_info(self) -> typing.Optional[AudioTrackSupportInfo]: ...
    @_property
    def label(self) -> str: ...
    @label.setter
    def label(self, value: str) -> None: ...
    @_property
    def id(self) -> str: ...
    @_property
    def language(self) -> str: ...
    @_property
    def track_kind(self) -> MediaTrackKind: ...

@typing.final
class AudioTrackOpenFailedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioTrackOpenFailedEventArgs: ...
    @_property
    def extended_error(self) -> winrt.windows.foundation.HResult: ...

@typing.final
class AudioTrackSupportInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioTrackSupportInfo: ...
    @_property
    def decoder_status(self) -> MediaDecoderStatus: ...
    @_property
    def degradation(self) -> AudioDecoderDegradation: ...
    @_property
    def degradation_reason(self) -> AudioDecoderDegradationReason: ...
    @_property
    def media_source_status(self) -> MediaSourceStatus: ...

@typing.final
class ChapterCue(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChapterCue: ...
    def __new__(cls: typing.Type[ChapterCue]) -> ChapterCue:...
    @_property
    def title(self) -> str: ...
    @title.setter
    def title(self, value: str) -> None: ...
    @_property
    def start_time(self) -> datetime.timedelta: ...
    @start_time.setter
    def start_time(self, value: datetime.timedelta) -> None: ...
    @_property
    def id(self) -> str: ...
    @id.setter
    def id(self, value: str) -> None: ...
    @_property
    def duration(self) -> datetime.timedelta: ...
    @duration.setter
    def duration(self, value: datetime.timedelta) -> None: ...

@typing.final
class CodecInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CodecInfo: ...
    @_property
    def category(self) -> CodecCategory: ...
    @_property
    def display_name(self) -> str: ...
    @_property
    def is_trusted(self) -> bool: ...
    @_property
    def kind(self) -> CodecKind: ...
    @_property
    def subtypes(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]: ...

@typing.final
class CodecQuery(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CodecQuery: ...
    def __new__(cls: typing.Type[CodecQuery]) -> CodecQuery:...
    def find_all_async(self, kind: CodecKind, category: CodecCategory, sub_type: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[CodecInfo]]: ...

@typing.final
class CodecSubtypes_Static(type):
    @_property
    def audio_format_aac(cls) -> str: ...
    @_property
    def audio_format_adts(cls) -> str: ...
    @_property
    def audio_format_alac(cls) -> str: ...
    @_property
    def audio_format_amr_n_b(cls) -> str: ...
    @_property
    def audio_format_amr_w_b(cls) -> str: ...
    @_property
    def audio_format_amr_w_p(cls) -> str: ...
    @_property
    def audio_format_dolby_a_c3(cls) -> str: ...
    @_property
    def audio_format_dolby_a_c3_spdif(cls) -> str: ...
    @_property
    def audio_format_dolby_d_d_plus(cls) -> str: ...
    @_property
    def audio_format_drm(cls) -> str: ...
    @_property
    def audio_format_dts(cls) -> str: ...
    @_property
    def audio_format_flac(cls) -> str: ...
    @_property
    def audio_format_float(cls) -> str: ...
    @_property
    def audio_format_m_p3(cls) -> str: ...
    @_property
    def audio_format_m_peg(cls) -> str: ...
    @_property
    def audio_format_msp1(cls) -> str: ...
    @_property
    def audio_format_opus(cls) -> str: ...
    @_property
    def audio_format_pcm(cls) -> str: ...
    @_property
    def audio_format_w_m_audio_lossless(cls) -> str: ...
    @_property
    def audio_format_w_m_audio_v8(cls) -> str: ...
    @_property
    def audio_format_w_m_audio_v9(cls) -> str: ...
    @_property
    def audio_format_wma_spdif(cls) -> str: ...
    @_property
    def video_format420_o(cls) -> str: ...
    @_property
    def video_format_d_v25(cls) -> str: ...
    @_property
    def video_format_d_v50(cls) -> str: ...
    @_property
    def video_format_dvc(cls) -> str: ...
    @_property
    def video_format_dvh1(cls) -> str: ...
    @_property
    def video_format_dvh_d(cls) -> str: ...
    @_property
    def video_format_dvsd(cls) -> str: ...
    @_property
    def video_format_dvsl(cls) -> str: ...
    @_property
    def video_format_h263(cls) -> str: ...
    @_property
    def video_format_h264(cls) -> str: ...
    @_property
    def video_format_h264_e_s(cls) -> str: ...
    @_property
    def video_format_h265(cls) -> str: ...
    @_property
    def video_format_hevc(cls) -> str: ...
    @_property
    def video_format_hevc_e_s(cls) -> str: ...
    @_property
    def video_format_m4_s2(cls) -> str: ...
    @_property
    def video_format_m_p43(cls) -> str: ...
    @_property
    def video_format_m_p4_s(cls) -> str: ...
    @_property
    def video_format_m_p4_v(cls) -> str: ...
    @_property
    def video_format_mjpg(cls) -> str: ...
    @_property
    def video_format_mpeg2(cls) -> str: ...
    @_property
    def video_format_mpg1(cls) -> str: ...
    @_property
    def video_format_mss1(cls) -> str: ...
    @_property
    def video_format_mss2(cls) -> str: ...
    @_property
    def video_format_v_p80(cls) -> str: ...
    @_property
    def video_format_v_p90(cls) -> str: ...
    @_property
    def video_format_wmv1(cls) -> str: ...
    @_property
    def video_format_wmv2(cls) -> str: ...
    @_property
    def video_format_wmv3(cls) -> str: ...
    @_property
    def video_format_wvc1(cls) -> str: ...

@typing.final
class CodecSubtypes(winrt.system.Object, metaclass=CodecSubtypes_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CodecSubtypes: ...

@typing.final
class DataCue(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DataCue: ...
    def __new__(cls: typing.Type[DataCue]) -> DataCue:...
    @_property
    def data(self) -> typing.Optional[winrt.windows.storage.streams.IBuffer]: ...
    @data.setter
    def data(self, value: typing.Optional[winrt.windows.storage.streams.IBuffer]) -> None: ...
    @_property
    def properties(self) -> typing.Optional[winrt.windows.foundation.collections.PropertySet]: ...
    @_property
    def start_time(self) -> datetime.timedelta: ...
    @start_time.setter
    def start_time(self, value: datetime.timedelta) -> None: ...
    @_property
    def id(self) -> str: ...
    @id.setter
    def id(self, value: str) -> None: ...
    @_property
    def duration(self) -> datetime.timedelta: ...
    @duration.setter
    def duration(self, value: datetime.timedelta) -> None: ...

@typing.final
class FaceDetectedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FaceDetectedEventArgs: ...
    @_property
    def result_frame(self) -> typing.Optional[FaceDetectionEffectFrame]: ...

@typing.final
class FaceDetectionEffect(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FaceDetectionEffect: ...
    def set_properties(self, configuration: typing.Optional[winrt.windows.foundation.collections.IPropertySet], /) -> None: ...
    def add_face_detected(self, handler: winrt.windows.foundation.TypedEventHandler[FaceDetectionEffect, FaceDetectedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_face_detected(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> None: ...
    @_property
    def desired_detection_interval(self) -> datetime.timedelta: ...
    @desired_detection_interval.setter
    def desired_detection_interval(self, value: datetime.timedelta) -> None: ...

@typing.final
class FaceDetectionEffectDefinition(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FaceDetectionEffectDefinition: ...
    def __new__(cls: typing.Type[FaceDetectionEffectDefinition]) -> FaceDetectionEffectDefinition:...
    @_property
    def synchronous_detection_enabled(self) -> bool: ...
    @synchronous_detection_enabled.setter
    def synchronous_detection_enabled(self, value: bool) -> None: ...
    @_property
    def detection_mode(self) -> FaceDetectionMode: ...
    @detection_mode.setter
    def detection_mode(self, value: FaceDetectionMode) -> None: ...
    @_property
    def activatable_class_id(self) -> str: ...
    @_property
    def properties(self) -> typing.Optional[winrt.windows.foundation.collections.IPropertySet]: ...

@typing.final
class FaceDetectionEffectFrame(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FaceDetectionEffectFrame: ...
    def close(self) -> None: ...
    @_property
    def detected_faces(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.media.faceanalysis.DetectedFace]]: ...
    @_property
    def system_relative_time(self) -> typing.Optional[typing.Optional[datetime.timedelta]]: ...
    @system_relative_time.setter
    def system_relative_time(self, value: typing.Optional[typing.Optional[datetime.timedelta]]) -> None: ...
    @_property
    def relative_time(self) -> typing.Optional[typing.Optional[datetime.timedelta]]: ...
    @relative_time.setter
    def relative_time(self, value: typing.Optional[typing.Optional[datetime.timedelta]]) -> None: ...
    @_property
    def is_discontinuous(self) -> bool: ...
    @is_discontinuous.setter
    def is_discontinuous(self, value: bool) -> None: ...
    @_property
    def duration(self) -> typing.Optional[typing.Optional[datetime.timedelta]]: ...
    @duration.setter
    def duration(self, value: typing.Optional[typing.Optional[datetime.timedelta]]) -> None: ...
    @_property
    def extended_properties(self) -> typing.Optional[winrt.windows.foundation.collections.IPropertySet]: ...
    @_property
    def is_read_only(self) -> bool: ...
    @_property
    def type(self) -> str: ...

@typing.final
class HighDynamicRangeControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HighDynamicRangeControl: ...
    @_property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> None: ...

@typing.final
class HighDynamicRangeOutput(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HighDynamicRangeOutput: ...
    @_property
    def certainty(self) -> winrt.system.Double: ...
    @_property
    def frame_controllers(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.media.devices.core.FrameController]]: ...

@typing.final
class ImageCue(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ImageCue: ...
    def __new__(cls: typing.Type[ImageCue]) -> ImageCue:...
    @_property
    def software_bitmap(self) -> typing.Optional[winrt.windows.graphics.imaging.SoftwareBitmap]: ...
    @software_bitmap.setter
    def software_bitmap(self, value: typing.Optional[winrt.windows.graphics.imaging.SoftwareBitmap]) -> None: ...
    @_property
    def position(self) -> TimedTextPoint: ...
    @position.setter
    def position(self, value: TimedTextPoint) -> None: ...
    @_property
    def extent(self) -> TimedTextSize: ...
    @extent.setter
    def extent(self, value: TimedTextSize) -> None: ...
    @_property
    def start_time(self) -> datetime.timedelta: ...
    @start_time.setter
    def start_time(self, value: datetime.timedelta) -> None: ...
    @_property
    def id(self) -> str: ...
    @id.setter
    def id(self, value: str) -> None: ...
    @_property
    def duration(self) -> datetime.timedelta: ...
    @duration.setter
    def duration(self, value: datetime.timedelta) -> None: ...

@typing.final
class InitializeMediaStreamSourceRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InitializeMediaStreamSourceRequestedEventArgs: ...
    def get_deferral(self) -> typing.Optional[winrt.windows.foundation.Deferral]: ...
    @_property
    def random_access_stream(self) -> typing.Optional[winrt.windows.storage.streams.IRandomAccessStream]: ...
    @_property
    def source(self) -> typing.Optional[MediaStreamSource]: ...

@typing.final
class LowLightFusion_Static(type):
    def fuse_async(cls, frame_set: typing.Iterable[winrt.windows.graphics.imaging.SoftwareBitmap], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[LowLightFusionResult, winrt.system.Double]: ...
    @_property
    def max_supported_frame_count(cls) -> winrt.system.Int32: ...
    @_property
    def supported_bitmap_pixel_formats(cls) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.graphics.imaging.BitmapPixelFormat]]: ...

@typing.final
class LowLightFusion(winrt.system.Object, metaclass=LowLightFusion_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LowLightFusion: ...

@typing.final
class LowLightFusionResult(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LowLightFusionResult: ...
    def close(self) -> None: ...
    @_property
    def frame(self) -> typing.Optional[winrt.windows.graphics.imaging.SoftwareBitmap]: ...

@typing.final
class MediaBinder(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaBinder: ...
    def __new__(cls: typing.Type[MediaBinder]) -> MediaBinder:...
    def add_binding(self, handler: winrt.windows.foundation.TypedEventHandler[MediaBinder, MediaBindingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_binding(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def token(self) -> str: ...
    @token.setter
    def token(self, value: str) -> None: ...
    @_property
    def source(self) -> typing.Optional[MediaSource]: ...

@typing.final
class MediaBindingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaBindingEventArgs: ...
    def get_deferral(self) -> typing.Optional[winrt.windows.foundation.Deferral]: ...
    def set_adaptive_media_source(self, media_source: typing.Optional[winrt.windows.media.streaming.adaptive.AdaptiveMediaSource], /) -> None: ...
    def set_download_operation(self, download_operation: typing.Optional[winrt.windows.networking.backgroundtransfer.DownloadOperation], /) -> None: ...
    def set_storage_file(self, file: typing.Optional[winrt.windows.storage.IStorageFile], /) -> None: ...
    def set_stream(self, stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStream], content_type: str, /) -> None: ...
    def set_stream_reference(self, stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference], content_type: str, /) -> None: ...
    def set_uri(self, uri: typing.Optional[winrt.windows.foundation.Uri], /) -> None: ...
    def add_canceled(self, handler: winrt.windows.foundation.TypedEventHandler[MediaBindingEventArgs, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_canceled(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def media_binder(self) -> typing.Optional[MediaBinder]: ...

@typing.final
class MediaCueEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaCueEventArgs: ...
    @_property
    def cue(self) -> typing.Optional[IMediaCue]: ...

@typing.final
class MediaSource_Static(type):
    def create_from_adaptive_media_source(cls, media_source: typing.Optional[winrt.windows.media.streaming.adaptive.AdaptiveMediaSource], /) -> typing.Optional[MediaSource]: ...
    def create_from_download_operation(cls, download_operation: typing.Optional[winrt.windows.networking.backgroundtransfer.DownloadOperation], /) -> typing.Optional[MediaSource]: ...
    def create_from_i_media_source(cls, media_source: typing.Optional[IMediaSource], /) -> typing.Optional[MediaSource]: ...
    def create_from_media_binder(cls, binder: typing.Optional[MediaBinder], /) -> typing.Optional[MediaSource]: ...
    def create_from_media_frame_source(cls, frame_source: typing.Optional[winrt.windows.media.capture.frames.MediaFrameSource], /) -> typing.Optional[MediaSource]: ...
    def create_from_media_stream_source(cls, media_source: typing.Optional[MediaStreamSource], /) -> typing.Optional[MediaSource]: ...
    def create_from_mse_stream_source(cls, media_source: typing.Optional[MseStreamSource], /) -> typing.Optional[MediaSource]: ...
    def create_from_storage_file(cls, file: typing.Optional[winrt.windows.storage.IStorageFile], /) -> typing.Optional[MediaSource]: ...
    def create_from_stream(cls, stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStream], content_type: str, /) -> typing.Optional[MediaSource]: ...
    def create_from_stream_reference(cls, stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference], content_type: str, /) -> typing.Optional[MediaSource]: ...
    def create_from_uri(cls, uri: typing.Optional[winrt.windows.foundation.Uri], /) -> typing.Optional[MediaSource]: ...

@typing.final
class MediaSource(winrt.system.Object, metaclass=MediaSource_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaSource: ...
    def close(self) -> None: ...
    def open_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def reset(self) -> None: ...
    def add_open_operation_completed(self, handler: winrt.windows.foundation.TypedEventHandler[MediaSource, MediaSourceOpenOperationCompletedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_open_operation_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_state_changed(self, handler: winrt.windows.foundation.TypedEventHandler[MediaSource, MediaSourceStateChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_state_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def custom_properties(self) -> typing.Optional[winrt.windows.foundation.collections.ValueSet]: ...
    @_property
    def duration(self) -> typing.Optional[typing.Optional[datetime.timedelta]]: ...
    @_property
    def external_timed_metadata_tracks(self) -> typing.Optional[winrt.windows.foundation.collections.IObservableVector[TimedMetadataTrack]]: ...
    @_property
    def external_timed_text_sources(self) -> typing.Optional[winrt.windows.foundation.collections.IObservableVector[TimedTextSource]]: ...
    @_property
    def is_open(self) -> bool: ...
    @_property
    def state(self) -> MediaSourceState: ...
    @_property
    def adaptive_media_source(self) -> typing.Optional[winrt.windows.media.streaming.adaptive.AdaptiveMediaSource]: ...
    @_property
    def media_stream_source(self) -> typing.Optional[MediaStreamSource]: ...
    @_property
    def mse_stream_source(self) -> typing.Optional[MseStreamSource]: ...
    @_property
    def uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @_property
    def download_operation(self) -> typing.Optional[winrt.windows.networking.backgroundtransfer.DownloadOperation]: ...

@typing.final
class MediaSourceAppServiceConnection(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaSourceAppServiceConnection: ...
    def __new__(cls: typing.Type[MediaSourceAppServiceConnection], app_service_connection: typing.Optional[winrt.windows.applicationmodel.appservice.AppServiceConnection]) -> MediaSourceAppServiceConnection:...
    def start(self) -> None: ...
    def add_initialize_media_stream_source_requested(self, handler: winrt.windows.foundation.TypedEventHandler[MediaSourceAppServiceConnection, InitializeMediaStreamSourceRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_initialize_media_stream_source_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

@typing.final
class MediaSourceError(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaSourceError: ...
    @_property
    def extended_error(self) -> winrt.windows.foundation.HResult: ...

@typing.final
class MediaSourceOpenOperationCompletedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaSourceOpenOperationCompletedEventArgs: ...
    @_property
    def error(self) -> typing.Optional[MediaSourceError]: ...

@typing.final
class MediaSourceStateChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaSourceStateChangedEventArgs: ...
    @_property
    def new_state(self) -> MediaSourceState: ...
    @_property
    def old_state(self) -> MediaSourceState: ...

@typing.final
class MediaStreamSample_Static(type):
    def create_from_buffer(cls, buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], timestamp: datetime.timedelta, /) -> typing.Optional[MediaStreamSample]: ...
    def create_from_direct3_d11_surface(cls, surface: typing.Optional[winrt.windows.graphics.directx.direct3d11.IDirect3DSurface], timestamp: datetime.timedelta, /) -> typing.Optional[MediaStreamSample]: ...
    def create_from_stream_async(cls, stream: typing.Optional[winrt.windows.storage.streams.IInputStream], count: winrt.system.UInt32, timestamp: datetime.timedelta, /) -> winrt.windows.foundation.IAsyncOperation[MediaStreamSample]: ...

@typing.final
class MediaStreamSample(winrt.system.Object, metaclass=MediaStreamSample_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaStreamSample: ...
    def add_processed(self, handler: winrt.windows.foundation.TypedEventHandler[MediaStreamSample, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_processed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def key_frame(self) -> bool: ...
    @key_frame.setter
    def key_frame(self, value: bool) -> None: ...
    @_property
    def duration(self) -> datetime.timedelta: ...
    @duration.setter
    def duration(self, value: datetime.timedelta) -> None: ...
    @_property
    def discontinuous(self) -> bool: ...
    @discontinuous.setter
    def discontinuous(self, value: bool) -> None: ...
    @_property
    def decode_timestamp(self) -> datetime.timedelta: ...
    @decode_timestamp.setter
    def decode_timestamp(self, value: datetime.timedelta) -> None: ...
    @_property
    def buffer(self) -> typing.Optional[winrt.windows.storage.streams.Buffer]: ...
    @_property
    def extended_properties(self) -> typing.Optional[MediaStreamSamplePropertySet]: ...
    @_property
    def protection(self) -> typing.Optional[MediaStreamSampleProtectionProperties]: ...
    @_property
    def timestamp(self) -> datetime.timedelta: ...
    @_property
    def direct3_d11_surface(self) -> typing.Optional[winrt.windows.graphics.directx.direct3d11.IDirect3DSurface]: ...

@typing.final
class MediaStreamSamplePropertySet(winrt.system.Object, winrt._winrt.MutableMapping[_uuid.UUID, winrt.system.Object]):
    def __len__(self) -> int: ...
    def __iter__(self) -> typing.Iterator[_uuid.UUID]: ...
    def __contains__(self, key: object) -> bool:...
    def __setitem__(self, key: _uuid.UUID, value: winrt.system.Object) -> None: ...
    def __getitem__(self, key: _uuid.UUID) -> winrt.system.Object: ...
    def __delitem__(self, key: _uuid.UUID) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaStreamSamplePropertySet: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[winrt.windows.foundation.collections.IKeyValuePair[_uuid.UUID, winrt.system.Object]]]: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[_uuid.UUID, winrt.system.Object]]: ...
    def has_key(self, key: _uuid.UUID, /) -> bool: ...
    def insert(self, key: _uuid.UUID, value: typing.Optional[winrt.system.Object], /) -> bool: ...
    def lookup(self, key: _uuid.UUID, /) -> typing.Optional[winrt.system.Object]: ...
    def remove(self, key: _uuid.UUID, /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class MediaStreamSampleProtectionProperties(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaStreamSampleProtectionProperties: ...
    def get_initialization_vector(self) -> winrt.system.Array[winrt.system.UInt8]: ...
    def get_key_identifier(self) -> winrt.system.Array[winrt.system.UInt8]: ...
    def get_sub_sample_mapping(self) -> winrt.system.Array[winrt.system.UInt8]: ...
    def set_initialization_vector(self, value: winrt.system.Array[winrt.system.UInt8], /) -> None: ...
    def set_key_identifier(self, value: winrt.system.Array[winrt.system.UInt8], /) -> None: ...
    def set_sub_sample_mapping(self, value: winrt.system.Array[winrt.system.UInt8], /) -> None: ...

@typing.final
class MediaStreamSource(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaStreamSource: ...
    @typing.overload
    def __new__(cls: typing.Type[MediaStreamSource], descriptor: typing.Optional[IMediaStreamDescriptor]) -> MediaStreamSource:...
    @typing.overload
    def __new__(cls: typing.Type[MediaStreamSource], descriptor: typing.Optional[IMediaStreamDescriptor], descriptor2: typing.Optional[IMediaStreamDescriptor]) -> MediaStreamSource:...
    def add_protection_key(self, stream_descriptor: typing.Optional[IMediaStreamDescriptor], key_identifier: winrt.system.Array[winrt.system.UInt8], license_data: winrt.system.Array[winrt.system.UInt8], /) -> None: ...
    def add_stream_descriptor(self, descriptor: typing.Optional[IMediaStreamDescriptor], /) -> None: ...
    def notify_error(self, error_status: MediaStreamSourceErrorStatus, /) -> None: ...
    def set_buffered_range(self, start_offset: datetime.timedelta, end_offset: datetime.timedelta, /) -> None: ...
    def add_closed(self, handler: winrt.windows.foundation.TypedEventHandler[MediaStreamSource, MediaStreamSourceClosedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_paused(self, handler: winrt.windows.foundation.TypedEventHandler[MediaStreamSource, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_paused(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_sample_requested(self, handler: winrt.windows.foundation.TypedEventHandler[MediaStreamSource, MediaStreamSourceSampleRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_sample_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_starting(self, handler: winrt.windows.foundation.TypedEventHandler[MediaStreamSource, MediaStreamSourceStartingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_starting(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_switch_streams_requested(self, handler: winrt.windows.foundation.TypedEventHandler[MediaStreamSource, MediaStreamSourceSwitchStreamsRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_switch_streams_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_sample_rendered(self, handler: winrt.windows.foundation.TypedEventHandler[MediaStreamSource, MediaStreamSourceSampleRenderedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_sample_rendered(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def thumbnail(self) -> typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference]: ...
    @thumbnail.setter
    def thumbnail(self, value: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference]) -> None: ...
    @_property
    def media_protection_manager(self) -> typing.Optional[winrt.windows.media.protection.MediaProtectionManager]: ...
    @media_protection_manager.setter
    def media_protection_manager(self, value: typing.Optional[winrt.windows.media.protection.MediaProtectionManager]) -> None: ...
    @_property
    def duration(self) -> datetime.timedelta: ...
    @duration.setter
    def duration(self, value: datetime.timedelta) -> None: ...
    @_property
    def can_seek(self) -> bool: ...
    @can_seek.setter
    def can_seek(self, value: bool) -> None: ...
    @_property
    def buffer_time(self) -> datetime.timedelta: ...
    @buffer_time.setter
    def buffer_time(self, value: datetime.timedelta) -> None: ...
    @_property
    def music_properties(self) -> typing.Optional[winrt.windows.storage.fileproperties.MusicProperties]: ...
    @_property
    def video_properties(self) -> typing.Optional[winrt.windows.storage.fileproperties.VideoProperties]: ...
    @_property
    def max_supported_playback_rate(self) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    @max_supported_playback_rate.setter
    def max_supported_playback_rate(self, value: typing.Optional[typing.Optional[winrt.system.Double]]) -> None: ...
    @_property
    def is_live(self) -> bool: ...
    @is_live.setter
    def is_live(self, value: bool) -> None: ...

@typing.final
class MediaStreamSourceClosedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaStreamSourceClosedEventArgs: ...
    @_property
    def request(self) -> typing.Optional[MediaStreamSourceClosedRequest]: ...

@typing.final
class MediaStreamSourceClosedRequest(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaStreamSourceClosedRequest: ...
    @_property
    def reason(self) -> MediaStreamSourceClosedReason: ...

@typing.final
class MediaStreamSourceSampleRenderedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaStreamSourceSampleRenderedEventArgs: ...
    @_property
    def sample_lag(self) -> datetime.timedelta: ...

@typing.final
class MediaStreamSourceSampleRequest(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaStreamSourceSampleRequest: ...
    def get_deferral(self) -> typing.Optional[MediaStreamSourceSampleRequestDeferral]: ...
    def report_sample_progress(self, progress: winrt.system.UInt32, /) -> None: ...
    @_property
    def sample(self) -> typing.Optional[MediaStreamSample]: ...
    @sample.setter
    def sample(self, value: typing.Optional[MediaStreamSample]) -> None: ...
    @_property
    def stream_descriptor(self) -> typing.Optional[IMediaStreamDescriptor]: ...

@typing.final
class MediaStreamSourceSampleRequestDeferral(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaStreamSourceSampleRequestDeferral: ...
    def complete(self) -> None: ...

@typing.final
class MediaStreamSourceSampleRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaStreamSourceSampleRequestedEventArgs: ...
    @_property
    def request(self) -> typing.Optional[MediaStreamSourceSampleRequest]: ...

@typing.final
class MediaStreamSourceStartingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaStreamSourceStartingEventArgs: ...
    @_property
    def request(self) -> typing.Optional[MediaStreamSourceStartingRequest]: ...

@typing.final
class MediaStreamSourceStartingRequest(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaStreamSourceStartingRequest: ...
    def get_deferral(self) -> typing.Optional[MediaStreamSourceStartingRequestDeferral]: ...
    def set_actual_start_position(self, position: datetime.timedelta, /) -> None: ...
    @_property
    def start_position(self) -> typing.Optional[typing.Optional[datetime.timedelta]]: ...

@typing.final
class MediaStreamSourceStartingRequestDeferral(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaStreamSourceStartingRequestDeferral: ...
    def complete(self) -> None: ...

@typing.final
class MediaStreamSourceSwitchStreamsRequest(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaStreamSourceSwitchStreamsRequest: ...
    def get_deferral(self) -> typing.Optional[MediaStreamSourceSwitchStreamsRequestDeferral]: ...
    @_property
    def new_stream_descriptor(self) -> typing.Optional[IMediaStreamDescriptor]: ...
    @_property
    def old_stream_descriptor(self) -> typing.Optional[IMediaStreamDescriptor]: ...

@typing.final
class MediaStreamSourceSwitchStreamsRequestDeferral(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaStreamSourceSwitchStreamsRequestDeferral: ...
    def complete(self) -> None: ...

@typing.final
class MediaStreamSourceSwitchStreamsRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaStreamSourceSwitchStreamsRequestedEventArgs: ...
    @_property
    def request(self) -> typing.Optional[MediaStreamSourceSwitchStreamsRequest]: ...

@typing.final
class MseSourceBuffer(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MseSourceBuffer: ...
    def abort(self) -> None: ...
    def append_buffer(self, buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> None: ...
    @typing.overload
    def append_stream(self, stream: typing.Optional[winrt.windows.storage.streams.IInputStream], /) -> None: ...
    @typing.overload
    def append_stream(self, stream: typing.Optional[winrt.windows.storage.streams.IInputStream], max_size: winrt.system.UInt64, /) -> None: ...
    def remove(self, start: datetime.timedelta, end: typing.Optional[datetime.timedelta], /) -> None: ...
    def add_aborted(self, handler: winrt.windows.foundation.TypedEventHandler[MseSourceBuffer, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_aborted(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_error_occurred(self, handler: winrt.windows.foundation.TypedEventHandler[MseSourceBuffer, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_error_occurred(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_update_ended(self, handler: winrt.windows.foundation.TypedEventHandler[MseSourceBuffer, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_update_ended(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_update_starting(self, handler: winrt.windows.foundation.TypedEventHandler[MseSourceBuffer, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_update_starting(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_updated(self, handler: winrt.windows.foundation.TypedEventHandler[MseSourceBuffer, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_updated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def timestamp_offset(self) -> datetime.timedelta: ...
    @timestamp_offset.setter
    def timestamp_offset(self, value: datetime.timedelta) -> None: ...
    @_property
    def mode(self) -> MseAppendMode: ...
    @mode.setter
    def mode(self, value: MseAppendMode) -> None: ...
    @_property
    def append_window_start(self) -> datetime.timedelta: ...
    @append_window_start.setter
    def append_window_start(self, value: datetime.timedelta) -> None: ...
    @_property
    def append_window_end(self) -> typing.Optional[typing.Optional[datetime.timedelta]]: ...
    @append_window_end.setter
    def append_window_end(self, value: typing.Optional[typing.Optional[datetime.timedelta]]) -> None: ...
    @_property
    def buffered(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MseTimeRange]]: ...
    @_property
    def is_updating(self) -> bool: ...

@typing.final
class MseSourceBufferList(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MseSourceBufferList: ...
    def add_source_buffer_added(self, handler: winrt.windows.foundation.TypedEventHandler[MseSourceBufferList, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_source_buffer_added(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_source_buffer_removed(self, handler: winrt.windows.foundation.TypedEventHandler[MseSourceBufferList, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_source_buffer_removed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def buffers(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MseSourceBuffer]]: ...

@typing.final
class MseStreamSource_Static(type):
    def is_content_type_supported(cls, content_type: str, /) -> bool: ...

@typing.final
class MseStreamSource(winrt.system.Object, metaclass=MseStreamSource_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MseStreamSource: ...
    def __new__(cls: typing.Type[MseStreamSource]) -> MseStreamSource:...
    def add_source_buffer(self, mime_type: str, /) -> typing.Optional[MseSourceBuffer]: ...
    def end_of_stream(self, status: MseEndOfStreamStatus, /) -> None: ...
    def remove_source_buffer(self, buffer: typing.Optional[MseSourceBuffer], /) -> None: ...
    def add_closed(self, handler: winrt.windows.foundation.TypedEventHandler[MseStreamSource, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_ended(self, handler: winrt.windows.foundation.TypedEventHandler[MseStreamSource, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_ended(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_opened(self, handler: winrt.windows.foundation.TypedEventHandler[MseStreamSource, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_opened(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def duration(self) -> typing.Optional[typing.Optional[datetime.timedelta]]: ...
    @duration.setter
    def duration(self, value: typing.Optional[typing.Optional[datetime.timedelta]]) -> None: ...
    @_property
    def active_source_buffers(self) -> typing.Optional[MseSourceBufferList]: ...
    @_property
    def ready_state(self) -> MseReadyState: ...
    @_property
    def source_buffers(self) -> typing.Optional[MseSourceBufferList]: ...
    @_property
    def live_seekable_range(self) -> typing.Optional[typing.Optional[MseTimeRange]]: ...
    @live_seekable_range.setter
    def live_seekable_range(self, value: typing.Optional[typing.Optional[MseTimeRange]]) -> None: ...

@typing.final
class SceneAnalysisEffect(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SceneAnalysisEffect: ...
    def set_properties(self, configuration: typing.Optional[winrt.windows.foundation.collections.IPropertySet], /) -> None: ...
    def add_scene_analyzed(self, handler: winrt.windows.foundation.TypedEventHandler[SceneAnalysisEffect, SceneAnalyzedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_scene_analyzed(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def desired_analysis_interval(self) -> datetime.timedelta: ...
    @desired_analysis_interval.setter
    def desired_analysis_interval(self, value: datetime.timedelta) -> None: ...
    @_property
    def high_dynamic_range_analyzer(self) -> typing.Optional[HighDynamicRangeControl]: ...

@typing.final
class SceneAnalysisEffectDefinition(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SceneAnalysisEffectDefinition: ...
    def __new__(cls: typing.Type[SceneAnalysisEffectDefinition]) -> SceneAnalysisEffectDefinition:...
    @_property
    def activatable_class_id(self) -> str: ...
    @_property
    def properties(self) -> typing.Optional[winrt.windows.foundation.collections.IPropertySet]: ...

@typing.final
class SceneAnalysisEffectFrame(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SceneAnalysisEffectFrame: ...
    def close(self) -> None: ...
    @_property
    def frame_control_values(self) -> typing.Optional[winrt.windows.media.capture.CapturedFrameControlValues]: ...
    @_property
    def high_dynamic_range(self) -> typing.Optional[HighDynamicRangeOutput]: ...
    @_property
    def analysis_recommendation(self) -> SceneAnalysisRecommendation: ...
    @_property
    def system_relative_time(self) -> typing.Optional[typing.Optional[datetime.timedelta]]: ...
    @system_relative_time.setter
    def system_relative_time(self, value: typing.Optional[typing.Optional[datetime.timedelta]]) -> None: ...
    @_property
    def relative_time(self) -> typing.Optional[typing.Optional[datetime.timedelta]]: ...
    @relative_time.setter
    def relative_time(self, value: typing.Optional[typing.Optional[datetime.timedelta]]) -> None: ...
    @_property
    def is_discontinuous(self) -> bool: ...
    @is_discontinuous.setter
    def is_discontinuous(self, value: bool) -> None: ...
    @_property
    def duration(self) -> typing.Optional[typing.Optional[datetime.timedelta]]: ...
    @duration.setter
    def duration(self, value: typing.Optional[typing.Optional[datetime.timedelta]]) -> None: ...
    @_property
    def extended_properties(self) -> typing.Optional[winrt.windows.foundation.collections.IPropertySet]: ...
    @_property
    def is_read_only(self) -> bool: ...
    @_property
    def type(self) -> str: ...

@typing.final
class SceneAnalyzedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SceneAnalyzedEventArgs: ...
    @_property
    def result_frame(self) -> typing.Optional[SceneAnalysisEffectFrame]: ...

@typing.final
class SpeechCue(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpeechCue: ...
    def __new__(cls: typing.Type[SpeechCue]) -> SpeechCue:...
    @_property
    def start_time(self) -> datetime.timedelta: ...
    @start_time.setter
    def start_time(self, value: datetime.timedelta) -> None: ...
    @_property
    def id(self) -> str: ...
    @id.setter
    def id(self, value: str) -> None: ...
    @_property
    def duration(self) -> datetime.timedelta: ...
    @duration.setter
    def duration(self, value: datetime.timedelta) -> None: ...
    @_property
    def text(self) -> str: ...
    @text.setter
    def text(self, value: str) -> None: ...
    @_property
    def start_position_in_input(self) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...
    @start_position_in_input.setter
    def start_position_in_input(self, value: typing.Optional[typing.Optional[winrt.system.Int32]]) -> None: ...
    @_property
    def end_position_in_input(self) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...
    @end_position_in_input.setter
    def end_position_in_input(self, value: typing.Optional[typing.Optional[winrt.system.Int32]]) -> None: ...

@typing.final
class TimedMetadataStreamDescriptor(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimedMetadataStreamDescriptor: ...
    def __new__(cls: typing.Type[TimedMetadataStreamDescriptor], encoding_properties: typing.Optional[winrt.windows.media.mediaproperties.TimedMetadataEncodingProperties]) -> TimedMetadataStreamDescriptor:...
    def copy(self) -> typing.Optional[TimedMetadataStreamDescriptor]: ...
    @_property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> None: ...
    @_property
    def language(self) -> str: ...
    @language.setter
    def language(self, value: str) -> None: ...
    @_property
    def is_selected(self) -> bool: ...
    @_property
    def label(self) -> str: ...
    @label.setter
    def label(self, value: str) -> None: ...
    @_property
    def encoding_properties(self) -> typing.Optional[winrt.windows.media.mediaproperties.TimedMetadataEncodingProperties]: ...

@typing.final
class TimedMetadataTrack(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimedMetadataTrack: ...
    def __new__(cls: typing.Type[TimedMetadataTrack], id: str, language: str, kind: TimedMetadataKind) -> TimedMetadataTrack:...
    def add_cue(self, cue: typing.Optional[IMediaCue], /) -> None: ...
    def remove_cue(self, cue: typing.Optional[IMediaCue], /) -> None: ...
    def add_cue_entered(self, handler: winrt.windows.foundation.TypedEventHandler[TimedMetadataTrack, MediaCueEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_cue_entered(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_cue_exited(self, handler: winrt.windows.foundation.TypedEventHandler[TimedMetadataTrack, MediaCueEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_cue_exited(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_track_failed(self, handler: winrt.windows.foundation.TypedEventHandler[TimedMetadataTrack, TimedMetadataTrackFailedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_track_failed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def label(self) -> str: ...
    @label.setter
    def label(self, value: str) -> None: ...
    @_property
    def id(self) -> str: ...
    @_property
    def language(self) -> str: ...
    @_property
    def track_kind(self) -> MediaTrackKind: ...
    @_property
    def active_cues(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[IMediaCue]]: ...
    @_property
    def cues(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[IMediaCue]]: ...
    @_property
    def dispatch_type(self) -> str: ...
    @_property
    def timed_metadata_kind(self) -> TimedMetadataKind: ...
    @_property
    def name(self) -> str: ...
    @_property
    def playback_item(self) -> typing.Optional[winrt.windows.media.playback.MediaPlaybackItem]: ...

@typing.final
class TimedMetadataTrackError(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimedMetadataTrackError: ...
    @_property
    def error_code(self) -> TimedMetadataTrackErrorCode: ...
    @_property
    def extended_error(self) -> winrt.windows.foundation.HResult: ...

@typing.final
class TimedMetadataTrackFailedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimedMetadataTrackFailedEventArgs: ...
    @_property
    def error(self) -> typing.Optional[TimedMetadataTrackError]: ...

@typing.final
class TimedTextBouten(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimedTextBouten: ...
    @_property
    def type(self) -> TimedTextBoutenType: ...
    @type.setter
    def type(self, value: TimedTextBoutenType) -> None: ...
    @_property
    def position(self) -> TimedTextBoutenPosition: ...
    @position.setter
    def position(self, value: TimedTextBoutenPosition) -> None: ...
    @_property
    def color(self) -> winrt.windows.ui.Color: ...
    @color.setter
    def color(self, value: winrt.windows.ui.Color) -> None: ...

@typing.final
class TimedTextCue(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimedTextCue: ...
    def __new__(cls: typing.Type[TimedTextCue]) -> TimedTextCue:...
    @_property
    def start_time(self) -> datetime.timedelta: ...
    @start_time.setter
    def start_time(self, value: datetime.timedelta) -> None: ...
    @_property
    def id(self) -> str: ...
    @id.setter
    def id(self, value: str) -> None: ...
    @_property
    def duration(self) -> datetime.timedelta: ...
    @duration.setter
    def duration(self, value: datetime.timedelta) -> None: ...
    @_property
    def cue_style(self) -> typing.Optional[TimedTextStyle]: ...
    @cue_style.setter
    def cue_style(self, value: typing.Optional[TimedTextStyle]) -> None: ...
    @_property
    def cue_region(self) -> typing.Optional[TimedTextRegion]: ...
    @cue_region.setter
    def cue_region(self, value: typing.Optional[TimedTextRegion]) -> None: ...
    @_property
    def lines(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[TimedTextLine]]: ...

@typing.final
class TimedTextLine(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimedTextLine: ...
    def __new__(cls: typing.Type[TimedTextLine]) -> TimedTextLine:...
    @_property
    def text(self) -> str: ...
    @text.setter
    def text(self, value: str) -> None: ...
    @_property
    def subformats(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[TimedTextSubformat]]: ...

@typing.final
class TimedTextRegion(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimedTextRegion: ...
    def __new__(cls: typing.Type[TimedTextRegion]) -> TimedTextRegion:...
    @_property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> None: ...
    @_property
    def line_height(self) -> TimedTextDouble: ...
    @line_height.setter
    def line_height(self, value: TimedTextDouble) -> None: ...
    @_property
    def is_overflow_clipped(self) -> bool: ...
    @is_overflow_clipped.setter
    def is_overflow_clipped(self, value: bool) -> None: ...
    @_property
    def extent(self) -> TimedTextSize: ...
    @extent.setter
    def extent(self, value: TimedTextSize) -> None: ...
    @_property
    def display_alignment(self) -> TimedTextDisplayAlignment: ...
    @display_alignment.setter
    def display_alignment(self, value: TimedTextDisplayAlignment) -> None: ...
    @_property
    def padding(self) -> TimedTextPadding: ...
    @padding.setter
    def padding(self, value: TimedTextPadding) -> None: ...
    @_property
    def background(self) -> winrt.windows.ui.Color: ...
    @background.setter
    def background(self, value: winrt.windows.ui.Color) -> None: ...
    @_property
    def z_index(self) -> winrt.system.Int32: ...
    @z_index.setter
    def z_index(self, value: winrt.system.Int32) -> None: ...
    @_property
    def writing_mode(self) -> TimedTextWritingMode: ...
    @writing_mode.setter
    def writing_mode(self, value: TimedTextWritingMode) -> None: ...
    @_property
    def text_wrapping(self) -> TimedTextWrapping: ...
    @text_wrapping.setter
    def text_wrapping(self, value: TimedTextWrapping) -> None: ...
    @_property
    def scroll_mode(self) -> TimedTextScrollMode: ...
    @scroll_mode.setter
    def scroll_mode(self, value: TimedTextScrollMode) -> None: ...
    @_property
    def position(self) -> TimedTextPoint: ...
    @position.setter
    def position(self, value: TimedTextPoint) -> None: ...

@typing.final
class TimedTextRuby(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimedTextRuby: ...
    @_property
    def text(self) -> str: ...
    @text.setter
    def text(self, value: str) -> None: ...
    @_property
    def reserve(self) -> TimedTextRubyReserve: ...
    @reserve.setter
    def reserve(self, value: TimedTextRubyReserve) -> None: ...
    @_property
    def position(self) -> TimedTextRubyPosition: ...
    @position.setter
    def position(self, value: TimedTextRubyPosition) -> None: ...
    @_property
    def align(self) -> TimedTextRubyAlign: ...
    @align.setter
    def align(self, value: TimedTextRubyAlign) -> None: ...

@typing.final
class TimedTextSource_Static(type):
    @typing.overload
    def create_from_stream(cls, stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStream], /) -> typing.Optional[TimedTextSource]: ...
    @typing.overload
    def create_from_stream(cls, stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStream], default_language: str, /) -> typing.Optional[TimedTextSource]: ...
    @typing.overload
    def create_from_stream_with_index(cls, stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStream], index_stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStream], /) -> typing.Optional[TimedTextSource]: ...
    @typing.overload
    def create_from_stream_with_index(cls, stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStream], index_stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStream], default_language: str, /) -> typing.Optional[TimedTextSource]: ...
    @typing.overload
    def create_from_uri(cls, uri: typing.Optional[winrt.windows.foundation.Uri], /) -> typing.Optional[TimedTextSource]: ...
    @typing.overload
    def create_from_uri(cls, uri: typing.Optional[winrt.windows.foundation.Uri], default_language: str, /) -> typing.Optional[TimedTextSource]: ...
    @typing.overload
    def create_from_uri_with_index(cls, uri: typing.Optional[winrt.windows.foundation.Uri], index_uri: typing.Optional[winrt.windows.foundation.Uri], /) -> typing.Optional[TimedTextSource]: ...
    @typing.overload
    def create_from_uri_with_index(cls, uri: typing.Optional[winrt.windows.foundation.Uri], index_uri: typing.Optional[winrt.windows.foundation.Uri], default_language: str, /) -> typing.Optional[TimedTextSource]: ...

@typing.final
class TimedTextSource(winrt.system.Object, metaclass=TimedTextSource_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimedTextSource: ...
    def add_resolved(self, handler: winrt.windows.foundation.TypedEventHandler[TimedTextSource, TimedTextSourceResolveResultEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_resolved(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

@typing.final
class TimedTextSourceResolveResultEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimedTextSourceResolveResultEventArgs: ...
    @_property
    def error(self) -> typing.Optional[TimedMetadataTrackError]: ...
    @_property
    def tracks(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[TimedMetadataTrack]]: ...

@typing.final
class TimedTextStyle(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimedTextStyle: ...
    def __new__(cls: typing.Type[TimedTextStyle]) -> TimedTextStyle:...
    @_property
    def line_alignment(self) -> TimedTextLineAlignment: ...
    @line_alignment.setter
    def line_alignment(self, value: TimedTextLineAlignment) -> None: ...
    @_property
    def is_background_always_shown(self) -> bool: ...
    @is_background_always_shown.setter
    def is_background_always_shown(self, value: bool) -> None: ...
    @_property
    def outline_color(self) -> winrt.windows.ui.Color: ...
    @outline_color.setter
    def outline_color(self, value: winrt.windows.ui.Color) -> None: ...
    @_property
    def foreground(self) -> winrt.windows.ui.Color: ...
    @foreground.setter
    def foreground(self, value: winrt.windows.ui.Color) -> None: ...
    @_property
    def font_weight(self) -> TimedTextWeight: ...
    @font_weight.setter
    def font_weight(self, value: TimedTextWeight) -> None: ...
    @_property
    def background(self) -> winrt.windows.ui.Color: ...
    @background.setter
    def background(self, value: winrt.windows.ui.Color) -> None: ...
    @_property
    def font_size(self) -> TimedTextDouble: ...
    @font_size.setter
    def font_size(self, value: TimedTextDouble) -> None: ...
    @_property
    def font_family(self) -> str: ...
    @font_family.setter
    def font_family(self, value: str) -> None: ...
    @_property
    def flow_direction(self) -> TimedTextFlowDirection: ...
    @flow_direction.setter
    def flow_direction(self, value: TimedTextFlowDirection) -> None: ...
    @_property
    def outline_thickness(self) -> TimedTextDouble: ...
    @outline_thickness.setter
    def outline_thickness(self, value: TimedTextDouble) -> None: ...
    @_property
    def outline_radius(self) -> TimedTextDouble: ...
    @outline_radius.setter
    def outline_radius(self, value: TimedTextDouble) -> None: ...
    @_property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> None: ...
    @_property
    def is_underline_enabled(self) -> bool: ...
    @is_underline_enabled.setter
    def is_underline_enabled(self, value: bool) -> None: ...
    @_property
    def is_overline_enabled(self) -> bool: ...
    @is_overline_enabled.setter
    def is_overline_enabled(self, value: bool) -> None: ...
    @_property
    def is_line_through_enabled(self) -> bool: ...
    @is_line_through_enabled.setter
    def is_line_through_enabled(self, value: bool) -> None: ...
    @_property
    def font_style(self) -> TimedTextFontStyle: ...
    @font_style.setter
    def font_style(self, value: TimedTextFontStyle) -> None: ...
    @_property
    def is_text_combined(self) -> bool: ...
    @is_text_combined.setter
    def is_text_combined(self, value: bool) -> None: ...
    @_property
    def font_angle_in_degrees(self) -> winrt.system.Double: ...
    @font_angle_in_degrees.setter
    def font_angle_in_degrees(self, value: winrt.system.Double) -> None: ...
    @_property
    def bouten(self) -> typing.Optional[TimedTextBouten]: ...
    @_property
    def ruby(self) -> typing.Optional[TimedTextRuby]: ...

@typing.final
class TimedTextSubformat(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimedTextSubformat: ...
    def __new__(cls: typing.Type[TimedTextSubformat]) -> TimedTextSubformat:...
    @_property
    def subformat_style(self) -> typing.Optional[TimedTextStyle]: ...
    @subformat_style.setter
    def subformat_style(self, value: typing.Optional[TimedTextStyle]) -> None: ...
    @_property
    def start_index(self) -> winrt.system.Int32: ...
    @start_index.setter
    def start_index(self, value: winrt.system.Int32) -> None: ...
    @_property
    def length(self) -> winrt.system.Int32: ...
    @length.setter
    def length(self, value: winrt.system.Int32) -> None: ...

@typing.final
class VideoStabilizationEffect(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VideoStabilizationEffect: ...
    def get_recommended_stream_configuration(self, controller: typing.Optional[winrt.windows.media.devices.VideoDeviceController], desired_properties: typing.Optional[winrt.windows.media.mediaproperties.VideoEncodingProperties], /) -> typing.Optional[winrt.windows.media.capture.VideoStreamConfiguration]: ...
    def set_properties(self, configuration: typing.Optional[winrt.windows.foundation.collections.IPropertySet], /) -> None: ...
    def add_enabled_changed(self, handler: winrt.windows.foundation.TypedEventHandler[VideoStabilizationEffect, VideoStabilizationEffectEnabledChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_enabled_changed(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> None: ...

@typing.final
class VideoStabilizationEffectDefinition(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VideoStabilizationEffectDefinition: ...
    def __new__(cls: typing.Type[VideoStabilizationEffectDefinition]) -> VideoStabilizationEffectDefinition:...
    @_property
    def activatable_class_id(self) -> str: ...
    @_property
    def properties(self) -> typing.Optional[winrt.windows.foundation.collections.IPropertySet]: ...

@typing.final
class VideoStabilizationEffectEnabledChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VideoStabilizationEffectEnabledChangedEventArgs: ...
    @_property
    def reason(self) -> VideoStabilizationEffectEnabledChangedReason: ...

@typing.final
class VideoStreamDescriptor(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VideoStreamDescriptor: ...
    def __new__(cls: typing.Type[VideoStreamDescriptor], encoding_properties: typing.Optional[winrt.windows.media.mediaproperties.VideoEncodingProperties]) -> VideoStreamDescriptor:...
    def copy(self) -> typing.Optional[VideoStreamDescriptor]: ...
    @_property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> None: ...
    @_property
    def language(self) -> str: ...
    @language.setter
    def language(self, value: str) -> None: ...
    @_property
    def is_selected(self) -> bool: ...
    @_property
    def label(self) -> str: ...
    @label.setter
    def label(self, value: str) -> None: ...
    @_property
    def encoding_properties(self) -> typing.Optional[winrt.windows.media.mediaproperties.VideoEncodingProperties]: ...

@typing.final
class VideoTrack(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VideoTrack: ...
    def get_encoding_properties(self) -> typing.Optional[winrt.windows.media.mediaproperties.VideoEncodingProperties]: ...
    def add_open_failed(self, handler: winrt.windows.foundation.TypedEventHandler[VideoTrack, VideoTrackOpenFailedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_open_failed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def label(self) -> str: ...
    @label.setter
    def label(self, value: str) -> None: ...
    @_property
    def id(self) -> str: ...
    @_property
    def language(self) -> str: ...
    @_property
    def track_kind(self) -> MediaTrackKind: ...
    @_property
    def name(self) -> str: ...
    @_property
    def playback_item(self) -> typing.Optional[winrt.windows.media.playback.MediaPlaybackItem]: ...
    @_property
    def support_info(self) -> typing.Optional[VideoTrackSupportInfo]: ...

@typing.final
class VideoTrackOpenFailedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VideoTrackOpenFailedEventArgs: ...
    @_property
    def extended_error(self) -> winrt.windows.foundation.HResult: ...

@typing.final
class VideoTrackSupportInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VideoTrackSupportInfo: ...
    @_property
    def decoder_status(self) -> MediaDecoderStatus: ...
    @_property
    def media_source_status(self) -> MediaSourceStatus: ...

@typing.final
class IMediaCue(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IMediaCue: ...
    @_property
    def duration(self) -> datetime.timedelta: ...
    @duration.setter
    def duration(self, value: datetime.timedelta) -> None: ...
    @_property
    def id(self) -> str: ...
    @id.setter
    def id(self, value: str) -> None: ...
    @_property
    def start_time(self) -> datetime.timedelta: ...
    @start_time.setter
    def start_time(self, value: datetime.timedelta) -> None: ...

@typing.final
class IMediaSource(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IMediaSource: ...

@typing.final
class IMediaStreamDescriptor(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IMediaStreamDescriptor: ...
    @_property
    def is_selected(self) -> bool: ...
    @_property
    def language(self) -> str: ...
    @language.setter
    def language(self, value: str) -> None: ...
    @_property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> None: ...

@typing.final
class IMediaStreamDescriptor2(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IMediaStreamDescriptor2: ...
    @_property
    def label(self) -> str: ...
    @label.setter
    def label(self, value: str) -> None: ...
    @_property
    def is_selected(self) -> bool: ...
    @_property
    def language(self) -> str: ...
    @language.setter
    def language(self, value: str) -> None: ...
    @_property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> None: ...

@typing.final
class IMediaTrack(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IMediaTrack: ...
    @_property
    def id(self) -> str: ...
    @_property
    def label(self) -> str: ...
    @label.setter
    def label(self, value: str) -> None: ...
    @_property
    def language(self) -> str: ...
    @_property
    def track_kind(self) -> MediaTrackKind: ...

@typing.final
class ISingleSelectMediaTrackList(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ISingleSelectMediaTrackList: ...
    def add_selected_index_changed(self, handler: winrt.windows.foundation.TypedEventHandler[ISingleSelectMediaTrackList, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_selected_index_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def selected_index(self) -> winrt.system.Int32: ...
    @selected_index.setter
    def selected_index(self, value: winrt.system.Int32) -> None: ...

@typing.final
class ITimedMetadataTrackProvider(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ITimedMetadataTrackProvider: ...
    @_property
    def timed_metadata_tracks(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[TimedMetadataTrack]]: ...

