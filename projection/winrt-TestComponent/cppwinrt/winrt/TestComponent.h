// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.240111.5

#pragma once
#ifndef WINRT_TestComponent_H
#define WINRT_TestComponent_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.240111.5"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.240111.5"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
#include "winrt/impl/TestComponent.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_TestComponent_ITestRunnerStatics<D>::TestProducer(winrt::TestComponent::ITests const& callee) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITestRunnerStatics)->TestProducer(*(void**)(&callee)));
    }
    template <typename D> auto consume_TestComponent_ITestRunnerStatics<D>::TestConsumer(winrt::TestComponent::TestHandler const& caller) const
    {
        uint32_t result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITestRunnerStatics)->TestConsumer(*(void**)(&caller), &result));
        return result;
    }
    template <typename D> auto consume_TestComponent_ITestRunnerStatics<D>::TestSelf() const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITestRunnerStatics)->TestSelf());
    }
    template <typename D> auto consume_TestComponent_ITestRunnerStatics<D>::MakeTests() const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITestRunnerStatics)->MakeTests(&result));
        return winrt::TestComponent::ITests{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITestRunnerStatics<D>::CreateInt32Vector() const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITestRunnerStatics)->CreateInt32Vector(&result));
        return winrt::Windows::Foundation::Collections::IVector<int32_t>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITestRunnerStatics<D>::CreateStringVector() const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITestRunnerStatics)->CreateStringVector(&result));
        return winrt::Windows::Foundation::Collections::IVector<hstring>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITestRunnerStatics<D>::CreateStringableVector() const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITestRunnerStatics)->CreateStringableVector(&result));
        return winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::IStringable>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Percentage() const
    {
        uint32_t value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->get_Percentage(&value));
        return value;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Simple() const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Simple());
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param1(bool a, bool& b) const
    {
        bool result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Param1(a, &b, &result));
        return result;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param2(uint8_t a, uint8_t& b) const
    {
        uint8_t result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Param2(a, &b, &result));
        return result;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param3(uint16_t a, uint16_t& b) const
    {
        uint16_t result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Param3(a, &b, &result));
        return result;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param4(uint32_t a, uint32_t& b) const
    {
        uint32_t result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Param4(a, &b, &result));
        return result;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param5(uint64_t a, uint64_t& b) const
    {
        uint64_t result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Param5(a, &b, &result));
        return result;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param6(int16_t a, int16_t& b) const
    {
        int16_t result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Param6(a, &b, &result));
        return result;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param7(int32_t a, int32_t& b) const
    {
        int32_t result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Param7(a, &b, &result));
        return result;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param8(int64_t a, int64_t& b) const
    {
        int64_t result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Param8(a, &b, &result));
        return result;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param9(float a, float& b) const
    {
        float result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Param9(a, &b, &result));
        return result;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param10(double a, double& b) const
    {
        double result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Param10(a, &b, &result));
        return result;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param11(char16_t a, char16_t& b) const
    {
        char16_t result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Param11(a, &b, &result));
        return result;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param12(param::hstring const& a, hstring& b) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Param12(*(void**)(&a), impl::bind_out(b), &result));
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param13(winrt::TestComponent::Blittable const& a, winrt::TestComponent::Blittable const& b, winrt::TestComponent::Blittable& c) const
    {
        winrt::TestComponent::Blittable result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Param13(impl::bind_in(a), impl::bind_in(b), impl::bind_out(c), put_abi(result)));
        return result;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param14(winrt::TestComponent::NonBlittable const& a, winrt::TestComponent::NonBlittable const& b, winrt::TestComponent::NonBlittable& c) const
    {
        winrt::TestComponent::NonBlittable result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Param14(impl::bind_in(a), impl::bind_in(b), impl::bind_out(c), put_abi(result)));
        return result;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param15(winrt::TestComponent::Nested const& a, winrt::TestComponent::Nested const& b, winrt::TestComponent::Nested& c) const
    {
        winrt::TestComponent::Nested result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Param15(impl::bind_in(a), impl::bind_in(b), impl::bind_out(c), put_abi(result)));
        return result;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param1Call(winrt::TestComponent::Param1Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Param1Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param2Call(winrt::TestComponent::Param2Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Param2Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param3Call(winrt::TestComponent::Param3Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Param3Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param4Call(winrt::TestComponent::Param4Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Param4Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param5Call(winrt::TestComponent::Param5Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Param5Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param6Call(winrt::TestComponent::Param6Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Param6Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param7Call(winrt::TestComponent::Param7Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Param7Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param8Call(winrt::TestComponent::Param8Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Param8Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param9Call(winrt::TestComponent::Param9Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Param9Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param10Call(winrt::TestComponent::Param10Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Param10Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param11Call(winrt::TestComponent::Param11Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Param11Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param12Call(winrt::TestComponent::Param12Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Param12Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param13Call(winrt::TestComponent::Param13Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Param13Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param14Call(winrt::TestComponent::Param14Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Param14Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param15Call(winrt::TestComponent::Param15Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Param15Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array1(array_view<bool const> a, array_view<bool> b, com_array<bool>& c) const
    {
        uint32_t result_impl_size{};
        bool* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Array1(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<bool>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array2(array_view<uint8_t const> a, array_view<uint8_t> b, com_array<uint8_t>& c) const
    {
        uint32_t result_impl_size{};
        uint8_t* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Array2(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<uint8_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array3(array_view<uint16_t const> a, array_view<uint16_t> b, com_array<uint16_t>& c) const
    {
        uint32_t result_impl_size{};
        uint16_t* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Array3(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<uint16_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array4(array_view<uint32_t const> a, array_view<uint32_t> b, com_array<uint32_t>& c) const
    {
        uint32_t result_impl_size{};
        uint32_t* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Array4(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<uint32_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array5(array_view<uint64_t const> a, array_view<uint64_t> b, com_array<uint64_t>& c) const
    {
        uint32_t result_impl_size{};
        uint64_t* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Array5(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<uint64_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array6(array_view<int16_t const> a, array_view<int16_t> b, com_array<int16_t>& c) const
    {
        uint32_t result_impl_size{};
        int16_t* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Array6(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<int16_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array7(array_view<int32_t const> a, array_view<int32_t> b, com_array<int32_t>& c) const
    {
        uint32_t result_impl_size{};
        int32_t* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Array7(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<int32_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array8(array_view<int64_t const> a, array_view<int64_t> b, com_array<int64_t>& c) const
    {
        uint32_t result_impl_size{};
        int64_t* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Array8(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<int64_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array9(array_view<float const> a, array_view<float> b, com_array<float>& c) const
    {
        uint32_t result_impl_size{};
        float* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Array9(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<float>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array10(array_view<double const> a, array_view<double> b, com_array<double>& c) const
    {
        uint32_t result_impl_size{};
        double* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Array10(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<double>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array11(array_view<char16_t const> a, array_view<char16_t> b, com_array<char16_t>& c) const
    {
        uint32_t result_impl_size{};
        char16_t* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Array11(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<char16_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array12(array_view<hstring const> a, array_view<hstring> b, com_array<hstring>& c) const
    {
        uint32_t result_impl_size{};
        void** result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Array12(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<hstring>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array13(array_view<winrt::TestComponent::Blittable const> a, array_view<winrt::TestComponent::Blittable> b, com_array<winrt::TestComponent::Blittable>& c) const
    {
        uint32_t result_impl_size{};
        struct struct_TestComponent_Blittable* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Array13(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<winrt::TestComponent::Blittable>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array14(array_view<winrt::TestComponent::NonBlittable const> a, array_view<winrt::TestComponent::NonBlittable> b, com_array<winrt::TestComponent::NonBlittable>& c) const
    {
        uint32_t result_impl_size{};
        struct struct_TestComponent_NonBlittable* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Array14(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<winrt::TestComponent::NonBlittable>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array15(array_view<winrt::TestComponent::Nested const> a, array_view<winrt::TestComponent::Nested> b, com_array<winrt::TestComponent::Nested>& c) const
    {
        uint32_t result_impl_size{};
        struct struct_TestComponent_Nested* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Array15(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<winrt::TestComponent::Nested>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array1Call(winrt::TestComponent::Array1Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Array1Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array2Call(winrt::TestComponent::Array2Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Array2Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array3Call(winrt::TestComponent::Array3Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Array3Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array4Call(winrt::TestComponent::Array4Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Array4Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array5Call(winrt::TestComponent::Array5Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Array5Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array6Call(winrt::TestComponent::Array6Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Array6Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array7Call(winrt::TestComponent::Array7Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Array7Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array8Call(winrt::TestComponent::Array8Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Array8Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array9Call(winrt::TestComponent::Array9Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Array9Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array10Call(winrt::TestComponent::Array10Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Array10Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array11Call(winrt::TestComponent::Array11Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Array11Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array12Call(winrt::TestComponent::Array12Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Array12Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array13Call(winrt::TestComponent::Array13Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Array13Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array14Call(winrt::TestComponent::Array14Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Array14Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array15Call(winrt::TestComponent::Array15Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Array15Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Collection1(param::iterable<hstring> const& a, winrt::Windows::Foundation::Collections::IIterable<hstring>& b) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Collection1(*(void**)(&a), impl::bind_out(b), &result));
        return winrt::Windows::Foundation::Collections::IIterable<hstring>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Collection2(param::iterable<winrt::Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>> const& a, winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>>& b) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Collection2(*(void**)(&a), impl::bind_out(b), &result));
        return winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Collection3(param::map<hstring, hstring> const& a, winrt::Windows::Foundation::Collections::IMap<hstring, hstring>& b) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Collection3(*(void**)(&a), impl::bind_out(b), &result));
        return winrt::Windows::Foundation::Collections::IMap<hstring, hstring>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Collection4(param::map_view<hstring, hstring> const& a, winrt::Windows::Foundation::Collections::IMapView<hstring, hstring>& b) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Collection4(*(void**)(&a), impl::bind_out(b), &result));
        return winrt::Windows::Foundation::Collections::IMapView<hstring, hstring>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Collection5(param::vector<hstring> const& a, winrt::Windows::Foundation::Collections::IVector<hstring>& b) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Collection5(*(void**)(&a), impl::bind_out(b), &result));
        return winrt::Windows::Foundation::Collections::IVector<hstring>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Collection6(param::vector_view<hstring> const& a, winrt::Windows::Foundation::Collections::IVectorView<hstring>& b) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Collection6(*(void**)(&a), impl::bind_out(b), &result));
        return winrt::Windows::Foundation::Collections::IVectorView<hstring>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Collection1Call(winrt::TestComponent::Collection1Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Collection1Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Collection2Call(winrt::TestComponent::Collection2Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Collection2Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Collection3Call(winrt::TestComponent::Collection3Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Collection3Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Collection4Call(winrt::TestComponent::Collection4Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Collection4Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Collection5Call(winrt::TestComponent::Collection5Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Collection5Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Collection6Call(winrt::TestComponent::Collection6Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Collection6Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Async1(winrt::Windows::Foundation::IAsyncAction const& suspend, bool fail) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Async1(*(void**)(&suspend), fail, &operation));
        return winrt::Windows::Foundation::IAsyncAction{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Async2(winrt::Windows::Foundation::IAsyncAction const& suspend, bool fail, int32_t progress) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Async2(*(void**)(&suspend), fail, progress, &operation));
        return winrt::Windows::Foundation::IAsyncActionWithProgress<int32_t>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Async3(winrt::Windows::Foundation::IAsyncAction const& suspend, bool fail, int32_t result) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Async3(*(void**)(&suspend), fail, result, &operation));
        return winrt::Windows::Foundation::IAsyncOperation<int32_t>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Async4(winrt::Windows::Foundation::IAsyncAction const& suspend, bool fail, int32_t result, int32_t progress) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Async4(*(void**)(&suspend), fail, result, progress, &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<int32_t, int32_t>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Async1Call(winrt::TestComponent::Async1Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Async1Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Async2Call(winrt::TestComponent::Async2Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Async2Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Async3Call(winrt::TestComponent::Async3Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Async3Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Async4Call(winrt::TestComponent::Async4Handler const& handler) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Async4Call(*(void**)(&handler)));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Event1(winrt::Windows::Foundation::EventHandler<int32_t> const& handler) const
    {
        winrt::event_token token{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->add_Event1(*(void**)(&handler), put_abi(token)));
        return token;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Event1(auto_revoke_t, winrt::Windows::Foundation::EventHandler<int32_t> const& handler) const
    {
        return impl::make_event_revoker<D, Event1_revoker>(this, Event1(handler));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Event1(winrt::event_token const& token) const noexcept
    {
        WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->remove_Event1(impl::bind_in(token));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Event2(winrt::Windows::Foundation::TypedEventHandler<winrt::TestComponent::ITests, int32_t> const& handler) const
    {
        winrt::event_token token{};
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->add_Event2(*(void**)(&handler), put_abi(token)));
        return token;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Event2(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::TestComponent::ITests, int32_t> const& handler) const
    {
        return impl::make_event_revoker<D, Event2_revoker>(this, Event2(handler));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Event2(winrt::event_token const& token) const noexcept
    {
        WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->remove_Event2(impl::bind_in(token));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Event1Call(int32_t value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Event1Call(value));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Event2Call(int32_t value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::TestComponent::ITests)->Event2Call(value));
    }
    template <typename H> struct delegate<winrt::TestComponent::Array10Handler, H> final : implements_delegate<winrt::TestComponent::Array10Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Array10Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint32_t __aSize, double* a, uint32_t __bSize, double* b, uint32_t* __cSize, double** c, uint32_t* __resultSize, double** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            std::tie(*__resultSize, *result) = detach_abi((*this)(array_view<double const>(reinterpret_cast<double const *>(a), reinterpret_cast<double const *>(a) + __aSize), array_view<double>(reinterpret_cast<double*>(b), reinterpret_cast<double*>(b) + __bSize), detach_abi<double>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Array11Handler, H> final : implements_delegate<winrt::TestComponent::Array11Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Array11Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint32_t __aSize, char16_t* a, uint32_t __bSize, char16_t* b, uint32_t* __cSize, char16_t** c, uint32_t* __resultSize, char16_t** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            std::tie(*__resultSize, *result) = detach_abi((*this)(array_view<char16_t const>(reinterpret_cast<char16_t const *>(a), reinterpret_cast<char16_t const *>(a) + __aSize), array_view<char16_t>(reinterpret_cast<char16_t*>(b), reinterpret_cast<char16_t*>(b) + __bSize), detach_abi<char16_t>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Array12Handler, H> final : implements_delegate<winrt::TestComponent::Array12Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Array12Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint32_t __aSize, void** a, uint32_t __bSize, void** b, uint32_t* __cSize, void*** c, uint32_t* __resultSize, void*** result) noexcept final try
        {
            zero_abi<hstring>(b, __bSize);
            clear_abi(c);
            clear_abi(result);
            std::tie(*__resultSize, *result) = detach_abi((*this)(array_view<hstring const>(reinterpret_cast<hstring const *>(a), reinterpret_cast<hstring const *>(a) + __aSize), array_view<hstring>(reinterpret_cast<hstring*>(b), reinterpret_cast<hstring*>(b) + __bSize), detach_abi<hstring>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Array13Handler, H> final : implements_delegate<winrt::TestComponent::Array13Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Array13Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint32_t __aSize, struct struct_TestComponent_Blittable* a, uint32_t __bSize, struct struct_TestComponent_Blittable* b, uint32_t* __cSize, struct struct_TestComponent_Blittable** c, uint32_t* __resultSize, struct struct_TestComponent_Blittable** result) noexcept final try
        {
            zero_abi<winrt::TestComponent::Blittable>(b, __bSize);
            clear_abi(c);
            clear_abi(result);
            std::tie(*__resultSize, *result) = detach_abi((*this)(array_view<winrt::TestComponent::Blittable const>(reinterpret_cast<winrt::TestComponent::Blittable const *>(a), reinterpret_cast<winrt::TestComponent::Blittable const *>(a) + __aSize), array_view<winrt::TestComponent::Blittable>(reinterpret_cast<winrt::TestComponent::Blittable*>(b), reinterpret_cast<winrt::TestComponent::Blittable*>(b) + __bSize), detach_abi<winrt::TestComponent::Blittable>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Array14Handler, H> final : implements_delegate<winrt::TestComponent::Array14Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Array14Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint32_t __aSize, struct struct_TestComponent_NonBlittable* a, uint32_t __bSize, struct struct_TestComponent_NonBlittable* b, uint32_t* __cSize, struct struct_TestComponent_NonBlittable** c, uint32_t* __resultSize, struct struct_TestComponent_NonBlittable** result) noexcept final try
        {
            zero_abi<winrt::TestComponent::NonBlittable>(b, __bSize);
            clear_abi(c);
            clear_abi(result);
            std::tie(*__resultSize, *result) = detach_abi((*this)(array_view<winrt::TestComponent::NonBlittable const>(reinterpret_cast<winrt::TestComponent::NonBlittable const *>(a), reinterpret_cast<winrt::TestComponent::NonBlittable const *>(a) + __aSize), array_view<winrt::TestComponent::NonBlittable>(reinterpret_cast<winrt::TestComponent::NonBlittable*>(b), reinterpret_cast<winrt::TestComponent::NonBlittable*>(b) + __bSize), detach_abi<winrt::TestComponent::NonBlittable>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Array15Handler, H> final : implements_delegate<winrt::TestComponent::Array15Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Array15Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint32_t __aSize, struct struct_TestComponent_Nested* a, uint32_t __bSize, struct struct_TestComponent_Nested* b, uint32_t* __cSize, struct struct_TestComponent_Nested** c, uint32_t* __resultSize, struct struct_TestComponent_Nested** result) noexcept final try
        {
            zero_abi<winrt::TestComponent::Nested>(b, __bSize);
            clear_abi(c);
            clear_abi(result);
            std::tie(*__resultSize, *result) = detach_abi((*this)(array_view<winrt::TestComponent::Nested const>(reinterpret_cast<winrt::TestComponent::Nested const *>(a), reinterpret_cast<winrt::TestComponent::Nested const *>(a) + __aSize), array_view<winrt::TestComponent::Nested>(reinterpret_cast<winrt::TestComponent::Nested*>(b), reinterpret_cast<winrt::TestComponent::Nested*>(b) + __bSize), detach_abi<winrt::TestComponent::Nested>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Array1Handler, H> final : implements_delegate<winrt::TestComponent::Array1Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Array1Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint32_t __aSize, bool* a, uint32_t __bSize, bool* b, uint32_t* __cSize, bool** c, uint32_t* __resultSize, bool** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            std::tie(*__resultSize, *result) = detach_abi((*this)(array_view<bool const>(reinterpret_cast<bool const *>(a), reinterpret_cast<bool const *>(a) + __aSize), array_view<bool>(reinterpret_cast<bool*>(b), reinterpret_cast<bool*>(b) + __bSize), detach_abi<bool>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Array2Handler, H> final : implements_delegate<winrt::TestComponent::Array2Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Array2Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint32_t __aSize, uint8_t* a, uint32_t __bSize, uint8_t* b, uint32_t* __cSize, uint8_t** c, uint32_t* __resultSize, uint8_t** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            std::tie(*__resultSize, *result) = detach_abi((*this)(array_view<uint8_t const>(reinterpret_cast<uint8_t const *>(a), reinterpret_cast<uint8_t const *>(a) + __aSize), array_view<uint8_t>(reinterpret_cast<uint8_t*>(b), reinterpret_cast<uint8_t*>(b) + __bSize), detach_abi<uint8_t>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Array3Handler, H> final : implements_delegate<winrt::TestComponent::Array3Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Array3Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint32_t __aSize, uint16_t* a, uint32_t __bSize, uint16_t* b, uint32_t* __cSize, uint16_t** c, uint32_t* __resultSize, uint16_t** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            std::tie(*__resultSize, *result) = detach_abi((*this)(array_view<uint16_t const>(reinterpret_cast<uint16_t const *>(a), reinterpret_cast<uint16_t const *>(a) + __aSize), array_view<uint16_t>(reinterpret_cast<uint16_t*>(b), reinterpret_cast<uint16_t*>(b) + __bSize), detach_abi<uint16_t>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Array4Handler, H> final : implements_delegate<winrt::TestComponent::Array4Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Array4Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint32_t __aSize, uint32_t* a, uint32_t __bSize, uint32_t* b, uint32_t* __cSize, uint32_t** c, uint32_t* __resultSize, uint32_t** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            std::tie(*__resultSize, *result) = detach_abi((*this)(array_view<uint32_t const>(reinterpret_cast<uint32_t const *>(a), reinterpret_cast<uint32_t const *>(a) + __aSize), array_view<uint32_t>(reinterpret_cast<uint32_t*>(b), reinterpret_cast<uint32_t*>(b) + __bSize), detach_abi<uint32_t>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Array5Handler, H> final : implements_delegate<winrt::TestComponent::Array5Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Array5Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint32_t __aSize, uint64_t* a, uint32_t __bSize, uint64_t* b, uint32_t* __cSize, uint64_t** c, uint32_t* __resultSize, uint64_t** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            std::tie(*__resultSize, *result) = detach_abi((*this)(array_view<uint64_t const>(reinterpret_cast<uint64_t const *>(a), reinterpret_cast<uint64_t const *>(a) + __aSize), array_view<uint64_t>(reinterpret_cast<uint64_t*>(b), reinterpret_cast<uint64_t*>(b) + __bSize), detach_abi<uint64_t>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Array6Handler, H> final : implements_delegate<winrt::TestComponent::Array6Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Array6Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint32_t __aSize, int16_t* a, uint32_t __bSize, int16_t* b, uint32_t* __cSize, int16_t** c, uint32_t* __resultSize, int16_t** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            std::tie(*__resultSize, *result) = detach_abi((*this)(array_view<int16_t const>(reinterpret_cast<int16_t const *>(a), reinterpret_cast<int16_t const *>(a) + __aSize), array_view<int16_t>(reinterpret_cast<int16_t*>(b), reinterpret_cast<int16_t*>(b) + __bSize), detach_abi<int16_t>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Array7Handler, H> final : implements_delegate<winrt::TestComponent::Array7Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Array7Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint32_t __aSize, int32_t* a, uint32_t __bSize, int32_t* b, uint32_t* __cSize, int32_t** c, uint32_t* __resultSize, int32_t** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            std::tie(*__resultSize, *result) = detach_abi((*this)(array_view<int32_t const>(reinterpret_cast<int32_t const *>(a), reinterpret_cast<int32_t const *>(a) + __aSize), array_view<int32_t>(reinterpret_cast<int32_t*>(b), reinterpret_cast<int32_t*>(b) + __bSize), detach_abi<int32_t>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Array8Handler, H> final : implements_delegate<winrt::TestComponent::Array8Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Array8Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint32_t __aSize, int64_t* a, uint32_t __bSize, int64_t* b, uint32_t* __cSize, int64_t** c, uint32_t* __resultSize, int64_t** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            std::tie(*__resultSize, *result) = detach_abi((*this)(array_view<int64_t const>(reinterpret_cast<int64_t const *>(a), reinterpret_cast<int64_t const *>(a) + __aSize), array_view<int64_t>(reinterpret_cast<int64_t*>(b), reinterpret_cast<int64_t*>(b) + __bSize), detach_abi<int64_t>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Array9Handler, H> final : implements_delegate<winrt::TestComponent::Array9Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Array9Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint32_t __aSize, float* a, uint32_t __bSize, float* b, uint32_t* __cSize, float** c, uint32_t* __resultSize, float** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            std::tie(*__resultSize, *result) = detach_abi((*this)(array_view<float const>(reinterpret_cast<float const *>(a), reinterpret_cast<float const *>(a) + __aSize), array_view<float>(reinterpret_cast<float*>(b), reinterpret_cast<float*>(b) + __bSize), detach_abi<float>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Async1Handler, H> final : implements_delegate<winrt::TestComponent::Async1Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Async1Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* suspend, bool fail, void** operation) noexcept final try
        {
            clear_abi(operation);
            *operation = detach_from<winrt::Windows::Foundation::IAsyncAction>((*this)(*reinterpret_cast<winrt::Windows::Foundation::IAsyncAction const*>(&suspend), fail));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Async2Handler, H> final : implements_delegate<winrt::TestComponent::Async2Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Async2Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* suspend, bool fail, int32_t progress, void** operation) noexcept final try
        {
            clear_abi(operation);
            *operation = detach_from<winrt::Windows::Foundation::IAsyncActionWithProgress<int32_t>>((*this)(*reinterpret_cast<winrt::Windows::Foundation::IAsyncAction const*>(&suspend), fail, progress));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Async3Handler, H> final : implements_delegate<winrt::TestComponent::Async3Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Async3Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* suspend, bool fail, int32_t result, void** operation) noexcept final try
        {
            clear_abi(operation);
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<int32_t>>((*this)(*reinterpret_cast<winrt::Windows::Foundation::IAsyncAction const*>(&suspend), fail, result));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Async4Handler, H> final : implements_delegate<winrt::TestComponent::Async4Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Async4Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* suspend, bool fail, int32_t result, int32_t progress, void** operation) noexcept final try
        {
            clear_abi(operation);
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<int32_t, int32_t>>((*this)(*reinterpret_cast<winrt::Windows::Foundation::IAsyncAction const*>(&suspend), fail, result, progress));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Collection1Handler, H> final : implements_delegate<winrt::TestComponent::Collection1Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Collection1Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* a, void** b, void** result) noexcept final try
        {
            clear_abi(b);
            clear_abi(result);
            *result = detach_from<winrt::Windows::Foundation::Collections::IIterable<hstring>>((*this)(*reinterpret_cast<winrt::Windows::Foundation::Collections::IIterable<hstring> const*>(&a), *reinterpret_cast<winrt::Windows::Foundation::Collections::IIterable<hstring>*>(b)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Collection2Handler, H> final : implements_delegate<winrt::TestComponent::Collection2Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Collection2Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* a, void** b, void** result) noexcept final try
        {
            clear_abi(b);
            clear_abi(result);
            *result = detach_from<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>>>((*this)(*reinterpret_cast<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>> const*>(&a), *reinterpret_cast<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>>*>(b)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Collection3Handler, H> final : implements_delegate<winrt::TestComponent::Collection3Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Collection3Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* a, void** b, void** result) noexcept final try
        {
            clear_abi(b);
            clear_abi(result);
            *result = detach_from<winrt::Windows::Foundation::Collections::IMap<hstring, hstring>>((*this)(*reinterpret_cast<winrt::Windows::Foundation::Collections::IMap<hstring, hstring> const*>(&a), *reinterpret_cast<winrt::Windows::Foundation::Collections::IMap<hstring, hstring>*>(b)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Collection4Handler, H> final : implements_delegate<winrt::TestComponent::Collection4Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Collection4Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* a, void** b, void** result) noexcept final try
        {
            clear_abi(b);
            clear_abi(result);
            *result = detach_from<winrt::Windows::Foundation::Collections::IMapView<hstring, hstring>>((*this)(*reinterpret_cast<winrt::Windows::Foundation::Collections::IMapView<hstring, hstring> const*>(&a), *reinterpret_cast<winrt::Windows::Foundation::Collections::IMapView<hstring, hstring>*>(b)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Collection5Handler, H> final : implements_delegate<winrt::TestComponent::Collection5Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Collection5Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* a, void** b, void** result) noexcept final try
        {
            clear_abi(b);
            clear_abi(result);
            *result = detach_from<winrt::Windows::Foundation::Collections::IVector<hstring>>((*this)(*reinterpret_cast<winrt::Windows::Foundation::Collections::IVector<hstring> const*>(&a), *reinterpret_cast<winrt::Windows::Foundation::Collections::IVector<hstring>*>(b)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Collection6Handler, H> final : implements_delegate<winrt::TestComponent::Collection6Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Collection6Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* a, void** b, void** result) noexcept final try
        {
            clear_abi(b);
            clear_abi(result);
            *result = detach_from<winrt::Windows::Foundation::Collections::IVectorView<hstring>>((*this)(*reinterpret_cast<winrt::Windows::Foundation::Collections::IVectorView<hstring> const*>(&a), *reinterpret_cast<winrt::Windows::Foundation::Collections::IVectorView<hstring>*>(b)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Param10Handler, H> final : implements_delegate<winrt::TestComponent::Param10Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Param10Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(double a, double* b, double* result) noexcept final try
        {
            *result = detach_from<double>((*this)(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Param11Handler, H> final : implements_delegate<winrt::TestComponent::Param11Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Param11Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(char16_t a, char16_t* b, char16_t* result) noexcept final try
        {
            *result = detach_from<char16_t>((*this)(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Param12Handler, H> final : implements_delegate<winrt::TestComponent::Param12Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Param12Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* a, void** b, void** result) noexcept final try
        {
            clear_abi(b);
            clear_abi(result);
            *result = detach_from<hstring>((*this)(*reinterpret_cast<hstring const*>(&a), *reinterpret_cast<hstring*>(b)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Param13Handler, H> final : implements_delegate<winrt::TestComponent::Param13Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Param13Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(struct struct_TestComponent_Blittable a, struct struct_TestComponent_Blittable const& b, struct struct_TestComponent_Blittable* c, struct struct_TestComponent_Blittable* result) noexcept final try
        {
            zero_abi<winrt::TestComponent::Blittable>(c);
            zero_abi<winrt::TestComponent::Blittable>(result);
            *result = detach_from<winrt::TestComponent::Blittable>((*this)(*reinterpret_cast<winrt::TestComponent::Blittable const*>(&a), *reinterpret_cast<winrt::TestComponent::Blittable const*>(&b), *reinterpret_cast<winrt::TestComponent::Blittable*>(c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Param14Handler, H> final : implements_delegate<winrt::TestComponent::Param14Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Param14Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(struct struct_TestComponent_NonBlittable a, struct struct_TestComponent_NonBlittable const& b, struct struct_TestComponent_NonBlittable* c, struct struct_TestComponent_NonBlittable* result) noexcept final try
        {
            zero_abi<winrt::TestComponent::NonBlittable>(c);
            zero_abi<winrt::TestComponent::NonBlittable>(result);
            *result = detach_from<winrt::TestComponent::NonBlittable>((*this)(*reinterpret_cast<winrt::TestComponent::NonBlittable const*>(&a), *reinterpret_cast<winrt::TestComponent::NonBlittable const*>(&b), *reinterpret_cast<winrt::TestComponent::NonBlittable*>(c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Param15Handler, H> final : implements_delegate<winrt::TestComponent::Param15Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Param15Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(struct struct_TestComponent_Nested a, struct struct_TestComponent_Nested const& b, struct struct_TestComponent_Nested* c, struct struct_TestComponent_Nested* result) noexcept final try
        {
            zero_abi<winrt::TestComponent::Nested>(c);
            zero_abi<winrt::TestComponent::Nested>(result);
            *result = detach_from<winrt::TestComponent::Nested>((*this)(*reinterpret_cast<winrt::TestComponent::Nested const*>(&a), *reinterpret_cast<winrt::TestComponent::Nested const*>(&b), *reinterpret_cast<winrt::TestComponent::Nested*>(c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Param1Handler, H> final : implements_delegate<winrt::TestComponent::Param1Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Param1Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(bool a, bool* b, bool* result) noexcept final try
        {
            *result = detach_from<bool>((*this)(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Param2Handler, H> final : implements_delegate<winrt::TestComponent::Param2Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Param2Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint8_t a, uint8_t* b, uint8_t* result) noexcept final try
        {
            *result = detach_from<uint8_t>((*this)(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Param3Handler, H> final : implements_delegate<winrt::TestComponent::Param3Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Param3Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint16_t a, uint16_t* b, uint16_t* result) noexcept final try
        {
            *result = detach_from<uint16_t>((*this)(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Param4Handler, H> final : implements_delegate<winrt::TestComponent::Param4Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Param4Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint32_t a, uint32_t* b, uint32_t* result) noexcept final try
        {
            *result = detach_from<uint32_t>((*this)(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Param5Handler, H> final : implements_delegate<winrt::TestComponent::Param5Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Param5Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint64_t a, uint64_t* b, uint64_t* result) noexcept final try
        {
            *result = detach_from<uint64_t>((*this)(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Param6Handler, H> final : implements_delegate<winrt::TestComponent::Param6Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Param6Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(int16_t a, int16_t* b, int16_t* result) noexcept final try
        {
            *result = detach_from<int16_t>((*this)(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Param7Handler, H> final : implements_delegate<winrt::TestComponent::Param7Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Param7Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(int32_t a, int32_t* b, int32_t* result) noexcept final try
        {
            *result = detach_from<int32_t>((*this)(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Param8Handler, H> final : implements_delegate<winrt::TestComponent::Param8Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Param8Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(int64_t a, int64_t* b, int64_t* result) noexcept final try
        {
            *result = detach_from<int64_t>((*this)(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Param9Handler, H> final : implements_delegate<winrt::TestComponent::Param9Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Param9Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(float a, float* b, float* result) noexcept final try
        {
            *result = detach_from<float>((*this)(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::TestHandler, H> final : implements_delegate<winrt::TestComponent::TestHandler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::TestHandler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* tests) noexcept final try
        {
            (*this)(*reinterpret_cast<winrt::TestComponent::ITests const*>(&tests));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::TestComponent::ITestRunnerStatics> : produce_base<D, winrt::TestComponent::ITestRunnerStatics>
    {
        int32_t __stdcall TestProducer(void* callee) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TestProducer(*reinterpret_cast<winrt::TestComponent::ITests const*>(&callee));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall TestConsumer(void* caller, uint32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<uint32_t>(this->shim().TestConsumer(*reinterpret_cast<winrt::TestComponent::TestHandler const*>(&caller)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall TestSelf() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TestSelf();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall MakeTests(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::TestComponent::ITests>(this->shim().MakeTests());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateInt32Vector(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVector<int32_t>>(this->shim().CreateInt32Vector());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateStringVector(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVector<hstring>>(this->shim().CreateStringVector());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateStringableVector(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::IStringable>>(this->shim().CreateStringableVector());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
    template <typename D>
    struct produce<D, winrt::TestComponent::ITests> : produce_base<D, winrt::TestComponent::ITests>
    {
        int32_t __stdcall get_Percentage(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().Percentage());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Simple() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Simple();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param1(bool a, bool* b, bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().Param1(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param2(uint8_t a, uint8_t* b, uint8_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<uint8_t>(this->shim().Param2(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param3(uint16_t a, uint16_t* b, uint16_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<uint16_t>(this->shim().Param3(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param4(uint32_t a, uint32_t* b, uint32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<uint32_t>(this->shim().Param4(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param5(uint64_t a, uint64_t* b, uint64_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<uint64_t>(this->shim().Param5(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param6(int16_t a, int16_t* b, int16_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<int16_t>(this->shim().Param6(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param7(int32_t a, int32_t* b, int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<int32_t>(this->shim().Param7(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param8(int64_t a, int64_t* b, int64_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<int64_t>(this->shim().Param8(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param9(float a, float* b, float* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<float>(this->shim().Param9(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param10(double a, double* b, double* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<double>(this->shim().Param10(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param11(char16_t a, char16_t* b, char16_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<char16_t>(this->shim().Param11(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param12(void* a, void** b, void** result) noexcept final try
        {
            clear_abi(b);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().Param12(*reinterpret_cast<hstring const*>(&a), *reinterpret_cast<hstring*>(b)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param13(struct struct_TestComponent_Blittable a, struct struct_TestComponent_Blittable const& b, struct struct_TestComponent_Blittable* c, struct struct_TestComponent_Blittable* result) noexcept final try
        {
            zero_abi<winrt::TestComponent::Blittable>(c);
            zero_abi<winrt::TestComponent::Blittable>(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::TestComponent::Blittable>(this->shim().Param13(*reinterpret_cast<winrt::TestComponent::Blittable const*>(&a), *reinterpret_cast<winrt::TestComponent::Blittable const*>(&b), *reinterpret_cast<winrt::TestComponent::Blittable*>(c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param14(struct struct_TestComponent_NonBlittable a, struct struct_TestComponent_NonBlittable const& b, struct struct_TestComponent_NonBlittable* c, struct struct_TestComponent_NonBlittable* result) noexcept final try
        {
            zero_abi<winrt::TestComponent::NonBlittable>(c);
            zero_abi<winrt::TestComponent::NonBlittable>(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::TestComponent::NonBlittable>(this->shim().Param14(*reinterpret_cast<winrt::TestComponent::NonBlittable const*>(&a), *reinterpret_cast<winrt::TestComponent::NonBlittable const*>(&b), *reinterpret_cast<winrt::TestComponent::NonBlittable*>(c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param15(struct struct_TestComponent_Nested a, struct struct_TestComponent_Nested const& b, struct struct_TestComponent_Nested* c, struct struct_TestComponent_Nested* result) noexcept final try
        {
            zero_abi<winrt::TestComponent::Nested>(c);
            zero_abi<winrt::TestComponent::Nested>(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::TestComponent::Nested>(this->shim().Param15(*reinterpret_cast<winrt::TestComponent::Nested const*>(&a), *reinterpret_cast<winrt::TestComponent::Nested const*>(&b), *reinterpret_cast<winrt::TestComponent::Nested*>(c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param1Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Param1Call(*reinterpret_cast<winrt::TestComponent::Param1Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param2Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Param2Call(*reinterpret_cast<winrt::TestComponent::Param2Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param3Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Param3Call(*reinterpret_cast<winrt::TestComponent::Param3Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param4Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Param4Call(*reinterpret_cast<winrt::TestComponent::Param4Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param5Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Param5Call(*reinterpret_cast<winrt::TestComponent::Param5Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param6Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Param6Call(*reinterpret_cast<winrt::TestComponent::Param6Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param7Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Param7Call(*reinterpret_cast<winrt::TestComponent::Param7Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param8Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Param8Call(*reinterpret_cast<winrt::TestComponent::Param8Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param9Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Param9Call(*reinterpret_cast<winrt::TestComponent::Param9Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param10Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Param10Call(*reinterpret_cast<winrt::TestComponent::Param10Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param11Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Param11Call(*reinterpret_cast<winrt::TestComponent::Param11Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param12Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Param12Call(*reinterpret_cast<winrt::TestComponent::Param12Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param13Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Param13Call(*reinterpret_cast<winrt::TestComponent::Param13Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param14Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Param14Call(*reinterpret_cast<winrt::TestComponent::Param14Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param15Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Param15Call(*reinterpret_cast<winrt::TestComponent::Param15Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array1(uint32_t __aSize, bool* a, uint32_t __bSize, bool* b, uint32_t* __cSize, bool** c, uint32_t* __resultSize, bool** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().Array1(array_view<bool const>(reinterpret_cast<bool const *>(a), reinterpret_cast<bool const *>(a) + __aSize), array_view<bool>(reinterpret_cast<bool*>(b), reinterpret_cast<bool*>(b) + __bSize), detach_abi<bool>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array2(uint32_t __aSize, uint8_t* a, uint32_t __bSize, uint8_t* b, uint32_t* __cSize, uint8_t** c, uint32_t* __resultSize, uint8_t** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().Array2(array_view<uint8_t const>(reinterpret_cast<uint8_t const *>(a), reinterpret_cast<uint8_t const *>(a) + __aSize), array_view<uint8_t>(reinterpret_cast<uint8_t*>(b), reinterpret_cast<uint8_t*>(b) + __bSize), detach_abi<uint8_t>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array3(uint32_t __aSize, uint16_t* a, uint32_t __bSize, uint16_t* b, uint32_t* __cSize, uint16_t** c, uint32_t* __resultSize, uint16_t** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().Array3(array_view<uint16_t const>(reinterpret_cast<uint16_t const *>(a), reinterpret_cast<uint16_t const *>(a) + __aSize), array_view<uint16_t>(reinterpret_cast<uint16_t*>(b), reinterpret_cast<uint16_t*>(b) + __bSize), detach_abi<uint16_t>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array4(uint32_t __aSize, uint32_t* a, uint32_t __bSize, uint32_t* b, uint32_t* __cSize, uint32_t** c, uint32_t* __resultSize, uint32_t** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().Array4(array_view<uint32_t const>(reinterpret_cast<uint32_t const *>(a), reinterpret_cast<uint32_t const *>(a) + __aSize), array_view<uint32_t>(reinterpret_cast<uint32_t*>(b), reinterpret_cast<uint32_t*>(b) + __bSize), detach_abi<uint32_t>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array5(uint32_t __aSize, uint64_t* a, uint32_t __bSize, uint64_t* b, uint32_t* __cSize, uint64_t** c, uint32_t* __resultSize, uint64_t** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().Array5(array_view<uint64_t const>(reinterpret_cast<uint64_t const *>(a), reinterpret_cast<uint64_t const *>(a) + __aSize), array_view<uint64_t>(reinterpret_cast<uint64_t*>(b), reinterpret_cast<uint64_t*>(b) + __bSize), detach_abi<uint64_t>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array6(uint32_t __aSize, int16_t* a, uint32_t __bSize, int16_t* b, uint32_t* __cSize, int16_t** c, uint32_t* __resultSize, int16_t** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().Array6(array_view<int16_t const>(reinterpret_cast<int16_t const *>(a), reinterpret_cast<int16_t const *>(a) + __aSize), array_view<int16_t>(reinterpret_cast<int16_t*>(b), reinterpret_cast<int16_t*>(b) + __bSize), detach_abi<int16_t>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array7(uint32_t __aSize, int32_t* a, uint32_t __bSize, int32_t* b, uint32_t* __cSize, int32_t** c, uint32_t* __resultSize, int32_t** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().Array7(array_view<int32_t const>(reinterpret_cast<int32_t const *>(a), reinterpret_cast<int32_t const *>(a) + __aSize), array_view<int32_t>(reinterpret_cast<int32_t*>(b), reinterpret_cast<int32_t*>(b) + __bSize), detach_abi<int32_t>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array8(uint32_t __aSize, int64_t* a, uint32_t __bSize, int64_t* b, uint32_t* __cSize, int64_t** c, uint32_t* __resultSize, int64_t** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().Array8(array_view<int64_t const>(reinterpret_cast<int64_t const *>(a), reinterpret_cast<int64_t const *>(a) + __aSize), array_view<int64_t>(reinterpret_cast<int64_t*>(b), reinterpret_cast<int64_t*>(b) + __bSize), detach_abi<int64_t>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array9(uint32_t __aSize, float* a, uint32_t __bSize, float* b, uint32_t* __cSize, float** c, uint32_t* __resultSize, float** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().Array9(array_view<float const>(reinterpret_cast<float const *>(a), reinterpret_cast<float const *>(a) + __aSize), array_view<float>(reinterpret_cast<float*>(b), reinterpret_cast<float*>(b) + __bSize), detach_abi<float>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array10(uint32_t __aSize, double* a, uint32_t __bSize, double* b, uint32_t* __cSize, double** c, uint32_t* __resultSize, double** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().Array10(array_view<double const>(reinterpret_cast<double const *>(a), reinterpret_cast<double const *>(a) + __aSize), array_view<double>(reinterpret_cast<double*>(b), reinterpret_cast<double*>(b) + __bSize), detach_abi<double>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array11(uint32_t __aSize, char16_t* a, uint32_t __bSize, char16_t* b, uint32_t* __cSize, char16_t** c, uint32_t* __resultSize, char16_t** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().Array11(array_view<char16_t const>(reinterpret_cast<char16_t const *>(a), reinterpret_cast<char16_t const *>(a) + __aSize), array_view<char16_t>(reinterpret_cast<char16_t*>(b), reinterpret_cast<char16_t*>(b) + __bSize), detach_abi<char16_t>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array12(uint32_t __aSize, void** a, uint32_t __bSize, void** b, uint32_t* __cSize, void*** c, uint32_t* __resultSize, void*** result) noexcept final try
        {
            zero_abi<hstring>(b, __bSize);
            clear_abi(c);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().Array12(array_view<hstring const>(reinterpret_cast<hstring const *>(a), reinterpret_cast<hstring const *>(a) + __aSize), array_view<hstring>(reinterpret_cast<hstring*>(b), reinterpret_cast<hstring*>(b) + __bSize), detach_abi<hstring>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array13(uint32_t __aSize, struct struct_TestComponent_Blittable* a, uint32_t __bSize, struct struct_TestComponent_Blittable* b, uint32_t* __cSize, struct struct_TestComponent_Blittable** c, uint32_t* __resultSize, struct struct_TestComponent_Blittable** result) noexcept final try
        {
            zero_abi<winrt::TestComponent::Blittable>(b, __bSize);
            clear_abi(c);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().Array13(array_view<winrt::TestComponent::Blittable const>(reinterpret_cast<winrt::TestComponent::Blittable const *>(a), reinterpret_cast<winrt::TestComponent::Blittable const *>(a) + __aSize), array_view<winrt::TestComponent::Blittable>(reinterpret_cast<winrt::TestComponent::Blittable*>(b), reinterpret_cast<winrt::TestComponent::Blittable*>(b) + __bSize), detach_abi<winrt::TestComponent::Blittable>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array14(uint32_t __aSize, struct struct_TestComponent_NonBlittable* a, uint32_t __bSize, struct struct_TestComponent_NonBlittable* b, uint32_t* __cSize, struct struct_TestComponent_NonBlittable** c, uint32_t* __resultSize, struct struct_TestComponent_NonBlittable** result) noexcept final try
        {
            zero_abi<winrt::TestComponent::NonBlittable>(b, __bSize);
            clear_abi(c);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().Array14(array_view<winrt::TestComponent::NonBlittable const>(reinterpret_cast<winrt::TestComponent::NonBlittable const *>(a), reinterpret_cast<winrt::TestComponent::NonBlittable const *>(a) + __aSize), array_view<winrt::TestComponent::NonBlittable>(reinterpret_cast<winrt::TestComponent::NonBlittable*>(b), reinterpret_cast<winrt::TestComponent::NonBlittable*>(b) + __bSize), detach_abi<winrt::TestComponent::NonBlittable>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array15(uint32_t __aSize, struct struct_TestComponent_Nested* a, uint32_t __bSize, struct struct_TestComponent_Nested* b, uint32_t* __cSize, struct struct_TestComponent_Nested** c, uint32_t* __resultSize, struct struct_TestComponent_Nested** result) noexcept final try
        {
            zero_abi<winrt::TestComponent::Nested>(b, __bSize);
            clear_abi(c);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().Array15(array_view<winrt::TestComponent::Nested const>(reinterpret_cast<winrt::TestComponent::Nested const *>(a), reinterpret_cast<winrt::TestComponent::Nested const *>(a) + __aSize), array_view<winrt::TestComponent::Nested>(reinterpret_cast<winrt::TestComponent::Nested*>(b), reinterpret_cast<winrt::TestComponent::Nested*>(b) + __bSize), detach_abi<winrt::TestComponent::Nested>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array1Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Array1Call(*reinterpret_cast<winrt::TestComponent::Array1Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array2Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Array2Call(*reinterpret_cast<winrt::TestComponent::Array2Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array3Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Array3Call(*reinterpret_cast<winrt::TestComponent::Array3Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array4Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Array4Call(*reinterpret_cast<winrt::TestComponent::Array4Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array5Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Array5Call(*reinterpret_cast<winrt::TestComponent::Array5Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array6Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Array6Call(*reinterpret_cast<winrt::TestComponent::Array6Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array7Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Array7Call(*reinterpret_cast<winrt::TestComponent::Array7Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array8Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Array8Call(*reinterpret_cast<winrt::TestComponent::Array8Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array9Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Array9Call(*reinterpret_cast<winrt::TestComponent::Array9Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array10Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Array10Call(*reinterpret_cast<winrt::TestComponent::Array10Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array11Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Array11Call(*reinterpret_cast<winrt::TestComponent::Array11Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array12Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Array12Call(*reinterpret_cast<winrt::TestComponent::Array12Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array13Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Array13Call(*reinterpret_cast<winrt::TestComponent::Array13Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array14Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Array14Call(*reinterpret_cast<winrt::TestComponent::Array14Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array15Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Array15Call(*reinterpret_cast<winrt::TestComponent::Array15Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Collection1(void* a, void** b, void** result) noexcept final try
        {
            clear_abi(b);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IIterable<hstring>>(this->shim().Collection1(*reinterpret_cast<winrt::Windows::Foundation::Collections::IIterable<hstring> const*>(&a), *reinterpret_cast<winrt::Windows::Foundation::Collections::IIterable<hstring>*>(b)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Collection2(void* a, void** b, void** result) noexcept final try
        {
            clear_abi(b);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>>>(this->shim().Collection2(*reinterpret_cast<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>> const*>(&a), *reinterpret_cast<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>>*>(b)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Collection3(void* a, void** b, void** result) noexcept final try
        {
            clear_abi(b);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IMap<hstring, hstring>>(this->shim().Collection3(*reinterpret_cast<winrt::Windows::Foundation::Collections::IMap<hstring, hstring> const*>(&a), *reinterpret_cast<winrt::Windows::Foundation::Collections::IMap<hstring, hstring>*>(b)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Collection4(void* a, void** b, void** result) noexcept final try
        {
            clear_abi(b);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IMapView<hstring, hstring>>(this->shim().Collection4(*reinterpret_cast<winrt::Windows::Foundation::Collections::IMapView<hstring, hstring> const*>(&a), *reinterpret_cast<winrt::Windows::Foundation::Collections::IMapView<hstring, hstring>*>(b)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Collection5(void* a, void** b, void** result) noexcept final try
        {
            clear_abi(b);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVector<hstring>>(this->shim().Collection5(*reinterpret_cast<winrt::Windows::Foundation::Collections::IVector<hstring> const*>(&a), *reinterpret_cast<winrt::Windows::Foundation::Collections::IVector<hstring>*>(b)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Collection6(void* a, void** b, void** result) noexcept final try
        {
            clear_abi(b);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVectorView<hstring>>(this->shim().Collection6(*reinterpret_cast<winrt::Windows::Foundation::Collections::IVectorView<hstring> const*>(&a), *reinterpret_cast<winrt::Windows::Foundation::Collections::IVectorView<hstring>*>(b)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Collection1Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Collection1Call(*reinterpret_cast<winrt::TestComponent::Collection1Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Collection2Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Collection2Call(*reinterpret_cast<winrt::TestComponent::Collection2Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Collection3Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Collection3Call(*reinterpret_cast<winrt::TestComponent::Collection3Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Collection4Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Collection4Call(*reinterpret_cast<winrt::TestComponent::Collection4Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Collection5Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Collection5Call(*reinterpret_cast<winrt::TestComponent::Collection5Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Collection6Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Collection6Call(*reinterpret_cast<winrt::TestComponent::Collection6Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Async1(void* suspend, bool fail, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncAction>(this->shim().Async1(*reinterpret_cast<winrt::Windows::Foundation::IAsyncAction const*>(&suspend), fail));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Async2(void* suspend, bool fail, int32_t progress, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncActionWithProgress<int32_t>>(this->shim().Async2(*reinterpret_cast<winrt::Windows::Foundation::IAsyncAction const*>(&suspend), fail, progress));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Async3(void* suspend, bool fail, int32_t result, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<int32_t>>(this->shim().Async3(*reinterpret_cast<winrt::Windows::Foundation::IAsyncAction const*>(&suspend), fail, result));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Async4(void* suspend, bool fail, int32_t result, int32_t progress, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<int32_t, int32_t>>(this->shim().Async4(*reinterpret_cast<winrt::Windows::Foundation::IAsyncAction const*>(&suspend), fail, result, progress));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Async1Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Async1Call(*reinterpret_cast<winrt::TestComponent::Async1Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Async2Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Async2Call(*reinterpret_cast<winrt::TestComponent::Async2Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Async3Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Async3Call(*reinterpret_cast<winrt::TestComponent::Async3Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Async4Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Async4Call(*reinterpret_cast<winrt::TestComponent::Async4Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_Event1(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().Event1(*reinterpret_cast<winrt::Windows::Foundation::EventHandler<int32_t> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_Event1(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Event1(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_Event2(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().Event2(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::TestComponent::ITests, int32_t> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_Event2(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Event2(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall Event1Call(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Event1Call(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Event2Call(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Event2Call(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
}
WINRT_EXPORT namespace winrt::TestComponent
{
    inline auto TestRunner::TestProducer(winrt::TestComponent::ITests const& callee)
    {
        impl::call_factory<TestRunner, ITestRunnerStatics>([&](ITestRunnerStatics const& f) { return f.TestProducer(callee); });
    }
    inline auto TestRunner::TestConsumer(winrt::TestComponent::TestHandler const& caller)
    {
        return impl::call_factory<TestRunner, ITestRunnerStatics>([&](ITestRunnerStatics const& f) { return f.TestConsumer(caller); });
    }
    inline auto TestRunner::TestSelf()
    {
        impl::call_factory_cast<void(*)(ITestRunnerStatics const&), TestRunner, ITestRunnerStatics>([](ITestRunnerStatics const& f) { return f.TestSelf(); });
    }
    inline auto TestRunner::MakeTests()
    {
        return impl::call_factory_cast<winrt::TestComponent::ITests(*)(ITestRunnerStatics const&), TestRunner, ITestRunnerStatics>([](ITestRunnerStatics const& f) { return f.MakeTests(); });
    }
    inline auto TestRunner::CreateInt32Vector()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::Collections::IVector<int32_t>(*)(ITestRunnerStatics const&), TestRunner, ITestRunnerStatics>([](ITestRunnerStatics const& f) { return f.CreateInt32Vector(); });
    }
    inline auto TestRunner::CreateStringVector()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::Collections::IVector<hstring>(*)(ITestRunnerStatics const&), TestRunner, ITestRunnerStatics>([](ITestRunnerStatics const& f) { return f.CreateStringVector(); });
    }
    inline auto TestRunner::CreateStringableVector()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::IStringable>(*)(ITestRunnerStatics const&), TestRunner, ITestRunnerStatics>([](ITestRunnerStatics const& f) { return f.CreateStringableVector(); });
    }
    template <typename L> Array10Handler::Array10Handler(L handler) :
        Array10Handler(impl::make_delegate<Array10Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Array10Handler::Array10Handler(F* handler) :
        Array10Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Array10Handler::Array10Handler(O* object, M method) :
        Array10Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Array10Handler::Array10Handler(com_ptr<O>&& object, M method) :
        Array10Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array10Handler::Array10Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Array10Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Array10Handler::Array10Handler(std::shared_ptr<O>&& object, M method) :
        Array10Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array10Handler::Array10Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Array10Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Array10Handler::operator()(array_view<double const> a, array_view<double> b, com_array<double>& c) const
    {
        uint32_t result_impl_size{};
        double* result{};
        check_hresult((*(impl::abi_t<Array10Handler>**)this)->Invoke(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<double>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename L> Array11Handler::Array11Handler(L handler) :
        Array11Handler(impl::make_delegate<Array11Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Array11Handler::Array11Handler(F* handler) :
        Array11Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Array11Handler::Array11Handler(O* object, M method) :
        Array11Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Array11Handler::Array11Handler(com_ptr<O>&& object, M method) :
        Array11Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array11Handler::Array11Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Array11Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Array11Handler::Array11Handler(std::shared_ptr<O>&& object, M method) :
        Array11Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array11Handler::Array11Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Array11Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Array11Handler::operator()(array_view<char16_t const> a, array_view<char16_t> b, com_array<char16_t>& c) const
    {
        uint32_t result_impl_size{};
        char16_t* result{};
        check_hresult((*(impl::abi_t<Array11Handler>**)this)->Invoke(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<char16_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename L> Array12Handler::Array12Handler(L handler) :
        Array12Handler(impl::make_delegate<Array12Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Array12Handler::Array12Handler(F* handler) :
        Array12Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Array12Handler::Array12Handler(O* object, M method) :
        Array12Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Array12Handler::Array12Handler(com_ptr<O>&& object, M method) :
        Array12Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array12Handler::Array12Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Array12Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Array12Handler::Array12Handler(std::shared_ptr<O>&& object, M method) :
        Array12Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array12Handler::Array12Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Array12Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Array12Handler::operator()(array_view<hstring const> a, array_view<hstring> b, com_array<hstring>& c) const
    {
        uint32_t result_impl_size{};
        void** result{};
        check_hresult((*(impl::abi_t<Array12Handler>**)this)->Invoke(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<hstring>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename L> Array13Handler::Array13Handler(L handler) :
        Array13Handler(impl::make_delegate<Array13Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Array13Handler::Array13Handler(F* handler) :
        Array13Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Array13Handler::Array13Handler(O* object, M method) :
        Array13Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Array13Handler::Array13Handler(com_ptr<O>&& object, M method) :
        Array13Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array13Handler::Array13Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Array13Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Array13Handler::Array13Handler(std::shared_ptr<O>&& object, M method) :
        Array13Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array13Handler::Array13Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Array13Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Array13Handler::operator()(array_view<winrt::TestComponent::Blittable const> a, array_view<winrt::TestComponent::Blittable> b, com_array<winrt::TestComponent::Blittable>& c) const
    {
        uint32_t result_impl_size{};
        struct impl::struct_TestComponent_Blittable* result{};
        check_hresult((*(impl::abi_t<Array13Handler>**)this)->Invoke(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<winrt::TestComponent::Blittable>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename L> Array14Handler::Array14Handler(L handler) :
        Array14Handler(impl::make_delegate<Array14Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Array14Handler::Array14Handler(F* handler) :
        Array14Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Array14Handler::Array14Handler(O* object, M method) :
        Array14Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Array14Handler::Array14Handler(com_ptr<O>&& object, M method) :
        Array14Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array14Handler::Array14Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Array14Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Array14Handler::Array14Handler(std::shared_ptr<O>&& object, M method) :
        Array14Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array14Handler::Array14Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Array14Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Array14Handler::operator()(array_view<winrt::TestComponent::NonBlittable const> a, array_view<winrt::TestComponent::NonBlittable> b, com_array<winrt::TestComponent::NonBlittable>& c) const
    {
        uint32_t result_impl_size{};
        struct impl::struct_TestComponent_NonBlittable* result{};
        check_hresult((*(impl::abi_t<Array14Handler>**)this)->Invoke(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<winrt::TestComponent::NonBlittable>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename L> Array15Handler::Array15Handler(L handler) :
        Array15Handler(impl::make_delegate<Array15Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Array15Handler::Array15Handler(F* handler) :
        Array15Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Array15Handler::Array15Handler(O* object, M method) :
        Array15Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Array15Handler::Array15Handler(com_ptr<O>&& object, M method) :
        Array15Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array15Handler::Array15Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Array15Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Array15Handler::Array15Handler(std::shared_ptr<O>&& object, M method) :
        Array15Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array15Handler::Array15Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Array15Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Array15Handler::operator()(array_view<winrt::TestComponent::Nested const> a, array_view<winrt::TestComponent::Nested> b, com_array<winrt::TestComponent::Nested>& c) const
    {
        uint32_t result_impl_size{};
        struct impl::struct_TestComponent_Nested* result{};
        check_hresult((*(impl::abi_t<Array15Handler>**)this)->Invoke(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<winrt::TestComponent::Nested>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename L> Array1Handler::Array1Handler(L handler) :
        Array1Handler(impl::make_delegate<Array1Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Array1Handler::Array1Handler(F* handler) :
        Array1Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Array1Handler::Array1Handler(O* object, M method) :
        Array1Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Array1Handler::Array1Handler(com_ptr<O>&& object, M method) :
        Array1Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array1Handler::Array1Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Array1Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Array1Handler::Array1Handler(std::shared_ptr<O>&& object, M method) :
        Array1Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array1Handler::Array1Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Array1Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Array1Handler::operator()(array_view<bool const> a, array_view<bool> b, com_array<bool>& c) const
    {
        uint32_t result_impl_size{};
        bool* result{};
        check_hresult((*(impl::abi_t<Array1Handler>**)this)->Invoke(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<bool>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename L> Array2Handler::Array2Handler(L handler) :
        Array2Handler(impl::make_delegate<Array2Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Array2Handler::Array2Handler(F* handler) :
        Array2Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Array2Handler::Array2Handler(O* object, M method) :
        Array2Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Array2Handler::Array2Handler(com_ptr<O>&& object, M method) :
        Array2Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array2Handler::Array2Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Array2Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Array2Handler::Array2Handler(std::shared_ptr<O>&& object, M method) :
        Array2Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array2Handler::Array2Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Array2Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Array2Handler::operator()(array_view<uint8_t const> a, array_view<uint8_t> b, com_array<uint8_t>& c) const
    {
        uint32_t result_impl_size{};
        uint8_t* result{};
        check_hresult((*(impl::abi_t<Array2Handler>**)this)->Invoke(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<uint8_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename L> Array3Handler::Array3Handler(L handler) :
        Array3Handler(impl::make_delegate<Array3Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Array3Handler::Array3Handler(F* handler) :
        Array3Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Array3Handler::Array3Handler(O* object, M method) :
        Array3Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Array3Handler::Array3Handler(com_ptr<O>&& object, M method) :
        Array3Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array3Handler::Array3Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Array3Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Array3Handler::Array3Handler(std::shared_ptr<O>&& object, M method) :
        Array3Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array3Handler::Array3Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Array3Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Array3Handler::operator()(array_view<uint16_t const> a, array_view<uint16_t> b, com_array<uint16_t>& c) const
    {
        uint32_t result_impl_size{};
        uint16_t* result{};
        check_hresult((*(impl::abi_t<Array3Handler>**)this)->Invoke(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<uint16_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename L> Array4Handler::Array4Handler(L handler) :
        Array4Handler(impl::make_delegate<Array4Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Array4Handler::Array4Handler(F* handler) :
        Array4Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Array4Handler::Array4Handler(O* object, M method) :
        Array4Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Array4Handler::Array4Handler(com_ptr<O>&& object, M method) :
        Array4Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array4Handler::Array4Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Array4Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Array4Handler::Array4Handler(std::shared_ptr<O>&& object, M method) :
        Array4Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array4Handler::Array4Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Array4Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Array4Handler::operator()(array_view<uint32_t const> a, array_view<uint32_t> b, com_array<uint32_t>& c) const
    {
        uint32_t result_impl_size{};
        uint32_t* result{};
        check_hresult((*(impl::abi_t<Array4Handler>**)this)->Invoke(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<uint32_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename L> Array5Handler::Array5Handler(L handler) :
        Array5Handler(impl::make_delegate<Array5Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Array5Handler::Array5Handler(F* handler) :
        Array5Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Array5Handler::Array5Handler(O* object, M method) :
        Array5Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Array5Handler::Array5Handler(com_ptr<O>&& object, M method) :
        Array5Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array5Handler::Array5Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Array5Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Array5Handler::Array5Handler(std::shared_ptr<O>&& object, M method) :
        Array5Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array5Handler::Array5Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Array5Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Array5Handler::operator()(array_view<uint64_t const> a, array_view<uint64_t> b, com_array<uint64_t>& c) const
    {
        uint32_t result_impl_size{};
        uint64_t* result{};
        check_hresult((*(impl::abi_t<Array5Handler>**)this)->Invoke(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<uint64_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename L> Array6Handler::Array6Handler(L handler) :
        Array6Handler(impl::make_delegate<Array6Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Array6Handler::Array6Handler(F* handler) :
        Array6Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Array6Handler::Array6Handler(O* object, M method) :
        Array6Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Array6Handler::Array6Handler(com_ptr<O>&& object, M method) :
        Array6Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array6Handler::Array6Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Array6Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Array6Handler::Array6Handler(std::shared_ptr<O>&& object, M method) :
        Array6Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array6Handler::Array6Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Array6Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Array6Handler::operator()(array_view<int16_t const> a, array_view<int16_t> b, com_array<int16_t>& c) const
    {
        uint32_t result_impl_size{};
        int16_t* result{};
        check_hresult((*(impl::abi_t<Array6Handler>**)this)->Invoke(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<int16_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename L> Array7Handler::Array7Handler(L handler) :
        Array7Handler(impl::make_delegate<Array7Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Array7Handler::Array7Handler(F* handler) :
        Array7Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Array7Handler::Array7Handler(O* object, M method) :
        Array7Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Array7Handler::Array7Handler(com_ptr<O>&& object, M method) :
        Array7Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array7Handler::Array7Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Array7Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Array7Handler::Array7Handler(std::shared_ptr<O>&& object, M method) :
        Array7Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array7Handler::Array7Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Array7Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Array7Handler::operator()(array_view<int32_t const> a, array_view<int32_t> b, com_array<int32_t>& c) const
    {
        uint32_t result_impl_size{};
        int32_t* result{};
        check_hresult((*(impl::abi_t<Array7Handler>**)this)->Invoke(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<int32_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename L> Array8Handler::Array8Handler(L handler) :
        Array8Handler(impl::make_delegate<Array8Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Array8Handler::Array8Handler(F* handler) :
        Array8Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Array8Handler::Array8Handler(O* object, M method) :
        Array8Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Array8Handler::Array8Handler(com_ptr<O>&& object, M method) :
        Array8Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array8Handler::Array8Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Array8Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Array8Handler::Array8Handler(std::shared_ptr<O>&& object, M method) :
        Array8Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array8Handler::Array8Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Array8Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Array8Handler::operator()(array_view<int64_t const> a, array_view<int64_t> b, com_array<int64_t>& c) const
    {
        uint32_t result_impl_size{};
        int64_t* result{};
        check_hresult((*(impl::abi_t<Array8Handler>**)this)->Invoke(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<int64_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename L> Array9Handler::Array9Handler(L handler) :
        Array9Handler(impl::make_delegate<Array9Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Array9Handler::Array9Handler(F* handler) :
        Array9Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Array9Handler::Array9Handler(O* object, M method) :
        Array9Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Array9Handler::Array9Handler(com_ptr<O>&& object, M method) :
        Array9Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array9Handler::Array9Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Array9Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Array9Handler::Array9Handler(std::shared_ptr<O>&& object, M method) :
        Array9Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array9Handler::Array9Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Array9Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Array9Handler::operator()(array_view<float const> a, array_view<float> b, com_array<float>& c) const
    {
        uint32_t result_impl_size{};
        float* result{};
        check_hresult((*(impl::abi_t<Array9Handler>**)this)->Invoke(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<float>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename L> Async1Handler::Async1Handler(L handler) :
        Async1Handler(impl::make_delegate<Async1Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Async1Handler::Async1Handler(F* handler) :
        Async1Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Async1Handler::Async1Handler(O* object, M method) :
        Async1Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Async1Handler::Async1Handler(com_ptr<O>&& object, M method) :
        Async1Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Async1Handler::Async1Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Async1Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Async1Handler::Async1Handler(std::shared_ptr<O>&& object, M method) :
        Async1Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Async1Handler::Async1Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Async1Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Async1Handler::operator()(winrt::Windows::Foundation::IAsyncAction const& suspend, bool fail) const
    {
        void* operation{};
        check_hresult((*(impl::abi_t<Async1Handler>**)this)->Invoke(*(void**)(&suspend), fail, &operation));
        return winrt::Windows::Foundation::IAsyncAction{ operation, take_ownership_from_abi };
    }
    template <typename L> Async2Handler::Async2Handler(L handler) :
        Async2Handler(impl::make_delegate<Async2Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Async2Handler::Async2Handler(F* handler) :
        Async2Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Async2Handler::Async2Handler(O* object, M method) :
        Async2Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Async2Handler::Async2Handler(com_ptr<O>&& object, M method) :
        Async2Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Async2Handler::Async2Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Async2Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Async2Handler::Async2Handler(std::shared_ptr<O>&& object, M method) :
        Async2Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Async2Handler::Async2Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Async2Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Async2Handler::operator()(winrt::Windows::Foundation::IAsyncAction const& suspend, bool fail, int32_t progress) const
    {
        void* operation{};
        check_hresult((*(impl::abi_t<Async2Handler>**)this)->Invoke(*(void**)(&suspend), fail, progress, &operation));
        return winrt::Windows::Foundation::IAsyncActionWithProgress<int32_t>{ operation, take_ownership_from_abi };
    }
    template <typename L> Async3Handler::Async3Handler(L handler) :
        Async3Handler(impl::make_delegate<Async3Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Async3Handler::Async3Handler(F* handler) :
        Async3Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Async3Handler::Async3Handler(O* object, M method) :
        Async3Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Async3Handler::Async3Handler(com_ptr<O>&& object, M method) :
        Async3Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Async3Handler::Async3Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Async3Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Async3Handler::Async3Handler(std::shared_ptr<O>&& object, M method) :
        Async3Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Async3Handler::Async3Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Async3Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Async3Handler::operator()(winrt::Windows::Foundation::IAsyncAction const& suspend, bool fail, int32_t result) const
    {
        void* operation{};
        check_hresult((*(impl::abi_t<Async3Handler>**)this)->Invoke(*(void**)(&suspend), fail, result, &operation));
        return winrt::Windows::Foundation::IAsyncOperation<int32_t>{ operation, take_ownership_from_abi };
    }
    template <typename L> Async4Handler::Async4Handler(L handler) :
        Async4Handler(impl::make_delegate<Async4Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Async4Handler::Async4Handler(F* handler) :
        Async4Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Async4Handler::Async4Handler(O* object, M method) :
        Async4Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Async4Handler::Async4Handler(com_ptr<O>&& object, M method) :
        Async4Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Async4Handler::Async4Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Async4Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Async4Handler::Async4Handler(std::shared_ptr<O>&& object, M method) :
        Async4Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Async4Handler::Async4Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Async4Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Async4Handler::operator()(winrt::Windows::Foundation::IAsyncAction const& suspend, bool fail, int32_t result, int32_t progress) const
    {
        void* operation{};
        check_hresult((*(impl::abi_t<Async4Handler>**)this)->Invoke(*(void**)(&suspend), fail, result, progress, &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<int32_t, int32_t>{ operation, take_ownership_from_abi };
    }
    template <typename L> Collection1Handler::Collection1Handler(L handler) :
        Collection1Handler(impl::make_delegate<Collection1Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Collection1Handler::Collection1Handler(F* handler) :
        Collection1Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Collection1Handler::Collection1Handler(O* object, M method) :
        Collection1Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Collection1Handler::Collection1Handler(com_ptr<O>&& object, M method) :
        Collection1Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Collection1Handler::Collection1Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Collection1Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Collection1Handler::Collection1Handler(std::shared_ptr<O>&& object, M method) :
        Collection1Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Collection1Handler::Collection1Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Collection1Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Collection1Handler::operator()(param::iterable<hstring> const& a, winrt::Windows::Foundation::Collections::IIterable<hstring>& b) const
    {
        void* result{};
        check_hresult((*(impl::abi_t<Collection1Handler>**)this)->Invoke(*(void**)(&a), impl::bind_out(b), &result));
        return winrt::Windows::Foundation::Collections::IIterable<hstring>{ result, take_ownership_from_abi };
    }
    template <typename L> Collection2Handler::Collection2Handler(L handler) :
        Collection2Handler(impl::make_delegate<Collection2Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Collection2Handler::Collection2Handler(F* handler) :
        Collection2Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Collection2Handler::Collection2Handler(O* object, M method) :
        Collection2Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Collection2Handler::Collection2Handler(com_ptr<O>&& object, M method) :
        Collection2Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Collection2Handler::Collection2Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Collection2Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Collection2Handler::Collection2Handler(std::shared_ptr<O>&& object, M method) :
        Collection2Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Collection2Handler::Collection2Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Collection2Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Collection2Handler::operator()(param::iterable<winrt::Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>> const& a, winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>>& b) const
    {
        void* result{};
        check_hresult((*(impl::abi_t<Collection2Handler>**)this)->Invoke(*(void**)(&a), impl::bind_out(b), &result));
        return winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>>{ result, take_ownership_from_abi };
    }
    template <typename L> Collection3Handler::Collection3Handler(L handler) :
        Collection3Handler(impl::make_delegate<Collection3Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Collection3Handler::Collection3Handler(F* handler) :
        Collection3Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Collection3Handler::Collection3Handler(O* object, M method) :
        Collection3Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Collection3Handler::Collection3Handler(com_ptr<O>&& object, M method) :
        Collection3Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Collection3Handler::Collection3Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Collection3Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Collection3Handler::Collection3Handler(std::shared_ptr<O>&& object, M method) :
        Collection3Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Collection3Handler::Collection3Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Collection3Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Collection3Handler::operator()(param::map<hstring, hstring> const& a, winrt::Windows::Foundation::Collections::IMap<hstring, hstring>& b) const
    {
        void* result{};
        check_hresult((*(impl::abi_t<Collection3Handler>**)this)->Invoke(*(void**)(&a), impl::bind_out(b), &result));
        return winrt::Windows::Foundation::Collections::IMap<hstring, hstring>{ result, take_ownership_from_abi };
    }
    template <typename L> Collection4Handler::Collection4Handler(L handler) :
        Collection4Handler(impl::make_delegate<Collection4Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Collection4Handler::Collection4Handler(F* handler) :
        Collection4Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Collection4Handler::Collection4Handler(O* object, M method) :
        Collection4Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Collection4Handler::Collection4Handler(com_ptr<O>&& object, M method) :
        Collection4Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Collection4Handler::Collection4Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Collection4Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Collection4Handler::Collection4Handler(std::shared_ptr<O>&& object, M method) :
        Collection4Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Collection4Handler::Collection4Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Collection4Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Collection4Handler::operator()(param::map_view<hstring, hstring> const& a, winrt::Windows::Foundation::Collections::IMapView<hstring, hstring>& b) const
    {
        void* result{};
        check_hresult((*(impl::abi_t<Collection4Handler>**)this)->Invoke(*(void**)(&a), impl::bind_out(b), &result));
        return winrt::Windows::Foundation::Collections::IMapView<hstring, hstring>{ result, take_ownership_from_abi };
    }
    template <typename L> Collection5Handler::Collection5Handler(L handler) :
        Collection5Handler(impl::make_delegate<Collection5Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Collection5Handler::Collection5Handler(F* handler) :
        Collection5Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Collection5Handler::Collection5Handler(O* object, M method) :
        Collection5Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Collection5Handler::Collection5Handler(com_ptr<O>&& object, M method) :
        Collection5Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Collection5Handler::Collection5Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Collection5Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Collection5Handler::Collection5Handler(std::shared_ptr<O>&& object, M method) :
        Collection5Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Collection5Handler::Collection5Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Collection5Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Collection5Handler::operator()(param::vector<hstring> const& a, winrt::Windows::Foundation::Collections::IVector<hstring>& b) const
    {
        void* result{};
        check_hresult((*(impl::abi_t<Collection5Handler>**)this)->Invoke(*(void**)(&a), impl::bind_out(b), &result));
        return winrt::Windows::Foundation::Collections::IVector<hstring>{ result, take_ownership_from_abi };
    }
    template <typename L> Collection6Handler::Collection6Handler(L handler) :
        Collection6Handler(impl::make_delegate<Collection6Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Collection6Handler::Collection6Handler(F* handler) :
        Collection6Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Collection6Handler::Collection6Handler(O* object, M method) :
        Collection6Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Collection6Handler::Collection6Handler(com_ptr<O>&& object, M method) :
        Collection6Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Collection6Handler::Collection6Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Collection6Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Collection6Handler::Collection6Handler(std::shared_ptr<O>&& object, M method) :
        Collection6Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Collection6Handler::Collection6Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Collection6Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Collection6Handler::operator()(param::vector_view<hstring> const& a, winrt::Windows::Foundation::Collections::IVectorView<hstring>& b) const
    {
        void* result{};
        check_hresult((*(impl::abi_t<Collection6Handler>**)this)->Invoke(*(void**)(&a), impl::bind_out(b), &result));
        return winrt::Windows::Foundation::Collections::IVectorView<hstring>{ result, take_ownership_from_abi };
    }
    template <typename L> Param10Handler::Param10Handler(L handler) :
        Param10Handler(impl::make_delegate<Param10Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Param10Handler::Param10Handler(F* handler) :
        Param10Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Param10Handler::Param10Handler(O* object, M method) :
        Param10Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Param10Handler::Param10Handler(com_ptr<O>&& object, M method) :
        Param10Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param10Handler::Param10Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Param10Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Param10Handler::Param10Handler(std::shared_ptr<O>&& object, M method) :
        Param10Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param10Handler::Param10Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Param10Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Param10Handler::operator()(double a, double& b) const
    {
        double result{};
        check_hresult((*(impl::abi_t<Param10Handler>**)this)->Invoke(a, &b, &result));
        return result;
    }
    template <typename L> Param11Handler::Param11Handler(L handler) :
        Param11Handler(impl::make_delegate<Param11Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Param11Handler::Param11Handler(F* handler) :
        Param11Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Param11Handler::Param11Handler(O* object, M method) :
        Param11Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Param11Handler::Param11Handler(com_ptr<O>&& object, M method) :
        Param11Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param11Handler::Param11Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Param11Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Param11Handler::Param11Handler(std::shared_ptr<O>&& object, M method) :
        Param11Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param11Handler::Param11Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Param11Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Param11Handler::operator()(char16_t a, char16_t& b) const
    {
        char16_t result{};
        check_hresult((*(impl::abi_t<Param11Handler>**)this)->Invoke(a, &b, &result));
        return result;
    }
    template <typename L> Param12Handler::Param12Handler(L handler) :
        Param12Handler(impl::make_delegate<Param12Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Param12Handler::Param12Handler(F* handler) :
        Param12Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Param12Handler::Param12Handler(O* object, M method) :
        Param12Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Param12Handler::Param12Handler(com_ptr<O>&& object, M method) :
        Param12Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param12Handler::Param12Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Param12Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Param12Handler::Param12Handler(std::shared_ptr<O>&& object, M method) :
        Param12Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param12Handler::Param12Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Param12Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Param12Handler::operator()(param::hstring const& a, hstring& b) const
    {
        void* result{};
        check_hresult((*(impl::abi_t<Param12Handler>**)this)->Invoke(*(void**)(&a), impl::bind_out(b), &result));
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename L> Param13Handler::Param13Handler(L handler) :
        Param13Handler(impl::make_delegate<Param13Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Param13Handler::Param13Handler(F* handler) :
        Param13Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Param13Handler::Param13Handler(O* object, M method) :
        Param13Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Param13Handler::Param13Handler(com_ptr<O>&& object, M method) :
        Param13Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param13Handler::Param13Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Param13Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Param13Handler::Param13Handler(std::shared_ptr<O>&& object, M method) :
        Param13Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param13Handler::Param13Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Param13Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Param13Handler::operator()(winrt::TestComponent::Blittable const& a, winrt::TestComponent::Blittable const& b, winrt::TestComponent::Blittable& c) const
    {
        winrt::TestComponent::Blittable result{};
        check_hresult((*(impl::abi_t<Param13Handler>**)this)->Invoke(impl::bind_in(a), impl::bind_in(b), impl::bind_out(c), put_abi(result)));
        return result;
    }
    template <typename L> Param14Handler::Param14Handler(L handler) :
        Param14Handler(impl::make_delegate<Param14Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Param14Handler::Param14Handler(F* handler) :
        Param14Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Param14Handler::Param14Handler(O* object, M method) :
        Param14Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Param14Handler::Param14Handler(com_ptr<O>&& object, M method) :
        Param14Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param14Handler::Param14Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Param14Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Param14Handler::Param14Handler(std::shared_ptr<O>&& object, M method) :
        Param14Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param14Handler::Param14Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Param14Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Param14Handler::operator()(winrt::TestComponent::NonBlittable const& a, winrt::TestComponent::NonBlittable const& b, winrt::TestComponent::NonBlittable& c) const
    {
        winrt::TestComponent::NonBlittable result{};
        check_hresult((*(impl::abi_t<Param14Handler>**)this)->Invoke(impl::bind_in(a), impl::bind_in(b), impl::bind_out(c), put_abi(result)));
        return result;
    }
    template <typename L> Param15Handler::Param15Handler(L handler) :
        Param15Handler(impl::make_delegate<Param15Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Param15Handler::Param15Handler(F* handler) :
        Param15Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Param15Handler::Param15Handler(O* object, M method) :
        Param15Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Param15Handler::Param15Handler(com_ptr<O>&& object, M method) :
        Param15Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param15Handler::Param15Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Param15Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Param15Handler::Param15Handler(std::shared_ptr<O>&& object, M method) :
        Param15Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param15Handler::Param15Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Param15Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Param15Handler::operator()(winrt::TestComponent::Nested const& a, winrt::TestComponent::Nested const& b, winrt::TestComponent::Nested& c) const
    {
        winrt::TestComponent::Nested result{};
        check_hresult((*(impl::abi_t<Param15Handler>**)this)->Invoke(impl::bind_in(a), impl::bind_in(b), impl::bind_out(c), put_abi(result)));
        return result;
    }
    template <typename L> Param1Handler::Param1Handler(L handler) :
        Param1Handler(impl::make_delegate<Param1Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Param1Handler::Param1Handler(F* handler) :
        Param1Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Param1Handler::Param1Handler(O* object, M method) :
        Param1Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Param1Handler::Param1Handler(com_ptr<O>&& object, M method) :
        Param1Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param1Handler::Param1Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Param1Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Param1Handler::Param1Handler(std::shared_ptr<O>&& object, M method) :
        Param1Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param1Handler::Param1Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Param1Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Param1Handler::operator()(bool a, bool& b) const
    {
        bool result{};
        check_hresult((*(impl::abi_t<Param1Handler>**)this)->Invoke(a, &b, &result));
        return result;
    }
    template <typename L> Param2Handler::Param2Handler(L handler) :
        Param2Handler(impl::make_delegate<Param2Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Param2Handler::Param2Handler(F* handler) :
        Param2Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Param2Handler::Param2Handler(O* object, M method) :
        Param2Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Param2Handler::Param2Handler(com_ptr<O>&& object, M method) :
        Param2Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param2Handler::Param2Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Param2Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Param2Handler::Param2Handler(std::shared_ptr<O>&& object, M method) :
        Param2Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param2Handler::Param2Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Param2Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Param2Handler::operator()(uint8_t a, uint8_t& b) const
    {
        uint8_t result{};
        check_hresult((*(impl::abi_t<Param2Handler>**)this)->Invoke(a, &b, &result));
        return result;
    }
    template <typename L> Param3Handler::Param3Handler(L handler) :
        Param3Handler(impl::make_delegate<Param3Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Param3Handler::Param3Handler(F* handler) :
        Param3Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Param3Handler::Param3Handler(O* object, M method) :
        Param3Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Param3Handler::Param3Handler(com_ptr<O>&& object, M method) :
        Param3Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param3Handler::Param3Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Param3Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Param3Handler::Param3Handler(std::shared_ptr<O>&& object, M method) :
        Param3Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param3Handler::Param3Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Param3Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Param3Handler::operator()(uint16_t a, uint16_t& b) const
    {
        uint16_t result{};
        check_hresult((*(impl::abi_t<Param3Handler>**)this)->Invoke(a, &b, &result));
        return result;
    }
    template <typename L> Param4Handler::Param4Handler(L handler) :
        Param4Handler(impl::make_delegate<Param4Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Param4Handler::Param4Handler(F* handler) :
        Param4Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Param4Handler::Param4Handler(O* object, M method) :
        Param4Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Param4Handler::Param4Handler(com_ptr<O>&& object, M method) :
        Param4Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param4Handler::Param4Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Param4Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Param4Handler::Param4Handler(std::shared_ptr<O>&& object, M method) :
        Param4Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param4Handler::Param4Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Param4Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Param4Handler::operator()(uint32_t a, uint32_t& b) const
    {
        uint32_t result{};
        check_hresult((*(impl::abi_t<Param4Handler>**)this)->Invoke(a, &b, &result));
        return result;
    }
    template <typename L> Param5Handler::Param5Handler(L handler) :
        Param5Handler(impl::make_delegate<Param5Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Param5Handler::Param5Handler(F* handler) :
        Param5Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Param5Handler::Param5Handler(O* object, M method) :
        Param5Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Param5Handler::Param5Handler(com_ptr<O>&& object, M method) :
        Param5Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param5Handler::Param5Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Param5Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Param5Handler::Param5Handler(std::shared_ptr<O>&& object, M method) :
        Param5Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param5Handler::Param5Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Param5Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Param5Handler::operator()(uint64_t a, uint64_t& b) const
    {
        uint64_t result{};
        check_hresult((*(impl::abi_t<Param5Handler>**)this)->Invoke(a, &b, &result));
        return result;
    }
    template <typename L> Param6Handler::Param6Handler(L handler) :
        Param6Handler(impl::make_delegate<Param6Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Param6Handler::Param6Handler(F* handler) :
        Param6Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Param6Handler::Param6Handler(O* object, M method) :
        Param6Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Param6Handler::Param6Handler(com_ptr<O>&& object, M method) :
        Param6Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param6Handler::Param6Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Param6Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Param6Handler::Param6Handler(std::shared_ptr<O>&& object, M method) :
        Param6Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param6Handler::Param6Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Param6Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Param6Handler::operator()(int16_t a, int16_t& b) const
    {
        int16_t result{};
        check_hresult((*(impl::abi_t<Param6Handler>**)this)->Invoke(a, &b, &result));
        return result;
    }
    template <typename L> Param7Handler::Param7Handler(L handler) :
        Param7Handler(impl::make_delegate<Param7Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Param7Handler::Param7Handler(F* handler) :
        Param7Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Param7Handler::Param7Handler(O* object, M method) :
        Param7Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Param7Handler::Param7Handler(com_ptr<O>&& object, M method) :
        Param7Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param7Handler::Param7Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Param7Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Param7Handler::Param7Handler(std::shared_ptr<O>&& object, M method) :
        Param7Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param7Handler::Param7Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Param7Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Param7Handler::operator()(int32_t a, int32_t& b) const
    {
        int32_t result{};
        check_hresult((*(impl::abi_t<Param7Handler>**)this)->Invoke(a, &b, &result));
        return result;
    }
    template <typename L> Param8Handler::Param8Handler(L handler) :
        Param8Handler(impl::make_delegate<Param8Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Param8Handler::Param8Handler(F* handler) :
        Param8Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Param8Handler::Param8Handler(O* object, M method) :
        Param8Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Param8Handler::Param8Handler(com_ptr<O>&& object, M method) :
        Param8Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param8Handler::Param8Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Param8Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Param8Handler::Param8Handler(std::shared_ptr<O>&& object, M method) :
        Param8Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param8Handler::Param8Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Param8Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Param8Handler::operator()(int64_t a, int64_t& b) const
    {
        int64_t result{};
        check_hresult((*(impl::abi_t<Param8Handler>**)this)->Invoke(a, &b, &result));
        return result;
    }
    template <typename L> Param9Handler::Param9Handler(L handler) :
        Param9Handler(impl::make_delegate<Param9Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Param9Handler::Param9Handler(F* handler) :
        Param9Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Param9Handler::Param9Handler(O* object, M method) :
        Param9Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Param9Handler::Param9Handler(com_ptr<O>&& object, M method) :
        Param9Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param9Handler::Param9Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Param9Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Param9Handler::Param9Handler(std::shared_ptr<O>&& object, M method) :
        Param9Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param9Handler::Param9Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Param9Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Param9Handler::operator()(float a, float& b) const
    {
        float result{};
        check_hresult((*(impl::abi_t<Param9Handler>**)this)->Invoke(a, &b, &result));
        return result;
    }
    template <typename L> TestHandler::TestHandler(L handler) :
        TestHandler(impl::make_delegate<TestHandler>(std::forward<L>(handler)))
    {
    }
    template <typename F> TestHandler::TestHandler(F* handler) :
        TestHandler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> TestHandler::TestHandler(O* object, M method) :
        TestHandler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> TestHandler::TestHandler(com_ptr<O>&& object, M method) :
        TestHandler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> TestHandler::TestHandler(weak_ref<O>&& object, LM&& lambda_or_method) :
        TestHandler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> TestHandler::TestHandler(std::shared_ptr<O>&& object, M method) :
        TestHandler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> TestHandler::TestHandler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        TestHandler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto TestHandler::operator()(winrt::TestComponent::ITests const& tests) const
    {
        check_hresult((*(impl::abi_t<TestHandler>**)this)->Invoke(*(void**)(&tests)));
    }
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::TestComponent::ITestRunnerStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::TestComponent::ITests> : winrt::impl::hash_base {};
    template<> struct hash<winrt::TestComponent::TestRunner> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}
#endif
