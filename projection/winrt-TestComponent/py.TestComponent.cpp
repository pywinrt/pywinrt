// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.TestComponent.h"

namespace py::cpp::TestComponent
{
    // ----- Class class --------------------

    static PyObject* _new_Class(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::TestComponent::Class instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Class(py::wrapper::TestComponent::Class* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Class_One(py::wrapper::TestComponent::Class* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.One());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_Class(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::TestComponent::Class>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Class(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::TestComponent::Class>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Class[] = {
        { "one", reinterpret_cast<PyCFunction>(Class_One), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Class, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Class), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Class[] = {
        { }
    };

    static PyType_Slot _type_slots_Class[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Class) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Class) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Class) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Class) },
        { }
    };

    static PyType_Spec type_spec_Class = {
        "winrt._winrt_testcomponent.Class",
        sizeof(py::wrapper::TestComponent::Class),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Class};

    // ----- Composable class --------------------

    struct PyWinrtComposable;
    using BasePyWinrtComposable = winrt::TestComponent::ComposableT<PyWinrtComposable, py::IPywinrtObject>;

    struct PyWinrtComposable : py::py_obj_ref, BasePyWinrtComposable
    {
        PyWinrtComposable(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtComposable() {}
        PyWinrtComposable(PyObject* py_obj, int32_t init) : py::py_obj_ref(py_obj), BasePyWinrtComposable(init) {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        int32_t GetComposableInner(winrt::Windows::Foundation::IInspectable& inner)
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtComposable* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_Composable(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::TestComponent::Composable>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtComposable>(self.get());

                    return self.detach();
                }

                winrt::TestComponent::Composable instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtComposable>(self.get(), param0);

                    return self.detach();
                }

                winrt::TestComponent::Composable instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Composable(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Composable_ExpectComposable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Composable>(args, 0);

                return py::convert(winrt::TestComponent::Composable::ExpectComposable(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Composable_ExpectRequiredFour(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::IRequiredFour>(args, 0);

                return py::convert(winrt::TestComponent::Composable::ExpectRequiredFour(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Composable_ExpectRequiredOne(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::IRequiredOne>(args, 0);

                return py::convert(winrt::TestComponent::Composable::ExpectRequiredOne(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Composable_ExpectRequiredThree(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::IRequiredThree>(args, 0);

                return py::convert(winrt::TestComponent::Composable::ExpectRequiredThree(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Composable_ExpectRequiredTwo(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::IRequiredTwo>(args, 0);

                return py::convert(winrt::TestComponent::Composable::ExpectRequiredTwo(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Composable_Four(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.try_as<winrt::TestComponent::Composable>().Four());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Composable_One(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.try_as<winrt::TestComponent::Composable>().One());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Composable_Three(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.try_as<winrt::TestComponent::Composable>().Three());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Composable_Two(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.try_as<winrt::TestComponent::Composable>().Two());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Composable_get_Value(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.try_as<winrt::TestComponent::Composable>().Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Composable_put_Value(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.try_as<winrt::TestComponent::Composable>().Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_Composable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::TestComponent::Composable>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Composable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::TestComponent::Composable>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Composable[] = {
        { "four", reinterpret_cast<PyCFunction>(Composable_Four), METH_VARARGS, nullptr },
        { "one", reinterpret_cast<PyCFunction>(Composable_One), METH_VARARGS, nullptr },
        { "three", reinterpret_cast<PyCFunction>(Composable_Three), METH_VARARGS, nullptr },
        { "two", reinterpret_cast<PyCFunction>(Composable_Two), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Composable, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Composable), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Composable[] = {
        { "value", reinterpret_cast<getter>(Composable_get_Value), reinterpret_cast<setter>(Composable_put_Value), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Composable[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Composable) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Composable) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Composable) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Composable) },
        { }
    };

    static PyType_Spec type_spec_Composable = {
        "winrt._winrt_testcomponent.Composable",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_Composable};

    static PyGetSetDef getset_Composable_Static[] = {
        { }
    };

    static PyMethodDef methods_Composable_Static[] = {
        { "expect_composable", reinterpret_cast<PyCFunction>(Composable_ExpectComposable), METH_VARARGS, nullptr },
        { "expect_required_four", reinterpret_cast<PyCFunction>(Composable_ExpectRequiredFour), METH_VARARGS, nullptr },
        { "expect_required_one", reinterpret_cast<PyCFunction>(Composable_ExpectRequiredOne), METH_VARARGS, nullptr },
        { "expect_required_three", reinterpret_cast<PyCFunction>(Composable_ExpectRequiredThree), METH_VARARGS, nullptr },
        { "expect_required_two", reinterpret_cast<PyCFunction>(Composable_ExpectRequiredTwo), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_Composable_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Composable_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Composable_Static) },
        { }
    };

    static PyType_Spec type_spec_Composable_Static =
    {
        "winrt._winrt_testcomponent.Composable_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_Composable_Static
    };

    // ----- Derived class --------------------

    struct PyWinrtDerived;
    using BasePyWinrtDerived = winrt::TestComponent::DerivedT<PyWinrtDerived, py::IPywinrtObject>;

    struct PyWinrtDerived : py::py_obj_ref, BasePyWinrtDerived
    {
        PyWinrtDerived(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtDerived() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        int32_t GetComposableInner(winrt::Windows::Foundation::IInspectable& inner)
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtDerived* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_Derived(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::TestComponent::Derived>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtDerived>(self.get());

                    return self.detach();
                }

                winrt::TestComponent::Derived instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Derived(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Derived(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::TestComponent::Derived>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Derived(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::TestComponent::Derived>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Derived[] = {
        { "_assign_array_", _assign_array_Derived, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Derived), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Derived[] = {
        { }
    };

    static PyType_Slot _type_slots_Derived[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Derived) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Derived) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Derived) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Derived) },
        { }
    };

    static PyType_Spec type_spec_Derived = {
        "winrt._winrt_testcomponent.Derived",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_Derived};

    static PyGetSetDef getset_Derived_Static[] = {
        { }
    };

    static PyMethodDef methods_Derived_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Derived_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Derived_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Derived_Static) },
        { }
    };

    static PyType_Spec type_spec_Derived_Static =
    {
        "winrt._winrt_testcomponent.Derived_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_Derived_Static
    };

    // ----- OverloadClass class --------------------

    struct PyWinrtOverloadClass;
    using BasePyWinrtOverloadClass = winrt::TestComponent::OverloadClassT<PyWinrtOverloadClass, py::IPywinrtObject>;

    struct PyWinrtOverloadClass : py::py_obj_ref, BasePyWinrtOverloadClass
    {
        PyWinrtOverloadClass(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtOverloadClass() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        int32_t GetComposableInner(winrt::Windows::Foundation::IInspectable& inner)
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtOverloadClass* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        void Overload(int32_t param0)
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_overload_with_one")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void Overload(int32_t param0, int32_t param1)
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_overload_with_two")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _new_OverloadClass(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::TestComponent::OverloadClass>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtOverloadClass>(self.get());

                    return self.detach();
                }

                winrt::TestComponent::OverloadClass instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_OverloadClass(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* OverloadClass_Overload(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.try_as<winrt::TestComponent::OverloadClass>().Overload();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OverloadClass_OverloadWithOne(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                py::get_inner_or_self(self->obj).try_as<winrt::TestComponent::IOverloadClassOverrides>().Overload(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OverloadClass_OverloadWithThree(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);

                self->obj.try_as<winrt::TestComponent::IOverloadClassProtected>().Overload(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OverloadClass_OverloadWithTwo(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                py::get_inner_or_self(self->obj).try_as<winrt::TestComponent::IOverloadClassOverrides2>().Overload(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_OverloadClass(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::TestComponent::OverloadClass>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_OverloadClass(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::TestComponent::OverloadClass>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_OverloadClass[] = {
        { "overload", reinterpret_cast<PyCFunction>(OverloadClass_Overload), METH_VARARGS, nullptr },
        { "_overload_with_one", reinterpret_cast<PyCFunction>(OverloadClass_OverloadWithOne), METH_VARARGS, nullptr },
        { "_overload_with_three", reinterpret_cast<PyCFunction>(OverloadClass_OverloadWithThree), METH_VARARGS, nullptr },
        { "_overload_with_two", reinterpret_cast<PyCFunction>(OverloadClass_OverloadWithTwo), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_OverloadClass, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_OverloadClass), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_OverloadClass[] = {
        { }
    };

    static PyType_Slot _type_slots_OverloadClass[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_OverloadClass) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_OverloadClass) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_OverloadClass) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_OverloadClass) },
        { }
    };

    static PyType_Spec type_spec_OverloadClass = {
        "winrt._winrt_testcomponent.OverloadClass",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_OverloadClass};

    static PyGetSetDef getset_OverloadClass_Static[] = {
        { }
    };

    static PyMethodDef methods_OverloadClass_Static[] = {
        { }
    };

    static PyType_Slot type_slots_OverloadClass_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_OverloadClass_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_OverloadClass_Static) },
        { }
    };

    static PyType_Spec type_spec_OverloadClass_Static =
    {
        "winrt._winrt_testcomponent.OverloadClass_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_OverloadClass_Static
    };

    // ----- Override class --------------------

    struct PyWinrtOverride;
    using BasePyWinrtOverride = winrt::TestComponent::OverrideT<PyWinrtOverride, py::IPywinrtObject>;

    struct PyWinrtOverride : py::py_obj_ref, BasePyWinrtOverride
    {
        PyWinrtOverride(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtOverride() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        int32_t GetComposableInner(winrt::Windows::Foundation::IInspectable& inner)
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtOverride* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        void OnOverridable()
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_on_overridable")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _new_Override(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::TestComponent::Override>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = winrt::make<PyWinrtOverride>(self.get());

                    return self.detach();
                }

                winrt::TestComponent::Override instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Override(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Override_CallOverridable(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.try_as<winrt::TestComponent::Override>().CallOverridable();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Override_CallProtected(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.try_as<winrt::TestComponent::Override>().CallProtected();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Override_OnOverridable(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                py::get_inner_or_self(self->obj).try_as<winrt::TestComponent::IOverrideOverrides>().OnOverridable();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Override_OnProtected(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.try_as<winrt::TestComponent::IOverrideProtected>().OnProtected();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Override_add_OverridableCalled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.try_as<winrt::TestComponent::Override>().OverridableCalled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Override_remove_OverridableCalled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::TestComponent::Override>().OverridableCalled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Override_add_ProtectedCalled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.try_as<winrt::TestComponent::Override>().ProtectedCalled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Override_remove_ProtectedCalled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::TestComponent::Override>().ProtectedCalled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Override(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::TestComponent::Override>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Override(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::TestComponent::Override>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Override[] = {
        { "call_overridable", reinterpret_cast<PyCFunction>(Override_CallOverridable), METH_VARARGS, nullptr },
        { "call_protected", reinterpret_cast<PyCFunction>(Override_CallProtected), METH_VARARGS, nullptr },
        { "_on_overridable", reinterpret_cast<PyCFunction>(Override_OnOverridable), METH_VARARGS, nullptr },
        { "_on_protected", reinterpret_cast<PyCFunction>(Override_OnProtected), METH_VARARGS, nullptr },
        { "add_overridable_called", reinterpret_cast<PyCFunction>(Override_add_OverridableCalled), METH_O, nullptr },
        { "remove_overridable_called", reinterpret_cast<PyCFunction>(Override_remove_OverridableCalled), METH_O, nullptr },
        { "add_protected_called", reinterpret_cast<PyCFunction>(Override_add_ProtectedCalled), METH_O, nullptr },
        { "remove_protected_called", reinterpret_cast<PyCFunction>(Override_remove_ProtectedCalled), METH_O, nullptr },
        { "_assign_array_", _assign_array_Override, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Override), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Override[] = {
        { }
    };

    static PyType_Slot _type_slots_Override[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Override) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Override) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Override) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Override) },
        { }
    };

    static PyType_Spec type_spec_Override = {
        "winrt._winrt_testcomponent.Override",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_Override};

    static PyGetSetDef getset_Override_Static[] = {
        { }
    };

    static PyMethodDef methods_Override_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Override_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Override_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Override_Static) },
        { }
    };

    static PyType_Spec type_spec_Override_Static =
    {
        "winrt._winrt_testcomponent.Override_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_Override_Static
    };

    // ----- TestRunner class --------------------

    static PyObject* _new_TestRunner(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::TestComponent::TestRunner>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::TestComponent::TestRunner>::type_name);
        return nullptr;
    }

    static PyObject* TestRunner_CreateAsyncAction(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(winrt::TestComponent::TestRunner::CreateAsyncAction(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TestRunner_CreateInt32Vector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::TestComponent::TestRunner::CreateInt32Vector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TestRunner_CreateStringVector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::TestComponent::TestRunner::CreateStringVector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TestRunner_CreateStringableVector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::TestComponent::TestRunner::CreateStringableVector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TestRunner_CreateTimeSpan(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(winrt::TestComponent::TestRunner::CreateTimeSpan(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TestRunner_ExpectObject(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(winrt::TestComponent::TestRunner::ExpectObject(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TestRunner_MakeTests(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::TestComponent::TestRunner::MakeTests());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TestRunner_TestConsumer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::TestHandler>(args, 0);

                return py::convert(winrt::TestComponent::TestRunner::TestConsumer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TestRunner_TestProducer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::ITests>(args, 0);

                winrt::TestComponent::TestRunner::TestProducer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TestRunner_TestSelf(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::TestComponent::TestRunner::TestSelf();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_TestRunner[] = {
        { }
    };

    static PyGetSetDef _getset_TestRunner[] = {
        { }
    };

    static PyType_Slot _type_slots_TestRunner[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TestRunner) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TestRunner) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TestRunner) },
        { }
    };

    static PyType_Spec type_spec_TestRunner = {
        "winrt._winrt_testcomponent.TestRunner",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TestRunner};

    static PyGetSetDef getset_TestRunner_Static[] = {
        { }
    };

    static PyMethodDef methods_TestRunner_Static[] = {
        { "create_async_action", reinterpret_cast<PyCFunction>(TestRunner_CreateAsyncAction), METH_VARARGS, nullptr },
        { "create_int32_vector", reinterpret_cast<PyCFunction>(TestRunner_CreateInt32Vector), METH_VARARGS, nullptr },
        { "create_string_vector", reinterpret_cast<PyCFunction>(TestRunner_CreateStringVector), METH_VARARGS, nullptr },
        { "create_stringable_vector", reinterpret_cast<PyCFunction>(TestRunner_CreateStringableVector), METH_VARARGS, nullptr },
        { "create_time_span", reinterpret_cast<PyCFunction>(TestRunner_CreateTimeSpan), METH_VARARGS, nullptr },
        { "expect_object", reinterpret_cast<PyCFunction>(TestRunner_ExpectObject), METH_VARARGS, nullptr },
        { "make_tests", reinterpret_cast<PyCFunction>(TestRunner_MakeTests), METH_VARARGS, nullptr },
        { "test_consumer", reinterpret_cast<PyCFunction>(TestRunner_TestConsumer), METH_VARARGS, nullptr },
        { "test_producer", reinterpret_cast<PyCFunction>(TestRunner_TestProducer), METH_VARARGS, nullptr },
        { "test_self", reinterpret_cast<PyCFunction>(TestRunner_TestSelf), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_TestRunner_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TestRunner_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TestRunner_Static) },
        { }
    };

    static PyType_Spec type_spec_TestRunner_Static =
    {
        "winrt._winrt_testcomponent.TestRunner_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TestRunner_Static
    };

    // ----- IRequiredFour interface --------------------

    static PyObject* _new_IRequiredFour(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::TestComponent::IRequiredFour>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::TestComponent::IRequiredFour>::type_name);
        return nullptr;
    }

    static void _dealloc_IRequiredFour(py::wrapper::TestComponent::IRequiredFour* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IRequiredFour_Four(py::wrapper::TestComponent::IRequiredFour* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Four());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRequiredFour_One(py::wrapper::TestComponent::IRequiredFour* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.One());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRequiredFour_Three(py::wrapper::TestComponent::IRequiredFour* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Three());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRequiredFour_Two(py::wrapper::TestComponent::IRequiredFour* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Two());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IRequiredFour(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::TestComponent::IRequiredFour>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IRequiredFour(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::TestComponent::IRequiredFour>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IRequiredFour[] = {
        { "four", reinterpret_cast<PyCFunction>(IRequiredFour_Four), METH_VARARGS, nullptr },
        { "one", reinterpret_cast<PyCFunction>(IRequiredFour_One), METH_VARARGS, nullptr },
        { "three", reinterpret_cast<PyCFunction>(IRequiredFour_Three), METH_VARARGS, nullptr },
        { "two", reinterpret_cast<PyCFunction>(IRequiredFour_Two), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IRequiredFour, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IRequiredFour), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IRequiredFour[] = {
        { }
    };

    static PyType_Slot _type_slots_IRequiredFour[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IRequiredFour) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IRequiredFour) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IRequiredFour) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IRequiredFour) },
        { }
    };

    static PyType_Spec type_spec_IRequiredFour = {
        "winrt._winrt_testcomponent.IRequiredFour",
        sizeof(py::wrapper::TestComponent::IRequiredFour),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IRequiredFour};

    // ----- IRequiredOne interface --------------------

    static PyObject* _new_IRequiredOne(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::TestComponent::IRequiredOne>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::TestComponent::IRequiredOne>::type_name);
        return nullptr;
    }

    static void _dealloc_IRequiredOne(py::wrapper::TestComponent::IRequiredOne* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IRequiredOne_One(py::wrapper::TestComponent::IRequiredOne* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.One());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IRequiredOne(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::TestComponent::IRequiredOne>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IRequiredOne(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::TestComponent::IRequiredOne>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IRequiredOne[] = {
        { "one", reinterpret_cast<PyCFunction>(IRequiredOne_One), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IRequiredOne, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IRequiredOne), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IRequiredOne[] = {
        { }
    };

    static PyType_Slot _type_slots_IRequiredOne[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IRequiredOne) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IRequiredOne) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IRequiredOne) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IRequiredOne) },
        { }
    };

    static PyType_Spec type_spec_IRequiredOne = {
        "winrt._winrt_testcomponent.IRequiredOne",
        sizeof(py::wrapper::TestComponent::IRequiredOne),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IRequiredOne};

    // ----- IRequiredThree interface --------------------

    static PyObject* _new_IRequiredThree(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::TestComponent::IRequiredThree>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::TestComponent::IRequiredThree>::type_name);
        return nullptr;
    }

    static void _dealloc_IRequiredThree(py::wrapper::TestComponent::IRequiredThree* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IRequiredThree_One(py::wrapper::TestComponent::IRequiredThree* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.One());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRequiredThree_Three(py::wrapper::TestComponent::IRequiredThree* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Three());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRequiredThree_Two(py::wrapper::TestComponent::IRequiredThree* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Two());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IRequiredThree(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::TestComponent::IRequiredThree>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IRequiredThree(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::TestComponent::IRequiredThree>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IRequiredThree[] = {
        { "one", reinterpret_cast<PyCFunction>(IRequiredThree_One), METH_VARARGS, nullptr },
        { "three", reinterpret_cast<PyCFunction>(IRequiredThree_Three), METH_VARARGS, nullptr },
        { "two", reinterpret_cast<PyCFunction>(IRequiredThree_Two), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IRequiredThree, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IRequiredThree), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IRequiredThree[] = {
        { }
    };

    static PyType_Slot _type_slots_IRequiredThree[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IRequiredThree) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IRequiredThree) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IRequiredThree) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IRequiredThree) },
        { }
    };

    static PyType_Spec type_spec_IRequiredThree = {
        "winrt._winrt_testcomponent.IRequiredThree",
        sizeof(py::wrapper::TestComponent::IRequiredThree),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IRequiredThree};

    // ----- IRequiredTwo interface --------------------

    static PyObject* _new_IRequiredTwo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::TestComponent::IRequiredTwo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::TestComponent::IRequiredTwo>::type_name);
        return nullptr;
    }

    static void _dealloc_IRequiredTwo(py::wrapper::TestComponent::IRequiredTwo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IRequiredTwo_One(py::wrapper::TestComponent::IRequiredTwo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.One());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRequiredTwo_Two(py::wrapper::TestComponent::IRequiredTwo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Two());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IRequiredTwo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::TestComponent::IRequiredTwo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IRequiredTwo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::TestComponent::IRequiredTwo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IRequiredTwo[] = {
        { "one", reinterpret_cast<PyCFunction>(IRequiredTwo_One), METH_VARARGS, nullptr },
        { "two", reinterpret_cast<PyCFunction>(IRequiredTwo_Two), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IRequiredTwo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IRequiredTwo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IRequiredTwo[] = {
        { }
    };

    static PyType_Slot _type_slots_IRequiredTwo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IRequiredTwo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IRequiredTwo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IRequiredTwo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IRequiredTwo) },
        { }
    };

    static PyType_Spec type_spec_IRequiredTwo = {
        "winrt._winrt_testcomponent.IRequiredTwo",
        sizeof(py::wrapper::TestComponent::IRequiredTwo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IRequiredTwo};

    // ----- ITests interface --------------------

    static PyObject* _new_ITests(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::TestComponent::ITests>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::TestComponent::ITests>::type_name);
        return nullptr;
    }

    static void _dealloc_ITests(py::wrapper::TestComponent::ITests* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ITests_Array1(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<py::pybuf_view<bool, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<bool, true>>(args, 1);
                winrt::com_array<bool> param2{};

                auto return_value = self->obj.Array1(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array10(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<py::pybuf_view<double, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<double, true>>(args, 1);
                winrt::com_array<double> param2{};

                auto return_value = self->obj.Array10(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array10Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Array10Handler>(args, 0);

                self->obj.Array10Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array11(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<py::pybuf_view<char16_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<char16_t, true>>(args, 1);
                winrt::com_array<char16_t> param2{};

                auto return_value = self->obj.Array11(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array11Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Array11Handler>(args, 0);

                self->obj.Array11Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array12(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::hstring, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::hstring, true>>(args, 1);
                winrt::com_array<winrt::hstring> param2{};

                auto return_value = self->obj.Array12(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array12Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Array12Handler>(args, 0);

                self->obj.Array12Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array13(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::TestComponent::Blittable, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::TestComponent::Blittable, true>>(args, 1);
                winrt::com_array<winrt::TestComponent::Blittable> param2{};

                auto return_value = self->obj.Array13(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array13Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Array13Handler>(args, 0);

                self->obj.Array13Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array14(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::TestComponent::NonBlittable, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::TestComponent::NonBlittable, true>>(args, 1);
                winrt::com_array<winrt::TestComponent::NonBlittable> param2{};

                auto return_value = self->obj.Array14(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array14Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Array14Handler>(args, 0);

                self->obj.Array14Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array15(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::TestComponent::Nested, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::TestComponent::Nested, true>>(args, 1);
                winrt::com_array<winrt::TestComponent::Nested> param2{};

                auto return_value = self->obj.Array15(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array15Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Array15Handler>(args, 0);

                self->obj.Array15Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array16(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::IStringable, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::IStringable, true>>(args, 1);
                winrt::com_array<winrt::Windows::Foundation::IStringable> param2{};

                auto return_value = self->obj.Array16(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array16Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Array16Handler>(args, 0);

                self->obj.Array16Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array1Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Array1Handler>(args, 0);

                self->obj.Array1Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array2(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, true>>(args, 1);
                winrt::com_array<uint8_t> param2{};

                auto return_value = self->obj.Array2(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array2Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Array2Handler>(args, 0);

                self->obj.Array2Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array3(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint16_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint16_t, true>>(args, 1);
                winrt::com_array<uint16_t> param2{};

                auto return_value = self->obj.Array3(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array3Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Array3Handler>(args, 0);

                self->obj.Array3Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array4(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint32_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint32_t, true>>(args, 1);
                winrt::com_array<uint32_t> param2{};

                auto return_value = self->obj.Array4(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array4Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Array4Handler>(args, 0);

                self->obj.Array4Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array5(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint64_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint64_t, true>>(args, 1);
                winrt::com_array<uint64_t> param2{};

                auto return_value = self->obj.Array5(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array5Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Array5Handler>(args, 0);

                self->obj.Array5Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array6(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int16_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int16_t, true>>(args, 1);
                winrt::com_array<int16_t> param2{};

                auto return_value = self->obj.Array6(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array6Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Array6Handler>(args, 0);

                self->obj.Array6Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array7(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int32_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int32_t, true>>(args, 1);
                winrt::com_array<int32_t> param2{};

                auto return_value = self->obj.Array7(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array7Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Array7Handler>(args, 0);

                self->obj.Array7Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array8(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int64_t, true>>(args, 1);
                winrt::com_array<int64_t> param2{};

                auto return_value = self->obj.Array8(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array8Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Array8Handler>(args, 0);

                self->obj.Array8Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array9(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<py::pybuf_view<float, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<float, true>>(args, 1);
                winrt::com_array<float> param2{};

                auto return_value = self->obj.Array9(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array9Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Array9Handler>(args, 0);

                self->obj.Array9Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Async1(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IAsyncAction>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.Async1(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Async1Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Async1Handler>(args, 0);

                self->obj.Async1Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Async2(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IAsyncAction>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);

                return py::convert(self->obj.Async2(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Async2Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Async2Handler>(args, 0);

                self->obj.Async2Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Async3(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IAsyncAction>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);

                return py::convert(self->obj.Async3(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Async3Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Async3Handler>(args, 0);

                self->obj.Async3Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Async4(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IAsyncAction>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                return py::convert(self->obj.Async4(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Async4Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Async4Handler>(args, 0);

                self->obj.Async4Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Box1(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Box1(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Box10(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Box10(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Box11(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Box11(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Box12(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<char16_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Box12(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Box13(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Box13(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Box14(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Box14(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Box15(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Blittable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Box15(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Box16(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::NonBlittable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Box16(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Box17(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Box17(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Box18(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Box18(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Box19(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<py::pybuf_view<bool, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Box19(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Box2(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Box2(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Box20(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::hstring, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Box20(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Box21(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::TimeSpan, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Box21(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Box3(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Box3(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Box4(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Box4(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Box5(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int16_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Box5(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Box6(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Box6(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Box7(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int64_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Box7(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Box8(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Box8(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Box9(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Box9(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Collection1(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                winrt::Windows::Foundation::Collections::IIterable<winrt::hstring> param1{nullptr};

                auto return_value = self->obj.Collection1(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Collection1Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Collection1Handler>(args, 0);

                self->obj.Collection1Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Collection2(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::hstring>>>(args, 0);
                winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::hstring>> param1{nullptr};

                auto return_value = self->obj.Collection2(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Collection2Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Collection2Handler>(args, 0);

                self->obj.Collection2Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Collection3(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::hstring>>(args, 0);
                winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::hstring> param1{nullptr};

                auto return_value = self->obj.Collection3(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Collection3Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Collection3Handler>(args, 0);

                self->obj.Collection3Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Collection4(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::hstring>>(args, 0);
                winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::hstring> param1{nullptr};

                auto return_value = self->obj.Collection4(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Collection4Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Collection4Handler>(args, 0);

                self->obj.Collection4Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Collection5(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::hstring>>(args, 0);
                winrt::Windows::Foundation::Collections::IVector<winrt::hstring> param1{nullptr};

                auto return_value = self->obj.Collection5(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Collection5Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Collection5Handler>(args, 0);

                self->obj.Collection5Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Collection6(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::hstring>>(args, 0);
                winrt::Windows::Foundation::Collections::IVectorView<winrt::hstring> param1{nullptr};

                auto return_value = self->obj.Collection6(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Collection6Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Collection6Handler>(args, 0);

                self->obj.Collection6Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Event1Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.Event1Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Event2Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.Event2Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_GetBlittableVectorSubset(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::TestComponent::Blittable>>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.GetBlittableVectorSubset(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_GetBooleanVectorSubset(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<bool>>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.GetBooleanVectorSubset(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_GetClassVectorSubset(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::TestComponent::Class>>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.GetClassVectorSubset(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_GetComposableClassVectorSubset(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::TestComponent::Composable>>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.GetComposableClassVectorSubset(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_GetInterfaceVectorSubset(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::TestComponent::IRequiredOne>>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.GetInterfaceVectorSubset(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_GetNonBlittableVectorSubset(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::TestComponent::NonBlittable>>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.GetNonBlittableVectorSubset(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_GetObjectVectorSubset(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Foundation::IInspectable>>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.GetObjectVectorSubset(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_GetStringVectorSubset(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.GetStringVectorSubset(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param1(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);
                bool param1{};

                auto return_value = self->obj.Param1(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param10(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                double param1{};

                auto return_value = self->obj.Param10(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param10Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Param10Handler>(args, 0);

                self->obj.Param10Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param11(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<char16_t>(args, 0);
                char16_t param1{};

                auto return_value = self->obj.Param11(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param11Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Param11Handler>(args, 0);

                self->obj.Param11Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param12(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::hstring param1{};

                auto return_value = self->obj.Param12(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param12Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Param12Handler>(args, 0);

                self->obj.Param12Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param13(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Blittable>(args, 0);
                auto param1 = py::convert_to<winrt::TestComponent::Blittable>(args, 1);
                winrt::TestComponent::Blittable param2{};

                auto return_value = self->obj.Param13(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param13Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Param13Handler>(args, 0);

                self->obj.Param13Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param14(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::NonBlittable>(args, 0);
                auto param1 = py::convert_to<winrt::TestComponent::NonBlittable>(args, 1);
                winrt::TestComponent::NonBlittable param2{};

                auto return_value = self->obj.Param14(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param14Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Param14Handler>(args, 0);

                self->obj.Param14Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param15(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Nested>(args, 0);
                auto param1 = py::convert_to<winrt::TestComponent::Nested>(args, 1);
                winrt::TestComponent::Nested param2{};

                auto return_value = self->obj.Param15(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param15Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Param15Handler>(args, 0);

                self->obj.Param15Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param1Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Param1Handler>(args, 0);

                self->obj.Param1Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param2(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                uint8_t param1{};

                auto return_value = self->obj.Param2(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param2Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Param2Handler>(args, 0);

                self->obj.Param2Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param3(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);
                uint16_t param1{};

                auto return_value = self->obj.Param3(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param3Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Param3Handler>(args, 0);

                self->obj.Param3Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param4(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                uint32_t param1{};

                auto return_value = self->obj.Param4(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param4Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Param4Handler>(args, 0);

                self->obj.Param4Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param5(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);
                uint64_t param1{};

                auto return_value = self->obj.Param5(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param5Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Param5Handler>(args, 0);

                self->obj.Param5Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param6(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int16_t>(args, 0);
                int16_t param1{};

                auto return_value = self->obj.Param6(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param6Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Param6Handler>(args, 0);

                self->obj.Param6Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param7(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                int32_t param1{};

                auto return_value = self->obj.Param7(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param7Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Param7Handler>(args, 0);

                self->obj.Param7Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param8(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int64_t>(args, 0);
                int64_t param1{};

                auto return_value = self->obj.Param8(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param8Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Param8Handler>(args, 0);

                self->obj.Param8Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param9(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<float>(args, 0);
                float param1{};

                auto return_value = self->obj.Param9(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param9Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Param9Handler>(args, 0);

                self->obj.Param9Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Simple(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Simple();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_get_Percentage(py::wrapper::TestComponent::ITests* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Percentage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITests_add_Event1(py::wrapper::TestComponent::ITests* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<int32_t>>(arg);

            return py::convert(self->obj.Event1(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITests_remove_Event1(py::wrapper::TestComponent::ITests* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Event1(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITests_add_Event2(py::wrapper::TestComponent::ITests* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::TestComponent::ITests, int32_t>>(arg);

            return py::convert(self->obj.Event2(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITests_remove_Event2(py::wrapper::TestComponent::ITests* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Event2(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ITests(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::TestComponent::ITests>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ITests(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::TestComponent::ITests>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITests[] = {
        { "array1", reinterpret_cast<PyCFunction>(ITests_Array1), METH_VARARGS, nullptr },
        { "array10", reinterpret_cast<PyCFunction>(ITests_Array10), METH_VARARGS, nullptr },
        { "array10_call", reinterpret_cast<PyCFunction>(ITests_Array10Call), METH_VARARGS, nullptr },
        { "array11", reinterpret_cast<PyCFunction>(ITests_Array11), METH_VARARGS, nullptr },
        { "array11_call", reinterpret_cast<PyCFunction>(ITests_Array11Call), METH_VARARGS, nullptr },
        { "array12", reinterpret_cast<PyCFunction>(ITests_Array12), METH_VARARGS, nullptr },
        { "array12_call", reinterpret_cast<PyCFunction>(ITests_Array12Call), METH_VARARGS, nullptr },
        { "array13", reinterpret_cast<PyCFunction>(ITests_Array13), METH_VARARGS, nullptr },
        { "array13_call", reinterpret_cast<PyCFunction>(ITests_Array13Call), METH_VARARGS, nullptr },
        { "array14", reinterpret_cast<PyCFunction>(ITests_Array14), METH_VARARGS, nullptr },
        { "array14_call", reinterpret_cast<PyCFunction>(ITests_Array14Call), METH_VARARGS, nullptr },
        { "array15", reinterpret_cast<PyCFunction>(ITests_Array15), METH_VARARGS, nullptr },
        { "array15_call", reinterpret_cast<PyCFunction>(ITests_Array15Call), METH_VARARGS, nullptr },
        { "array16", reinterpret_cast<PyCFunction>(ITests_Array16), METH_VARARGS, nullptr },
        { "array16_call", reinterpret_cast<PyCFunction>(ITests_Array16Call), METH_VARARGS, nullptr },
        { "array1_call", reinterpret_cast<PyCFunction>(ITests_Array1Call), METH_VARARGS, nullptr },
        { "array2", reinterpret_cast<PyCFunction>(ITests_Array2), METH_VARARGS, nullptr },
        { "array2_call", reinterpret_cast<PyCFunction>(ITests_Array2Call), METH_VARARGS, nullptr },
        { "array3", reinterpret_cast<PyCFunction>(ITests_Array3), METH_VARARGS, nullptr },
        { "array3_call", reinterpret_cast<PyCFunction>(ITests_Array3Call), METH_VARARGS, nullptr },
        { "array4", reinterpret_cast<PyCFunction>(ITests_Array4), METH_VARARGS, nullptr },
        { "array4_call", reinterpret_cast<PyCFunction>(ITests_Array4Call), METH_VARARGS, nullptr },
        { "array5", reinterpret_cast<PyCFunction>(ITests_Array5), METH_VARARGS, nullptr },
        { "array5_call", reinterpret_cast<PyCFunction>(ITests_Array5Call), METH_VARARGS, nullptr },
        { "array6", reinterpret_cast<PyCFunction>(ITests_Array6), METH_VARARGS, nullptr },
        { "array6_call", reinterpret_cast<PyCFunction>(ITests_Array6Call), METH_VARARGS, nullptr },
        { "array7", reinterpret_cast<PyCFunction>(ITests_Array7), METH_VARARGS, nullptr },
        { "array7_call", reinterpret_cast<PyCFunction>(ITests_Array7Call), METH_VARARGS, nullptr },
        { "array8", reinterpret_cast<PyCFunction>(ITests_Array8), METH_VARARGS, nullptr },
        { "array8_call", reinterpret_cast<PyCFunction>(ITests_Array8Call), METH_VARARGS, nullptr },
        { "array9", reinterpret_cast<PyCFunction>(ITests_Array9), METH_VARARGS, nullptr },
        { "array9_call", reinterpret_cast<PyCFunction>(ITests_Array9Call), METH_VARARGS, nullptr },
        { "async1", reinterpret_cast<PyCFunction>(ITests_Async1), METH_VARARGS, nullptr },
        { "async1_call", reinterpret_cast<PyCFunction>(ITests_Async1Call), METH_VARARGS, nullptr },
        { "async2", reinterpret_cast<PyCFunction>(ITests_Async2), METH_VARARGS, nullptr },
        { "async2_call", reinterpret_cast<PyCFunction>(ITests_Async2Call), METH_VARARGS, nullptr },
        { "async3", reinterpret_cast<PyCFunction>(ITests_Async3), METH_VARARGS, nullptr },
        { "async3_call", reinterpret_cast<PyCFunction>(ITests_Async3Call), METH_VARARGS, nullptr },
        { "async4", reinterpret_cast<PyCFunction>(ITests_Async4), METH_VARARGS, nullptr },
        { "async4_call", reinterpret_cast<PyCFunction>(ITests_Async4Call), METH_VARARGS, nullptr },
        { "box1", reinterpret_cast<PyCFunction>(ITests_Box1), METH_VARARGS, nullptr },
        { "box10", reinterpret_cast<PyCFunction>(ITests_Box10), METH_VARARGS, nullptr },
        { "box11", reinterpret_cast<PyCFunction>(ITests_Box11), METH_VARARGS, nullptr },
        { "box12", reinterpret_cast<PyCFunction>(ITests_Box12), METH_VARARGS, nullptr },
        { "box13", reinterpret_cast<PyCFunction>(ITests_Box13), METH_VARARGS, nullptr },
        { "box14", reinterpret_cast<PyCFunction>(ITests_Box14), METH_VARARGS, nullptr },
        { "box15", reinterpret_cast<PyCFunction>(ITests_Box15), METH_VARARGS, nullptr },
        { "box16", reinterpret_cast<PyCFunction>(ITests_Box16), METH_VARARGS, nullptr },
        { "box17", reinterpret_cast<PyCFunction>(ITests_Box17), METH_VARARGS, nullptr },
        { "box18", reinterpret_cast<PyCFunction>(ITests_Box18), METH_VARARGS, nullptr },
        { "box19", reinterpret_cast<PyCFunction>(ITests_Box19), METH_VARARGS, nullptr },
        { "box2", reinterpret_cast<PyCFunction>(ITests_Box2), METH_VARARGS, nullptr },
        { "box20", reinterpret_cast<PyCFunction>(ITests_Box20), METH_VARARGS, nullptr },
        { "box21", reinterpret_cast<PyCFunction>(ITests_Box21), METH_VARARGS, nullptr },
        { "box3", reinterpret_cast<PyCFunction>(ITests_Box3), METH_VARARGS, nullptr },
        { "box4", reinterpret_cast<PyCFunction>(ITests_Box4), METH_VARARGS, nullptr },
        { "box5", reinterpret_cast<PyCFunction>(ITests_Box5), METH_VARARGS, nullptr },
        { "box6", reinterpret_cast<PyCFunction>(ITests_Box6), METH_VARARGS, nullptr },
        { "box7", reinterpret_cast<PyCFunction>(ITests_Box7), METH_VARARGS, nullptr },
        { "box8", reinterpret_cast<PyCFunction>(ITests_Box8), METH_VARARGS, nullptr },
        { "box9", reinterpret_cast<PyCFunction>(ITests_Box9), METH_VARARGS, nullptr },
        { "collection1", reinterpret_cast<PyCFunction>(ITests_Collection1), METH_VARARGS, nullptr },
        { "collection1_call", reinterpret_cast<PyCFunction>(ITests_Collection1Call), METH_VARARGS, nullptr },
        { "collection2", reinterpret_cast<PyCFunction>(ITests_Collection2), METH_VARARGS, nullptr },
        { "collection2_call", reinterpret_cast<PyCFunction>(ITests_Collection2Call), METH_VARARGS, nullptr },
        { "collection3", reinterpret_cast<PyCFunction>(ITests_Collection3), METH_VARARGS, nullptr },
        { "collection3_call", reinterpret_cast<PyCFunction>(ITests_Collection3Call), METH_VARARGS, nullptr },
        { "collection4", reinterpret_cast<PyCFunction>(ITests_Collection4), METH_VARARGS, nullptr },
        { "collection4_call", reinterpret_cast<PyCFunction>(ITests_Collection4Call), METH_VARARGS, nullptr },
        { "collection5", reinterpret_cast<PyCFunction>(ITests_Collection5), METH_VARARGS, nullptr },
        { "collection5_call", reinterpret_cast<PyCFunction>(ITests_Collection5Call), METH_VARARGS, nullptr },
        { "collection6", reinterpret_cast<PyCFunction>(ITests_Collection6), METH_VARARGS, nullptr },
        { "collection6_call", reinterpret_cast<PyCFunction>(ITests_Collection6Call), METH_VARARGS, nullptr },
        { "event1_call", reinterpret_cast<PyCFunction>(ITests_Event1Call), METH_VARARGS, nullptr },
        { "event2_call", reinterpret_cast<PyCFunction>(ITests_Event2Call), METH_VARARGS, nullptr },
        { "get_blittable_vector_subset", reinterpret_cast<PyCFunction>(ITests_GetBlittableVectorSubset), METH_VARARGS, nullptr },
        { "get_boolean_vector_subset", reinterpret_cast<PyCFunction>(ITests_GetBooleanVectorSubset), METH_VARARGS, nullptr },
        { "get_class_vector_subset", reinterpret_cast<PyCFunction>(ITests_GetClassVectorSubset), METH_VARARGS, nullptr },
        { "get_composable_class_vector_subset", reinterpret_cast<PyCFunction>(ITests_GetComposableClassVectorSubset), METH_VARARGS, nullptr },
        { "get_interface_vector_subset", reinterpret_cast<PyCFunction>(ITests_GetInterfaceVectorSubset), METH_VARARGS, nullptr },
        { "get_non_blittable_vector_subset", reinterpret_cast<PyCFunction>(ITests_GetNonBlittableVectorSubset), METH_VARARGS, nullptr },
        { "get_object_vector_subset", reinterpret_cast<PyCFunction>(ITests_GetObjectVectorSubset), METH_VARARGS, nullptr },
        { "get_string_vector_subset", reinterpret_cast<PyCFunction>(ITests_GetStringVectorSubset), METH_VARARGS, nullptr },
        { "param1", reinterpret_cast<PyCFunction>(ITests_Param1), METH_VARARGS, nullptr },
        { "param10", reinterpret_cast<PyCFunction>(ITests_Param10), METH_VARARGS, nullptr },
        { "param10_call", reinterpret_cast<PyCFunction>(ITests_Param10Call), METH_VARARGS, nullptr },
        { "param11", reinterpret_cast<PyCFunction>(ITests_Param11), METH_VARARGS, nullptr },
        { "param11_call", reinterpret_cast<PyCFunction>(ITests_Param11Call), METH_VARARGS, nullptr },
        { "param12", reinterpret_cast<PyCFunction>(ITests_Param12), METH_VARARGS, nullptr },
        { "param12_call", reinterpret_cast<PyCFunction>(ITests_Param12Call), METH_VARARGS, nullptr },
        { "param13", reinterpret_cast<PyCFunction>(ITests_Param13), METH_VARARGS, nullptr },
        { "param13_call", reinterpret_cast<PyCFunction>(ITests_Param13Call), METH_VARARGS, nullptr },
        { "param14", reinterpret_cast<PyCFunction>(ITests_Param14), METH_VARARGS, nullptr },
        { "param14_call", reinterpret_cast<PyCFunction>(ITests_Param14Call), METH_VARARGS, nullptr },
        { "param15", reinterpret_cast<PyCFunction>(ITests_Param15), METH_VARARGS, nullptr },
        { "param15_call", reinterpret_cast<PyCFunction>(ITests_Param15Call), METH_VARARGS, nullptr },
        { "param1_call", reinterpret_cast<PyCFunction>(ITests_Param1Call), METH_VARARGS, nullptr },
        { "param2", reinterpret_cast<PyCFunction>(ITests_Param2), METH_VARARGS, nullptr },
        { "param2_call", reinterpret_cast<PyCFunction>(ITests_Param2Call), METH_VARARGS, nullptr },
        { "param3", reinterpret_cast<PyCFunction>(ITests_Param3), METH_VARARGS, nullptr },
        { "param3_call", reinterpret_cast<PyCFunction>(ITests_Param3Call), METH_VARARGS, nullptr },
        { "param4", reinterpret_cast<PyCFunction>(ITests_Param4), METH_VARARGS, nullptr },
        { "param4_call", reinterpret_cast<PyCFunction>(ITests_Param4Call), METH_VARARGS, nullptr },
        { "param5", reinterpret_cast<PyCFunction>(ITests_Param5), METH_VARARGS, nullptr },
        { "param5_call", reinterpret_cast<PyCFunction>(ITests_Param5Call), METH_VARARGS, nullptr },
        { "param6", reinterpret_cast<PyCFunction>(ITests_Param6), METH_VARARGS, nullptr },
        { "param6_call", reinterpret_cast<PyCFunction>(ITests_Param6Call), METH_VARARGS, nullptr },
        { "param7", reinterpret_cast<PyCFunction>(ITests_Param7), METH_VARARGS, nullptr },
        { "param7_call", reinterpret_cast<PyCFunction>(ITests_Param7Call), METH_VARARGS, nullptr },
        { "param8", reinterpret_cast<PyCFunction>(ITests_Param8), METH_VARARGS, nullptr },
        { "param8_call", reinterpret_cast<PyCFunction>(ITests_Param8Call), METH_VARARGS, nullptr },
        { "param9", reinterpret_cast<PyCFunction>(ITests_Param9), METH_VARARGS, nullptr },
        { "param9_call", reinterpret_cast<PyCFunction>(ITests_Param9Call), METH_VARARGS, nullptr },
        { "simple", reinterpret_cast<PyCFunction>(ITests_Simple), METH_VARARGS, nullptr },
        { "add_event1", reinterpret_cast<PyCFunction>(ITests_add_Event1), METH_O, nullptr },
        { "remove_event1", reinterpret_cast<PyCFunction>(ITests_remove_Event1), METH_O, nullptr },
        { "add_event2", reinterpret_cast<PyCFunction>(ITests_add_Event2), METH_O, nullptr },
        { "remove_event2", reinterpret_cast<PyCFunction>(ITests_remove_Event2), METH_O, nullptr },
        { "_assign_array_", _assign_array_ITests, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ITests), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ITests[] = {
        { "percentage", reinterpret_cast<getter>(ITests_get_Percentage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ITests[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ITests) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ITests) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ITests) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ITests) },
        { }
    };

    static PyType_Spec type_spec_ITests = {
        "winrt._winrt_testcomponent.ITests",
        sizeof(py::wrapper::TestComponent::ITests),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITests};

    // ----- Blittable struct --------------------

    winrt_struct_wrapper<winrt::TestComponent::Blittable>* _new_Blittable(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::TestComponent::Blittable>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_Blittable(winrt_struct_wrapper<winrt::TestComponent::Blittable>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint8_t _A{};
        uint16_t _B{};
        uint32_t _C{};
        uint64_t _D{};
        int16_t _E{};
        int32_t _F{};
        int64_t _G{};
        float _H{};
        double _I{};
        PyObject* _J{};

        static const char* kwlist[] = {"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "BHIKhiLfdO", const_cast<char**>(kwlist), &_A, &_B, &_C, &_D, &_E, &_F, &_G, &_H, &_I, &_J))
        {
            return -1;
        }

        try
        {
            self->obj.A = _A;
            self->obj.B = _B;
            self->obj.C = _C;
            self->obj.D = _D;
            self->obj.E = _E;
            self->obj.F = _F;
            self->obj.G = _G;
            self->obj.H = _H;
            self->obj.I = _I;
            self->obj.J = py::convert_to<winrt::guid>(_J);

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_Blittable(py::wrapper::TestComponent::Blittable* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Blittable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::TestComponent::Blittable>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_Blittable[] = {
        { "_assign_array_", _assign_array_Blittable, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* Blittable_get_A(py::wrapper::TestComponent::Blittable* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.A);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Blittable_set_A(py::wrapper::TestComponent::Blittable* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.A = py::convert_to<uint8_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Blittable_get_B(py::wrapper::TestComponent::Blittable* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.B);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Blittable_set_B(py::wrapper::TestComponent::Blittable* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.B = py::convert_to<uint16_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Blittable_get_C(py::wrapper::TestComponent::Blittable* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.C);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Blittable_set_C(py::wrapper::TestComponent::Blittable* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.C = py::convert_to<uint32_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Blittable_get_D(py::wrapper::TestComponent::Blittable* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.D);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Blittable_set_D(py::wrapper::TestComponent::Blittable* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.D = py::convert_to<uint64_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Blittable_get_E(py::wrapper::TestComponent::Blittable* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.E);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Blittable_set_E(py::wrapper::TestComponent::Blittable* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.E = py::convert_to<int16_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Blittable_get_F(py::wrapper::TestComponent::Blittable* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.F);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Blittable_set_F(py::wrapper::TestComponent::Blittable* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.F = py::convert_to<int32_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Blittable_get_G(py::wrapper::TestComponent::Blittable* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.G);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Blittable_set_G(py::wrapper::TestComponent::Blittable* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.G = py::convert_to<int64_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Blittable_get_H(py::wrapper::TestComponent::Blittable* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.H);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Blittable_set_H(py::wrapper::TestComponent::Blittable* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.H = py::convert_to<float>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Blittable_get_I(py::wrapper::TestComponent::Blittable* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.I);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Blittable_set_I(py::wrapper::TestComponent::Blittable* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.I = py::convert_to<double>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Blittable_get_J(py::wrapper::TestComponent::Blittable* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.J);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Blittable_set_J(py::wrapper::TestComponent::Blittable* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.J = py::convert_to<winrt::guid>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Blittable[] = {
        { "a", reinterpret_cast<getter>(Blittable_get_A), reinterpret_cast<setter>(Blittable_set_A), nullptr, nullptr },
        { "b", reinterpret_cast<getter>(Blittable_get_B), reinterpret_cast<setter>(Blittable_set_B), nullptr, nullptr },
        { "c", reinterpret_cast<getter>(Blittable_get_C), reinterpret_cast<setter>(Blittable_set_C), nullptr, nullptr },
        { "d", reinterpret_cast<getter>(Blittable_get_D), reinterpret_cast<setter>(Blittable_set_D), nullptr, nullptr },
        { "e", reinterpret_cast<getter>(Blittable_get_E), reinterpret_cast<setter>(Blittable_set_E), nullptr, nullptr },
        { "f", reinterpret_cast<getter>(Blittable_get_F), reinterpret_cast<setter>(Blittable_set_F), nullptr, nullptr },
        { "g", reinterpret_cast<getter>(Blittable_get_G), reinterpret_cast<setter>(Blittable_set_G), nullptr, nullptr },
        { "h", reinterpret_cast<getter>(Blittable_get_H), reinterpret_cast<setter>(Blittable_set_H), nullptr, nullptr },
        { "i", reinterpret_cast<getter>(Blittable_get_I), reinterpret_cast<setter>(Blittable_set_I), nullptr, nullptr },
        { "j", reinterpret_cast<getter>(Blittable_get_J), reinterpret_cast<setter>(Blittable_set_J), nullptr, nullptr },
        { }
    };

    static PyObject* _richcompare_Blittable(py::wrapper::TestComponent::Blittable* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::TestComponent::Blittable>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_Blittable(PyObject* self) noexcept
    {
        py::pyobj_handle A{PyObject_GetAttrString(self, "a")};
        if (!A)
        {
            return nullptr;
        }

        py::pyobj_handle B{PyObject_GetAttrString(self, "b")};
        if (!B)
        {
            return nullptr;
        }

        py::pyobj_handle C{PyObject_GetAttrString(self, "c")};
        if (!C)
        {
            return nullptr;
        }

        py::pyobj_handle D{PyObject_GetAttrString(self, "d")};
        if (!D)
        {
            return nullptr;
        }

        py::pyobj_handle E{PyObject_GetAttrString(self, "e")};
        if (!E)
        {
            return nullptr;
        }

        py::pyobj_handle F{PyObject_GetAttrString(self, "f")};
        if (!F)
        {
            return nullptr;
        }

        py::pyobj_handle G{PyObject_GetAttrString(self, "g")};
        if (!G)
        {
            return nullptr;
        }

        py::pyobj_handle H{PyObject_GetAttrString(self, "h")};
        if (!H)
        {
            return nullptr;
        }

        py::pyobj_handle I{PyObject_GetAttrString(self, "i")};
        if (!I)
        {
            return nullptr;
        }

        py::pyobj_handle J{PyObject_GetAttrString(self, "j")};
        if (!J)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("Blittable(a=%R, b=%R, c=%R, d=%R, e=%R, f=%R, g=%R, h=%R, i=%R, j=%R)", A.get(), B.get(), C.get(), D.get(), E.get(), F.get(), G.get(), H.get(), I.get(), J.get());
    }

    static PyType_Slot _type_slots_Blittable[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Blittable) },
        { Py_tp_init, reinterpret_cast<void*>(_init_Blittable) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Blittable) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Blittable) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Blittable) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_Blittable) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_Blittable) },
        { }
    };

    static PyType_Spec type_spec_Blittable = {
        "winrt._winrt_testcomponent.Blittable",
        sizeof(py::wrapper::TestComponent::Blittable),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Blittable};

    // ----- Nested struct --------------------

    winrt_struct_wrapper<winrt::TestComponent::Nested>* _new_Nested(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::TestComponent::Nested>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_Nested(winrt_struct_wrapper<winrt::TestComponent::Nested>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        PyObject* _Blittable{};
        PyObject* _NonBlittable{};

        static const char* kwlist[] = {"blittable", "non_blittable", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "OO", const_cast<char**>(kwlist), &_Blittable, &_NonBlittable))
        {
            return -1;
        }

        try
        {
            self->obj.Blittable = py::convert_to<winrt::TestComponent::Blittable>(_Blittable);
            self->obj.NonBlittable = py::convert_to<winrt::TestComponent::NonBlittable>(_NonBlittable);

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_Nested(py::wrapper::TestComponent::Nested* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Nested(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::TestComponent::Nested>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_Nested[] = {
        { "_assign_array_", _assign_array_Nested, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* Nested_get_Blittable(py::wrapper::TestComponent::Nested* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Blittable);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Nested_set_Blittable(py::wrapper::TestComponent::Nested* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Blittable = py::convert_to<winrt::TestComponent::Blittable>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Nested_get_NonBlittable(py::wrapper::TestComponent::Nested* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NonBlittable);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Nested_set_NonBlittable(py::wrapper::TestComponent::Nested* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.NonBlittable = py::convert_to<winrt::TestComponent::NonBlittable>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Nested[] = {
        { "blittable", reinterpret_cast<getter>(Nested_get_Blittable), reinterpret_cast<setter>(Nested_set_Blittable), nullptr, nullptr },
        { "non_blittable", reinterpret_cast<getter>(Nested_get_NonBlittable), reinterpret_cast<setter>(Nested_set_NonBlittable), nullptr, nullptr },
        { }
    };

    static PyObject* _richcompare_Nested(py::wrapper::TestComponent::Nested* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::TestComponent::Nested>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_Nested(PyObject* self) noexcept
    {
        py::pyobj_handle Blittable{PyObject_GetAttrString(self, "blittable")};
        if (!Blittable)
        {
            return nullptr;
        }

        py::pyobj_handle NonBlittable{PyObject_GetAttrString(self, "non_blittable")};
        if (!NonBlittable)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("Nested(blittable=%R, non_blittable=%R)", Blittable.get(), NonBlittable.get());
    }

    static PyType_Slot _type_slots_Nested[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Nested) },
        { Py_tp_init, reinterpret_cast<void*>(_init_Nested) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Nested) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Nested) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Nested) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_Nested) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_Nested) },
        { }
    };

    static PyType_Spec type_spec_Nested = {
        "winrt._winrt_testcomponent.Nested",
        sizeof(py::wrapper::TestComponent::Nested),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Nested};

    // ----- NonBlittable struct --------------------

    winrt_struct_wrapper<winrt::TestComponent::NonBlittable>* _new_NonBlittable(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::TestComponent::NonBlittable>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_NonBlittable(winrt_struct_wrapper<winrt::TestComponent::NonBlittable>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        int _A{};
        PyObject* _B{};
        PyObject* _C{};
        PyObject* _D{};

        static const char* kwlist[] = {"a", "b", "c", "d", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "pOOO", const_cast<char**>(kwlist), &_A, &_B, &_C, &_D))
        {
            return -1;
        }

        try
        {
            self->obj.A = _A;
            self->obj.B = py::convert_to<char16_t>(_B);
            self->obj.C = py::convert_to<winrt::hstring>(_C);
            self->obj.D = py::convert_to<winrt::Windows::Foundation::IReference<int64_t>>(_D);

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_NonBlittable(py::wrapper::TestComponent::NonBlittable* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_NonBlittable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::TestComponent::NonBlittable>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_NonBlittable[] = {
        { "_assign_array_", _assign_array_NonBlittable, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* NonBlittable_get_A(py::wrapper::TestComponent::NonBlittable* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.A);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NonBlittable_set_A(py::wrapper::TestComponent::NonBlittable* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.A = py::convert_to<bool>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NonBlittable_get_B(py::wrapper::TestComponent::NonBlittable* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.B);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NonBlittable_set_B(py::wrapper::TestComponent::NonBlittable* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.B = py::convert_to<char16_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NonBlittable_get_C(py::wrapper::TestComponent::NonBlittable* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.C);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NonBlittable_set_C(py::wrapper::TestComponent::NonBlittable* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.C = py::convert_to<winrt::hstring>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NonBlittable_get_D(py::wrapper::TestComponent::NonBlittable* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.D);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NonBlittable_set_D(py::wrapper::TestComponent::NonBlittable* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.D = py::convert_to<winrt::Windows::Foundation::IReference<int64_t>>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_NonBlittable[] = {
        { "a", reinterpret_cast<getter>(NonBlittable_get_A), reinterpret_cast<setter>(NonBlittable_set_A), nullptr, nullptr },
        { "b", reinterpret_cast<getter>(NonBlittable_get_B), reinterpret_cast<setter>(NonBlittable_set_B), nullptr, nullptr },
        { "c", reinterpret_cast<getter>(NonBlittable_get_C), reinterpret_cast<setter>(NonBlittable_set_C), nullptr, nullptr },
        { "d", reinterpret_cast<getter>(NonBlittable_get_D), reinterpret_cast<setter>(NonBlittable_set_D), nullptr, nullptr },
        { }
    };

    static PyObject* _richcompare_NonBlittable(py::wrapper::TestComponent::NonBlittable* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::TestComponent::NonBlittable>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_NonBlittable(PyObject* self) noexcept
    {
        py::pyobj_handle A{PyObject_GetAttrString(self, "a")};
        if (!A)
        {
            return nullptr;
        }

        py::pyobj_handle B{PyObject_GetAttrString(self, "b")};
        if (!B)
        {
            return nullptr;
        }

        py::pyobj_handle C{PyObject_GetAttrString(self, "c")};
        if (!C)
        {
            return nullptr;
        }

        py::pyobj_handle D{PyObject_GetAttrString(self, "d")};
        if (!D)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("NonBlittable(a=%R, b=%R, c=%R, d=%R)", A.get(), B.get(), C.get(), D.get());
    }

    static PyType_Slot _type_slots_NonBlittable[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NonBlittable) },
        { Py_tp_init, reinterpret_cast<void*>(_init_NonBlittable) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NonBlittable) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NonBlittable) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NonBlittable) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_NonBlittable) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_NonBlittable) },
        { }
    };

    static PyType_Spec type_spec_NonBlittable = {
        "winrt._winrt_testcomponent.NonBlittable",
        sizeof(py::wrapper::TestComponent::NonBlittable),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NonBlittable};

    // ----- TestComponent Initialization --------------------

    PyDoc_STRVAR(module_doc, "TestComponent");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_testcomponent",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::TestComponent

PyMODINIT_FUNC PyInit__winrt_testcomponent(void) noexcept
{
    using namespace py::cpp::TestComponent;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle Class_type{py::register_python_type(module.get(), &type_spec_Class, object_bases.get(), nullptr)};
    if (!Class_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_Composable_Static{PyType_FromSpec(&type_spec_Composable_Static)};
    if (!type_Composable_Static)
    {
        return nullptr;
    }

    py::pytype_handle Composable_type{py::register_python_type(module.get(), &type_spec_Composable, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Composable_Static.get()))};
    if (!Composable_type)
    {
        return nullptr;
    }

    py::pyobj_handle Derived_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(Composable_type.get())))};
    if (!Derived_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Derived_Static{PyType_FromSpecWithBases(&type_spec_Derived_Static, Derived_Static_bases.get())};
    if (!type_Derived_Static)
    {
        return nullptr;
    }

    py::pyobj_handle Derived_bases{PyTuple_Pack(1, Composable_type.get())};
    if (!Derived_bases)
    {
        return nullptr;
    }

    py::pytype_handle Derived_type{py::register_python_type(module.get(), &type_spec_Derived, Derived_bases.get(), reinterpret_cast<PyTypeObject*>(type_Derived_Static.get()))};
    if (!Derived_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_OverloadClass_Static{PyType_FromSpec(&type_spec_OverloadClass_Static)};
    if (!type_OverloadClass_Static)
    {
        return nullptr;
    }

    py::pytype_handle OverloadClass_type{py::register_python_type(module.get(), &type_spec_OverloadClass, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_OverloadClass_Static.get()))};
    if (!OverloadClass_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_Override_Static{PyType_FromSpec(&type_spec_Override_Static)};
    if (!type_Override_Static)
    {
        return nullptr;
    }

    py::pytype_handle Override_type{py::register_python_type(module.get(), &type_spec_Override, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Override_Static.get()))};
    if (!Override_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_TestRunner_Static{PyType_FromSpec(&type_spec_TestRunner_Static)};
    if (!type_TestRunner_Static)
    {
        return nullptr;
    }

    py::pytype_handle TestRunner_type{py::register_python_type(module.get(), &type_spec_TestRunner, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TestRunner_Static.get()))};
    if (!TestRunner_type)
    {
        return nullptr;
    }

    py::pytype_handle IRequiredFour_type{py::register_python_type(module.get(), &type_spec_IRequiredFour, object_bases.get(), nullptr)};
    if (!IRequiredFour_type)
    {
        return nullptr;
    }

    py::pytype_handle IRequiredOne_type{py::register_python_type(module.get(), &type_spec_IRequiredOne, object_bases.get(), nullptr)};
    if (!IRequiredOne_type)
    {
        return nullptr;
    }

    py::pytype_handle IRequiredThree_type{py::register_python_type(module.get(), &type_spec_IRequiredThree, object_bases.get(), nullptr)};
    if (!IRequiredThree_type)
    {
        return nullptr;
    }

    py::pytype_handle IRequiredTwo_type{py::register_python_type(module.get(), &type_spec_IRequiredTwo, object_bases.get(), nullptr)};
    if (!IRequiredTwo_type)
    {
        return nullptr;
    }

    py::pytype_handle ITests_type{py::register_python_type(module.get(), &type_spec_ITests, object_bases.get(), nullptr)};
    if (!ITests_type)
    {
        return nullptr;
    }

    py::pytype_handle Blittable_type{py::register_python_type(module.get(), &type_spec_Blittable, nullptr, nullptr)};
    if (!Blittable_type)
    {
        return nullptr;
    }

    py::pytype_handle Nested_type{py::register_python_type(module.get(), &type_spec_Nested, nullptr, nullptr)};
    if (!Nested_type)
    {
        return nullptr;
    }

    py::pytype_handle NonBlittable_type{py::register_python_type(module.get(), &type_spec_NonBlittable, nullptr, nullptr)};
    if (!NonBlittable_type)
    {
        return nullptr;
    }


    return module.detach();
}
