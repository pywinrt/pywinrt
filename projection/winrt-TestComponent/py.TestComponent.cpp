// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.TestComponent.h"


namespace py::cpp::TestComponent
{
    // ----- TestRunner class --------------------

    static PyObject* _new_TestRunner(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::TestComponent::TestRunner>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::TestComponent::TestRunner>::type_name);
        return nullptr;
    }

    static PyObject* TestRunner_CreateInt32Vector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.TestRunner", L"CreateInt32Vector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::TestComponent::TestRunner::CreateInt32Vector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TestRunner_CreateStringVector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.TestRunner", L"CreateStringVector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::TestComponent::TestRunner::CreateStringVector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TestRunner_CreateStringableVector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.TestRunner", L"CreateStringableVector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::TestComponent::TestRunner::CreateStringableVector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TestRunner_MakeTests(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.TestRunner", L"MakeTests", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::TestComponent::TestRunner::MakeTests());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TestRunner_TestConsumer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.TestRunner", L"TestConsumer", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::TestHandler>(args, 0);

                return py::convert(winrt::TestComponent::TestRunner::TestConsumer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TestRunner_TestProducer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.TestRunner", L"TestProducer", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::ITests>(args, 0);

                winrt::TestComponent::TestRunner::TestProducer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TestRunner_TestSelf(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.TestRunner", L"TestSelf", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::TestComponent::TestRunner::TestSelf();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_TestRunner[] = {
        { "create_int32_vector", reinterpret_cast<PyCFunction>(TestRunner_CreateInt32Vector), METH_VARARGS | METH_STATIC, nullptr },
        { "create_string_vector", reinterpret_cast<PyCFunction>(TestRunner_CreateStringVector), METH_VARARGS | METH_STATIC, nullptr },
        { "create_stringable_vector", reinterpret_cast<PyCFunction>(TestRunner_CreateStringableVector), METH_VARARGS | METH_STATIC, nullptr },
        { "make_tests", reinterpret_cast<PyCFunction>(TestRunner_MakeTests), METH_VARARGS | METH_STATIC, nullptr },
        { "test_consumer", reinterpret_cast<PyCFunction>(TestRunner_TestConsumer), METH_VARARGS | METH_STATIC, nullptr },
        { "test_producer", reinterpret_cast<PyCFunction>(TestRunner_TestProducer), METH_VARARGS | METH_STATIC, nullptr },
        { "test_self", reinterpret_cast<PyCFunction>(TestRunner_TestSelf), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TestRunner[] = {
        { }
    };

    static PyType_Slot _type_slots_TestRunner[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TestRunner) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TestRunner) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TestRunner) },
        { },
    };

    static PyType_Spec type_spec_TestRunner =
    {
        "winrt._winrt_testcomponent.TestRunner",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TestRunner
    };

    // ----- ITests interface --------------------

    static PyObject* _new_ITests(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::TestComponent::ITests>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::TestComponent::ITests>::type_name);
        return nullptr;
    }

    static void _dealloc_ITests(py::wrapper::TestComponent::ITests* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ITests_Array1(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Array1", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<bool, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<bool, true>>(args, 1);
                winrt::com_array<bool> param2 { };

                auto return_value = self->obj.Array1(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array10(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Array10", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<double, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<double, true>>(args, 1);
                winrt::com_array<double> param2 { };

                auto return_value = self->obj.Array10(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array10Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Array10Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Array10Handler>(args, 0);

                self->obj.Array10Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array11(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Array11", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<char16_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<char16_t, true>>(args, 1);
                winrt::com_array<char16_t> param2 { };

                auto return_value = self->obj.Array11(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array11Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Array11Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Array11Handler>(args, 0);

                self->obj.Array11Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array12(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Array12", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::hstring, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::hstring, true>>(args, 1);
                winrt::com_array<winrt::hstring> param2 { };

                auto return_value = self->obj.Array12(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array12Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Array12Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Array12Handler>(args, 0);

                self->obj.Array12Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array13(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Array13", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::TestComponent::Blittable, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::TestComponent::Blittable, true>>(args, 1);
                winrt::com_array<winrt::TestComponent::Blittable> param2 { };

                auto return_value = self->obj.Array13(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array13Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Array13Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Array13Handler>(args, 0);

                self->obj.Array13Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array14(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Array14", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::TestComponent::NonBlittable, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::TestComponent::NonBlittable, true>>(args, 1);
                winrt::com_array<winrt::TestComponent::NonBlittable> param2 { };

                auto return_value = self->obj.Array14(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array14Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Array14Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Array14Handler>(args, 0);

                self->obj.Array14Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array15(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Array15", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::TestComponent::Nested, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::TestComponent::Nested, true>>(args, 1);
                winrt::com_array<winrt::TestComponent::Nested> param2 { };

                auto return_value = self->obj.Array15(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array15Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Array15Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Array15Handler>(args, 0);

                self->obj.Array15Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array1Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Array1Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Array1Handler>(args, 0);

                self->obj.Array1Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array2(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Array2", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, true>>(args, 1);
                winrt::com_array<uint8_t> param2 { };

                auto return_value = self->obj.Array2(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array2Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Array2Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Array2Handler>(args, 0);

                self->obj.Array2Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array3(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Array3", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint16_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint16_t, true>>(args, 1);
                winrt::com_array<uint16_t> param2 { };

                auto return_value = self->obj.Array3(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array3Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Array3Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Array3Handler>(args, 0);

                self->obj.Array3Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array4(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Array4", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint32_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint32_t, true>>(args, 1);
                winrt::com_array<uint32_t> param2 { };

                auto return_value = self->obj.Array4(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array4Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Array4Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Array4Handler>(args, 0);

                self->obj.Array4Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array5(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Array5", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint64_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint64_t, true>>(args, 1);
                winrt::com_array<uint64_t> param2 { };

                auto return_value = self->obj.Array5(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array5Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Array5Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Array5Handler>(args, 0);

                self->obj.Array5Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array6(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Array6", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int16_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int16_t, true>>(args, 1);
                winrt::com_array<int16_t> param2 { };

                auto return_value = self->obj.Array6(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array6Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Array6Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Array6Handler>(args, 0);

                self->obj.Array6Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array7(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Array7", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int32_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int32_t, true>>(args, 1);
                winrt::com_array<int32_t> param2 { };

                auto return_value = self->obj.Array7(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array7Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Array7Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Array7Handler>(args, 0);

                self->obj.Array7Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array8(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Array8", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int64_t, true>>(args, 1);
                winrt::com_array<int64_t> param2 { };

                auto return_value = self->obj.Array8(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array8Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Array8Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Array8Handler>(args, 0);

                self->obj.Array8Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array9(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Array9", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<float, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<float, true>>(args, 1);
                winrt::com_array<float> param2 { };

                auto return_value = self->obj.Array9(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Array9Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Array9Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Array9Handler>(args, 0);

                self->obj.Array9Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Async1(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Async1", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IAsyncAction>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.Async1(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Async1Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Async1Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Async1Handler>(args, 0);

                self->obj.Async1Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Async2(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Async2", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IAsyncAction>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);

                return py::convert(self->obj.Async2(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Async2Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Async2Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Async2Handler>(args, 0);

                self->obj.Async2Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Async3(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Async3", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IAsyncAction>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);

                return py::convert(self->obj.Async3(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Async3Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Async3Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Async3Handler>(args, 0);

                self->obj.Async3Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Async4(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Async4", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IAsyncAction>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                return py::convert(self->obj.Async4(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Async4Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Async4Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Async4Handler>(args, 0);

                self->obj.Async4Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Collection1(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Collection1", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                winrt::Windows::Foundation::Collections::IIterable<winrt::hstring> param1 { nullptr };

                auto return_value = self->obj.Collection1(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Collection1Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Collection1Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Collection1Handler>(args, 0);

                self->obj.Collection1Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Collection2(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Collection2", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::hstring>>>(args, 0);
                winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::hstring>> param1 { nullptr };

                auto return_value = self->obj.Collection2(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Collection2Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Collection2Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Collection2Handler>(args, 0);

                self->obj.Collection2Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Collection3(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Collection3", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::hstring>>(args, 0);
                winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::hstring> param1 { nullptr };

                auto return_value = self->obj.Collection3(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Collection3Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Collection3Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Collection3Handler>(args, 0);

                self->obj.Collection3Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Collection4(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Collection4", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::hstring>>(args, 0);
                winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::hstring> param1 { nullptr };

                auto return_value = self->obj.Collection4(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Collection4Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Collection4Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Collection4Handler>(args, 0);

                self->obj.Collection4Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Collection5(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Collection5", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::hstring>>(args, 0);
                winrt::Windows::Foundation::Collections::IVector<winrt::hstring> param1 { nullptr };

                auto return_value = self->obj.Collection5(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Collection5Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Collection5Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Collection5Handler>(args, 0);

                self->obj.Collection5Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Collection6(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Collection6", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::hstring>>(args, 0);
                winrt::Windows::Foundation::Collections::IVectorView<winrt::hstring> param1 { nullptr };

                auto return_value = self->obj.Collection6(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Collection6Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Collection6Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Collection6Handler>(args, 0);

                self->obj.Collection6Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Event1Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Event1Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.Event1Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Event2Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Event2Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.Event2Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param1(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Param1", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);
                bool param1 {  };

                auto return_value = self->obj.Param1(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param10(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Param10", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                double param1 {  };

                auto return_value = self->obj.Param10(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param10Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Param10Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Param10Handler>(args, 0);

                self->obj.Param10Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param11(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Param11", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<char16_t>(args, 0);
                char16_t param1 {  };

                auto return_value = self->obj.Param11(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param11Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Param11Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Param11Handler>(args, 0);

                self->obj.Param11Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param12(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Param12", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::hstring param1 {  };

                auto return_value = self->obj.Param12(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param12Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Param12Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Param12Handler>(args, 0);

                self->obj.Param12Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param13(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Param13", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Blittable>(args, 0);
                auto param1 = py::convert_to<winrt::TestComponent::Blittable>(args, 1);
                winrt::TestComponent::Blittable param2 {  };

                auto return_value = self->obj.Param13(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param13Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Param13Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Param13Handler>(args, 0);

                self->obj.Param13Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param14(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Param14", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::NonBlittable>(args, 0);
                auto param1 = py::convert_to<winrt::TestComponent::NonBlittable>(args, 1);
                winrt::TestComponent::NonBlittable param2 {  };

                auto return_value = self->obj.Param14(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param14Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Param14Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Param14Handler>(args, 0);

                self->obj.Param14Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param15(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Param15", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Nested>(args, 0);
                auto param1 = py::convert_to<winrt::TestComponent::Nested>(args, 1);
                winrt::TestComponent::Nested param2 {  };

                auto return_value = self->obj.Param15(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param15Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Param15Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Param15Handler>(args, 0);

                self->obj.Param15Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param1Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Param1Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Param1Handler>(args, 0);

                self->obj.Param1Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param2(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Param2", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                uint8_t param1 {  };

                auto return_value = self->obj.Param2(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param2Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Param2Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Param2Handler>(args, 0);

                self->obj.Param2Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param3(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Param3", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);
                uint16_t param1 {  };

                auto return_value = self->obj.Param3(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param3Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Param3Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Param3Handler>(args, 0);

                self->obj.Param3Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param4(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Param4", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.Param4(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param4Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Param4Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Param4Handler>(args, 0);

                self->obj.Param4Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param5(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Param5", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);
                uint64_t param1 {  };

                auto return_value = self->obj.Param5(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param5Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Param5Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Param5Handler>(args, 0);

                self->obj.Param5Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param6(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Param6", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int16_t>(args, 0);
                int16_t param1 {  };

                auto return_value = self->obj.Param6(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param6Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Param6Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Param6Handler>(args, 0);

                self->obj.Param6Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param7(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Param7", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                int32_t param1 {  };

                auto return_value = self->obj.Param7(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param7Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Param7Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Param7Handler>(args, 0);

                self->obj.Param7Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param8(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Param8", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int64_t>(args, 0);
                int64_t param1 {  };

                auto return_value = self->obj.Param8(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param8Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Param8Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Param8Handler>(args, 0);

                self->obj.Param8Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param9(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Param9", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<float>(args, 0);
                float param1 {  };

                auto return_value = self->obj.Param9(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Param9Call(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Param9Call", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::TestComponent::Param9Handler>(args, 0);

                self->obj.Param9Call(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_Simple(py::wrapper::TestComponent::ITests* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"TestComponent.ITests", L"Simple", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Simple();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITests_get_Percentage(py::wrapper::TestComponent::ITests* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"TestComponent.ITests", L"Percentage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Percentage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITests_add_Event1(py::wrapper::TestComponent::ITests* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"TestComponent.ITests", L"Event1"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<int32_t>>(arg);

            return py::convert(self->obj.Event1(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITests_remove_Event1(py::wrapper::TestComponent::ITests* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"TestComponent.ITests", L"Event1"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Event1(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITests_add_Event2(py::wrapper::TestComponent::ITests* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"TestComponent.ITests", L"Event2"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::TestComponent::ITests, int32_t>>(arg);

            return py::convert(self->obj.Event2(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITests_remove_Event2(py::wrapper::TestComponent::ITests* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"TestComponent.ITests", L"Event2"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Event2(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ITests(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::TestComponent::ITests>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ITests(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::TestComponent::ITests>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITests[] = {
        { "array1", reinterpret_cast<PyCFunction>(ITests_Array1), METH_VARARGS, nullptr },
        { "array10", reinterpret_cast<PyCFunction>(ITests_Array10), METH_VARARGS, nullptr },
        { "array10_call", reinterpret_cast<PyCFunction>(ITests_Array10Call), METH_VARARGS, nullptr },
        { "array11", reinterpret_cast<PyCFunction>(ITests_Array11), METH_VARARGS, nullptr },
        { "array11_call", reinterpret_cast<PyCFunction>(ITests_Array11Call), METH_VARARGS, nullptr },
        { "array12", reinterpret_cast<PyCFunction>(ITests_Array12), METH_VARARGS, nullptr },
        { "array12_call", reinterpret_cast<PyCFunction>(ITests_Array12Call), METH_VARARGS, nullptr },
        { "array13", reinterpret_cast<PyCFunction>(ITests_Array13), METH_VARARGS, nullptr },
        { "array13_call", reinterpret_cast<PyCFunction>(ITests_Array13Call), METH_VARARGS, nullptr },
        { "array14", reinterpret_cast<PyCFunction>(ITests_Array14), METH_VARARGS, nullptr },
        { "array14_call", reinterpret_cast<PyCFunction>(ITests_Array14Call), METH_VARARGS, nullptr },
        { "array15", reinterpret_cast<PyCFunction>(ITests_Array15), METH_VARARGS, nullptr },
        { "array15_call", reinterpret_cast<PyCFunction>(ITests_Array15Call), METH_VARARGS, nullptr },
        { "array1_call", reinterpret_cast<PyCFunction>(ITests_Array1Call), METH_VARARGS, nullptr },
        { "array2", reinterpret_cast<PyCFunction>(ITests_Array2), METH_VARARGS, nullptr },
        { "array2_call", reinterpret_cast<PyCFunction>(ITests_Array2Call), METH_VARARGS, nullptr },
        { "array3", reinterpret_cast<PyCFunction>(ITests_Array3), METH_VARARGS, nullptr },
        { "array3_call", reinterpret_cast<PyCFunction>(ITests_Array3Call), METH_VARARGS, nullptr },
        { "array4", reinterpret_cast<PyCFunction>(ITests_Array4), METH_VARARGS, nullptr },
        { "array4_call", reinterpret_cast<PyCFunction>(ITests_Array4Call), METH_VARARGS, nullptr },
        { "array5", reinterpret_cast<PyCFunction>(ITests_Array5), METH_VARARGS, nullptr },
        { "array5_call", reinterpret_cast<PyCFunction>(ITests_Array5Call), METH_VARARGS, nullptr },
        { "array6", reinterpret_cast<PyCFunction>(ITests_Array6), METH_VARARGS, nullptr },
        { "array6_call", reinterpret_cast<PyCFunction>(ITests_Array6Call), METH_VARARGS, nullptr },
        { "array7", reinterpret_cast<PyCFunction>(ITests_Array7), METH_VARARGS, nullptr },
        { "array7_call", reinterpret_cast<PyCFunction>(ITests_Array7Call), METH_VARARGS, nullptr },
        { "array8", reinterpret_cast<PyCFunction>(ITests_Array8), METH_VARARGS, nullptr },
        { "array8_call", reinterpret_cast<PyCFunction>(ITests_Array8Call), METH_VARARGS, nullptr },
        { "array9", reinterpret_cast<PyCFunction>(ITests_Array9), METH_VARARGS, nullptr },
        { "array9_call", reinterpret_cast<PyCFunction>(ITests_Array9Call), METH_VARARGS, nullptr },
        { "async1", reinterpret_cast<PyCFunction>(ITests_Async1), METH_VARARGS, nullptr },
        { "async1_call", reinterpret_cast<PyCFunction>(ITests_Async1Call), METH_VARARGS, nullptr },
        { "async2", reinterpret_cast<PyCFunction>(ITests_Async2), METH_VARARGS, nullptr },
        { "async2_call", reinterpret_cast<PyCFunction>(ITests_Async2Call), METH_VARARGS, nullptr },
        { "async3", reinterpret_cast<PyCFunction>(ITests_Async3), METH_VARARGS, nullptr },
        { "async3_call", reinterpret_cast<PyCFunction>(ITests_Async3Call), METH_VARARGS, nullptr },
        { "async4", reinterpret_cast<PyCFunction>(ITests_Async4), METH_VARARGS, nullptr },
        { "async4_call", reinterpret_cast<PyCFunction>(ITests_Async4Call), METH_VARARGS, nullptr },
        { "collection1", reinterpret_cast<PyCFunction>(ITests_Collection1), METH_VARARGS, nullptr },
        { "collection1_call", reinterpret_cast<PyCFunction>(ITests_Collection1Call), METH_VARARGS, nullptr },
        { "collection2", reinterpret_cast<PyCFunction>(ITests_Collection2), METH_VARARGS, nullptr },
        { "collection2_call", reinterpret_cast<PyCFunction>(ITests_Collection2Call), METH_VARARGS, nullptr },
        { "collection3", reinterpret_cast<PyCFunction>(ITests_Collection3), METH_VARARGS, nullptr },
        { "collection3_call", reinterpret_cast<PyCFunction>(ITests_Collection3Call), METH_VARARGS, nullptr },
        { "collection4", reinterpret_cast<PyCFunction>(ITests_Collection4), METH_VARARGS, nullptr },
        { "collection4_call", reinterpret_cast<PyCFunction>(ITests_Collection4Call), METH_VARARGS, nullptr },
        { "collection5", reinterpret_cast<PyCFunction>(ITests_Collection5), METH_VARARGS, nullptr },
        { "collection5_call", reinterpret_cast<PyCFunction>(ITests_Collection5Call), METH_VARARGS, nullptr },
        { "collection6", reinterpret_cast<PyCFunction>(ITests_Collection6), METH_VARARGS, nullptr },
        { "collection6_call", reinterpret_cast<PyCFunction>(ITests_Collection6Call), METH_VARARGS, nullptr },
        { "event1_call", reinterpret_cast<PyCFunction>(ITests_Event1Call), METH_VARARGS, nullptr },
        { "event2_call", reinterpret_cast<PyCFunction>(ITests_Event2Call), METH_VARARGS, nullptr },
        { "param1", reinterpret_cast<PyCFunction>(ITests_Param1), METH_VARARGS, nullptr },
        { "param10", reinterpret_cast<PyCFunction>(ITests_Param10), METH_VARARGS, nullptr },
        { "param10_call", reinterpret_cast<PyCFunction>(ITests_Param10Call), METH_VARARGS, nullptr },
        { "param11", reinterpret_cast<PyCFunction>(ITests_Param11), METH_VARARGS, nullptr },
        { "param11_call", reinterpret_cast<PyCFunction>(ITests_Param11Call), METH_VARARGS, nullptr },
        { "param12", reinterpret_cast<PyCFunction>(ITests_Param12), METH_VARARGS, nullptr },
        { "param12_call", reinterpret_cast<PyCFunction>(ITests_Param12Call), METH_VARARGS, nullptr },
        { "param13", reinterpret_cast<PyCFunction>(ITests_Param13), METH_VARARGS, nullptr },
        { "param13_call", reinterpret_cast<PyCFunction>(ITests_Param13Call), METH_VARARGS, nullptr },
        { "param14", reinterpret_cast<PyCFunction>(ITests_Param14), METH_VARARGS, nullptr },
        { "param14_call", reinterpret_cast<PyCFunction>(ITests_Param14Call), METH_VARARGS, nullptr },
        { "param15", reinterpret_cast<PyCFunction>(ITests_Param15), METH_VARARGS, nullptr },
        { "param15_call", reinterpret_cast<PyCFunction>(ITests_Param15Call), METH_VARARGS, nullptr },
        { "param1_call", reinterpret_cast<PyCFunction>(ITests_Param1Call), METH_VARARGS, nullptr },
        { "param2", reinterpret_cast<PyCFunction>(ITests_Param2), METH_VARARGS, nullptr },
        { "param2_call", reinterpret_cast<PyCFunction>(ITests_Param2Call), METH_VARARGS, nullptr },
        { "param3", reinterpret_cast<PyCFunction>(ITests_Param3), METH_VARARGS, nullptr },
        { "param3_call", reinterpret_cast<PyCFunction>(ITests_Param3Call), METH_VARARGS, nullptr },
        { "param4", reinterpret_cast<PyCFunction>(ITests_Param4), METH_VARARGS, nullptr },
        { "param4_call", reinterpret_cast<PyCFunction>(ITests_Param4Call), METH_VARARGS, nullptr },
        { "param5", reinterpret_cast<PyCFunction>(ITests_Param5), METH_VARARGS, nullptr },
        { "param5_call", reinterpret_cast<PyCFunction>(ITests_Param5Call), METH_VARARGS, nullptr },
        { "param6", reinterpret_cast<PyCFunction>(ITests_Param6), METH_VARARGS, nullptr },
        { "param6_call", reinterpret_cast<PyCFunction>(ITests_Param6Call), METH_VARARGS, nullptr },
        { "param7", reinterpret_cast<PyCFunction>(ITests_Param7), METH_VARARGS, nullptr },
        { "param7_call", reinterpret_cast<PyCFunction>(ITests_Param7Call), METH_VARARGS, nullptr },
        { "param8", reinterpret_cast<PyCFunction>(ITests_Param8), METH_VARARGS, nullptr },
        { "param8_call", reinterpret_cast<PyCFunction>(ITests_Param8Call), METH_VARARGS, nullptr },
        { "param9", reinterpret_cast<PyCFunction>(ITests_Param9), METH_VARARGS, nullptr },
        { "param9_call", reinterpret_cast<PyCFunction>(ITests_Param9Call), METH_VARARGS, nullptr },
        { "simple", reinterpret_cast<PyCFunction>(ITests_Simple), METH_VARARGS, nullptr },
        { "add_event1", reinterpret_cast<PyCFunction>(ITests_add_Event1), METH_O, nullptr },
        { "remove_event1", reinterpret_cast<PyCFunction>(ITests_remove_Event1), METH_O, nullptr },
        { "add_event2", reinterpret_cast<PyCFunction>(ITests_add_Event2), METH_O, nullptr },
        { "remove_event2", reinterpret_cast<PyCFunction>(ITests_remove_Event2), METH_O, nullptr },
        { "_assign_array_", _assign_array_ITests, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ITests), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ITests[] = {
        { "percentage", reinterpret_cast<getter>(ITests_get_Percentage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ITests[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ITests) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ITests) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ITests) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ITests) },
        { },
    };

    static PyType_Spec type_spec_ITests =
    {
        "winrt._winrt_testcomponent.ITests",
        sizeof(py::wrapper::TestComponent::ITests),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITests
    };

    // ----- Blittable struct --------------------

    winrt_struct_wrapper<winrt::TestComponent::Blittable>* _new_Blittable(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::TestComponent::Blittable>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_Blittable(winrt_struct_wrapper<winrt::TestComponent::Blittable>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint8_t _A{};
        uint16_t _B{};
        uint32_t _C{};
        uint64_t _D{};
        int16_t _E{};
        int32_t _F{};
        int64_t _G{};
        float _H{};
        double _I{};
        PyObject* _J{};

        static const char* kwlist[] = {"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "BHIKhiLfdO", const_cast<char**>(kwlist), &_A, &_B, &_C, &_D, &_E, &_F, &_G, &_H, &_I, &_J))
        {
            return -1;
        }

        try
        {
            self->obj = {_A, _B, _C, _D, _E, _F, _G, _H, _I, py::converter<winrt::guid>::convert_to(_J)};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_Blittable(py::wrapper::TestComponent::Blittable* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Blittable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::TestComponent::Blittable>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_Blittable[] = {
        { "_assign_array_", _assign_array_Blittable, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* Blittable_get_A(py::wrapper::TestComponent::Blittable* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.A);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Blittable_set_A(py::wrapper::TestComponent::Blittable* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.A = py::converter<uint8_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Blittable_get_B(py::wrapper::TestComponent::Blittable* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.B);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Blittable_set_B(py::wrapper::TestComponent::Blittable* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.B = py::converter<uint16_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Blittable_get_C(py::wrapper::TestComponent::Blittable* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.C);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Blittable_set_C(py::wrapper::TestComponent::Blittable* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.C = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Blittable_get_D(py::wrapper::TestComponent::Blittable* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.D);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Blittable_set_D(py::wrapper::TestComponent::Blittable* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.D = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Blittable_get_E(py::wrapper::TestComponent::Blittable* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.E);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Blittable_set_E(py::wrapper::TestComponent::Blittable* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.E = py::converter<int16_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Blittable_get_F(py::wrapper::TestComponent::Blittable* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.F);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Blittable_set_F(py::wrapper::TestComponent::Blittable* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.F = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Blittable_get_G(py::wrapper::TestComponent::Blittable* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.G);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Blittable_set_G(py::wrapper::TestComponent::Blittable* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.G = py::converter<int64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Blittable_get_H(py::wrapper::TestComponent::Blittable* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.H);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Blittable_set_H(py::wrapper::TestComponent::Blittable* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.H = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Blittable_get_I(py::wrapper::TestComponent::Blittable* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.I);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Blittable_set_I(py::wrapper::TestComponent::Blittable* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.I = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Blittable_get_J(py::wrapper::TestComponent::Blittable* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.J);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Blittable_set_J(py::wrapper::TestComponent::Blittable* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.J = py::converter<winrt::guid>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Blittable[] = {
        { "a", reinterpret_cast<getter>(Blittable_get_A), reinterpret_cast<setter>(Blittable_set_A), nullptr, nullptr },
        { "b", reinterpret_cast<getter>(Blittable_get_B), reinterpret_cast<setter>(Blittable_set_B), nullptr, nullptr },
        { "c", reinterpret_cast<getter>(Blittable_get_C), reinterpret_cast<setter>(Blittable_set_C), nullptr, nullptr },
        { "d", reinterpret_cast<getter>(Blittable_get_D), reinterpret_cast<setter>(Blittable_set_D), nullptr, nullptr },
        { "e", reinterpret_cast<getter>(Blittable_get_E), reinterpret_cast<setter>(Blittable_set_E), nullptr, nullptr },
        { "f", reinterpret_cast<getter>(Blittable_get_F), reinterpret_cast<setter>(Blittable_set_F), nullptr, nullptr },
        { "g", reinterpret_cast<getter>(Blittable_get_G), reinterpret_cast<setter>(Blittable_set_G), nullptr, nullptr },
        { "h", reinterpret_cast<getter>(Blittable_get_H), reinterpret_cast<setter>(Blittable_set_H), nullptr, nullptr },
        { "i", reinterpret_cast<getter>(Blittable_get_I), reinterpret_cast<setter>(Blittable_set_I), nullptr, nullptr },
        { "j", reinterpret_cast<getter>(Blittable_get_J), reinterpret_cast<setter>(Blittable_set_J), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Blittable[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Blittable) },
        { Py_tp_init, reinterpret_cast<void*>(_init_Blittable) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Blittable) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Blittable) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Blittable) },
        { },
    };

    static PyType_Spec type_spec_Blittable =
    {
        "winrt._winrt_testcomponent.Blittable",
        sizeof(py::wrapper::TestComponent::Blittable),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Blittable
    };

    // ----- Nested struct --------------------

    winrt_struct_wrapper<winrt::TestComponent::Nested>* _new_Nested(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::TestComponent::Nested>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_Nested(winrt_struct_wrapper<winrt::TestComponent::Nested>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        PyObject* _Blittable{};
        PyObject* _NonBlittable{};

        static const char* kwlist[] = {"blittable", "non_blittable", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "OO", const_cast<char**>(kwlist), &_Blittable, &_NonBlittable))
        {
            return -1;
        }

        try
        {
            self->obj = {py::converter<winrt::TestComponent::Blittable>::convert_to(_Blittable), py::converter<winrt::TestComponent::NonBlittable>::convert_to(_NonBlittable)};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_Nested(py::wrapper::TestComponent::Nested* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Nested(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::TestComponent::Nested>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_Nested[] = {
        { "_assign_array_", _assign_array_Nested, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* Nested_get_Blittable(py::wrapper::TestComponent::Nested* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Blittable);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Nested_set_Blittable(py::wrapper::TestComponent::Nested* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Blittable = py::converter<winrt::TestComponent::Blittable>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Nested_get_NonBlittable(py::wrapper::TestComponent::Nested* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NonBlittable);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Nested_set_NonBlittable(py::wrapper::TestComponent::Nested* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.NonBlittable = py::converter<winrt::TestComponent::NonBlittable>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Nested[] = {
        { "blittable", reinterpret_cast<getter>(Nested_get_Blittable), reinterpret_cast<setter>(Nested_set_Blittable), nullptr, nullptr },
        { "non_blittable", reinterpret_cast<getter>(Nested_get_NonBlittable), reinterpret_cast<setter>(Nested_set_NonBlittable), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Nested[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Nested) },
        { Py_tp_init, reinterpret_cast<void*>(_init_Nested) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Nested) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Nested) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Nested) },
        { },
    };

    static PyType_Spec type_spec_Nested =
    {
        "winrt._winrt_testcomponent.Nested",
        sizeof(py::wrapper::TestComponent::Nested),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Nested
    };

    // ----- NonBlittable struct --------------------

    winrt_struct_wrapper<winrt::TestComponent::NonBlittable>* _new_NonBlittable(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::TestComponent::NonBlittable>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_NonBlittable(winrt_struct_wrapper<winrt::TestComponent::NonBlittable>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        bool _A{};
        char16_t _B{};
        winrt::hstring _C{};
        int64_t _D{};

        static const char* kwlist[] = {"a", "b", "c", "d", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "pu1uL", const_cast<char**>(kwlist), &_A, &_B, &_C, &_D))
        {
            return -1;
        }

        try
        {
            self->obj = {_A, _B, _C, _D};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_NonBlittable(py::wrapper::TestComponent::NonBlittable* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_NonBlittable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::TestComponent::NonBlittable>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_NonBlittable[] = {
        { "_assign_array_", _assign_array_NonBlittable, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* NonBlittable_get_A(py::wrapper::TestComponent::NonBlittable* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.A);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NonBlittable_set_A(py::wrapper::TestComponent::NonBlittable* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.A = py::converter<bool>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NonBlittable_get_B(py::wrapper::TestComponent::NonBlittable* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.B);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NonBlittable_set_B(py::wrapper::TestComponent::NonBlittable* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.B = py::converter<char16_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NonBlittable_get_C(py::wrapper::TestComponent::NonBlittable* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.C);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NonBlittable_set_C(py::wrapper::TestComponent::NonBlittable* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.C = py::converter<winrt::hstring>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NonBlittable_get_D(py::wrapper::TestComponent::NonBlittable* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.D);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NonBlittable_set_D(py::wrapper::TestComponent::NonBlittable* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.D = py::converter<winrt::Windows::Foundation::IReference<int64_t>>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_NonBlittable[] = {
        { "a", reinterpret_cast<getter>(NonBlittable_get_A), reinterpret_cast<setter>(NonBlittable_set_A), nullptr, nullptr },
        { "b", reinterpret_cast<getter>(NonBlittable_get_B), reinterpret_cast<setter>(NonBlittable_set_B), nullptr, nullptr },
        { "c", reinterpret_cast<getter>(NonBlittable_get_C), reinterpret_cast<setter>(NonBlittable_set_C), nullptr, nullptr },
        { "d", reinterpret_cast<getter>(NonBlittable_get_D), reinterpret_cast<setter>(NonBlittable_set_D), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NonBlittable[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NonBlittable) },
        { Py_tp_init, reinterpret_cast<void*>(_init_NonBlittable) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NonBlittable) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NonBlittable) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NonBlittable) },
        { },
    };

    static PyType_Spec type_spec_NonBlittable =
    {
        "winrt._winrt_testcomponent.NonBlittable",
        sizeof(py::wrapper::TestComponent::NonBlittable),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NonBlittable
    };

    // ----- TestComponent Initialization --------------------
    PyDoc_STRVAR(module_doc, "TestComponent");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_testcomponent",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::TestComponent

PyMODINIT_FUNC PyInit__winrt_testcomponent(void) noexcept
{
    using namespace py::cpp::TestComponent;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TestRunner, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ITests, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Blittable, nullptr, nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Nested, nullptr, nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_NonBlittable, nullptr, nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
