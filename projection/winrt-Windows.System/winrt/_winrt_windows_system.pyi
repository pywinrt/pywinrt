# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.1

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.applicationmodel
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.storage
import winrt.windows.storage.search
import winrt.windows.storage.streams
import winrt.windows.system.diagnostics
import winrt.windows.system.remotesystems
import winrt.windows.ui.popups
import winrt.windows.ui.viewmanagement

from winrt.windows.system import AppDiagnosticInfoWatcherStatus, AppMemoryUsageLevel, AppResourceGroupEnergyQuotaState, AppResourceGroupExecutionState, AppResourceGroupInfoWatcherStatus, AutoUpdateTimeZoneStatus, DiagnosticAccessStatus, DispatcherQueuePriority, LaunchFileStatus, LaunchQuerySupportStatus, LaunchQuerySupportType, LaunchUriStatus, PowerState, ProcessorArchitecture, RemoteLaunchUriStatus, ShutdownKind, UserAgeConsentGroup, UserAgeConsentResult, UserAuthenticationStatus, UserPictureSize, UserType, UserWatcherStatus, UserWatcherUpdateKind, VirtualKey, VirtualKeyModifiers
from winrt.windows.system import DispatcherQueueHandler

Self = typing.TypeVar('Self')

@typing.final
class AppActivationResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppActivationResult: ...
    @_property
    def app_resource_group_info(self) -> typing.Optional[AppResourceGroupInfo]: ...
    @_property
    def extended_error(self) -> winrt.windows.foundation.HResult: ...

@typing.final
class AppDiagnosticInfo_Static(type):
    def create_watcher(cls) -> typing.Optional[AppDiagnosticInfoWatcher]: ...
    def request_access_async(cls) -> winrt.windows.foundation.IAsyncOperation[DiagnosticAccessStatus]: ...
    def request_info_async(cls) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVector[AppDiagnosticInfo]]: ...
    @typing.overload
    def request_info_for_app_async(cls) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVector[AppDiagnosticInfo]]: ...
    @typing.overload
    def request_info_for_app_async(cls, app_user_model_id: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVector[AppDiagnosticInfo]]: ...
    def request_info_for_package_async(cls, package_family_name: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVector[AppDiagnosticInfo]]: ...

@typing.final
class AppDiagnosticInfo(winrt.system.Object, metaclass=AppDiagnosticInfo_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppDiagnosticInfo: ...
    def create_resource_group_watcher(self) -> typing.Optional[AppResourceGroupInfoWatcher]: ...
    def get_resource_groups(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[AppResourceGroupInfo]]: ...
    def launch_async(self) -> winrt.windows.foundation.IAsyncOperation[AppActivationResult]: ...
    @_property
    def app_info(self) -> typing.Optional[winrt.windows.applicationmodel.AppInfo]: ...

@typing.final
class AppDiagnosticInfoWatcher(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppDiagnosticInfoWatcher: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_added(self, handler: winrt.windows.foundation.TypedEventHandler[AppDiagnosticInfoWatcher, AppDiagnosticInfoWatcherEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_added(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_enumeration_completed(self, handler: winrt.windows.foundation.TypedEventHandler[AppDiagnosticInfoWatcher, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_enumeration_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_removed(self, handler: winrt.windows.foundation.TypedEventHandler[AppDiagnosticInfoWatcher, AppDiagnosticInfoWatcherEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_removed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_stopped(self, handler: winrt.windows.foundation.TypedEventHandler[AppDiagnosticInfoWatcher, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_stopped(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def status(self) -> AppDiagnosticInfoWatcherStatus: ...

@typing.final
class AppDiagnosticInfoWatcherEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppDiagnosticInfoWatcherEventArgs: ...
    @_property
    def app_diagnostic_info(self) -> typing.Optional[AppDiagnosticInfo]: ...

@typing.final
class AppExecutionStateChangeResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppExecutionStateChangeResult: ...
    @_property
    def extended_error(self) -> winrt.windows.foundation.HResult: ...

@typing.final
class AppMemoryReport(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppMemoryReport: ...
    @_property
    def peak_private_commit_usage(self) -> winrt.system.UInt64: ...
    @_property
    def private_commit_usage(self) -> winrt.system.UInt64: ...
    @_property
    def total_commit_limit(self) -> winrt.system.UInt64: ...
    @_property
    def total_commit_usage(self) -> winrt.system.UInt64: ...
    @_property
    def expected_total_commit_limit(self) -> winrt.system.UInt64: ...

@typing.final
class AppMemoryUsageLimitChangingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppMemoryUsageLimitChangingEventArgs: ...
    @_property
    def new_limit(self) -> winrt.system.UInt64: ...
    @_property
    def old_limit(self) -> winrt.system.UInt64: ...

@typing.final
class AppResourceGroupBackgroundTaskReport(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppResourceGroupBackgroundTaskReport: ...
    @_property
    def entry_point(self) -> str: ...
    @_property
    def name(self) -> str: ...
    @_property
    def task_id(self) -> _uuid.UUID: ...
    @_property
    def trigger(self) -> str: ...

@typing.final
class AppResourceGroupInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppResourceGroupInfo: ...
    def get_background_task_reports(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[AppResourceGroupBackgroundTaskReport]]: ...
    def get_memory_report(self) -> typing.Optional[AppResourceGroupMemoryReport]: ...
    def get_process_diagnostic_infos(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.system.diagnostics.ProcessDiagnosticInfo]]: ...
    def get_state_report(self) -> typing.Optional[AppResourceGroupStateReport]: ...
    def start_resume_async(self) -> winrt.windows.foundation.IAsyncOperation[AppExecutionStateChangeResult]: ...
    def start_suspend_async(self) -> winrt.windows.foundation.IAsyncOperation[AppExecutionStateChangeResult]: ...
    def start_terminate_async(self) -> winrt.windows.foundation.IAsyncOperation[AppExecutionStateChangeResult]: ...
    @_property
    def instance_id(self) -> _uuid.UUID: ...
    @_property
    def is_shared(self) -> bool: ...

@typing.final
class AppResourceGroupInfoWatcher(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppResourceGroupInfoWatcher: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_added(self, handler: winrt.windows.foundation.TypedEventHandler[AppResourceGroupInfoWatcher, AppResourceGroupInfoWatcherEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_added(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_enumeration_completed(self, handler: winrt.windows.foundation.TypedEventHandler[AppResourceGroupInfoWatcher, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_enumeration_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_execution_state_changed(self, handler: winrt.windows.foundation.TypedEventHandler[AppResourceGroupInfoWatcher, AppResourceGroupInfoWatcherExecutionStateChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_execution_state_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_removed(self, handler: winrt.windows.foundation.TypedEventHandler[AppResourceGroupInfoWatcher, AppResourceGroupInfoWatcherEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_removed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_stopped(self, handler: winrt.windows.foundation.TypedEventHandler[AppResourceGroupInfoWatcher, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_stopped(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def status(self) -> AppResourceGroupInfoWatcherStatus: ...

@typing.final
class AppResourceGroupInfoWatcherEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppResourceGroupInfoWatcherEventArgs: ...
    @_property
    def app_diagnostic_infos(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[AppDiagnosticInfo]]: ...
    @_property
    def app_resource_group_info(self) -> typing.Optional[AppResourceGroupInfo]: ...

@typing.final
class AppResourceGroupInfoWatcherExecutionStateChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppResourceGroupInfoWatcherExecutionStateChangedEventArgs: ...
    @_property
    def app_diagnostic_infos(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[AppDiagnosticInfo]]: ...
    @_property
    def app_resource_group_info(self) -> typing.Optional[AppResourceGroupInfo]: ...

@typing.final
class AppResourceGroupMemoryReport(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppResourceGroupMemoryReport: ...
    @_property
    def commit_usage_level(self) -> AppMemoryUsageLevel: ...
    @_property
    def commit_usage_limit(self) -> winrt.system.UInt64: ...
    @_property
    def private_commit_usage(self) -> winrt.system.UInt64: ...
    @_property
    def total_commit_usage(self) -> winrt.system.UInt64: ...

@typing.final
class AppResourceGroupStateReport(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppResourceGroupStateReport: ...
    @_property
    def energy_quota_state(self) -> AppResourceGroupEnergyQuotaState: ...
    @_property
    def execution_state(self) -> AppResourceGroupExecutionState: ...

@typing.final
class AppUriHandlerHost(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppUriHandlerHost: ...
    @typing.overload
    def __new__(cls: typing.Type[AppUriHandlerHost], name: str) -> AppUriHandlerHost:...
    @typing.overload
    def __new__(cls: typing.Type[AppUriHandlerHost]) -> AppUriHandlerHost:...
    @_property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> None: ...
    @_property
    def is_enabled(self) -> bool: ...
    @is_enabled.setter
    def is_enabled(self, value: bool) -> None: ...

@typing.final
class AppUriHandlerRegistration(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppUriHandlerRegistration: ...
    def get_all_hosts(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[AppUriHandlerHost]]: ...
    def get_app_added_hosts_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVector[AppUriHandlerHost]]: ...
    def set_app_added_hosts_async(self, hosts: typing.Iterable[AppUriHandlerHost], /) -> winrt.windows.foundation.IAsyncAction: ...
    def update_hosts(self, hosts: typing.Iterable[AppUriHandlerHost], /) -> None: ...
    @_property
    def name(self) -> str: ...
    @_property
    def user(self) -> typing.Optional[User]: ...
    @_property
    def package_family_name(self) -> str: ...

@typing.final
class AppUriHandlerRegistrationManager_Static(type):
    def get_default(cls) -> typing.Optional[AppUriHandlerRegistrationManager]: ...
    def get_for_package(cls, package_family_name: str, /) -> typing.Optional[AppUriHandlerRegistrationManager]: ...
    def get_for_package_for_user(cls, package_family_name: str, user: typing.Optional[User], /) -> typing.Optional[AppUriHandlerRegistrationManager]: ...
    def get_for_user(cls, user: typing.Optional[User], /) -> typing.Optional[AppUriHandlerRegistrationManager]: ...

@typing.final
class AppUriHandlerRegistrationManager(winrt.system.Object, metaclass=AppUriHandlerRegistrationManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppUriHandlerRegistrationManager: ...
    def try_get_registration(self, name: str, /) -> typing.Optional[AppUriHandlerRegistration]: ...
    @_property
    def user(self) -> typing.Optional[User]: ...
    @_property
    def package_family_name(self) -> str: ...

@typing.final
class DateTimeSettings_Static(type):
    def set_system_date_time(cls, utc_date_time: datetime.datetime, /) -> None: ...

@typing.final
class DateTimeSettings(winrt.system.Object, metaclass=DateTimeSettings_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DateTimeSettings: ...

@typing.final
class DispatcherQueue_Static(type):
    def get_for_current_thread(cls) -> typing.Optional[DispatcherQueue]: ...

@typing.final
class DispatcherQueue(winrt.system.Object, metaclass=DispatcherQueue_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DispatcherQueue: ...
    def create_timer(self) -> typing.Optional[DispatcherQueueTimer]: ...
    @typing.overload
    def try_enqueue(self, callback: typing.Optional[DispatcherQueueHandler], /) -> bool: ...
    @typing.overload
    def try_enqueue(self, priority: DispatcherQueuePriority, callback: typing.Optional[DispatcherQueueHandler], /) -> bool: ...
    def add_shutdown_completed(self, handler: winrt.windows.foundation.TypedEventHandler[DispatcherQueue, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_shutdown_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_shutdown_starting(self, handler: winrt.windows.foundation.TypedEventHandler[DispatcherQueue, DispatcherQueueShutdownStartingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_shutdown_starting(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def has_thread_access(self) -> bool: ...

@typing.final
class DispatcherQueueController_Static(type):
    def create_on_dedicated_thread(cls) -> typing.Optional[DispatcherQueueController]: ...

@typing.final
class DispatcherQueueController(winrt.system.Object, metaclass=DispatcherQueueController_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DispatcherQueueController: ...
    def shutdown_queue_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    @_property
    def dispatcher_queue(self) -> typing.Optional[DispatcherQueue]: ...

@typing.final
class DispatcherQueueShutdownStartingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DispatcherQueueShutdownStartingEventArgs: ...
    def get_deferral(self) -> typing.Optional[winrt.windows.foundation.Deferral]: ...

@typing.final
class DispatcherQueueTimer(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DispatcherQueueTimer: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_tick(self, handler: winrt.windows.foundation.TypedEventHandler[DispatcherQueueTimer, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_tick(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def is_repeating(self) -> bool: ...
    @is_repeating.setter
    def is_repeating(self, value: bool) -> None: ...
    @_property
    def interval(self) -> datetime.timedelta: ...
    @interval.setter
    def interval(self, value: datetime.timedelta) -> None: ...
    @_property
    def is_running(self) -> bool: ...

@typing.final
class FolderLauncherOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FolderLauncherOptions: ...
    def __new__(cls: typing.Type[FolderLauncherOptions]) -> FolderLauncherOptions:...
    @_property
    def items_to_select(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.storage.IStorageItem]]: ...
    @_property
    def desired_remaining_view(self) -> winrt.windows.ui.viewmanagement.ViewSizePreference: ...
    @desired_remaining_view.setter
    def desired_remaining_view(self, value: winrt.windows.ui.viewmanagement.ViewSizePreference) -> None: ...

@typing.final
class KnownUserProperties_Static(type):
    @_property
    def account_name(cls) -> str: ...
    @_property
    def display_name(cls) -> str: ...
    @_property
    def domain_name(cls) -> str: ...
    @_property
    def first_name(cls) -> str: ...
    @_property
    def guest_host(cls) -> str: ...
    @_property
    def last_name(cls) -> str: ...
    @_property
    def principal_name(cls) -> str: ...
    @_property
    def provider_name(cls) -> str: ...
    @_property
    def session_initiation_protocol_uri(cls) -> str: ...
    @_property
    def age_enforcement_region(cls) -> str: ...

@typing.final
class KnownUserProperties(winrt.system.Object, metaclass=KnownUserProperties_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KnownUserProperties: ...

@typing.final
class LaunchUriResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LaunchUriResult: ...
    @_property
    def result(self) -> typing.Optional[winrt.windows.foundation.collections.ValueSet]: ...
    @_property
    def status(self) -> LaunchUriStatus: ...

@typing.final
class Launcher_Static(type):
    def find_app_uri_handlers_async(cls, uri: typing.Optional[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.windows.applicationmodel.AppInfo]]: ...
    def find_file_handlers_async(cls, extension: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.windows.applicationmodel.AppInfo]]: ...
    @typing.overload
    def find_uri_scheme_handlers_async(cls, scheme: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.windows.applicationmodel.AppInfo]]: ...
    @typing.overload
    def find_uri_scheme_handlers_async(cls, scheme: str, launch_query_support_type: LaunchQuerySupportType, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.windows.applicationmodel.AppInfo]]: ...
    @typing.overload
    def launch_file_async(cls, file: typing.Optional[winrt.windows.storage.IStorageFile], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def launch_file_async(cls, file: typing.Optional[winrt.windows.storage.IStorageFile], options: typing.Optional[LauncherOptions], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def launch_folder_async(cls, folder: typing.Optional[winrt.windows.storage.IStorageFolder], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def launch_folder_async(cls, folder: typing.Optional[winrt.windows.storage.IStorageFolder], options: typing.Optional[FolderLauncherOptions], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def launch_folder_path_async(cls, path: str, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def launch_folder_path_async(cls, path: str, options: typing.Optional[FolderLauncherOptions], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def launch_folder_path_for_user_async(cls, user: typing.Optional[User], path: str, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def launch_folder_path_for_user_async(cls, user: typing.Optional[User], path: str, options: typing.Optional[FolderLauncherOptions], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def launch_uri_async(cls, uri: typing.Optional[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def launch_uri_async(cls, uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[LauncherOptions], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def launch_uri_async(cls, uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[LauncherOptions], input_data: typing.Optional[winrt.windows.foundation.collections.ValueSet], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def launch_uri_for_results_async(cls, uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[LauncherOptions], /) -> winrt.windows.foundation.IAsyncOperation[LaunchUriResult]: ...
    @typing.overload
    def launch_uri_for_results_async(cls, uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[LauncherOptions], input_data: typing.Optional[winrt.windows.foundation.collections.ValueSet], /) -> winrt.windows.foundation.IAsyncOperation[LaunchUriResult]: ...
    @typing.overload
    def launch_uri_for_results_for_user_async(cls, user: typing.Optional[User], uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[LauncherOptions], /) -> winrt.windows.foundation.IAsyncOperation[LaunchUriResult]: ...
    @typing.overload
    def launch_uri_for_results_for_user_async(cls, user: typing.Optional[User], uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[LauncherOptions], input_data: typing.Optional[winrt.windows.foundation.collections.ValueSet], /) -> winrt.windows.foundation.IAsyncOperation[LaunchUriResult]: ...
    @typing.overload
    def launch_uri_for_user_async(cls, user: typing.Optional[User], uri: typing.Optional[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperation[LaunchUriStatus]: ...
    @typing.overload
    def launch_uri_for_user_async(cls, user: typing.Optional[User], uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[LauncherOptions], /) -> winrt.windows.foundation.IAsyncOperation[LaunchUriStatus]: ...
    @typing.overload
    def launch_uri_for_user_async(cls, user: typing.Optional[User], uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[LauncherOptions], input_data: typing.Optional[winrt.windows.foundation.collections.ValueSet], /) -> winrt.windows.foundation.IAsyncOperation[LaunchUriStatus]: ...
    @typing.overload
    def query_app_uri_support_async(cls, uri: typing.Optional[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperation[LaunchQuerySupportStatus]: ...
    @typing.overload
    def query_app_uri_support_async(cls, uri: typing.Optional[winrt.windows.foundation.Uri], package_family_name: str, /) -> winrt.windows.foundation.IAsyncOperation[LaunchQuerySupportStatus]: ...
    @typing.overload
    def query_file_support_async(cls, file: typing.Optional[winrt.windows.storage.StorageFile], /) -> winrt.windows.foundation.IAsyncOperation[LaunchQuerySupportStatus]: ...
    @typing.overload
    def query_file_support_async(cls, file: typing.Optional[winrt.windows.storage.StorageFile], package_family_name: str, /) -> winrt.windows.foundation.IAsyncOperation[LaunchQuerySupportStatus]: ...
    @typing.overload
    def query_uri_support_async(cls, uri: typing.Optional[winrt.windows.foundation.Uri], launch_query_support_type: LaunchQuerySupportType, /) -> winrt.windows.foundation.IAsyncOperation[LaunchQuerySupportStatus]: ...
    @typing.overload
    def query_uri_support_async(cls, uri: typing.Optional[winrt.windows.foundation.Uri], launch_query_support_type: LaunchQuerySupportType, package_family_name: str, /) -> winrt.windows.foundation.IAsyncOperation[LaunchQuerySupportStatus]: ...

@typing.final
class Launcher(winrt.system.Object, metaclass=Launcher_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Launcher: ...

@typing.final
class LauncherOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LauncherOptions: ...
    def __new__(cls: typing.Type[LauncherOptions]) -> LauncherOptions:...
    @_property
    def treat_as_untrusted(self) -> bool: ...
    @treat_as_untrusted.setter
    def treat_as_untrusted(self, value: bool) -> None: ...
    @_property
    def preferred_application_package_family_name(self) -> str: ...
    @preferred_application_package_family_name.setter
    def preferred_application_package_family_name(self, value: str) -> None: ...
    @_property
    def preferred_application_display_name(self) -> str: ...
    @preferred_application_display_name.setter
    def preferred_application_display_name(self, value: str) -> None: ...
    @_property
    def fallback_uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @fallback_uri.setter
    def fallback_uri(self, value: typing.Optional[winrt.windows.foundation.Uri]) -> None: ...
    @_property
    def display_application_picker(self) -> bool: ...
    @display_application_picker.setter
    def display_application_picker(self, value: bool) -> None: ...
    @_property
    def content_type(self) -> str: ...
    @content_type.setter
    def content_type(self, value: str) -> None: ...
    @_property
    def u_i(self) -> typing.Optional[LauncherUIOptions]: ...
    @_property
    def target_application_package_family_name(self) -> str: ...
    @target_application_package_family_name.setter
    def target_application_package_family_name(self, value: str) -> None: ...
    @_property
    def neighboring_files_query(self) -> typing.Optional[winrt.windows.storage.search.StorageFileQueryResult]: ...
    @neighboring_files_query.setter
    def neighboring_files_query(self, value: typing.Optional[winrt.windows.storage.search.StorageFileQueryResult]) -> None: ...
    @_property
    def ignore_app_uri_handlers(self) -> bool: ...
    @ignore_app_uri_handlers.setter
    def ignore_app_uri_handlers(self, value: bool) -> None: ...
    @_property
    def limit_picker_to_current_app_and_app_uri_handlers(self) -> bool: ...
    @limit_picker_to_current_app_and_app_uri_handlers.setter
    def limit_picker_to_current_app_and_app_uri_handlers(self, value: bool) -> None: ...
    @_property
    def desired_remaining_view(self) -> winrt.windows.ui.viewmanagement.ViewSizePreference: ...
    @desired_remaining_view.setter
    def desired_remaining_view(self, value: winrt.windows.ui.viewmanagement.ViewSizePreference) -> None: ...

@typing.final
class LauncherUIOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LauncherUIOptions: ...
    @_property
    def selection_rect(self) -> typing.Optional[typing.Optional[winrt.windows.foundation.Rect]]: ...
    @selection_rect.setter
    def selection_rect(self, value: typing.Optional[typing.Optional[winrt.windows.foundation.Rect]]) -> None: ...
    @_property
    def preferred_placement(self) -> winrt.windows.ui.popups.Placement: ...
    @preferred_placement.setter
    def preferred_placement(self, value: winrt.windows.ui.popups.Placement) -> None: ...
    @_property
    def invocation_point(self) -> typing.Optional[typing.Optional[winrt.windows.foundation.Point]]: ...
    @invocation_point.setter
    def invocation_point(self, value: typing.Optional[typing.Optional[winrt.windows.foundation.Point]]) -> None: ...

@typing.final
class MemoryManager_Static(type):
    def get_app_memory_report(cls) -> typing.Optional[AppMemoryReport]: ...
    def get_process_memory_report(cls) -> typing.Optional[ProcessMemoryReport]: ...
    def try_set_app_memory_usage_limit(cls, value: winrt.system.UInt64, /) -> bool: ...
    def add_app_memory_usage_decreased(cls, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_app_memory_usage_decreased(cls, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_app_memory_usage_increased(cls, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_app_memory_usage_increased(cls, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_app_memory_usage_limit_changing(cls, handler: winrt.windows.foundation.EventHandler[AppMemoryUsageLimitChangingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_app_memory_usage_limit_changing(cls, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def app_memory_usage(cls) -> winrt.system.UInt64: ...
    @_property
    def app_memory_usage_level(cls) -> AppMemoryUsageLevel: ...
    @_property
    def app_memory_usage_limit(cls) -> winrt.system.UInt64: ...
    @_property
    def expected_app_memory_usage_limit(cls) -> winrt.system.UInt64: ...

@typing.final
class MemoryManager(winrt.system.Object, metaclass=MemoryManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MemoryManager: ...

@typing.final
class ProcessLauncher_Static(type):
    @typing.overload
    def run_to_completion_async(cls, file_name: str, args: str, /) -> winrt.windows.foundation.IAsyncOperation[ProcessLauncherResult]: ...
    @typing.overload
    def run_to_completion_async(cls, file_name: str, args: str, options: typing.Optional[ProcessLauncherOptions], /) -> winrt.windows.foundation.IAsyncOperation[ProcessLauncherResult]: ...

@typing.final
class ProcessLauncher(winrt.system.Object, metaclass=ProcessLauncher_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProcessLauncher: ...

@typing.final
class ProcessLauncherOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProcessLauncherOptions: ...
    def __new__(cls: typing.Type[ProcessLauncherOptions]) -> ProcessLauncherOptions:...
    @_property
    def working_directory(self) -> str: ...
    @working_directory.setter
    def working_directory(self, value: str) -> None: ...
    @_property
    def standard_output(self) -> typing.Optional[winrt.windows.storage.streams.IOutputStream]: ...
    @standard_output.setter
    def standard_output(self, value: typing.Optional[winrt.windows.storage.streams.IOutputStream]) -> None: ...
    @_property
    def standard_input(self) -> typing.Optional[winrt.windows.storage.streams.IInputStream]: ...
    @standard_input.setter
    def standard_input(self, value: typing.Optional[winrt.windows.storage.streams.IInputStream]) -> None: ...
    @_property
    def standard_error(self) -> typing.Optional[winrt.windows.storage.streams.IOutputStream]: ...
    @standard_error.setter
    def standard_error(self, value: typing.Optional[winrt.windows.storage.streams.IOutputStream]) -> None: ...

@typing.final
class ProcessLauncherResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProcessLauncherResult: ...
    @_property
    def exit_code(self) -> winrt.system.UInt32: ...

@typing.final
class ProcessMemoryReport(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProcessMemoryReport: ...
    @_property
    def private_working_set_usage(self) -> winrt.system.UInt64: ...
    @_property
    def total_working_set_usage(self) -> winrt.system.UInt64: ...

@typing.final
class ProtocolForResultsOperation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProtocolForResultsOperation: ...
    def report_completed(self, data: typing.Optional[winrt.windows.foundation.collections.ValueSet], /) -> None: ...

@typing.final
class RemoteLauncher_Static(type):
    @typing.overload
    def launch_uri_async(cls, remote_system_connection_request: typing.Optional[winrt.windows.system.remotesystems.RemoteSystemConnectionRequest], uri: typing.Optional[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperation[RemoteLaunchUriStatus]: ...
    @typing.overload
    def launch_uri_async(cls, remote_system_connection_request: typing.Optional[winrt.windows.system.remotesystems.RemoteSystemConnectionRequest], uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[RemoteLauncherOptions], /) -> winrt.windows.foundation.IAsyncOperation[RemoteLaunchUriStatus]: ...
    @typing.overload
    def launch_uri_async(cls, remote_system_connection_request: typing.Optional[winrt.windows.system.remotesystems.RemoteSystemConnectionRequest], uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[RemoteLauncherOptions], input_data: typing.Optional[winrt.windows.foundation.collections.ValueSet], /) -> winrt.windows.foundation.IAsyncOperation[RemoteLaunchUriStatus]: ...

@typing.final
class RemoteLauncher(winrt.system.Object, metaclass=RemoteLauncher_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RemoteLauncher: ...

@typing.final
class RemoteLauncherOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RemoteLauncherOptions: ...
    def __new__(cls: typing.Type[RemoteLauncherOptions]) -> RemoteLauncherOptions:...
    @_property
    def fallback_uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @fallback_uri.setter
    def fallback_uri(self, value: typing.Optional[winrt.windows.foundation.Uri]) -> None: ...
    @_property
    def preferred_app_ids(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...

@typing.final
class ShutdownManager_Static(type):
    def begin_shutdown(cls, shutdown_kind: ShutdownKind, timeout: datetime.timedelta, /) -> None: ...
    def cancel_shutdown(cls) -> None: ...
    @typing.overload
    def enter_power_state(cls, power_state: PowerState, /) -> None: ...
    @typing.overload
    def enter_power_state(cls, power_state: PowerState, wake_up_after: datetime.timedelta, /) -> None: ...
    def is_power_state_supported(cls, power_state: PowerState, /) -> bool: ...

@typing.final
class ShutdownManager(winrt.system.Object, metaclass=ShutdownManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ShutdownManager: ...

@typing.final
class TimeZoneSettings_Static(type):
    def auto_update_time_zone_async(cls, timeout: datetime.timedelta, /) -> winrt.windows.foundation.IAsyncOperation[AutoUpdateTimeZoneStatus]: ...
    def change_time_zone_by_display_name(cls, time_zone_display_name: str, /) -> None: ...
    @_property
    def can_change_time_zone(cls) -> bool: ...
    @_property
    def current_time_zone_display_name(cls) -> str: ...
    @_property
    def supported_time_zone_display_names(cls) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]: ...

@typing.final
class TimeZoneSettings(winrt.system.Object, metaclass=TimeZoneSettings_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimeZoneSettings: ...

@typing.final
class User_Static(type):
    def create_watcher(cls) -> typing.Optional[UserWatcher]: ...
    @typing.overload
    def find_all_async(cls) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[User]]: ...
    @typing.overload
    def find_all_async(cls, type: UserType, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[User]]: ...
    @typing.overload
    def find_all_async(cls, type: UserType, status: UserAuthenticationStatus, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[User]]: ...
    def get_default(cls) -> typing.Optional[User]: ...
    def get_from_id(cls, non_roamable_id: str, /) -> typing.Optional[User]: ...

@typing.final
class User(winrt.system.Object, metaclass=User_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> User: ...
    def check_user_age_consent_group_async(self, consent_group: UserAgeConsentGroup, /) -> winrt.windows.foundation.IAsyncOperation[UserAgeConsentResult]: ...
    def get_picture_async(self, desired_size: UserPictureSize, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IRandomAccessStreamReference]: ...
    def get_properties_async(self, values: winrt.windows.foundation.collections.IVectorView[str], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IPropertySet]: ...
    def get_property_async(self, value: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Object]: ...
    @_property
    def authentication_status(self) -> UserAuthenticationStatus: ...
    @_property
    def non_roamable_id(self) -> str: ...
    @_property
    def type(self) -> UserType: ...

@typing.final
class UserAuthenticationStatusChangeDeferral(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UserAuthenticationStatusChangeDeferral: ...
    def complete(self) -> None: ...

@typing.final
class UserAuthenticationStatusChangingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UserAuthenticationStatusChangingEventArgs: ...
    def get_deferral(self) -> typing.Optional[UserAuthenticationStatusChangeDeferral]: ...
    @_property
    def current_status(self) -> UserAuthenticationStatus: ...
    @_property
    def new_status(self) -> UserAuthenticationStatus: ...
    @_property
    def user(self) -> typing.Optional[User]: ...

@typing.final
class UserChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UserChangedEventArgs: ...
    @_property
    def user(self) -> typing.Optional[User]: ...
    @_property
    def changed_property_kinds(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[UserWatcherUpdateKind]]: ...

@typing.final
class UserDeviceAssociation_Static(type):
    def find_user_from_device_id(cls, device_id: str, /) -> typing.Optional[User]: ...
    def add_user_device_association_changed(cls, handler: winrt.windows.foundation.EventHandler[UserDeviceAssociationChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_user_device_association_changed(cls, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

@typing.final
class UserDeviceAssociation(winrt.system.Object, metaclass=UserDeviceAssociation_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UserDeviceAssociation: ...

@typing.final
class UserDeviceAssociationChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UserDeviceAssociationChangedEventArgs: ...
    @_property
    def device_id(self) -> str: ...
    @_property
    def new_user(self) -> typing.Optional[User]: ...
    @_property
    def old_user(self) -> typing.Optional[User]: ...

@typing.final
class UserPicker_Static(type):
    def is_supported(cls) -> bool: ...

@typing.final
class UserPicker(winrt.system.Object, metaclass=UserPicker_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UserPicker: ...
    def __new__(cls: typing.Type[UserPicker]) -> UserPicker:...
    def pick_single_user_async(self) -> winrt.windows.foundation.IAsyncOperation[User]: ...
    @_property
    def suggested_selected_user(self) -> typing.Optional[User]: ...
    @suggested_selected_user.setter
    def suggested_selected_user(self, value: typing.Optional[User]) -> None: ...
    @_property
    def allow_guest_accounts(self) -> bool: ...
    @allow_guest_accounts.setter
    def allow_guest_accounts(self, value: bool) -> None: ...

@typing.final
class UserWatcher(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UserWatcher: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_added(self, handler: winrt.windows.foundation.TypedEventHandler[UserWatcher, UserChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_added(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_authentication_status_changed(self, handler: winrt.windows.foundation.TypedEventHandler[UserWatcher, UserChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_authentication_status_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_authentication_status_changing(self, handler: winrt.windows.foundation.TypedEventHandler[UserWatcher, UserAuthenticationStatusChangingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_authentication_status_changing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_enumeration_completed(self, handler: winrt.windows.foundation.TypedEventHandler[UserWatcher, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_enumeration_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_removed(self, handler: winrt.windows.foundation.TypedEventHandler[UserWatcher, UserChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_removed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_stopped(self, handler: winrt.windows.foundation.TypedEventHandler[UserWatcher, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_stopped(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_updated(self, handler: winrt.windows.foundation.TypedEventHandler[UserWatcher, UserChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_updated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def status(self) -> UserWatcherStatus: ...

@typing.final
class ILauncherViewOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ILauncherViewOptions: ...
    @_property
    def desired_remaining_view(self) -> winrt.windows.ui.viewmanagement.ViewSizePreference: ...
    @desired_remaining_view.setter
    def desired_remaining_view(self, value: winrt.windows.ui.viewmanagement.ViewSizePreference) -> None: ...

