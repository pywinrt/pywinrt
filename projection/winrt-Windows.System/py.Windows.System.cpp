// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.System.h"


namespace py::cpp::Windows::System
{
    // ----- AppActivationResult class --------------------

    static PyObject* _new_AppActivationResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::AppActivationResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::AppActivationResult>::type_name);
        return nullptr;
    }

    static void _dealloc_AppActivationResult(py::wrapper::Windows::System::AppActivationResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppActivationResult_get_AppResourceGroupInfo(py::wrapper::Windows::System::AppActivationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppActivationResult", L"AppResourceGroupInfo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppResourceGroupInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppActivationResult_get_ExtendedError(py::wrapper::Windows::System::AppActivationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppActivationResult", L"ExtendedError"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppActivationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppActivationResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppActivationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppActivationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppActivationResult[] = {
        { "_assign_array_", _assign_array_AppActivationResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppActivationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppActivationResult[] = {
        { "app_resource_group_info", reinterpret_cast<getter>(AppActivationResult_get_AppResourceGroupInfo), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(AppActivationResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppActivationResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppActivationResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppActivationResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppActivationResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppActivationResult) },
        { },
    };

    static PyType_Spec type_spec_AppActivationResult =
    {
        "winrt._winrt_windows_system.AppActivationResult",
        sizeof(py::wrapper::Windows::System::AppActivationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppActivationResult
    };

    // ----- AppDiagnosticInfo class --------------------

    static PyObject* _new_AppDiagnosticInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::AppDiagnosticInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::AppDiagnosticInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_AppDiagnosticInfo(py::wrapper::Windows::System::AppDiagnosticInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppDiagnosticInfo_CreateResourceGroupWatcher(py::wrapper::Windows::System::AppDiagnosticInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppDiagnosticInfo", L"CreateResourceGroupWatcher", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateResourceGroupWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfo_CreateWatcher(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppDiagnosticInfo", L"CreateWatcher", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::System::AppDiagnosticInfo::CreateWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfo_GetResourceGroups(py::wrapper::Windows::System::AppDiagnosticInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppDiagnosticInfo", L"GetResourceGroups", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetResourceGroups());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfo_LaunchAsync(py::wrapper::Windows::System::AppDiagnosticInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppDiagnosticInfo", L"LaunchAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.LaunchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfo_RequestAccessAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppDiagnosticInfo", L"RequestAccessAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::System::AppDiagnosticInfo::RequestAccessAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfo_RequestInfoAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppDiagnosticInfo", L"RequestInfoAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::System::AppDiagnosticInfo::RequestInfoAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfo_RequestInfoForAppAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppDiagnosticInfo", L"RequestInfoForAppAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::System::AppDiagnosticInfo::RequestInfoForAppAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppDiagnosticInfo", L"RequestInfoForAppAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::System::AppDiagnosticInfo::RequestInfoForAppAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfo_RequestInfoForPackageAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppDiagnosticInfo", L"RequestInfoForPackageAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::System::AppDiagnosticInfo::RequestInfoForPackageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfo_get_AppInfo(py::wrapper::Windows::System::AppDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppDiagnosticInfo", L"AppInfo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppDiagnosticInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppDiagnosticInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppDiagnosticInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppDiagnosticInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppDiagnosticInfo[] = {
        { "create_resource_group_watcher", reinterpret_cast<PyCFunction>(AppDiagnosticInfo_CreateResourceGroupWatcher), METH_VARARGS, nullptr },
        { "get_resource_groups", reinterpret_cast<PyCFunction>(AppDiagnosticInfo_GetResourceGroups), METH_VARARGS, nullptr },
        { "launch_async", reinterpret_cast<PyCFunction>(AppDiagnosticInfo_LaunchAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppDiagnosticInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppDiagnosticInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppDiagnosticInfo[] = {
        { "app_info", reinterpret_cast<getter>(AppDiagnosticInfo_get_AppInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppDiagnosticInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppDiagnosticInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppDiagnosticInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppDiagnosticInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppDiagnosticInfo) },
        { },
    };

    static PyType_Spec type_spec_AppDiagnosticInfo =
    {
        "winrt._winrt_windows_system.AppDiagnosticInfo",
        sizeof(py::wrapper::Windows::System::AppDiagnosticInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppDiagnosticInfo
    };

    static PyGetSetDef getset_AppDiagnosticInfo_Static[] = {
        { }
    };

    static PyMethodDef methods_AppDiagnosticInfo_Static[] = {
        { "create_watcher", reinterpret_cast<PyCFunction>(AppDiagnosticInfo_CreateWatcher), METH_VARARGS, nullptr },
        { "request_access_async", reinterpret_cast<PyCFunction>(AppDiagnosticInfo_RequestAccessAsync), METH_VARARGS, nullptr },
        { "request_info_async", reinterpret_cast<PyCFunction>(AppDiagnosticInfo_RequestInfoAsync), METH_VARARGS, nullptr },
        { "request_info_for_app_async", reinterpret_cast<PyCFunction>(AppDiagnosticInfo_RequestInfoForAppAsync), METH_VARARGS, nullptr },
        { "request_info_for_package_async", reinterpret_cast<PyCFunction>(AppDiagnosticInfo_RequestInfoForPackageAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AppDiagnosticInfo_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppDiagnosticInfo_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppDiagnosticInfo_Static) },
        { }
    };

    static PyType_Spec type_spec_AppDiagnosticInfo_Static =
    {
        "winrt._winrt_windows_system.AppDiagnosticInfo_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AppDiagnosticInfo_Static
    };

    // ----- AppDiagnosticInfoWatcher class --------------------

    static PyObject* _new_AppDiagnosticInfoWatcher(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::AppDiagnosticInfoWatcher>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::AppDiagnosticInfoWatcher>::type_name);
        return nullptr;
    }

    static void _dealloc_AppDiagnosticInfoWatcher(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppDiagnosticInfoWatcher_Start(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppDiagnosticInfoWatcher", L"Start", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfoWatcher_Stop(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppDiagnosticInfoWatcher", L"Stop", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfoWatcher_get_Status(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppDiagnosticInfoWatcher", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfoWatcher_add_Added(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppDiagnosticInfoWatcher", L"Added"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::AppDiagnosticInfoWatcher, winrt::Windows::System::AppDiagnosticInfoWatcherEventArgs>>(arg);

            return py::convert(self->obj.Added(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfoWatcher_remove_Added(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppDiagnosticInfoWatcher", L"Added"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Added(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfoWatcher_add_EnumerationCompleted(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppDiagnosticInfoWatcher", L"EnumerationCompleted"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::AppDiagnosticInfoWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfoWatcher_remove_EnumerationCompleted(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppDiagnosticInfoWatcher", L"EnumerationCompleted"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfoWatcher_add_Removed(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppDiagnosticInfoWatcher", L"Removed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::AppDiagnosticInfoWatcher, winrt::Windows::System::AppDiagnosticInfoWatcherEventArgs>>(arg);

            return py::convert(self->obj.Removed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfoWatcher_remove_Removed(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppDiagnosticInfoWatcher", L"Removed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Removed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfoWatcher_add_Stopped(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppDiagnosticInfoWatcher", L"Stopped"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::AppDiagnosticInfoWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfoWatcher_remove_Stopped(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppDiagnosticInfoWatcher", L"Stopped"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppDiagnosticInfoWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppDiagnosticInfoWatcher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppDiagnosticInfoWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppDiagnosticInfoWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppDiagnosticInfoWatcher[] = {
        { "start", reinterpret_cast<PyCFunction>(AppDiagnosticInfoWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AppDiagnosticInfoWatcher_Stop), METH_VARARGS, nullptr },
        { "add_added", reinterpret_cast<PyCFunction>(AppDiagnosticInfoWatcher_add_Added), METH_O, nullptr },
        { "remove_added", reinterpret_cast<PyCFunction>(AppDiagnosticInfoWatcher_remove_Added), METH_O, nullptr },
        { "add_enumeration_completed", reinterpret_cast<PyCFunction>(AppDiagnosticInfoWatcher_add_EnumerationCompleted), METH_O, nullptr },
        { "remove_enumeration_completed", reinterpret_cast<PyCFunction>(AppDiagnosticInfoWatcher_remove_EnumerationCompleted), METH_O, nullptr },
        { "add_removed", reinterpret_cast<PyCFunction>(AppDiagnosticInfoWatcher_add_Removed), METH_O, nullptr },
        { "remove_removed", reinterpret_cast<PyCFunction>(AppDiagnosticInfoWatcher_remove_Removed), METH_O, nullptr },
        { "add_stopped", reinterpret_cast<PyCFunction>(AppDiagnosticInfoWatcher_add_Stopped), METH_O, nullptr },
        { "remove_stopped", reinterpret_cast<PyCFunction>(AppDiagnosticInfoWatcher_remove_Stopped), METH_O, nullptr },
        { "_assign_array_", _assign_array_AppDiagnosticInfoWatcher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppDiagnosticInfoWatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppDiagnosticInfoWatcher[] = {
        { "status", reinterpret_cast<getter>(AppDiagnosticInfoWatcher_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppDiagnosticInfoWatcher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppDiagnosticInfoWatcher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppDiagnosticInfoWatcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppDiagnosticInfoWatcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppDiagnosticInfoWatcher) },
        { },
    };

    static PyType_Spec type_spec_AppDiagnosticInfoWatcher =
    {
        "winrt._winrt_windows_system.AppDiagnosticInfoWatcher",
        sizeof(py::wrapper::Windows::System::AppDiagnosticInfoWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppDiagnosticInfoWatcher
    };

    // ----- AppDiagnosticInfoWatcherEventArgs class --------------------

    static PyObject* _new_AppDiagnosticInfoWatcherEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::AppDiagnosticInfoWatcherEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::AppDiagnosticInfoWatcherEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AppDiagnosticInfoWatcherEventArgs(py::wrapper::Windows::System::AppDiagnosticInfoWatcherEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppDiagnosticInfoWatcherEventArgs_get_AppDiagnosticInfo(py::wrapper::Windows::System::AppDiagnosticInfoWatcherEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppDiagnosticInfoWatcherEventArgs", L"AppDiagnosticInfo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppDiagnosticInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppDiagnosticInfoWatcherEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppDiagnosticInfoWatcherEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppDiagnosticInfoWatcherEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppDiagnosticInfoWatcherEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppDiagnosticInfoWatcherEventArgs[] = {
        { "_assign_array_", _assign_array_AppDiagnosticInfoWatcherEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppDiagnosticInfoWatcherEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppDiagnosticInfoWatcherEventArgs[] = {
        { "app_diagnostic_info", reinterpret_cast<getter>(AppDiagnosticInfoWatcherEventArgs_get_AppDiagnosticInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppDiagnosticInfoWatcherEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppDiagnosticInfoWatcherEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppDiagnosticInfoWatcherEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppDiagnosticInfoWatcherEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppDiagnosticInfoWatcherEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AppDiagnosticInfoWatcherEventArgs =
    {
        "winrt._winrt_windows_system.AppDiagnosticInfoWatcherEventArgs",
        sizeof(py::wrapper::Windows::System::AppDiagnosticInfoWatcherEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppDiagnosticInfoWatcherEventArgs
    };

    // ----- AppExecutionStateChangeResult class --------------------

    static PyObject* _new_AppExecutionStateChangeResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::AppExecutionStateChangeResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::AppExecutionStateChangeResult>::type_name);
        return nullptr;
    }

    static void _dealloc_AppExecutionStateChangeResult(py::wrapper::Windows::System::AppExecutionStateChangeResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppExecutionStateChangeResult_get_ExtendedError(py::wrapper::Windows::System::AppExecutionStateChangeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppExecutionStateChangeResult", L"ExtendedError"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppExecutionStateChangeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppExecutionStateChangeResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppExecutionStateChangeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppExecutionStateChangeResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppExecutionStateChangeResult[] = {
        { "_assign_array_", _assign_array_AppExecutionStateChangeResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppExecutionStateChangeResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppExecutionStateChangeResult[] = {
        { "extended_error", reinterpret_cast<getter>(AppExecutionStateChangeResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppExecutionStateChangeResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppExecutionStateChangeResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppExecutionStateChangeResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppExecutionStateChangeResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppExecutionStateChangeResult) },
        { },
    };

    static PyType_Spec type_spec_AppExecutionStateChangeResult =
    {
        "winrt._winrt_windows_system.AppExecutionStateChangeResult",
        sizeof(py::wrapper::Windows::System::AppExecutionStateChangeResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppExecutionStateChangeResult
    };

    // ----- AppMemoryReport class --------------------

    static PyObject* _new_AppMemoryReport(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::AppMemoryReport>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::AppMemoryReport>::type_name);
        return nullptr;
    }

    static void _dealloc_AppMemoryReport(py::wrapper::Windows::System::AppMemoryReport* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppMemoryReport_get_PeakPrivateCommitUsage(py::wrapper::Windows::System::AppMemoryReport* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppMemoryReport", L"PeakPrivateCommitUsage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PeakPrivateCommitUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppMemoryReport_get_PrivateCommitUsage(py::wrapper::Windows::System::AppMemoryReport* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppMemoryReport", L"PrivateCommitUsage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PrivateCommitUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppMemoryReport_get_TotalCommitLimit(py::wrapper::Windows::System::AppMemoryReport* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppMemoryReport", L"TotalCommitLimit"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TotalCommitLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppMemoryReport_get_TotalCommitUsage(py::wrapper::Windows::System::AppMemoryReport* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppMemoryReport", L"TotalCommitUsage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TotalCommitUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppMemoryReport_get_ExpectedTotalCommitLimit(py::wrapper::Windows::System::AppMemoryReport* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppMemoryReport", L"ExpectedTotalCommitLimit"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpectedTotalCommitLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppMemoryReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppMemoryReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppMemoryReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppMemoryReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppMemoryReport[] = {
        { "_assign_array_", _assign_array_AppMemoryReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppMemoryReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppMemoryReport[] = {
        { "peak_private_commit_usage", reinterpret_cast<getter>(AppMemoryReport_get_PeakPrivateCommitUsage), nullptr, nullptr, nullptr },
        { "private_commit_usage", reinterpret_cast<getter>(AppMemoryReport_get_PrivateCommitUsage), nullptr, nullptr, nullptr },
        { "total_commit_limit", reinterpret_cast<getter>(AppMemoryReport_get_TotalCommitLimit), nullptr, nullptr, nullptr },
        { "total_commit_usage", reinterpret_cast<getter>(AppMemoryReport_get_TotalCommitUsage), nullptr, nullptr, nullptr },
        { "expected_total_commit_limit", reinterpret_cast<getter>(AppMemoryReport_get_ExpectedTotalCommitLimit), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppMemoryReport[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppMemoryReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppMemoryReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppMemoryReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppMemoryReport) },
        { },
    };

    static PyType_Spec type_spec_AppMemoryReport =
    {
        "winrt._winrt_windows_system.AppMemoryReport",
        sizeof(py::wrapper::Windows::System::AppMemoryReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppMemoryReport
    };

    // ----- AppMemoryUsageLimitChangingEventArgs class --------------------

    static PyObject* _new_AppMemoryUsageLimitChangingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::AppMemoryUsageLimitChangingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::AppMemoryUsageLimitChangingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AppMemoryUsageLimitChangingEventArgs(py::wrapper::Windows::System::AppMemoryUsageLimitChangingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppMemoryUsageLimitChangingEventArgs_get_NewLimit(py::wrapper::Windows::System::AppMemoryUsageLimitChangingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppMemoryUsageLimitChangingEventArgs", L"NewLimit"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NewLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppMemoryUsageLimitChangingEventArgs_get_OldLimit(py::wrapper::Windows::System::AppMemoryUsageLimitChangingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppMemoryUsageLimitChangingEventArgs", L"OldLimit"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OldLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppMemoryUsageLimitChangingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppMemoryUsageLimitChangingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppMemoryUsageLimitChangingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppMemoryUsageLimitChangingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppMemoryUsageLimitChangingEventArgs[] = {
        { "_assign_array_", _assign_array_AppMemoryUsageLimitChangingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppMemoryUsageLimitChangingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppMemoryUsageLimitChangingEventArgs[] = {
        { "new_limit", reinterpret_cast<getter>(AppMemoryUsageLimitChangingEventArgs_get_NewLimit), nullptr, nullptr, nullptr },
        { "old_limit", reinterpret_cast<getter>(AppMemoryUsageLimitChangingEventArgs_get_OldLimit), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppMemoryUsageLimitChangingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppMemoryUsageLimitChangingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppMemoryUsageLimitChangingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppMemoryUsageLimitChangingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppMemoryUsageLimitChangingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AppMemoryUsageLimitChangingEventArgs =
    {
        "winrt._winrt_windows_system.AppMemoryUsageLimitChangingEventArgs",
        sizeof(py::wrapper::Windows::System::AppMemoryUsageLimitChangingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppMemoryUsageLimitChangingEventArgs
    };

    // ----- AppResourceGroupBackgroundTaskReport class --------------------

    static PyObject* _new_AppResourceGroupBackgroundTaskReport(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::AppResourceGroupBackgroundTaskReport>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::AppResourceGroupBackgroundTaskReport>::type_name);
        return nullptr;
    }

    static void _dealloc_AppResourceGroupBackgroundTaskReport(py::wrapper::Windows::System::AppResourceGroupBackgroundTaskReport* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppResourceGroupBackgroundTaskReport_get_EntryPoint(py::wrapper::Windows::System::AppResourceGroupBackgroundTaskReport* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupBackgroundTaskReport", L"EntryPoint"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EntryPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupBackgroundTaskReport_get_Name(py::wrapper::Windows::System::AppResourceGroupBackgroundTaskReport* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupBackgroundTaskReport", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupBackgroundTaskReport_get_TaskId(py::wrapper::Windows::System::AppResourceGroupBackgroundTaskReport* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupBackgroundTaskReport", L"TaskId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TaskId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupBackgroundTaskReport_get_Trigger(py::wrapper::Windows::System::AppResourceGroupBackgroundTaskReport* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupBackgroundTaskReport", L"Trigger"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Trigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppResourceGroupBackgroundTaskReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppResourceGroupBackgroundTaskReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppResourceGroupBackgroundTaskReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppResourceGroupBackgroundTaskReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppResourceGroupBackgroundTaskReport[] = {
        { "_assign_array_", _assign_array_AppResourceGroupBackgroundTaskReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppResourceGroupBackgroundTaskReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppResourceGroupBackgroundTaskReport[] = {
        { "entry_point", reinterpret_cast<getter>(AppResourceGroupBackgroundTaskReport_get_EntryPoint), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(AppResourceGroupBackgroundTaskReport_get_Name), nullptr, nullptr, nullptr },
        { "task_id", reinterpret_cast<getter>(AppResourceGroupBackgroundTaskReport_get_TaskId), nullptr, nullptr, nullptr },
        { "trigger", reinterpret_cast<getter>(AppResourceGroupBackgroundTaskReport_get_Trigger), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppResourceGroupBackgroundTaskReport[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppResourceGroupBackgroundTaskReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppResourceGroupBackgroundTaskReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppResourceGroupBackgroundTaskReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppResourceGroupBackgroundTaskReport) },
        { },
    };

    static PyType_Spec type_spec_AppResourceGroupBackgroundTaskReport =
    {
        "winrt._winrt_windows_system.AppResourceGroupBackgroundTaskReport",
        sizeof(py::wrapper::Windows::System::AppResourceGroupBackgroundTaskReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppResourceGroupBackgroundTaskReport
    };

    // ----- AppResourceGroupInfo class --------------------

    static PyObject* _new_AppResourceGroupInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::AppResourceGroupInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::AppResourceGroupInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_AppResourceGroupInfo(py::wrapper::Windows::System::AppResourceGroupInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppResourceGroupInfo_GetBackgroundTaskReports(py::wrapper::Windows::System::AppResourceGroupInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppResourceGroupInfo", L"GetBackgroundTaskReports", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetBackgroundTaskReports());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfo_GetMemoryReport(py::wrapper::Windows::System::AppResourceGroupInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppResourceGroupInfo", L"GetMemoryReport", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetMemoryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfo_GetProcessDiagnosticInfos(py::wrapper::Windows::System::AppResourceGroupInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppResourceGroupInfo", L"GetProcessDiagnosticInfos", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetProcessDiagnosticInfos());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfo_GetStateReport(py::wrapper::Windows::System::AppResourceGroupInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppResourceGroupInfo", L"GetStateReport", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetStateReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfo_StartResumeAsync(py::wrapper::Windows::System::AppResourceGroupInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppResourceGroupInfo", L"StartResumeAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.StartResumeAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfo_StartSuspendAsync(py::wrapper::Windows::System::AppResourceGroupInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppResourceGroupInfo", L"StartSuspendAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.StartSuspendAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfo_StartTerminateAsync(py::wrapper::Windows::System::AppResourceGroupInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppResourceGroupInfo", L"StartTerminateAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.StartTerminateAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfo_get_InstanceId(py::wrapper::Windows::System::AppResourceGroupInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupInfo", L"InstanceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InstanceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfo_get_IsShared(py::wrapper::Windows::System::AppResourceGroupInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupInfo", L"IsShared"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsShared());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppResourceGroupInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppResourceGroupInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppResourceGroupInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppResourceGroupInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppResourceGroupInfo[] = {
        { "get_background_task_reports", reinterpret_cast<PyCFunction>(AppResourceGroupInfo_GetBackgroundTaskReports), METH_VARARGS, nullptr },
        { "get_memory_report", reinterpret_cast<PyCFunction>(AppResourceGroupInfo_GetMemoryReport), METH_VARARGS, nullptr },
        { "get_process_diagnostic_infos", reinterpret_cast<PyCFunction>(AppResourceGroupInfo_GetProcessDiagnosticInfos), METH_VARARGS, nullptr },
        { "get_state_report", reinterpret_cast<PyCFunction>(AppResourceGroupInfo_GetStateReport), METH_VARARGS, nullptr },
        { "start_resume_async", reinterpret_cast<PyCFunction>(AppResourceGroupInfo_StartResumeAsync), METH_VARARGS, nullptr },
        { "start_suspend_async", reinterpret_cast<PyCFunction>(AppResourceGroupInfo_StartSuspendAsync), METH_VARARGS, nullptr },
        { "start_terminate_async", reinterpret_cast<PyCFunction>(AppResourceGroupInfo_StartTerminateAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppResourceGroupInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppResourceGroupInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppResourceGroupInfo[] = {
        { "instance_id", reinterpret_cast<getter>(AppResourceGroupInfo_get_InstanceId), nullptr, nullptr, nullptr },
        { "is_shared", reinterpret_cast<getter>(AppResourceGroupInfo_get_IsShared), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppResourceGroupInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppResourceGroupInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppResourceGroupInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppResourceGroupInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppResourceGroupInfo) },
        { },
    };

    static PyType_Spec type_spec_AppResourceGroupInfo =
    {
        "winrt._winrt_windows_system.AppResourceGroupInfo",
        sizeof(py::wrapper::Windows::System::AppResourceGroupInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppResourceGroupInfo
    };

    // ----- AppResourceGroupInfoWatcher class --------------------

    static PyObject* _new_AppResourceGroupInfoWatcher(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::AppResourceGroupInfoWatcher>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::AppResourceGroupInfoWatcher>::type_name);
        return nullptr;
    }

    static void _dealloc_AppResourceGroupInfoWatcher(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppResourceGroupInfoWatcher_Start(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppResourceGroupInfoWatcher", L"Start", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_Stop(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppResourceGroupInfoWatcher", L"Stop", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_get_Status(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupInfoWatcher", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_add_Added(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppResourceGroupInfoWatcher", L"Added"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::AppResourceGroupInfoWatcher, winrt::Windows::System::AppResourceGroupInfoWatcherEventArgs>>(arg);

            return py::convert(self->obj.Added(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_remove_Added(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppResourceGroupInfoWatcher", L"Added"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Added(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_add_EnumerationCompleted(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppResourceGroupInfoWatcher", L"EnumerationCompleted"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::AppResourceGroupInfoWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_remove_EnumerationCompleted(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppResourceGroupInfoWatcher", L"EnumerationCompleted"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_add_ExecutionStateChanged(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppResourceGroupInfoWatcher", L"ExecutionStateChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::AppResourceGroupInfoWatcher, winrt::Windows::System::AppResourceGroupInfoWatcherExecutionStateChangedEventArgs>>(arg);

            return py::convert(self->obj.ExecutionStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_remove_ExecutionStateChanged(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppResourceGroupInfoWatcher", L"ExecutionStateChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ExecutionStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_add_Removed(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppResourceGroupInfoWatcher", L"Removed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::AppResourceGroupInfoWatcher, winrt::Windows::System::AppResourceGroupInfoWatcherEventArgs>>(arg);

            return py::convert(self->obj.Removed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_remove_Removed(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppResourceGroupInfoWatcher", L"Removed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Removed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_add_Stopped(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppResourceGroupInfoWatcher", L"Stopped"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::AppResourceGroupInfoWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_remove_Stopped(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppResourceGroupInfoWatcher", L"Stopped"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppResourceGroupInfoWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppResourceGroupInfoWatcher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppResourceGroupInfoWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppResourceGroupInfoWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppResourceGroupInfoWatcher[] = {
        { "start", reinterpret_cast<PyCFunction>(AppResourceGroupInfoWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AppResourceGroupInfoWatcher_Stop), METH_VARARGS, nullptr },
        { "add_added", reinterpret_cast<PyCFunction>(AppResourceGroupInfoWatcher_add_Added), METH_O, nullptr },
        { "remove_added", reinterpret_cast<PyCFunction>(AppResourceGroupInfoWatcher_remove_Added), METH_O, nullptr },
        { "add_enumeration_completed", reinterpret_cast<PyCFunction>(AppResourceGroupInfoWatcher_add_EnumerationCompleted), METH_O, nullptr },
        { "remove_enumeration_completed", reinterpret_cast<PyCFunction>(AppResourceGroupInfoWatcher_remove_EnumerationCompleted), METH_O, nullptr },
        { "add_execution_state_changed", reinterpret_cast<PyCFunction>(AppResourceGroupInfoWatcher_add_ExecutionStateChanged), METH_O, nullptr },
        { "remove_execution_state_changed", reinterpret_cast<PyCFunction>(AppResourceGroupInfoWatcher_remove_ExecutionStateChanged), METH_O, nullptr },
        { "add_removed", reinterpret_cast<PyCFunction>(AppResourceGroupInfoWatcher_add_Removed), METH_O, nullptr },
        { "remove_removed", reinterpret_cast<PyCFunction>(AppResourceGroupInfoWatcher_remove_Removed), METH_O, nullptr },
        { "add_stopped", reinterpret_cast<PyCFunction>(AppResourceGroupInfoWatcher_add_Stopped), METH_O, nullptr },
        { "remove_stopped", reinterpret_cast<PyCFunction>(AppResourceGroupInfoWatcher_remove_Stopped), METH_O, nullptr },
        { "_assign_array_", _assign_array_AppResourceGroupInfoWatcher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppResourceGroupInfoWatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppResourceGroupInfoWatcher[] = {
        { "status", reinterpret_cast<getter>(AppResourceGroupInfoWatcher_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppResourceGroupInfoWatcher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppResourceGroupInfoWatcher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppResourceGroupInfoWatcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppResourceGroupInfoWatcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppResourceGroupInfoWatcher) },
        { },
    };

    static PyType_Spec type_spec_AppResourceGroupInfoWatcher =
    {
        "winrt._winrt_windows_system.AppResourceGroupInfoWatcher",
        sizeof(py::wrapper::Windows::System::AppResourceGroupInfoWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppResourceGroupInfoWatcher
    };

    // ----- AppResourceGroupInfoWatcherEventArgs class --------------------

    static PyObject* _new_AppResourceGroupInfoWatcherEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::AppResourceGroupInfoWatcherEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::AppResourceGroupInfoWatcherEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AppResourceGroupInfoWatcherEventArgs(py::wrapper::Windows::System::AppResourceGroupInfoWatcherEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppResourceGroupInfoWatcherEventArgs_get_AppDiagnosticInfos(py::wrapper::Windows::System::AppResourceGroupInfoWatcherEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupInfoWatcherEventArgs", L"AppDiagnosticInfos"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppDiagnosticInfos());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcherEventArgs_get_AppResourceGroupInfo(py::wrapper::Windows::System::AppResourceGroupInfoWatcherEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupInfoWatcherEventArgs", L"AppResourceGroupInfo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppResourceGroupInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppResourceGroupInfoWatcherEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppResourceGroupInfoWatcherEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppResourceGroupInfoWatcherEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppResourceGroupInfoWatcherEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppResourceGroupInfoWatcherEventArgs[] = {
        { "_assign_array_", _assign_array_AppResourceGroupInfoWatcherEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppResourceGroupInfoWatcherEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppResourceGroupInfoWatcherEventArgs[] = {
        { "app_diagnostic_infos", reinterpret_cast<getter>(AppResourceGroupInfoWatcherEventArgs_get_AppDiagnosticInfos), nullptr, nullptr, nullptr },
        { "app_resource_group_info", reinterpret_cast<getter>(AppResourceGroupInfoWatcherEventArgs_get_AppResourceGroupInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppResourceGroupInfoWatcherEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppResourceGroupInfoWatcherEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppResourceGroupInfoWatcherEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppResourceGroupInfoWatcherEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppResourceGroupInfoWatcherEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AppResourceGroupInfoWatcherEventArgs =
    {
        "winrt._winrt_windows_system.AppResourceGroupInfoWatcherEventArgs",
        sizeof(py::wrapper::Windows::System::AppResourceGroupInfoWatcherEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppResourceGroupInfoWatcherEventArgs
    };

    // ----- AppResourceGroupInfoWatcherExecutionStateChangedEventArgs class --------------------

    static PyObject* _new_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::AppResourceGroupInfoWatcherExecutionStateChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::AppResourceGroupInfoWatcherExecutionStateChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs(py::wrapper::Windows::System::AppResourceGroupInfoWatcherExecutionStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppResourceGroupInfoWatcherExecutionStateChangedEventArgs_get_AppDiagnosticInfos(py::wrapper::Windows::System::AppResourceGroupInfoWatcherExecutionStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupInfoWatcherExecutionStateChangedEventArgs", L"AppDiagnosticInfos"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppDiagnosticInfos());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcherExecutionStateChangedEventArgs_get_AppResourceGroupInfo(py::wrapper::Windows::System::AppResourceGroupInfoWatcherExecutionStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupInfoWatcherExecutionStateChangedEventArgs", L"AppResourceGroupInfo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppResourceGroupInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppResourceGroupInfoWatcherExecutionStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppResourceGroupInfoWatcherExecutionStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs[] = {
        { "app_diagnostic_infos", reinterpret_cast<getter>(AppResourceGroupInfoWatcherExecutionStateChangedEventArgs_get_AppDiagnosticInfos), nullptr, nullptr, nullptr },
        { "app_resource_group_info", reinterpret_cast<getter>(AppResourceGroupInfoWatcherExecutionStateChangedEventArgs_get_AppResourceGroupInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs =
    {
        "winrt._winrt_windows_system.AppResourceGroupInfoWatcherExecutionStateChangedEventArgs",
        sizeof(py::wrapper::Windows::System::AppResourceGroupInfoWatcherExecutionStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs
    };

    // ----- AppResourceGroupMemoryReport class --------------------

    static PyObject* _new_AppResourceGroupMemoryReport(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::AppResourceGroupMemoryReport>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::AppResourceGroupMemoryReport>::type_name);
        return nullptr;
    }

    static void _dealloc_AppResourceGroupMemoryReport(py::wrapper::Windows::System::AppResourceGroupMemoryReport* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppResourceGroupMemoryReport_get_CommitUsageLevel(py::wrapper::Windows::System::AppResourceGroupMemoryReport* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupMemoryReport", L"CommitUsageLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CommitUsageLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupMemoryReport_get_CommitUsageLimit(py::wrapper::Windows::System::AppResourceGroupMemoryReport* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupMemoryReport", L"CommitUsageLimit"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CommitUsageLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupMemoryReport_get_PrivateCommitUsage(py::wrapper::Windows::System::AppResourceGroupMemoryReport* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupMemoryReport", L"PrivateCommitUsage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PrivateCommitUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupMemoryReport_get_TotalCommitUsage(py::wrapper::Windows::System::AppResourceGroupMemoryReport* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupMemoryReport", L"TotalCommitUsage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TotalCommitUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppResourceGroupMemoryReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppResourceGroupMemoryReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppResourceGroupMemoryReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppResourceGroupMemoryReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppResourceGroupMemoryReport[] = {
        { "_assign_array_", _assign_array_AppResourceGroupMemoryReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppResourceGroupMemoryReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppResourceGroupMemoryReport[] = {
        { "commit_usage_level", reinterpret_cast<getter>(AppResourceGroupMemoryReport_get_CommitUsageLevel), nullptr, nullptr, nullptr },
        { "commit_usage_limit", reinterpret_cast<getter>(AppResourceGroupMemoryReport_get_CommitUsageLimit), nullptr, nullptr, nullptr },
        { "private_commit_usage", reinterpret_cast<getter>(AppResourceGroupMemoryReport_get_PrivateCommitUsage), nullptr, nullptr, nullptr },
        { "total_commit_usage", reinterpret_cast<getter>(AppResourceGroupMemoryReport_get_TotalCommitUsage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppResourceGroupMemoryReport[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppResourceGroupMemoryReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppResourceGroupMemoryReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppResourceGroupMemoryReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppResourceGroupMemoryReport) },
        { },
    };

    static PyType_Spec type_spec_AppResourceGroupMemoryReport =
    {
        "winrt._winrt_windows_system.AppResourceGroupMemoryReport",
        sizeof(py::wrapper::Windows::System::AppResourceGroupMemoryReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppResourceGroupMemoryReport
    };

    // ----- AppResourceGroupStateReport class --------------------

    static PyObject* _new_AppResourceGroupStateReport(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::AppResourceGroupStateReport>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::AppResourceGroupStateReport>::type_name);
        return nullptr;
    }

    static void _dealloc_AppResourceGroupStateReport(py::wrapper::Windows::System::AppResourceGroupStateReport* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppResourceGroupStateReport_get_EnergyQuotaState(py::wrapper::Windows::System::AppResourceGroupStateReport* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupStateReport", L"EnergyQuotaState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EnergyQuotaState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupStateReport_get_ExecutionState(py::wrapper::Windows::System::AppResourceGroupStateReport* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupStateReport", L"ExecutionState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppResourceGroupStateReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppResourceGroupStateReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppResourceGroupStateReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppResourceGroupStateReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppResourceGroupStateReport[] = {
        { "_assign_array_", _assign_array_AppResourceGroupStateReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppResourceGroupStateReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppResourceGroupStateReport[] = {
        { "energy_quota_state", reinterpret_cast<getter>(AppResourceGroupStateReport_get_EnergyQuotaState), nullptr, nullptr, nullptr },
        { "execution_state", reinterpret_cast<getter>(AppResourceGroupStateReport_get_ExecutionState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppResourceGroupStateReport[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppResourceGroupStateReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppResourceGroupStateReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppResourceGroupStateReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppResourceGroupStateReport) },
        { },
    };

    static PyType_Spec type_spec_AppResourceGroupStateReport =
    {
        "winrt._winrt_windows_system.AppResourceGroupStateReport",
        sizeof(py::wrapper::Windows::System::AppResourceGroupStateReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppResourceGroupStateReport
    };

    // ----- AppUriHandlerHost class --------------------

    static PyObject* _new_AppUriHandlerHost(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::System::AppUriHandlerHost instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::System::AppUriHandlerHost instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppUriHandlerHost(py::wrapper::Windows::System::AppUriHandlerHost* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppUriHandlerHost_get_Name(py::wrapper::Windows::System::AppUriHandlerHost* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppUriHandlerHost", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppUriHandlerHost_put_Name(py::wrapper::Windows::System::AppUriHandlerHost* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppUriHandlerHost", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppUriHandlerHost_get_IsEnabled(py::wrapper::Windows::System::AppUriHandlerHost* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppUriHandlerHost", L"IsEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppUriHandlerHost_put_IsEnabled(py::wrapper::Windows::System::AppUriHandlerHost* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppUriHandlerHost", L"IsEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AppUriHandlerHost(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppUriHandlerHost>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppUriHandlerHost(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppUriHandlerHost>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppUriHandlerHost[] = {
        { "_assign_array_", _assign_array_AppUriHandlerHost, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppUriHandlerHost), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppUriHandlerHost[] = {
        { "name", reinterpret_cast<getter>(AppUriHandlerHost_get_Name), reinterpret_cast<setter>(AppUriHandlerHost_put_Name), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(AppUriHandlerHost_get_IsEnabled), reinterpret_cast<setter>(AppUriHandlerHost_put_IsEnabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppUriHandlerHost[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppUriHandlerHost) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppUriHandlerHost) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppUriHandlerHost) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppUriHandlerHost) },
        { },
    };

    static PyType_Spec type_spec_AppUriHandlerHost =
    {
        "winrt._winrt_windows_system.AppUriHandlerHost",
        sizeof(py::wrapper::Windows::System::AppUriHandlerHost),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppUriHandlerHost
    };

    // ----- AppUriHandlerRegistration class --------------------

    static PyObject* _new_AppUriHandlerRegistration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::AppUriHandlerRegistration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::AppUriHandlerRegistration>::type_name);
        return nullptr;
    }

    static void _dealloc_AppUriHandlerRegistration(py::wrapper::Windows::System::AppUriHandlerRegistration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppUriHandlerRegistration_GetAllHosts(py::wrapper::Windows::System::AppUriHandlerRegistration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppUriHandlerRegistration", L"GetAllHosts", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAllHosts());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistration_GetAppAddedHostsAsync(py::wrapper::Windows::System::AppUriHandlerRegistration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppUriHandlerRegistration", L"GetAppAddedHostsAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAppAddedHostsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistration_SetAppAddedHostsAsync(py::wrapper::Windows::System::AppUriHandlerRegistration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppUriHandlerRegistration", L"SetAppAddedHostsAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::System::AppUriHandlerHost>>(args, 0);

                return py::convert(self->obj.SetAppAddedHostsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistration_UpdateHosts(py::wrapper::Windows::System::AppUriHandlerRegistration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppUriHandlerRegistration", L"UpdateHosts", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::System::AppUriHandlerHost>>(args, 0);

                self->obj.UpdateHosts(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistration_get_Name(py::wrapper::Windows::System::AppUriHandlerRegistration* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppUriHandlerRegistration", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistration_get_User(py::wrapper::Windows::System::AppUriHandlerRegistration* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppUriHandlerRegistration", L"User"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistration_get_PackageFamilyName(py::wrapper::Windows::System::AppUriHandlerRegistration* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppUriHandlerRegistration", L"PackageFamilyName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppUriHandlerRegistration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppUriHandlerRegistration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppUriHandlerRegistration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppUriHandlerRegistration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppUriHandlerRegistration[] = {
        { "get_all_hosts", reinterpret_cast<PyCFunction>(AppUriHandlerRegistration_GetAllHosts), METH_VARARGS, nullptr },
        { "get_app_added_hosts_async", reinterpret_cast<PyCFunction>(AppUriHandlerRegistration_GetAppAddedHostsAsync), METH_VARARGS, nullptr },
        { "set_app_added_hosts_async", reinterpret_cast<PyCFunction>(AppUriHandlerRegistration_SetAppAddedHostsAsync), METH_VARARGS, nullptr },
        { "update_hosts", reinterpret_cast<PyCFunction>(AppUriHandlerRegistration_UpdateHosts), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppUriHandlerRegistration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppUriHandlerRegistration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppUriHandlerRegistration[] = {
        { "name", reinterpret_cast<getter>(AppUriHandlerRegistration_get_Name), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(AppUriHandlerRegistration_get_User), nullptr, nullptr, nullptr },
        { "package_family_name", reinterpret_cast<getter>(AppUriHandlerRegistration_get_PackageFamilyName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppUriHandlerRegistration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppUriHandlerRegistration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppUriHandlerRegistration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppUriHandlerRegistration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppUriHandlerRegistration) },
        { },
    };

    static PyType_Spec type_spec_AppUriHandlerRegistration =
    {
        "winrt._winrt_windows_system.AppUriHandlerRegistration",
        sizeof(py::wrapper::Windows::System::AppUriHandlerRegistration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppUriHandlerRegistration
    };

    // ----- AppUriHandlerRegistrationManager class --------------------

    static PyObject* _new_AppUriHandlerRegistrationManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::AppUriHandlerRegistrationManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::AppUriHandlerRegistrationManager>::type_name);
        return nullptr;
    }

    static void _dealloc_AppUriHandlerRegistrationManager(py::wrapper::Windows::System::AppUriHandlerRegistrationManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppUriHandlerRegistrationManager_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppUriHandlerRegistrationManager", L"GetDefault", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::System::AppUriHandlerRegistrationManager::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistrationManager_GetForPackage(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppUriHandlerRegistrationManager", L"GetForPackage", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::System::AppUriHandlerRegistrationManager::GetForPackage(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistrationManager_GetForPackageForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppUriHandlerRegistrationManager", L"GetForPackageForUser", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::User>(args, 1);

                return py::convert(winrt::Windows::System::AppUriHandlerRegistrationManager::GetForPackageForUser(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistrationManager_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppUriHandlerRegistrationManager", L"GetForUser", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::System::AppUriHandlerRegistrationManager::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistrationManager_TryGetRegistration(py::wrapper::Windows::System::AppUriHandlerRegistrationManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppUriHandlerRegistrationManager", L"TryGetRegistration", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryGetRegistration(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistrationManager_get_User(py::wrapper::Windows::System::AppUriHandlerRegistrationManager* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppUriHandlerRegistrationManager", L"User"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistrationManager_get_PackageFamilyName(py::wrapper::Windows::System::AppUriHandlerRegistrationManager* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppUriHandlerRegistrationManager", L"PackageFamilyName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppUriHandlerRegistrationManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppUriHandlerRegistrationManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppUriHandlerRegistrationManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppUriHandlerRegistrationManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppUriHandlerRegistrationManager[] = {
        { "try_get_registration", reinterpret_cast<PyCFunction>(AppUriHandlerRegistrationManager_TryGetRegistration), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppUriHandlerRegistrationManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppUriHandlerRegistrationManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppUriHandlerRegistrationManager[] = {
        { "user", reinterpret_cast<getter>(AppUriHandlerRegistrationManager_get_User), nullptr, nullptr, nullptr },
        { "package_family_name", reinterpret_cast<getter>(AppUriHandlerRegistrationManager_get_PackageFamilyName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppUriHandlerRegistrationManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppUriHandlerRegistrationManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppUriHandlerRegistrationManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppUriHandlerRegistrationManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppUriHandlerRegistrationManager) },
        { },
    };

    static PyType_Spec type_spec_AppUriHandlerRegistrationManager =
    {
        "winrt._winrt_windows_system.AppUriHandlerRegistrationManager",
        sizeof(py::wrapper::Windows::System::AppUriHandlerRegistrationManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppUriHandlerRegistrationManager
    };

    static PyGetSetDef getset_AppUriHandlerRegistrationManager_Static[] = {
        { }
    };

    static PyMethodDef methods_AppUriHandlerRegistrationManager_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(AppUriHandlerRegistrationManager_GetDefault), METH_VARARGS, nullptr },
        { "get_for_package", reinterpret_cast<PyCFunction>(AppUriHandlerRegistrationManager_GetForPackage), METH_VARARGS, nullptr },
        { "get_for_package_for_user", reinterpret_cast<PyCFunction>(AppUriHandlerRegistrationManager_GetForPackageForUser), METH_VARARGS, nullptr },
        { "get_for_user", reinterpret_cast<PyCFunction>(AppUriHandlerRegistrationManager_GetForUser), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AppUriHandlerRegistrationManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppUriHandlerRegistrationManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppUriHandlerRegistrationManager_Static) },
        { }
    };

    static PyType_Spec type_spec_AppUriHandlerRegistrationManager_Static =
    {
        "winrt._winrt_windows_system.AppUriHandlerRegistrationManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AppUriHandlerRegistrationManager_Static
    };

    // ----- DateTimeSettings class --------------------

    static PyObject* _new_DateTimeSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::DateTimeSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::DateTimeSettings>::type_name);
        return nullptr;
    }

    static PyObject* DateTimeSettings_SetSystemDateTime(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.DateTimeSettings", L"SetSystemDateTime", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

                winrt::Windows::System::DateTimeSettings::SetSystemDateTime(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_DateTimeSettings[] = {
        { }
    };

    static PyGetSetDef _getset_DateTimeSettings[] = {
        { }
    };

    static PyType_Slot _type_slots_DateTimeSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DateTimeSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DateTimeSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DateTimeSettings) },
        { },
    };

    static PyType_Spec type_spec_DateTimeSettings =
    {
        "winrt._winrt_windows_system.DateTimeSettings",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DateTimeSettings
    };

    static PyGetSetDef getset_DateTimeSettings_Static[] = {
        { }
    };

    static PyMethodDef methods_DateTimeSettings_Static[] = {
        { "set_system_date_time", reinterpret_cast<PyCFunction>(DateTimeSettings_SetSystemDateTime), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_DateTimeSettings_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DateTimeSettings_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DateTimeSettings_Static) },
        { }
    };

    static PyType_Spec type_spec_DateTimeSettings_Static =
    {
        "winrt._winrt_windows_system.DateTimeSettings_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DateTimeSettings_Static
    };

    // ----- DispatcherQueue class --------------------

    static PyObject* _new_DispatcherQueue(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::DispatcherQueue>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::DispatcherQueue>::type_name);
        return nullptr;
    }

    static void _dealloc_DispatcherQueue(py::wrapper::Windows::System::DispatcherQueue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DispatcherQueue_CreateTimer(py::wrapper::Windows::System::DispatcherQueue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.DispatcherQueue", L"CreateTimer", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateTimer());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DispatcherQueue_GetForCurrentThread(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.DispatcherQueue", L"GetForCurrentThread", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::System::DispatcherQueue::GetForCurrentThread());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DispatcherQueue_TryEnqueue(py::wrapper::Windows::System::DispatcherQueue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.DispatcherQueue", L"TryEnqueue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::DispatcherQueueHandler>(args, 0);

                return py::convert(self->obj.TryEnqueue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.DispatcherQueue", L"TryEnqueue", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::DispatcherQueuePriority>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::DispatcherQueueHandler>(args, 1);

                return py::convert(self->obj.TryEnqueue(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DispatcherQueue_get_HasThreadAccess(py::wrapper::Windows::System::DispatcherQueue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.DispatcherQueue", L"HasThreadAccess"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HasThreadAccess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DispatcherQueue_add_ShutdownCompleted(py::wrapper::Windows::System::DispatcherQueue* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.DispatcherQueue", L"ShutdownCompleted"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::DispatcherQueue, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ShutdownCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DispatcherQueue_remove_ShutdownCompleted(py::wrapper::Windows::System::DispatcherQueue* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.DispatcherQueue", L"ShutdownCompleted"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ShutdownCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DispatcherQueue_add_ShutdownStarting(py::wrapper::Windows::System::DispatcherQueue* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.DispatcherQueue", L"ShutdownStarting"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::DispatcherQueue, winrt::Windows::System::DispatcherQueueShutdownStartingEventArgs>>(arg);

            return py::convert(self->obj.ShutdownStarting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DispatcherQueue_remove_ShutdownStarting(py::wrapper::Windows::System::DispatcherQueue* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.DispatcherQueue", L"ShutdownStarting"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ShutdownStarting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DispatcherQueue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::DispatcherQueue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DispatcherQueue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::DispatcherQueue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DispatcherQueue[] = {
        { "create_timer", reinterpret_cast<PyCFunction>(DispatcherQueue_CreateTimer), METH_VARARGS, nullptr },
        { "try_enqueue", reinterpret_cast<PyCFunction>(DispatcherQueue_TryEnqueue), METH_VARARGS, nullptr },
        { "add_shutdown_completed", reinterpret_cast<PyCFunction>(DispatcherQueue_add_ShutdownCompleted), METH_O, nullptr },
        { "remove_shutdown_completed", reinterpret_cast<PyCFunction>(DispatcherQueue_remove_ShutdownCompleted), METH_O, nullptr },
        { "add_shutdown_starting", reinterpret_cast<PyCFunction>(DispatcherQueue_add_ShutdownStarting), METH_O, nullptr },
        { "remove_shutdown_starting", reinterpret_cast<PyCFunction>(DispatcherQueue_remove_ShutdownStarting), METH_O, nullptr },
        { "_assign_array_", _assign_array_DispatcherQueue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DispatcherQueue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DispatcherQueue[] = {
        { "has_thread_access", reinterpret_cast<getter>(DispatcherQueue_get_HasThreadAccess), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DispatcherQueue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DispatcherQueue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DispatcherQueue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DispatcherQueue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DispatcherQueue) },
        { },
    };

    static PyType_Spec type_spec_DispatcherQueue =
    {
        "winrt._winrt_windows_system.DispatcherQueue",
        sizeof(py::wrapper::Windows::System::DispatcherQueue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DispatcherQueue
    };

    static PyGetSetDef getset_DispatcherQueue_Static[] = {
        { }
    };

    static PyMethodDef methods_DispatcherQueue_Static[] = {
        { "get_for_current_thread", reinterpret_cast<PyCFunction>(DispatcherQueue_GetForCurrentThread), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_DispatcherQueue_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DispatcherQueue_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DispatcherQueue_Static) },
        { }
    };

    static PyType_Spec type_spec_DispatcherQueue_Static =
    {
        "winrt._winrt_windows_system.DispatcherQueue_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DispatcherQueue_Static
    };

    // ----- DispatcherQueueController class --------------------

    static PyObject* _new_DispatcherQueueController(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::DispatcherQueueController>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::DispatcherQueueController>::type_name);
        return nullptr;
    }

    static void _dealloc_DispatcherQueueController(py::wrapper::Windows::System::DispatcherQueueController* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DispatcherQueueController_CreateOnDedicatedThread(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.DispatcherQueueController", L"CreateOnDedicatedThread", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::System::DispatcherQueueController::CreateOnDedicatedThread());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DispatcherQueueController_ShutdownQueueAsync(py::wrapper::Windows::System::DispatcherQueueController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.DispatcherQueueController", L"ShutdownQueueAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ShutdownQueueAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DispatcherQueueController_get_DispatcherQueue(py::wrapper::Windows::System::DispatcherQueueController* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.DispatcherQueueController", L"DispatcherQueue"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DispatcherQueue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DispatcherQueueController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::DispatcherQueueController>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DispatcherQueueController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::DispatcherQueueController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DispatcherQueueController[] = {
        { "shutdown_queue_async", reinterpret_cast<PyCFunction>(DispatcherQueueController_ShutdownQueueAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DispatcherQueueController, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DispatcherQueueController), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DispatcherQueueController[] = {
        { "dispatcher_queue", reinterpret_cast<getter>(DispatcherQueueController_get_DispatcherQueue), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DispatcherQueueController[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DispatcherQueueController) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DispatcherQueueController) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DispatcherQueueController) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DispatcherQueueController) },
        { },
    };

    static PyType_Spec type_spec_DispatcherQueueController =
    {
        "winrt._winrt_windows_system.DispatcherQueueController",
        sizeof(py::wrapper::Windows::System::DispatcherQueueController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DispatcherQueueController
    };

    static PyGetSetDef getset_DispatcherQueueController_Static[] = {
        { }
    };

    static PyMethodDef methods_DispatcherQueueController_Static[] = {
        { "create_on_dedicated_thread", reinterpret_cast<PyCFunction>(DispatcherQueueController_CreateOnDedicatedThread), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_DispatcherQueueController_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DispatcherQueueController_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DispatcherQueueController_Static) },
        { }
    };

    static PyType_Spec type_spec_DispatcherQueueController_Static =
    {
        "winrt._winrt_windows_system.DispatcherQueueController_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DispatcherQueueController_Static
    };

    // ----- DispatcherQueueShutdownStartingEventArgs class --------------------

    static PyObject* _new_DispatcherQueueShutdownStartingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::DispatcherQueueShutdownStartingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::DispatcherQueueShutdownStartingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_DispatcherQueueShutdownStartingEventArgs(py::wrapper::Windows::System::DispatcherQueueShutdownStartingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DispatcherQueueShutdownStartingEventArgs_GetDeferral(py::wrapper::Windows::System::DispatcherQueueShutdownStartingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.DispatcherQueueShutdownStartingEventArgs", L"GetDeferral", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_DispatcherQueueShutdownStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::DispatcherQueueShutdownStartingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DispatcherQueueShutdownStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::DispatcherQueueShutdownStartingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DispatcherQueueShutdownStartingEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(DispatcherQueueShutdownStartingEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DispatcherQueueShutdownStartingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DispatcherQueueShutdownStartingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DispatcherQueueShutdownStartingEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_DispatcherQueueShutdownStartingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DispatcherQueueShutdownStartingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DispatcherQueueShutdownStartingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DispatcherQueueShutdownStartingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DispatcherQueueShutdownStartingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DispatcherQueueShutdownStartingEventArgs =
    {
        "winrt._winrt_windows_system.DispatcherQueueShutdownStartingEventArgs",
        sizeof(py::wrapper::Windows::System::DispatcherQueueShutdownStartingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DispatcherQueueShutdownStartingEventArgs
    };

    // ----- DispatcherQueueTimer class --------------------

    static PyObject* _new_DispatcherQueueTimer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::DispatcherQueueTimer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::DispatcherQueueTimer>::type_name);
        return nullptr;
    }

    static void _dealloc_DispatcherQueueTimer(py::wrapper::Windows::System::DispatcherQueueTimer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DispatcherQueueTimer_Start(py::wrapper::Windows::System::DispatcherQueueTimer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.DispatcherQueueTimer", L"Start", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DispatcherQueueTimer_Stop(py::wrapper::Windows::System::DispatcherQueueTimer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.DispatcherQueueTimer", L"Stop", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DispatcherQueueTimer_get_IsRepeating(py::wrapper::Windows::System::DispatcherQueueTimer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.DispatcherQueueTimer", L"IsRepeating"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsRepeating());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DispatcherQueueTimer_put_IsRepeating(py::wrapper::Windows::System::DispatcherQueueTimer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.DispatcherQueueTimer", L"IsRepeating"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsRepeating(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DispatcherQueueTimer_get_Interval(py::wrapper::Windows::System::DispatcherQueueTimer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.DispatcherQueueTimer", L"Interval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Interval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DispatcherQueueTimer_put_Interval(py::wrapper::Windows::System::DispatcherQueueTimer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.DispatcherQueueTimer", L"Interval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Interval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DispatcherQueueTimer_get_IsRunning(py::wrapper::Windows::System::DispatcherQueueTimer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.DispatcherQueueTimer", L"IsRunning"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsRunning());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DispatcherQueueTimer_add_Tick(py::wrapper::Windows::System::DispatcherQueueTimer* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.DispatcherQueueTimer", L"Tick"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::DispatcherQueueTimer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Tick(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DispatcherQueueTimer_remove_Tick(py::wrapper::Windows::System::DispatcherQueueTimer* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.DispatcherQueueTimer", L"Tick"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Tick(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DispatcherQueueTimer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::DispatcherQueueTimer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DispatcherQueueTimer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::DispatcherQueueTimer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DispatcherQueueTimer[] = {
        { "start", reinterpret_cast<PyCFunction>(DispatcherQueueTimer_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(DispatcherQueueTimer_Stop), METH_VARARGS, nullptr },
        { "add_tick", reinterpret_cast<PyCFunction>(DispatcherQueueTimer_add_Tick), METH_O, nullptr },
        { "remove_tick", reinterpret_cast<PyCFunction>(DispatcherQueueTimer_remove_Tick), METH_O, nullptr },
        { "_assign_array_", _assign_array_DispatcherQueueTimer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DispatcherQueueTimer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DispatcherQueueTimer[] = {
        { "is_repeating", reinterpret_cast<getter>(DispatcherQueueTimer_get_IsRepeating), reinterpret_cast<setter>(DispatcherQueueTimer_put_IsRepeating), nullptr, nullptr },
        { "interval", reinterpret_cast<getter>(DispatcherQueueTimer_get_Interval), reinterpret_cast<setter>(DispatcherQueueTimer_put_Interval), nullptr, nullptr },
        { "is_running", reinterpret_cast<getter>(DispatcherQueueTimer_get_IsRunning), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DispatcherQueueTimer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DispatcherQueueTimer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DispatcherQueueTimer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DispatcherQueueTimer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DispatcherQueueTimer) },
        { },
    };

    static PyType_Spec type_spec_DispatcherQueueTimer =
    {
        "winrt._winrt_windows_system.DispatcherQueueTimer",
        sizeof(py::wrapper::Windows::System::DispatcherQueueTimer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DispatcherQueueTimer
    };

    // ----- FolderLauncherOptions class --------------------

    static PyObject* _new_FolderLauncherOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::System::FolderLauncherOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FolderLauncherOptions(py::wrapper::Windows::System::FolderLauncherOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FolderLauncherOptions_get_ItemsToSelect(py::wrapper::Windows::System::FolderLauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.FolderLauncherOptions", L"ItemsToSelect"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ItemsToSelect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FolderLauncherOptions_get_DesiredRemainingView(py::wrapper::Windows::System::FolderLauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.FolderLauncherOptions", L"DesiredRemainingView"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DesiredRemainingView());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FolderLauncherOptions_put_DesiredRemainingView(py::wrapper::Windows::System::FolderLauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.FolderLauncherOptions", L"DesiredRemainingView"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::ViewSizePreference>(arg);

            self->obj.DesiredRemainingView(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_FolderLauncherOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::FolderLauncherOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FolderLauncherOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::FolderLauncherOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FolderLauncherOptions[] = {
        { "_assign_array_", _assign_array_FolderLauncherOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FolderLauncherOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FolderLauncherOptions[] = {
        { "items_to_select", reinterpret_cast<getter>(FolderLauncherOptions_get_ItemsToSelect), nullptr, nullptr, nullptr },
        { "desired_remaining_view", reinterpret_cast<getter>(FolderLauncherOptions_get_DesiredRemainingView), reinterpret_cast<setter>(FolderLauncherOptions_put_DesiredRemainingView), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FolderLauncherOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FolderLauncherOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FolderLauncherOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FolderLauncherOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FolderLauncherOptions) },
        { },
    };

    static PyType_Spec type_spec_FolderLauncherOptions =
    {
        "winrt._winrt_windows_system.FolderLauncherOptions",
        sizeof(py::wrapper::Windows::System::FolderLauncherOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FolderLauncherOptions
    };

    // ----- KnownUserProperties class --------------------

    static PyObject* _new_KnownUserProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::KnownUserProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::KnownUserProperties>::type_name);
        return nullptr;
    }

    static PyObject* KnownUserProperties_get_AccountName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.KnownUserProperties", L"AccountName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::System::KnownUserProperties::AccountName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUserProperties_get_DisplayName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.KnownUserProperties", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::System::KnownUserProperties::DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUserProperties_get_DomainName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.KnownUserProperties", L"DomainName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::System::KnownUserProperties::DomainName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUserProperties_get_FirstName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.KnownUserProperties", L"FirstName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::System::KnownUserProperties::FirstName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUserProperties_get_GuestHost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.KnownUserProperties", L"GuestHost"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::System::KnownUserProperties::GuestHost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUserProperties_get_LastName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.KnownUserProperties", L"LastName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::System::KnownUserProperties::LastName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUserProperties_get_PrincipalName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.KnownUserProperties", L"PrincipalName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::System::KnownUserProperties::PrincipalName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUserProperties_get_ProviderName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.KnownUserProperties", L"ProviderName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::System::KnownUserProperties::ProviderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUserProperties_get_SessionInitiationProtocolUri(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.KnownUserProperties", L"SessionInitiationProtocolUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::System::KnownUserProperties::SessionInitiationProtocolUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUserProperties_get_AgeEnforcementRegion(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.KnownUserProperties", L"AgeEnforcementRegion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::System::KnownUserProperties::AgeEnforcementRegion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownUserProperties[] = {
        { }
    };

    static PyGetSetDef _getset_KnownUserProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownUserProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownUserProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownUserProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownUserProperties) },
        { },
    };

    static PyType_Spec type_spec_KnownUserProperties =
    {
        "winrt._winrt_windows_system.KnownUserProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownUserProperties
    };

    static PyGetSetDef getset_KnownUserProperties_Static[] = {
        { "account_name", reinterpret_cast<getter>(KnownUserProperties_get_AccountName), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(KnownUserProperties_get_DisplayName), nullptr, nullptr, nullptr },
        { "domain_name", reinterpret_cast<getter>(KnownUserProperties_get_DomainName), nullptr, nullptr, nullptr },
        { "first_name", reinterpret_cast<getter>(KnownUserProperties_get_FirstName), nullptr, nullptr, nullptr },
        { "guest_host", reinterpret_cast<getter>(KnownUserProperties_get_GuestHost), nullptr, nullptr, nullptr },
        { "last_name", reinterpret_cast<getter>(KnownUserProperties_get_LastName), nullptr, nullptr, nullptr },
        { "principal_name", reinterpret_cast<getter>(KnownUserProperties_get_PrincipalName), nullptr, nullptr, nullptr },
        { "provider_name", reinterpret_cast<getter>(KnownUserProperties_get_ProviderName), nullptr, nullptr, nullptr },
        { "session_initiation_protocol_uri", reinterpret_cast<getter>(KnownUserProperties_get_SessionInitiationProtocolUri), nullptr, nullptr, nullptr },
        { "age_enforcement_region", reinterpret_cast<getter>(KnownUserProperties_get_AgeEnforcementRegion), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_KnownUserProperties_Static[] = {
        { }
    };

    static PyType_Slot type_slots_KnownUserProperties_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownUserProperties_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_KnownUserProperties_Static) },
        { }
    };

    static PyType_Spec type_spec_KnownUserProperties_Static =
    {
        "winrt._winrt_windows_system.KnownUserProperties_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownUserProperties_Static
    };

    // ----- LaunchUriResult class --------------------

    static PyObject* _new_LaunchUriResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::LaunchUriResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::LaunchUriResult>::type_name);
        return nullptr;
    }

    static void _dealloc_LaunchUriResult(py::wrapper::Windows::System::LaunchUriResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LaunchUriResult_get_Result(py::wrapper::Windows::System::LaunchUriResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LaunchUriResult", L"Result"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Result());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LaunchUriResult_get_Status(py::wrapper::Windows::System::LaunchUriResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LaunchUriResult", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LaunchUriResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::LaunchUriResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LaunchUriResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::LaunchUriResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LaunchUriResult[] = {
        { "_assign_array_", _assign_array_LaunchUriResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LaunchUriResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LaunchUriResult[] = {
        { "result", reinterpret_cast<getter>(LaunchUriResult_get_Result), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(LaunchUriResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LaunchUriResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LaunchUriResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LaunchUriResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LaunchUriResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LaunchUriResult) },
        { },
    };

    static PyType_Spec type_spec_LaunchUriResult =
    {
        "winrt._winrt_windows_system.LaunchUriResult",
        sizeof(py::wrapper::Windows::System::LaunchUriResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LaunchUriResult
    };

    // ----- Launcher class --------------------

    static PyObject* _new_Launcher(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Launcher>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Launcher>::type_name);
        return nullptr;
    }

    static PyObject* Launcher_FindAppUriHandlersAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"FindAppUriHandlersAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(winrt::Windows::System::Launcher::FindAppUriHandlersAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_FindFileHandlersAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"FindFileHandlersAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::System::Launcher::FindFileHandlersAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_FindUriSchemeHandlersAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"FindUriSchemeHandlersAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::System::Launcher::FindUriSchemeHandlersAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"FindUriSchemeHandlersAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::LaunchQuerySupportType>(args, 1);

                return py::convert(winrt::Windows::System::Launcher::FindUriSchemeHandlersAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_LaunchFileAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchFileAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(winrt::Windows::System::Launcher::LaunchFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchFileAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::LauncherOptions>(args, 1);

                return py::convert(winrt::Windows::System::Launcher::LaunchFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_LaunchFolderAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchFolderAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);

                return py::convert(winrt::Windows::System::Launcher::LaunchFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchFolderAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::FolderLauncherOptions>(args, 1);

                return py::convert(winrt::Windows::System::Launcher::LaunchFolderAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_LaunchFolderPathAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchFolderPathAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::System::Launcher::LaunchFolderPathAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchFolderPathAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::FolderLauncherOptions>(args, 1);

                return py::convert(winrt::Windows::System::Launcher::LaunchFolderPathAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_LaunchFolderPathForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchFolderPathForUserAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::System::Launcher::LaunchFolderPathForUserAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchFolderPathForUserAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::System::FolderLauncherOptions>(args, 2);

                return py::convert(winrt::Windows::System::Launcher::LaunchFolderPathForUserAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_LaunchUriAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchUriAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(winrt::Windows::System::Launcher::LaunchUriAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchUriAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::LauncherOptions>(args, 1);

                return py::convert(winrt::Windows::System::Launcher::LaunchUriAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchUriAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::LauncherOptions>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 2);

                return py::convert(winrt::Windows::System::Launcher::LaunchUriAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_LaunchUriForResultsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchUriForResultsAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::LauncherOptions>(args, 1);

                return py::convert(winrt::Windows::System::Launcher::LaunchUriForResultsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchUriForResultsAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::LauncherOptions>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 2);

                return py::convert(winrt::Windows::System::Launcher::LaunchUriForResultsAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_LaunchUriForResultsForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchUriForResultsForUserAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::System::LauncherOptions>(args, 2);

                return py::convert(winrt::Windows::System::Launcher::LaunchUriForResultsForUserAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchUriForResultsForUserAsync", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::System::LauncherOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 3);

                return py::convert(winrt::Windows::System::Launcher::LaunchUriForResultsForUserAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_LaunchUriForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchUriForUserAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);

                return py::convert(winrt::Windows::System::Launcher::LaunchUriForUserAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchUriForUserAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::System::LauncherOptions>(args, 2);

                return py::convert(winrt::Windows::System::Launcher::LaunchUriForUserAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchUriForUserAsync", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::System::LauncherOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 3);

                return py::convert(winrt::Windows::System::Launcher::LaunchUriForUserAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_QueryAppUriSupportAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"QueryAppUriSupportAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(winrt::Windows::System::Launcher::QueryAppUriSupportAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"QueryAppUriSupportAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::System::Launcher::QueryAppUriSupportAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_QueryFileSupportAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"QueryFileSupportAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);

                return py::convert(winrt::Windows::System::Launcher::QueryFileSupportAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"QueryFileSupportAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::System::Launcher::QueryFileSupportAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_QueryUriSupportAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"QueryUriSupportAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::LaunchQuerySupportType>(args, 1);

                return py::convert(winrt::Windows::System::Launcher::QueryUriSupportAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"QueryUriSupportAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::LaunchQuerySupportType>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(winrt::Windows::System::Launcher::QueryUriSupportAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_Launcher[] = {
        { }
    };

    static PyGetSetDef _getset_Launcher[] = {
        { }
    };

    static PyType_Slot _type_slots_Launcher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Launcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Launcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Launcher) },
        { },
    };

    static PyType_Spec type_spec_Launcher =
    {
        "winrt._winrt_windows_system.Launcher",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Launcher
    };

    static PyGetSetDef getset_Launcher_Static[] = {
        { }
    };

    static PyMethodDef methods_Launcher_Static[] = {
        { "find_app_uri_handlers_async", reinterpret_cast<PyCFunction>(Launcher_FindAppUriHandlersAsync), METH_VARARGS, nullptr },
        { "find_file_handlers_async", reinterpret_cast<PyCFunction>(Launcher_FindFileHandlersAsync), METH_VARARGS, nullptr },
        { "find_uri_scheme_handlers_async", reinterpret_cast<PyCFunction>(Launcher_FindUriSchemeHandlersAsync), METH_VARARGS, nullptr },
        { "launch_file_async", reinterpret_cast<PyCFunction>(Launcher_LaunchFileAsync), METH_VARARGS, nullptr },
        { "launch_folder_async", reinterpret_cast<PyCFunction>(Launcher_LaunchFolderAsync), METH_VARARGS, nullptr },
        { "launch_folder_path_async", reinterpret_cast<PyCFunction>(Launcher_LaunchFolderPathAsync), METH_VARARGS, nullptr },
        { "launch_folder_path_for_user_async", reinterpret_cast<PyCFunction>(Launcher_LaunchFolderPathForUserAsync), METH_VARARGS, nullptr },
        { "launch_uri_async", reinterpret_cast<PyCFunction>(Launcher_LaunchUriAsync), METH_VARARGS, nullptr },
        { "launch_uri_for_results_async", reinterpret_cast<PyCFunction>(Launcher_LaunchUriForResultsAsync), METH_VARARGS, nullptr },
        { "launch_uri_for_results_for_user_async", reinterpret_cast<PyCFunction>(Launcher_LaunchUriForResultsForUserAsync), METH_VARARGS, nullptr },
        { "launch_uri_for_user_async", reinterpret_cast<PyCFunction>(Launcher_LaunchUriForUserAsync), METH_VARARGS, nullptr },
        { "query_app_uri_support_async", reinterpret_cast<PyCFunction>(Launcher_QueryAppUriSupportAsync), METH_VARARGS, nullptr },
        { "query_file_support_async", reinterpret_cast<PyCFunction>(Launcher_QueryFileSupportAsync), METH_VARARGS, nullptr },
        { "query_uri_support_async", reinterpret_cast<PyCFunction>(Launcher_QueryUriSupportAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_Launcher_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Launcher_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Launcher_Static) },
        { }
    };

    static PyType_Spec type_spec_Launcher_Static =
    {
        "winrt._winrt_windows_system.Launcher_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Launcher_Static
    };

    // ----- LauncherOptions class --------------------

    static PyObject* _new_LauncherOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::System::LauncherOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LauncherOptions(py::wrapper::Windows::System::LauncherOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LauncherOptions_get_TreatAsUntrusted(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"TreatAsUntrusted"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TreatAsUntrusted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherOptions_put_TreatAsUntrusted(py::wrapper::Windows::System::LauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"TreatAsUntrusted"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.TreatAsUntrusted(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherOptions_get_PreferredApplicationPackageFamilyName(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"PreferredApplicationPackageFamilyName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreferredApplicationPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherOptions_put_PreferredApplicationPackageFamilyName(py::wrapper::Windows::System::LauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"PreferredApplicationPackageFamilyName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PreferredApplicationPackageFamilyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherOptions_get_PreferredApplicationDisplayName(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"PreferredApplicationDisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreferredApplicationDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherOptions_put_PreferredApplicationDisplayName(py::wrapper::Windows::System::LauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"PreferredApplicationDisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PreferredApplicationDisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherOptions_get_FallbackUri(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"FallbackUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FallbackUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherOptions_put_FallbackUri(py::wrapper::Windows::System::LauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"FallbackUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.FallbackUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherOptions_get_DisplayApplicationPicker(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"DisplayApplicationPicker"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayApplicationPicker());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherOptions_put_DisplayApplicationPicker(py::wrapper::Windows::System::LauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"DisplayApplicationPicker"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.DisplayApplicationPicker(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherOptions_get_ContentType(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"ContentType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherOptions_put_ContentType(py::wrapper::Windows::System::LauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"ContentType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContentType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherOptions_get_UI(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"UI"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LauncherOptions_get_TargetApplicationPackageFamilyName(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"TargetApplicationPackageFamilyName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TargetApplicationPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherOptions_put_TargetApplicationPackageFamilyName(py::wrapper::Windows::System::LauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"TargetApplicationPackageFamilyName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TargetApplicationPackageFamilyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherOptions_get_NeighboringFilesQuery(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"NeighboringFilesQuery"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NeighboringFilesQuery());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherOptions_put_NeighboringFilesQuery(py::wrapper::Windows::System::LauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"NeighboringFilesQuery"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Search::StorageFileQueryResult>(arg);

            self->obj.NeighboringFilesQuery(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherOptions_get_IgnoreAppUriHandlers(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"IgnoreAppUriHandlers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IgnoreAppUriHandlers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherOptions_put_IgnoreAppUriHandlers(py::wrapper::Windows::System::LauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"IgnoreAppUriHandlers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IgnoreAppUriHandlers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherOptions_get_LimitPickerToCurrentAppAndAppUriHandlers(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"LimitPickerToCurrentAppAndAppUriHandlers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LimitPickerToCurrentAppAndAppUriHandlers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherOptions_put_LimitPickerToCurrentAppAndAppUriHandlers(py::wrapper::Windows::System::LauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"LimitPickerToCurrentAppAndAppUriHandlers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.LimitPickerToCurrentAppAndAppUriHandlers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherOptions_get_DesiredRemainingView(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"DesiredRemainingView"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DesiredRemainingView());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherOptions_put_DesiredRemainingView(py::wrapper::Windows::System::LauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"DesiredRemainingView"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::ViewSizePreference>(arg);

            self->obj.DesiredRemainingView(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_LauncherOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::LauncherOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LauncherOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::LauncherOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LauncherOptions[] = {
        { "_assign_array_", _assign_array_LauncherOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LauncherOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LauncherOptions[] = {
        { "treat_as_untrusted", reinterpret_cast<getter>(LauncherOptions_get_TreatAsUntrusted), reinterpret_cast<setter>(LauncherOptions_put_TreatAsUntrusted), nullptr, nullptr },
        { "preferred_application_package_family_name", reinterpret_cast<getter>(LauncherOptions_get_PreferredApplicationPackageFamilyName), reinterpret_cast<setter>(LauncherOptions_put_PreferredApplicationPackageFamilyName), nullptr, nullptr },
        { "preferred_application_display_name", reinterpret_cast<getter>(LauncherOptions_get_PreferredApplicationDisplayName), reinterpret_cast<setter>(LauncherOptions_put_PreferredApplicationDisplayName), nullptr, nullptr },
        { "fallback_uri", reinterpret_cast<getter>(LauncherOptions_get_FallbackUri), reinterpret_cast<setter>(LauncherOptions_put_FallbackUri), nullptr, nullptr },
        { "display_application_picker", reinterpret_cast<getter>(LauncherOptions_get_DisplayApplicationPicker), reinterpret_cast<setter>(LauncherOptions_put_DisplayApplicationPicker), nullptr, nullptr },
        { "content_type", reinterpret_cast<getter>(LauncherOptions_get_ContentType), reinterpret_cast<setter>(LauncherOptions_put_ContentType), nullptr, nullptr },
        { "u_i", reinterpret_cast<getter>(LauncherOptions_get_UI), nullptr, nullptr, nullptr },
        { "target_application_package_family_name", reinterpret_cast<getter>(LauncherOptions_get_TargetApplicationPackageFamilyName), reinterpret_cast<setter>(LauncherOptions_put_TargetApplicationPackageFamilyName), nullptr, nullptr },
        { "neighboring_files_query", reinterpret_cast<getter>(LauncherOptions_get_NeighboringFilesQuery), reinterpret_cast<setter>(LauncherOptions_put_NeighboringFilesQuery), nullptr, nullptr },
        { "ignore_app_uri_handlers", reinterpret_cast<getter>(LauncherOptions_get_IgnoreAppUriHandlers), reinterpret_cast<setter>(LauncherOptions_put_IgnoreAppUriHandlers), nullptr, nullptr },
        { "limit_picker_to_current_app_and_app_uri_handlers", reinterpret_cast<getter>(LauncherOptions_get_LimitPickerToCurrentAppAndAppUriHandlers), reinterpret_cast<setter>(LauncherOptions_put_LimitPickerToCurrentAppAndAppUriHandlers), nullptr, nullptr },
        { "desired_remaining_view", reinterpret_cast<getter>(LauncherOptions_get_DesiredRemainingView), reinterpret_cast<setter>(LauncherOptions_put_DesiredRemainingView), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LauncherOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LauncherOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LauncherOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LauncherOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LauncherOptions) },
        { },
    };

    static PyType_Spec type_spec_LauncherOptions =
    {
        "winrt._winrt_windows_system.LauncherOptions",
        sizeof(py::wrapper::Windows::System::LauncherOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LauncherOptions
    };

    // ----- LauncherUIOptions class --------------------

    static PyObject* _new_LauncherUIOptions(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::LauncherUIOptions>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::LauncherUIOptions>::type_name);
        return nullptr;
    }

    static void _dealloc_LauncherUIOptions(py::wrapper::Windows::System::LauncherUIOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LauncherUIOptions_get_SelectionRect(py::wrapper::Windows::System::LauncherUIOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherUIOptions", L"SelectionRect"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectionRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherUIOptions_put_SelectionRect(py::wrapper::Windows::System::LauncherUIOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherUIOptions", L"SelectionRect"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Rect>>(arg);

            self->obj.SelectionRect(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherUIOptions_get_PreferredPlacement(py::wrapper::Windows::System::LauncherUIOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherUIOptions", L"PreferredPlacement"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreferredPlacement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherUIOptions_put_PreferredPlacement(py::wrapper::Windows::System::LauncherUIOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherUIOptions", L"PreferredPlacement"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Popups::Placement>(arg);

            self->obj.PreferredPlacement(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherUIOptions_get_InvocationPoint(py::wrapper::Windows::System::LauncherUIOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherUIOptions", L"InvocationPoint"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InvocationPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherUIOptions_put_InvocationPoint(py::wrapper::Windows::System::LauncherUIOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherUIOptions", L"InvocationPoint"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Point>>(arg);

            self->obj.InvocationPoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_LauncherUIOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::LauncherUIOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LauncherUIOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::LauncherUIOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LauncherUIOptions[] = {
        { "_assign_array_", _assign_array_LauncherUIOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LauncherUIOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LauncherUIOptions[] = {
        { "selection_rect", reinterpret_cast<getter>(LauncherUIOptions_get_SelectionRect), reinterpret_cast<setter>(LauncherUIOptions_put_SelectionRect), nullptr, nullptr },
        { "preferred_placement", reinterpret_cast<getter>(LauncherUIOptions_get_PreferredPlacement), reinterpret_cast<setter>(LauncherUIOptions_put_PreferredPlacement), nullptr, nullptr },
        { "invocation_point", reinterpret_cast<getter>(LauncherUIOptions_get_InvocationPoint), reinterpret_cast<setter>(LauncherUIOptions_put_InvocationPoint), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LauncherUIOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LauncherUIOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LauncherUIOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LauncherUIOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LauncherUIOptions) },
        { },
    };

    static PyType_Spec type_spec_LauncherUIOptions =
    {
        "winrt._winrt_windows_system.LauncherUIOptions",
        sizeof(py::wrapper::Windows::System::LauncherUIOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LauncherUIOptions
    };

    // ----- MemoryManager class --------------------

    static PyObject* _new_MemoryManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::MemoryManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::MemoryManager>::type_name);
        return nullptr;
    }

    static PyObject* MemoryManager_GetAppMemoryReport(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.MemoryManager", L"GetAppMemoryReport", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::System::MemoryManager::GetAppMemoryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MemoryManager_GetProcessMemoryReport(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.MemoryManager", L"GetProcessMemoryReport", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::System::MemoryManager::GetProcessMemoryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MemoryManager_TrySetAppMemoryUsageLimit(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.MemoryManager", L"TrySetAppMemoryUsageLimit", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(winrt::Windows::System::MemoryManager::TrySetAppMemoryUsageLimit(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MemoryManager_get_AppMemoryUsage(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.MemoryManager", L"AppMemoryUsage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::System::MemoryManager::AppMemoryUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MemoryManager_get_AppMemoryUsageLevel(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.MemoryManager", L"AppMemoryUsageLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::System::MemoryManager::AppMemoryUsageLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MemoryManager_get_AppMemoryUsageLimit(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.MemoryManager", L"AppMemoryUsageLimit"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::System::MemoryManager::AppMemoryUsageLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MemoryManager_get_ExpectedAppMemoryUsageLimit(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.MemoryManager", L"ExpectedAppMemoryUsageLimit"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::System::MemoryManager::ExpectedAppMemoryUsageLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MemoryManager_add_AppMemoryUsageDecreased(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.MemoryManager", L"AppMemoryUsageDecreased"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::System::MemoryManager::AppMemoryUsageDecreased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MemoryManager_remove_AppMemoryUsageDecreased(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.MemoryManager", L"AppMemoryUsageDecreased"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::System::MemoryManager::AppMemoryUsageDecreased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MemoryManager_add_AppMemoryUsageIncreased(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.MemoryManager", L"AppMemoryUsageIncreased"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::System::MemoryManager::AppMemoryUsageIncreased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MemoryManager_remove_AppMemoryUsageIncreased(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.MemoryManager", L"AppMemoryUsageIncreased"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::System::MemoryManager::AppMemoryUsageIncreased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MemoryManager_add_AppMemoryUsageLimitChanging(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.MemoryManager", L"AppMemoryUsageLimitChanging"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::System::AppMemoryUsageLimitChangingEventArgs>>(arg);

            return py::convert(winrt::Windows::System::MemoryManager::AppMemoryUsageLimitChanging(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MemoryManager_remove_AppMemoryUsageLimitChanging(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.MemoryManager", L"AppMemoryUsageLimitChanging"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::System::MemoryManager::AppMemoryUsageLimitChanging(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MemoryManager[] = {
        { "add_app_memory_usage_decreased", reinterpret_cast<PyCFunction>(MemoryManager_add_AppMemoryUsageDecreased), METH_O | METH_STATIC, nullptr },
        { "remove_app_memory_usage_decreased", reinterpret_cast<PyCFunction>(MemoryManager_remove_AppMemoryUsageDecreased), METH_O | METH_STATIC, nullptr },
        { "add_app_memory_usage_increased", reinterpret_cast<PyCFunction>(MemoryManager_add_AppMemoryUsageIncreased), METH_O | METH_STATIC, nullptr },
        { "remove_app_memory_usage_increased", reinterpret_cast<PyCFunction>(MemoryManager_remove_AppMemoryUsageIncreased), METH_O | METH_STATIC, nullptr },
        { "add_app_memory_usage_limit_changing", reinterpret_cast<PyCFunction>(MemoryManager_add_AppMemoryUsageLimitChanging), METH_O | METH_STATIC, nullptr },
        { "remove_app_memory_usage_limit_changing", reinterpret_cast<PyCFunction>(MemoryManager_remove_AppMemoryUsageLimitChanging), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MemoryManager[] = {
        { }
    };

    static PyType_Slot _type_slots_MemoryManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MemoryManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MemoryManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MemoryManager) },
        { },
    };

    static PyType_Spec type_spec_MemoryManager =
    {
        "winrt._winrt_windows_system.MemoryManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MemoryManager
    };

    static PyGetSetDef getset_MemoryManager_Static[] = {
        { "app_memory_usage", reinterpret_cast<getter>(MemoryManager_get_AppMemoryUsage), nullptr, nullptr, nullptr },
        { "app_memory_usage_level", reinterpret_cast<getter>(MemoryManager_get_AppMemoryUsageLevel), nullptr, nullptr, nullptr },
        { "app_memory_usage_limit", reinterpret_cast<getter>(MemoryManager_get_AppMemoryUsageLimit), nullptr, nullptr, nullptr },
        { "expected_app_memory_usage_limit", reinterpret_cast<getter>(MemoryManager_get_ExpectedAppMemoryUsageLimit), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_MemoryManager_Static[] = {
        { "get_app_memory_report", reinterpret_cast<PyCFunction>(MemoryManager_GetAppMemoryReport), METH_VARARGS, nullptr },
        { "get_process_memory_report", reinterpret_cast<PyCFunction>(MemoryManager_GetProcessMemoryReport), METH_VARARGS, nullptr },
        { "try_set_app_memory_usage_limit", reinterpret_cast<PyCFunction>(MemoryManager_TrySetAppMemoryUsageLimit), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_MemoryManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MemoryManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MemoryManager_Static) },
        { }
    };

    static PyType_Spec type_spec_MemoryManager_Static =
    {
        "winrt._winrt_windows_system.MemoryManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MemoryManager_Static
    };

    // ----- ProcessLauncher class --------------------

    static PyObject* _new_ProcessLauncher(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::ProcessLauncher>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::ProcessLauncher>::type_name);
        return nullptr;
    }

    static PyObject* ProcessLauncher_RunToCompletionAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.ProcessLauncher", L"RunToCompletionAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::System::ProcessLauncher::RunToCompletionAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.ProcessLauncher", L"RunToCompletionAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::System::ProcessLauncherOptions>(args, 2);

                return py::convert(winrt::Windows::System::ProcessLauncher::RunToCompletionAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessLauncher[] = {
        { }
    };

    static PyGetSetDef _getset_ProcessLauncher[] = {
        { }
    };

    static PyType_Slot _type_slots_ProcessLauncher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessLauncher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessLauncher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessLauncher) },
        { },
    };

    static PyType_Spec type_spec_ProcessLauncher =
    {
        "winrt._winrt_windows_system.ProcessLauncher",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessLauncher
    };

    static PyGetSetDef getset_ProcessLauncher_Static[] = {
        { }
    };

    static PyMethodDef methods_ProcessLauncher_Static[] = {
        { "run_to_completion_async", reinterpret_cast<PyCFunction>(ProcessLauncher_RunToCompletionAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_ProcessLauncher_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ProcessLauncher_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ProcessLauncher_Static) },
        { }
    };

    static PyType_Spec type_spec_ProcessLauncher_Static =
    {
        "winrt._winrt_windows_system.ProcessLauncher_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ProcessLauncher_Static
    };

    // ----- ProcessLauncherOptions class --------------------

    static PyObject* _new_ProcessLauncherOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::System::ProcessLauncherOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ProcessLauncherOptions(py::wrapper::Windows::System::ProcessLauncherOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProcessLauncherOptions_get_WorkingDirectory(py::wrapper::Windows::System::ProcessLauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.ProcessLauncherOptions", L"WorkingDirectory"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WorkingDirectory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProcessLauncherOptions_put_WorkingDirectory(py::wrapper::Windows::System::ProcessLauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.ProcessLauncherOptions", L"WorkingDirectory"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.WorkingDirectory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProcessLauncherOptions_get_StandardOutput(py::wrapper::Windows::System::ProcessLauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.ProcessLauncherOptions", L"StandardOutput"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StandardOutput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProcessLauncherOptions_put_StandardOutput(py::wrapper::Windows::System::ProcessLauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.ProcessLauncherOptions", L"StandardOutput"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(arg);

            self->obj.StandardOutput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProcessLauncherOptions_get_StandardInput(py::wrapper::Windows::System::ProcessLauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.ProcessLauncherOptions", L"StandardInput"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StandardInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProcessLauncherOptions_put_StandardInput(py::wrapper::Windows::System::ProcessLauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.ProcessLauncherOptions", L"StandardInput"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(arg);

            self->obj.StandardInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProcessLauncherOptions_get_StandardError(py::wrapper::Windows::System::ProcessLauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.ProcessLauncherOptions", L"StandardError"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StandardError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProcessLauncherOptions_put_StandardError(py::wrapper::Windows::System::ProcessLauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.ProcessLauncherOptions", L"StandardError"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(arg);

            self->obj.StandardError(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ProcessLauncherOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::ProcessLauncherOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProcessLauncherOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::ProcessLauncherOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessLauncherOptions[] = {
        { "_assign_array_", _assign_array_ProcessLauncherOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessLauncherOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessLauncherOptions[] = {
        { "working_directory", reinterpret_cast<getter>(ProcessLauncherOptions_get_WorkingDirectory), reinterpret_cast<setter>(ProcessLauncherOptions_put_WorkingDirectory), nullptr, nullptr },
        { "standard_output", reinterpret_cast<getter>(ProcessLauncherOptions_get_StandardOutput), reinterpret_cast<setter>(ProcessLauncherOptions_put_StandardOutput), nullptr, nullptr },
        { "standard_input", reinterpret_cast<getter>(ProcessLauncherOptions_get_StandardInput), reinterpret_cast<setter>(ProcessLauncherOptions_put_StandardInput), nullptr, nullptr },
        { "standard_error", reinterpret_cast<getter>(ProcessLauncherOptions_get_StandardError), reinterpret_cast<setter>(ProcessLauncherOptions_put_StandardError), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProcessLauncherOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessLauncherOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProcessLauncherOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessLauncherOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessLauncherOptions) },
        { },
    };

    static PyType_Spec type_spec_ProcessLauncherOptions =
    {
        "winrt._winrt_windows_system.ProcessLauncherOptions",
        sizeof(py::wrapper::Windows::System::ProcessLauncherOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessLauncherOptions
    };

    // ----- ProcessLauncherResult class --------------------

    static PyObject* _new_ProcessLauncherResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::ProcessLauncherResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::ProcessLauncherResult>::type_name);
        return nullptr;
    }

    static void _dealloc_ProcessLauncherResult(py::wrapper::Windows::System::ProcessLauncherResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProcessLauncherResult_get_ExitCode(py::wrapper::Windows::System::ProcessLauncherResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.ProcessLauncherResult", L"ExitCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExitCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProcessLauncherResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::ProcessLauncherResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProcessLauncherResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::ProcessLauncherResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessLauncherResult[] = {
        { "_assign_array_", _assign_array_ProcessLauncherResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessLauncherResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessLauncherResult[] = {
        { "exit_code", reinterpret_cast<getter>(ProcessLauncherResult_get_ExitCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProcessLauncherResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessLauncherResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProcessLauncherResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessLauncherResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessLauncherResult) },
        { },
    };

    static PyType_Spec type_spec_ProcessLauncherResult =
    {
        "winrt._winrt_windows_system.ProcessLauncherResult",
        sizeof(py::wrapper::Windows::System::ProcessLauncherResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessLauncherResult
    };

    // ----- ProcessMemoryReport class --------------------

    static PyObject* _new_ProcessMemoryReport(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::ProcessMemoryReport>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::ProcessMemoryReport>::type_name);
        return nullptr;
    }

    static void _dealloc_ProcessMemoryReport(py::wrapper::Windows::System::ProcessMemoryReport* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProcessMemoryReport_get_PrivateWorkingSetUsage(py::wrapper::Windows::System::ProcessMemoryReport* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.ProcessMemoryReport", L"PrivateWorkingSetUsage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PrivateWorkingSetUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryReport_get_TotalWorkingSetUsage(py::wrapper::Windows::System::ProcessMemoryReport* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.ProcessMemoryReport", L"TotalWorkingSetUsage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TotalWorkingSetUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProcessMemoryReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::ProcessMemoryReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProcessMemoryReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::ProcessMemoryReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessMemoryReport[] = {
        { "_assign_array_", _assign_array_ProcessMemoryReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessMemoryReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessMemoryReport[] = {
        { "private_working_set_usage", reinterpret_cast<getter>(ProcessMemoryReport_get_PrivateWorkingSetUsage), nullptr, nullptr, nullptr },
        { "total_working_set_usage", reinterpret_cast<getter>(ProcessMemoryReport_get_TotalWorkingSetUsage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProcessMemoryReport[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessMemoryReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProcessMemoryReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessMemoryReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessMemoryReport) },
        { },
    };

    static PyType_Spec type_spec_ProcessMemoryReport =
    {
        "winrt._winrt_windows_system.ProcessMemoryReport",
        sizeof(py::wrapper::Windows::System::ProcessMemoryReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessMemoryReport
    };

    // ----- ProtocolForResultsOperation class --------------------

    static PyObject* _new_ProtocolForResultsOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::ProtocolForResultsOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::ProtocolForResultsOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_ProtocolForResultsOperation(py::wrapper::Windows::System::ProtocolForResultsOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProtocolForResultsOperation_ReportCompleted(py::wrapper::Windows::System::ProtocolForResultsOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.ProtocolForResultsOperation", L"ReportCompleted", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 0);

                self->obj.ReportCompleted(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProtocolForResultsOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::ProtocolForResultsOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProtocolForResultsOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::ProtocolForResultsOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProtocolForResultsOperation[] = {
        { "report_completed", reinterpret_cast<PyCFunction>(ProtocolForResultsOperation_ReportCompleted), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ProtocolForResultsOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProtocolForResultsOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProtocolForResultsOperation[] = {
        { }
    };

    static PyType_Slot _type_slots_ProtocolForResultsOperation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProtocolForResultsOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProtocolForResultsOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProtocolForResultsOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProtocolForResultsOperation) },
        { },
    };

    static PyType_Spec type_spec_ProtocolForResultsOperation =
    {
        "winrt._winrt_windows_system.ProtocolForResultsOperation",
        sizeof(py::wrapper::Windows::System::ProtocolForResultsOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProtocolForResultsOperation
    };

    // ----- RemoteLauncher class --------------------

    static PyObject* _new_RemoteLauncher(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::RemoteLauncher>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::RemoteLauncher>::type_name);
        return nullptr;
    }

    static PyObject* RemoteLauncher_LaunchUriAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteLauncher", L"LaunchUriAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystemConnectionRequest>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);

                return py::convert(winrt::Windows::System::RemoteLauncher::LaunchUriAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteLauncher", L"LaunchUriAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystemConnectionRequest>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::System::RemoteLauncherOptions>(args, 2);

                return py::convert(winrt::Windows::System::RemoteLauncher::LaunchUriAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteLauncher", L"LaunchUriAsync", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystemConnectionRequest>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::System::RemoteLauncherOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 3);

                return py::convert(winrt::Windows::System::RemoteLauncher::LaunchUriAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteLauncher[] = {
        { }
    };

    static PyGetSetDef _getset_RemoteLauncher[] = {
        { }
    };

    static PyType_Slot _type_slots_RemoteLauncher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteLauncher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteLauncher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteLauncher) },
        { },
    };

    static PyType_Spec type_spec_RemoteLauncher =
    {
        "winrt._winrt_windows_system.RemoteLauncher",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteLauncher
    };

    static PyGetSetDef getset_RemoteLauncher_Static[] = {
        { }
    };

    static PyMethodDef methods_RemoteLauncher_Static[] = {
        { "launch_uri_async", reinterpret_cast<PyCFunction>(RemoteLauncher_LaunchUriAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_RemoteLauncher_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RemoteLauncher_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RemoteLauncher_Static) },
        { }
    };

    static PyType_Spec type_spec_RemoteLauncher_Static =
    {
        "winrt._winrt_windows_system.RemoteLauncher_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RemoteLauncher_Static
    };

    // ----- RemoteLauncherOptions class --------------------

    static PyObject* _new_RemoteLauncherOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::System::RemoteLauncherOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RemoteLauncherOptions(py::wrapper::Windows::System::RemoteLauncherOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteLauncherOptions_get_FallbackUri(py::wrapper::Windows::System::RemoteLauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteLauncherOptions", L"FallbackUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FallbackUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RemoteLauncherOptions_put_FallbackUri(py::wrapper::Windows::System::RemoteLauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteLauncherOptions", L"FallbackUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.FallbackUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RemoteLauncherOptions_get_PreferredAppIds(py::wrapper::Windows::System::RemoteLauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteLauncherOptions", L"PreferredAppIds"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreferredAppIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteLauncherOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteLauncherOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteLauncherOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteLauncherOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteLauncherOptions[] = {
        { "_assign_array_", _assign_array_RemoteLauncherOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteLauncherOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteLauncherOptions[] = {
        { "fallback_uri", reinterpret_cast<getter>(RemoteLauncherOptions_get_FallbackUri), reinterpret_cast<setter>(RemoteLauncherOptions_put_FallbackUri), nullptr, nullptr },
        { "preferred_app_ids", reinterpret_cast<getter>(RemoteLauncherOptions_get_PreferredAppIds), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteLauncherOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteLauncherOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteLauncherOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteLauncherOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteLauncherOptions) },
        { },
    };

    static PyType_Spec type_spec_RemoteLauncherOptions =
    {
        "winrt._winrt_windows_system.RemoteLauncherOptions",
        sizeof(py::wrapper::Windows::System::RemoteLauncherOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteLauncherOptions
    };

    // ----- ShutdownManager class --------------------

    static PyObject* _new_ShutdownManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::ShutdownManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::ShutdownManager>::type_name);
        return nullptr;
    }

    static PyObject* ShutdownManager_BeginShutdown(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.ShutdownManager", L"BeginShutdown", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::ShutdownKind>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                winrt::Windows::System::ShutdownManager::BeginShutdown(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ShutdownManager_CancelShutdown(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.ShutdownManager", L"CancelShutdown", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::Windows::System::ShutdownManager::CancelShutdown();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ShutdownManager_EnterPowerState(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.ShutdownManager", L"EnterPowerState", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::PowerState>(args, 0);

                winrt::Windows::System::ShutdownManager::EnterPowerState(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.ShutdownManager", L"EnterPowerState", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::PowerState>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                winrt::Windows::System::ShutdownManager::EnterPowerState(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ShutdownManager_IsPowerStateSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.ShutdownManager", L"IsPowerStateSupported", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::PowerState>(args, 0);

                return py::convert(winrt::Windows::System::ShutdownManager::IsPowerStateSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_ShutdownManager[] = {
        { }
    };

    static PyGetSetDef _getset_ShutdownManager[] = {
        { }
    };

    static PyType_Slot _type_slots_ShutdownManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ShutdownManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ShutdownManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ShutdownManager) },
        { },
    };

    static PyType_Spec type_spec_ShutdownManager =
    {
        "winrt._winrt_windows_system.ShutdownManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ShutdownManager
    };

    static PyGetSetDef getset_ShutdownManager_Static[] = {
        { }
    };

    static PyMethodDef methods_ShutdownManager_Static[] = {
        { "begin_shutdown", reinterpret_cast<PyCFunction>(ShutdownManager_BeginShutdown), METH_VARARGS, nullptr },
        { "cancel_shutdown", reinterpret_cast<PyCFunction>(ShutdownManager_CancelShutdown), METH_VARARGS, nullptr },
        { "enter_power_state", reinterpret_cast<PyCFunction>(ShutdownManager_EnterPowerState), METH_VARARGS, nullptr },
        { "is_power_state_supported", reinterpret_cast<PyCFunction>(ShutdownManager_IsPowerStateSupported), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_ShutdownManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ShutdownManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ShutdownManager_Static) },
        { }
    };

    static PyType_Spec type_spec_ShutdownManager_Static =
    {
        "winrt._winrt_windows_system.ShutdownManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ShutdownManager_Static
    };

    // ----- TimeZoneSettings class --------------------

    static PyObject* _new_TimeZoneSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::TimeZoneSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::TimeZoneSettings>::type_name);
        return nullptr;
    }

    static PyObject* TimeZoneSettings_AutoUpdateTimeZoneAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.TimeZoneSettings", L"AutoUpdateTimeZoneAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                return py::convert(winrt::Windows::System::TimeZoneSettings::AutoUpdateTimeZoneAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimeZoneSettings_ChangeTimeZoneByDisplayName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.TimeZoneSettings", L"ChangeTimeZoneByDisplayName", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::System::TimeZoneSettings::ChangeTimeZoneByDisplayName(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimeZoneSettings_get_CanChangeTimeZone(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.TimeZoneSettings", L"CanChangeTimeZone"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::System::TimeZoneSettings::CanChangeTimeZone());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimeZoneSettings_get_CurrentTimeZoneDisplayName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.TimeZoneSettings", L"CurrentTimeZoneDisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::System::TimeZoneSettings::CurrentTimeZoneDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimeZoneSettings_get_SupportedTimeZoneDisplayNames(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.TimeZoneSettings", L"SupportedTimeZoneDisplayNames"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::System::TimeZoneSettings::SupportedTimeZoneDisplayNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimeZoneSettings[] = {
        { }
    };

    static PyGetSetDef _getset_TimeZoneSettings[] = {
        { }
    };

    static PyType_Slot _type_slots_TimeZoneSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimeZoneSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimeZoneSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimeZoneSettings) },
        { },
    };

    static PyType_Spec type_spec_TimeZoneSettings =
    {
        "winrt._winrt_windows_system.TimeZoneSettings",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimeZoneSettings
    };

    static PyGetSetDef getset_TimeZoneSettings_Static[] = {
        { "can_change_time_zone", reinterpret_cast<getter>(TimeZoneSettings_get_CanChangeTimeZone), nullptr, nullptr, nullptr },
        { "current_time_zone_display_name", reinterpret_cast<getter>(TimeZoneSettings_get_CurrentTimeZoneDisplayName), nullptr, nullptr, nullptr },
        { "supported_time_zone_display_names", reinterpret_cast<getter>(TimeZoneSettings_get_SupportedTimeZoneDisplayNames), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_TimeZoneSettings_Static[] = {
        { "auto_update_time_zone_async", reinterpret_cast<PyCFunction>(TimeZoneSettings_AutoUpdateTimeZoneAsync), METH_VARARGS, nullptr },
        { "change_time_zone_by_display_name", reinterpret_cast<PyCFunction>(TimeZoneSettings_ChangeTimeZoneByDisplayName), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_TimeZoneSettings_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TimeZoneSettings_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TimeZoneSettings_Static) },
        { }
    };

    static PyType_Spec type_spec_TimeZoneSettings_Static =
    {
        "winrt._winrt_windows_system.TimeZoneSettings_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TimeZoneSettings_Static
    };

    // ----- User class --------------------

    static PyObject* _new_User(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::User>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::User>::type_name);
        return nullptr;
    }

    static void _dealloc_User(py::wrapper::Windows::System::User* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* User_CheckUserAgeConsentGroupAsync(py::wrapper::Windows::System::User* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.User", L"CheckUserAgeConsentGroupAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::UserAgeConsentGroup>(args, 0);

                return py::convert(self->obj.CheckUserAgeConsentGroupAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* User_CreateWatcher(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.User", L"CreateWatcher", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::System::User::CreateWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* User_FindAllAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.User", L"FindAllAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::System::User::FindAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.User", L"FindAllAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::UserType>(args, 0);

                return py::convert(winrt::Windows::System::User::FindAllAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.User", L"FindAllAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::UserType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::UserAuthenticationStatus>(args, 1);

                return py::convert(winrt::Windows::System::User::FindAllAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* User_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.User", L"GetDefault", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::System::User::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* User_GetFromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.User", L"GetFromId", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::System::User::GetFromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* User_GetPictureAsync(py::wrapper::Windows::System::User* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.User", L"GetPictureAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::UserPictureSize>(args, 0);

                return py::convert(self->obj.GetPictureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* User_GetPropertiesAsync(py::wrapper::Windows::System::User* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.User", L"GetPropertiesAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetPropertiesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* User_GetPropertyAsync(py::wrapper::Windows::System::User* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.User", L"GetPropertyAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetPropertyAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* User_get_AuthenticationStatus(py::wrapper::Windows::System::User* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.User", L"AuthenticationStatus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AuthenticationStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* User_get_NonRoamableId(py::wrapper::Windows::System::User* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.User", L"NonRoamableId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NonRoamableId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* User_get_Type(py::wrapper::Windows::System::User* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.User", L"Type"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_User(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::User>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_User(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::User>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_User[] = {
        { "check_user_age_consent_group_async", reinterpret_cast<PyCFunction>(User_CheckUserAgeConsentGroupAsync), METH_VARARGS, nullptr },
        { "get_picture_async", reinterpret_cast<PyCFunction>(User_GetPictureAsync), METH_VARARGS, nullptr },
        { "get_properties_async", reinterpret_cast<PyCFunction>(User_GetPropertiesAsync), METH_VARARGS, nullptr },
        { "get_property_async", reinterpret_cast<PyCFunction>(User_GetPropertyAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_User, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_User), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_User[] = {
        { "authentication_status", reinterpret_cast<getter>(User_get_AuthenticationStatus), nullptr, nullptr, nullptr },
        { "non_roamable_id", reinterpret_cast<getter>(User_get_NonRoamableId), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(User_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_User[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_User) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_User) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_User) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_User) },
        { },
    };

    static PyType_Spec type_spec_User =
    {
        "winrt._winrt_windows_system.User",
        sizeof(py::wrapper::Windows::System::User),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_User
    };

    static PyGetSetDef getset_User_Static[] = {
        { }
    };

    static PyMethodDef methods_User_Static[] = {
        { "create_watcher", reinterpret_cast<PyCFunction>(User_CreateWatcher), METH_VARARGS, nullptr },
        { "find_all_async", reinterpret_cast<PyCFunction>(User_FindAllAsync), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(User_GetDefault), METH_VARARGS, nullptr },
        { "get_from_id", reinterpret_cast<PyCFunction>(User_GetFromId), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_User_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_User_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_User_Static) },
        { }
    };

    static PyType_Spec type_spec_User_Static =
    {
        "winrt._winrt_windows_system.User_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_User_Static
    };

    // ----- UserAuthenticationStatusChangeDeferral class --------------------

    static PyObject* _new_UserAuthenticationStatusChangeDeferral(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::UserAuthenticationStatusChangeDeferral>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::UserAuthenticationStatusChangeDeferral>::type_name);
        return nullptr;
    }

    static void _dealloc_UserAuthenticationStatusChangeDeferral(py::wrapper::Windows::System::UserAuthenticationStatusChangeDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UserAuthenticationStatusChangeDeferral_Complete(py::wrapper::Windows::System::UserAuthenticationStatusChangeDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.UserAuthenticationStatusChangeDeferral", L"Complete", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_UserAuthenticationStatusChangeDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::UserAuthenticationStatusChangeDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UserAuthenticationStatusChangeDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::UserAuthenticationStatusChangeDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserAuthenticationStatusChangeDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(UserAuthenticationStatusChangeDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_UserAuthenticationStatusChangeDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UserAuthenticationStatusChangeDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UserAuthenticationStatusChangeDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_UserAuthenticationStatusChangeDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UserAuthenticationStatusChangeDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UserAuthenticationStatusChangeDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UserAuthenticationStatusChangeDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UserAuthenticationStatusChangeDeferral) },
        { },
    };

    static PyType_Spec type_spec_UserAuthenticationStatusChangeDeferral =
    {
        "winrt._winrt_windows_system.UserAuthenticationStatusChangeDeferral",
        sizeof(py::wrapper::Windows::System::UserAuthenticationStatusChangeDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserAuthenticationStatusChangeDeferral
    };

    // ----- UserAuthenticationStatusChangingEventArgs class --------------------

    static PyObject* _new_UserAuthenticationStatusChangingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::UserAuthenticationStatusChangingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::UserAuthenticationStatusChangingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_UserAuthenticationStatusChangingEventArgs(py::wrapper::Windows::System::UserAuthenticationStatusChangingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UserAuthenticationStatusChangingEventArgs_GetDeferral(py::wrapper::Windows::System::UserAuthenticationStatusChangingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.UserAuthenticationStatusChangingEventArgs", L"GetDeferral", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserAuthenticationStatusChangingEventArgs_get_CurrentStatus(py::wrapper::Windows::System::UserAuthenticationStatusChangingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.UserAuthenticationStatusChangingEventArgs", L"CurrentStatus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CurrentStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserAuthenticationStatusChangingEventArgs_get_NewStatus(py::wrapper::Windows::System::UserAuthenticationStatusChangingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.UserAuthenticationStatusChangingEventArgs", L"NewStatus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NewStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserAuthenticationStatusChangingEventArgs_get_User(py::wrapper::Windows::System::UserAuthenticationStatusChangingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.UserAuthenticationStatusChangingEventArgs", L"User"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UserAuthenticationStatusChangingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::UserAuthenticationStatusChangingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UserAuthenticationStatusChangingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::UserAuthenticationStatusChangingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserAuthenticationStatusChangingEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(UserAuthenticationStatusChangingEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_UserAuthenticationStatusChangingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UserAuthenticationStatusChangingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UserAuthenticationStatusChangingEventArgs[] = {
        { "current_status", reinterpret_cast<getter>(UserAuthenticationStatusChangingEventArgs_get_CurrentStatus), nullptr, nullptr, nullptr },
        { "new_status", reinterpret_cast<getter>(UserAuthenticationStatusChangingEventArgs_get_NewStatus), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(UserAuthenticationStatusChangingEventArgs_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UserAuthenticationStatusChangingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UserAuthenticationStatusChangingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UserAuthenticationStatusChangingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UserAuthenticationStatusChangingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UserAuthenticationStatusChangingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_UserAuthenticationStatusChangingEventArgs =
    {
        "winrt._winrt_windows_system.UserAuthenticationStatusChangingEventArgs",
        sizeof(py::wrapper::Windows::System::UserAuthenticationStatusChangingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserAuthenticationStatusChangingEventArgs
    };

    // ----- UserChangedEventArgs class --------------------

    static PyObject* _new_UserChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::UserChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::UserChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_UserChangedEventArgs(py::wrapper::Windows::System::UserChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UserChangedEventArgs_get_User(py::wrapper::Windows::System::UserChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.UserChangedEventArgs", L"User"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserChangedEventArgs_get_ChangedPropertyKinds(py::wrapper::Windows::System::UserChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.UserChangedEventArgs", L"ChangedPropertyKinds"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ChangedPropertyKinds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UserChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::UserChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UserChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::UserChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserChangedEventArgs[] = {
        { "_assign_array_", _assign_array_UserChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UserChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UserChangedEventArgs[] = {
        { "user", reinterpret_cast<getter>(UserChangedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "changed_property_kinds", reinterpret_cast<getter>(UserChangedEventArgs_get_ChangedPropertyKinds), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UserChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UserChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UserChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UserChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UserChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_UserChangedEventArgs =
    {
        "winrt._winrt_windows_system.UserChangedEventArgs",
        sizeof(py::wrapper::Windows::System::UserChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserChangedEventArgs
    };

    // ----- UserDeviceAssociation class --------------------

    static PyObject* _new_UserDeviceAssociation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::UserDeviceAssociation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::UserDeviceAssociation>::type_name);
        return nullptr;
    }

    static PyObject* UserDeviceAssociation_FindUserFromDeviceId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.UserDeviceAssociation", L"FindUserFromDeviceId", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::System::UserDeviceAssociation::FindUserFromDeviceId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserDeviceAssociation_add_UserDeviceAssociationChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.UserDeviceAssociation", L"UserDeviceAssociationChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::System::UserDeviceAssociationChangedEventArgs>>(arg);

            return py::convert(winrt::Windows::System::UserDeviceAssociation::UserDeviceAssociationChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDeviceAssociation_remove_UserDeviceAssociationChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.UserDeviceAssociation", L"UserDeviceAssociationChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::System::UserDeviceAssociation::UserDeviceAssociationChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserDeviceAssociation[] = {
        { "add_user_device_association_changed", reinterpret_cast<PyCFunction>(UserDeviceAssociation_add_UserDeviceAssociationChanged), METH_O | METH_STATIC, nullptr },
        { "remove_user_device_association_changed", reinterpret_cast<PyCFunction>(UserDeviceAssociation_remove_UserDeviceAssociationChanged), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UserDeviceAssociation[] = {
        { }
    };

    static PyType_Slot _type_slots_UserDeviceAssociation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UserDeviceAssociation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UserDeviceAssociation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UserDeviceAssociation) },
        { },
    };

    static PyType_Spec type_spec_UserDeviceAssociation =
    {
        "winrt._winrt_windows_system.UserDeviceAssociation",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserDeviceAssociation
    };

    static PyGetSetDef getset_UserDeviceAssociation_Static[] = {
        { }
    };

    static PyMethodDef methods_UserDeviceAssociation_Static[] = {
        { "find_user_from_device_id", reinterpret_cast<PyCFunction>(UserDeviceAssociation_FindUserFromDeviceId), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_UserDeviceAssociation_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_UserDeviceAssociation_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_UserDeviceAssociation_Static) },
        { }
    };

    static PyType_Spec type_spec_UserDeviceAssociation_Static =
    {
        "winrt._winrt_windows_system.UserDeviceAssociation_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_UserDeviceAssociation_Static
    };

    // ----- UserDeviceAssociationChangedEventArgs class --------------------

    static PyObject* _new_UserDeviceAssociationChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::UserDeviceAssociationChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::UserDeviceAssociationChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_UserDeviceAssociationChangedEventArgs(py::wrapper::Windows::System::UserDeviceAssociationChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UserDeviceAssociationChangedEventArgs_get_DeviceId(py::wrapper::Windows::System::UserDeviceAssociationChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.UserDeviceAssociationChangedEventArgs", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDeviceAssociationChangedEventArgs_get_NewUser(py::wrapper::Windows::System::UserDeviceAssociationChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.UserDeviceAssociationChangedEventArgs", L"NewUser"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NewUser());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDeviceAssociationChangedEventArgs_get_OldUser(py::wrapper::Windows::System::UserDeviceAssociationChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.UserDeviceAssociationChangedEventArgs", L"OldUser"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OldUser());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UserDeviceAssociationChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::UserDeviceAssociationChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UserDeviceAssociationChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::UserDeviceAssociationChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserDeviceAssociationChangedEventArgs[] = {
        { "_assign_array_", _assign_array_UserDeviceAssociationChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UserDeviceAssociationChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UserDeviceAssociationChangedEventArgs[] = {
        { "device_id", reinterpret_cast<getter>(UserDeviceAssociationChangedEventArgs_get_DeviceId), nullptr, nullptr, nullptr },
        { "new_user", reinterpret_cast<getter>(UserDeviceAssociationChangedEventArgs_get_NewUser), nullptr, nullptr, nullptr },
        { "old_user", reinterpret_cast<getter>(UserDeviceAssociationChangedEventArgs_get_OldUser), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UserDeviceAssociationChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UserDeviceAssociationChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UserDeviceAssociationChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UserDeviceAssociationChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UserDeviceAssociationChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_UserDeviceAssociationChangedEventArgs =
    {
        "winrt._winrt_windows_system.UserDeviceAssociationChangedEventArgs",
        sizeof(py::wrapper::Windows::System::UserDeviceAssociationChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserDeviceAssociationChangedEventArgs
    };

    // ----- UserPicker class --------------------

    static PyObject* _new_UserPicker(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::System::UserPicker instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_UserPicker(py::wrapper::Windows::System::UserPicker* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UserPicker_IsSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.UserPicker", L"IsSupported", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::System::UserPicker::IsSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserPicker_PickSingleUserAsync(py::wrapper::Windows::System::UserPicker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.UserPicker", L"PickSingleUserAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.PickSingleUserAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserPicker_get_SuggestedSelectedUser(py::wrapper::Windows::System::UserPicker* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.UserPicker", L"SuggestedSelectedUser"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SuggestedSelectedUser());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UserPicker_put_SuggestedSelectedUser(py::wrapper::Windows::System::UserPicker* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.UserPicker", L"SuggestedSelectedUser"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::System::User>(arg);

            self->obj.SuggestedSelectedUser(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UserPicker_get_AllowGuestAccounts(py::wrapper::Windows::System::UserPicker* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.UserPicker", L"AllowGuestAccounts"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowGuestAccounts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UserPicker_put_AllowGuestAccounts(py::wrapper::Windows::System::UserPicker* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.UserPicker", L"AllowGuestAccounts"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowGuestAccounts(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_UserPicker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::UserPicker>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UserPicker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::UserPicker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserPicker[] = {
        { "pick_single_user_async", reinterpret_cast<PyCFunction>(UserPicker_PickSingleUserAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_UserPicker, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UserPicker), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UserPicker[] = {
        { "suggested_selected_user", reinterpret_cast<getter>(UserPicker_get_SuggestedSelectedUser), reinterpret_cast<setter>(UserPicker_put_SuggestedSelectedUser), nullptr, nullptr },
        { "allow_guest_accounts", reinterpret_cast<getter>(UserPicker_get_AllowGuestAccounts), reinterpret_cast<setter>(UserPicker_put_AllowGuestAccounts), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UserPicker[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UserPicker) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UserPicker) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UserPicker) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UserPicker) },
        { },
    };

    static PyType_Spec type_spec_UserPicker =
    {
        "winrt._winrt_windows_system.UserPicker",
        sizeof(py::wrapper::Windows::System::UserPicker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserPicker
    };

    static PyGetSetDef getset_UserPicker_Static[] = {
        { }
    };

    static PyMethodDef methods_UserPicker_Static[] = {
        { "is_supported", reinterpret_cast<PyCFunction>(UserPicker_IsSupported), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_UserPicker_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_UserPicker_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_UserPicker_Static) },
        { }
    };

    static PyType_Spec type_spec_UserPicker_Static =
    {
        "winrt._winrt_windows_system.UserPicker_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_UserPicker_Static
    };

    // ----- UserWatcher class --------------------

    static PyObject* _new_UserWatcher(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::UserWatcher>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::UserWatcher>::type_name);
        return nullptr;
    }

    static void _dealloc_UserWatcher(py::wrapper::Windows::System::UserWatcher* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UserWatcher_Start(py::wrapper::Windows::System::UserWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.UserWatcher", L"Start", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserWatcher_Stop(py::wrapper::Windows::System::UserWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.UserWatcher", L"Stop", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserWatcher_get_Status(py::wrapper::Windows::System::UserWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.UserWatcher", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_add_Added(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.UserWatcher", L"Added"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::UserWatcher, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert(self->obj.Added(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_remove_Added(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.UserWatcher", L"Added"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Added(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_add_AuthenticationStatusChanged(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.UserWatcher", L"AuthenticationStatusChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::UserWatcher, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert(self->obj.AuthenticationStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_remove_AuthenticationStatusChanged(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.UserWatcher", L"AuthenticationStatusChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AuthenticationStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_add_AuthenticationStatusChanging(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.UserWatcher", L"AuthenticationStatusChanging"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::UserWatcher, winrt::Windows::System::UserAuthenticationStatusChangingEventArgs>>(arg);

            return py::convert(self->obj.AuthenticationStatusChanging(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_remove_AuthenticationStatusChanging(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.UserWatcher", L"AuthenticationStatusChanging"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AuthenticationStatusChanging(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_add_EnumerationCompleted(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.UserWatcher", L"EnumerationCompleted"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::UserWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_remove_EnumerationCompleted(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.UserWatcher", L"EnumerationCompleted"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_add_Removed(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.UserWatcher", L"Removed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::UserWatcher, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert(self->obj.Removed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_remove_Removed(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.UserWatcher", L"Removed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Removed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_add_Stopped(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.UserWatcher", L"Stopped"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::UserWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_remove_Stopped(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.UserWatcher", L"Stopped"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_add_Updated(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.UserWatcher", L"Updated"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::UserWatcher, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert(self->obj.Updated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_remove_Updated(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.UserWatcher", L"Updated"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Updated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UserWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::UserWatcher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UserWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::UserWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserWatcher[] = {
        { "start", reinterpret_cast<PyCFunction>(UserWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(UserWatcher_Stop), METH_VARARGS, nullptr },
        { "add_added", reinterpret_cast<PyCFunction>(UserWatcher_add_Added), METH_O, nullptr },
        { "remove_added", reinterpret_cast<PyCFunction>(UserWatcher_remove_Added), METH_O, nullptr },
        { "add_authentication_status_changed", reinterpret_cast<PyCFunction>(UserWatcher_add_AuthenticationStatusChanged), METH_O, nullptr },
        { "remove_authentication_status_changed", reinterpret_cast<PyCFunction>(UserWatcher_remove_AuthenticationStatusChanged), METH_O, nullptr },
        { "add_authentication_status_changing", reinterpret_cast<PyCFunction>(UserWatcher_add_AuthenticationStatusChanging), METH_O, nullptr },
        { "remove_authentication_status_changing", reinterpret_cast<PyCFunction>(UserWatcher_remove_AuthenticationStatusChanging), METH_O, nullptr },
        { "add_enumeration_completed", reinterpret_cast<PyCFunction>(UserWatcher_add_EnumerationCompleted), METH_O, nullptr },
        { "remove_enumeration_completed", reinterpret_cast<PyCFunction>(UserWatcher_remove_EnumerationCompleted), METH_O, nullptr },
        { "add_removed", reinterpret_cast<PyCFunction>(UserWatcher_add_Removed), METH_O, nullptr },
        { "remove_removed", reinterpret_cast<PyCFunction>(UserWatcher_remove_Removed), METH_O, nullptr },
        { "add_stopped", reinterpret_cast<PyCFunction>(UserWatcher_add_Stopped), METH_O, nullptr },
        { "remove_stopped", reinterpret_cast<PyCFunction>(UserWatcher_remove_Stopped), METH_O, nullptr },
        { "add_updated", reinterpret_cast<PyCFunction>(UserWatcher_add_Updated), METH_O, nullptr },
        { "remove_updated", reinterpret_cast<PyCFunction>(UserWatcher_remove_Updated), METH_O, nullptr },
        { "_assign_array_", _assign_array_UserWatcher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UserWatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UserWatcher[] = {
        { "status", reinterpret_cast<getter>(UserWatcher_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UserWatcher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UserWatcher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UserWatcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UserWatcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UserWatcher) },
        { },
    };

    static PyType_Spec type_spec_UserWatcher =
    {
        "winrt._winrt_windows_system.UserWatcher",
        sizeof(py::wrapper::Windows::System::UserWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserWatcher
    };

    // ----- ILauncherViewOptions interface --------------------

    static PyObject* _new_ILauncherViewOptions(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::ILauncherViewOptions>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::ILauncherViewOptions>::type_name);
        return nullptr;
    }

    static void _dealloc_ILauncherViewOptions(py::wrapper::Windows::System::ILauncherViewOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ILauncherViewOptions_get_DesiredRemainingView(py::wrapper::Windows::System::ILauncherViewOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.ILauncherViewOptions", L"DesiredRemainingView"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DesiredRemainingView());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ILauncherViewOptions_put_DesiredRemainingView(py::wrapper::Windows::System::ILauncherViewOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.ILauncherViewOptions", L"DesiredRemainingView"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::ViewSizePreference>(arg);

            self->obj.DesiredRemainingView(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ILauncherViewOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::ILauncherViewOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ILauncherViewOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::ILauncherViewOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILauncherViewOptions[] = {
        { "_assign_array_", _assign_array_ILauncherViewOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ILauncherViewOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ILauncherViewOptions[] = {
        { "desired_remaining_view", reinterpret_cast<getter>(ILauncherViewOptions_get_DesiredRemainingView), reinterpret_cast<setter>(ILauncherViewOptions_put_DesiredRemainingView), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ILauncherViewOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ILauncherViewOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ILauncherViewOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ILauncherViewOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ILauncherViewOptions) },
        { },
    };

    static PyType_Spec type_spec_ILauncherViewOptions =
    {
        "winrt._winrt_windows_system.ILauncherViewOptions",
        sizeof(py::wrapper::Windows::System::ILauncherViewOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILauncherViewOptions
    };

    // ----- Windows.System Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::System");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_system",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::System

PyMODINIT_FUNC PyInit__winrt_windows_system(void) noexcept
{
    using namespace py::cpp::Windows::System;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppActivationResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppDiagnosticInfo_Static{PyType_FromSpec(&type_spec_AppDiagnosticInfo_Static)};
    if (!type_AppDiagnosticInfo_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppDiagnosticInfo, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppDiagnosticInfo_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppDiagnosticInfoWatcher, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppDiagnosticInfoWatcherEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppExecutionStateChangeResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppMemoryReport, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppMemoryUsageLimitChangingEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppResourceGroupBackgroundTaskReport, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppResourceGroupInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppResourceGroupInfoWatcher, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppResourceGroupInfoWatcherEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppResourceGroupMemoryReport, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppResourceGroupStateReport, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppUriHandlerHost, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppUriHandlerRegistration, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppUriHandlerRegistrationManager_Static{PyType_FromSpec(&type_spec_AppUriHandlerRegistrationManager_Static)};
    if (!type_AppUriHandlerRegistrationManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppUriHandlerRegistrationManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppUriHandlerRegistrationManager_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_DateTimeSettings_Static{PyType_FromSpec(&type_spec_DateTimeSettings_Static)};
    if (!type_DateTimeSettings_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DateTimeSettings, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DateTimeSettings_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_DispatcherQueue_Static{PyType_FromSpec(&type_spec_DispatcherQueue_Static)};
    if (!type_DispatcherQueue_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DispatcherQueue, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DispatcherQueue_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_DispatcherQueueController_Static{PyType_FromSpec(&type_spec_DispatcherQueueController_Static)};
    if (!type_DispatcherQueueController_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DispatcherQueueController, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DispatcherQueueController_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DispatcherQueueShutdownStartingEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DispatcherQueueTimer, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_FolderLauncherOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownUserProperties_Static{PyType_FromSpec(&type_spec_KnownUserProperties_Static)};
    if (!type_KnownUserProperties_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_KnownUserProperties, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KnownUserProperties_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LaunchUriResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_Launcher_Static{PyType_FromSpec(&type_spec_Launcher_Static)};
    if (!type_Launcher_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Launcher, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Launcher_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LauncherOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LauncherUIOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MemoryManager_Static{PyType_FromSpec(&type_spec_MemoryManager_Static)};
    if (!type_MemoryManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MemoryManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MemoryManager_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ProcessLauncher_Static{PyType_FromSpec(&type_spec_ProcessLauncher_Static)};
    if (!type_ProcessLauncher_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ProcessLauncher, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ProcessLauncher_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ProcessLauncherOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ProcessLauncherResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ProcessMemoryReport, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ProtocolForResultsOperation, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_RemoteLauncher_Static{PyType_FromSpec(&type_spec_RemoteLauncher_Static)};
    if (!type_RemoteLauncher_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteLauncher, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RemoteLauncher_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteLauncherOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ShutdownManager_Static{PyType_FromSpec(&type_spec_ShutdownManager_Static)};
    if (!type_ShutdownManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ShutdownManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ShutdownManager_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_TimeZoneSettings_Static{PyType_FromSpec(&type_spec_TimeZoneSettings_Static)};
    if (!type_TimeZoneSettings_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TimeZoneSettings, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TimeZoneSettings_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_User_Static{PyType_FromSpec(&type_spec_User_Static)};
    if (!type_User_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_User, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_User_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UserAuthenticationStatusChangeDeferral, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UserAuthenticationStatusChangingEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UserChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_UserDeviceAssociation_Static{PyType_FromSpec(&type_spec_UserDeviceAssociation_Static)};
    if (!type_UserDeviceAssociation_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UserDeviceAssociation, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_UserDeviceAssociation_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UserDeviceAssociationChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_UserPicker_Static{PyType_FromSpec(&type_spec_UserPicker_Static)};
    if (!type_UserPicker_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UserPicker, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_UserPicker_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UserWatcher, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ILauncherViewOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
