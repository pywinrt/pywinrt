// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.System.h"


namespace py::cpp::Windows::System
{
    struct module_state
    {
        PyTypeObject* type_AppActivationResult;
        PyTypeObject* type_AppDiagnosticInfo;
        PyTypeObject* type_AppDiagnosticInfoWatcher;
        PyTypeObject* type_AppDiagnosticInfoWatcherEventArgs;
        PyTypeObject* type_AppExecutionStateChangeResult;
        PyTypeObject* type_AppMemoryReport;
        PyTypeObject* type_AppMemoryUsageLimitChangingEventArgs;
        PyTypeObject* type_AppResourceGroupBackgroundTaskReport;
        PyTypeObject* type_AppResourceGroupInfo;
        PyTypeObject* type_AppResourceGroupInfoWatcher;
        PyTypeObject* type_AppResourceGroupInfoWatcherEventArgs;
        PyTypeObject* type_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs;
        PyTypeObject* type_AppResourceGroupMemoryReport;
        PyTypeObject* type_AppResourceGroupStateReport;
        PyTypeObject* type_AppUriHandlerHost;
        PyTypeObject* type_AppUriHandlerRegistration;
        PyTypeObject* type_AppUriHandlerRegistrationManager;
        PyTypeObject* type_DateTimeSettings;
        PyTypeObject* type_DispatcherQueue;
        PyTypeObject* type_DispatcherQueueController;
        PyTypeObject* type_DispatcherQueueShutdownStartingEventArgs;
        PyTypeObject* type_DispatcherQueueTimer;
        PyTypeObject* type_FolderLauncherOptions;
        PyTypeObject* type_KnownUserProperties;
        PyTypeObject* type_LaunchUriResult;
        PyTypeObject* type_Launcher;
        PyTypeObject* type_LauncherOptions;
        PyTypeObject* type_LauncherUIOptions;
        PyTypeObject* type_MemoryManager;
        PyTypeObject* type_ProcessLauncher;
        PyTypeObject* type_ProcessLauncherOptions;
        PyTypeObject* type_ProcessLauncherResult;
        PyTypeObject* type_ProcessMemoryReport;
        PyTypeObject* type_ProtocolForResultsOperation;
        PyTypeObject* type_RemoteLauncher;
        PyTypeObject* type_RemoteLauncherOptions;
        PyTypeObject* type_ShutdownManager;
        PyTypeObject* type_TimeZoneSettings;
        PyTypeObject* type_User;
        PyTypeObject* type_UserAuthenticationStatusChangeDeferral;
        PyTypeObject* type_UserAuthenticationStatusChangingEventArgs;
        PyTypeObject* type_UserChangedEventArgs;
        PyTypeObject* type_UserDeviceAssociation;
        PyTypeObject* type_UserDeviceAssociationChangedEventArgs;
        PyTypeObject* type_UserPicker;
        PyTypeObject* type_UserWatcher;
        PyTypeObject* type_ILauncherViewOptions;
    };

    // ----- AppActivationResult class --------------------
    static constexpr const char* const type_name_AppActivationResult = "AppActivationResult";

    static PyObject* _new_AppActivationResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppActivationResult);
        return nullptr;
    }

    static void _dealloc_AppActivationResult(py::wrapper::Windows::System::AppActivationResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppActivationResult_get_AppResourceGroupInfo(py::wrapper::Windows::System::AppActivationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppActivationResult", L"AppResourceGroupInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppResourceGroupInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppActivationResult_get_ExtendedError(py::wrapper::Windows::System::AppActivationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppActivationResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppActivationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppActivationResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppActivationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppActivationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppActivationResult[] = {
        { "_assign_array_", _assign_array_AppActivationResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppActivationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppActivationResult[] = {
        { "app_resource_group_info", reinterpret_cast<getter>(AppActivationResult_get_AppResourceGroupInfo), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(AppActivationResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppActivationResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppActivationResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppActivationResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppActivationResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppActivationResult) },
        { },
    };

    static PyType_Spec type_spec_AppActivationResult =
    {
        "_winrt_Windows_System.AppActivationResult",
        sizeof(py::wrapper::Windows::System::AppActivationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppActivationResult
    };

    // ----- AppDiagnosticInfo class --------------------
    static constexpr const char* const type_name_AppDiagnosticInfo = "AppDiagnosticInfo";

    static PyObject* _new_AppDiagnosticInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppDiagnosticInfo);
        return nullptr;
    }

    static void _dealloc_AppDiagnosticInfo(py::wrapper::Windows::System::AppDiagnosticInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppDiagnosticInfo_CreateResourceGroupWatcher(py::wrapper::Windows::System::AppDiagnosticInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppDiagnosticInfo", L"CreateResourceGroupWatcher", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateResourceGroupWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfo_CreateWatcher(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppDiagnosticInfo", L"CreateWatcher", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::System::AppDiagnosticInfo::CreateWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfo_GetResourceGroups(py::wrapper::Windows::System::AppDiagnosticInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppDiagnosticInfo", L"GetResourceGroups", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetResourceGroups());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfo_LaunchAsync(py::wrapper::Windows::System::AppDiagnosticInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppDiagnosticInfo", L"LaunchAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.LaunchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfo_RequestAccessAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppDiagnosticInfo", L"RequestAccessAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::System::AppDiagnosticInfo::RequestAccessAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfo_RequestInfoAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppDiagnosticInfo", L"RequestInfoAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::System::AppDiagnosticInfo::RequestInfoAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfo_RequestInfoForAppAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppDiagnosticInfo", L"RequestInfoForAppAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::System::AppDiagnosticInfo::RequestInfoForAppAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppDiagnosticInfo", L"RequestInfoForAppAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::System::AppDiagnosticInfo::RequestInfoForAppAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfo_RequestInfoForPackageAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppDiagnosticInfo", L"RequestInfoForPackageAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::System::AppDiagnosticInfo::RequestInfoForPackageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfo_get_AppInfo(py::wrapper::Windows::System::AppDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppDiagnosticInfo", L"AppInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppDiagnosticInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppDiagnosticInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppDiagnosticInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppDiagnosticInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppDiagnosticInfo[] = {
        { "create_resource_group_watcher", reinterpret_cast<PyCFunction>(AppDiagnosticInfo_CreateResourceGroupWatcher), METH_VARARGS, nullptr },
        { "create_watcher", reinterpret_cast<PyCFunction>(AppDiagnosticInfo_CreateWatcher), METH_VARARGS | METH_STATIC, nullptr },
        { "get_resource_groups", reinterpret_cast<PyCFunction>(AppDiagnosticInfo_GetResourceGroups), METH_VARARGS, nullptr },
        { "launch_async", reinterpret_cast<PyCFunction>(AppDiagnosticInfo_LaunchAsync), METH_VARARGS, nullptr },
        { "request_access_async", reinterpret_cast<PyCFunction>(AppDiagnosticInfo_RequestAccessAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "request_info_async", reinterpret_cast<PyCFunction>(AppDiagnosticInfo_RequestInfoAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "request_info_for_app_async", reinterpret_cast<PyCFunction>(AppDiagnosticInfo_RequestInfoForAppAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "request_info_for_package_async", reinterpret_cast<PyCFunction>(AppDiagnosticInfo_RequestInfoForPackageAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_AppDiagnosticInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppDiagnosticInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppDiagnosticInfo[] = {
        { "app_info", reinterpret_cast<getter>(AppDiagnosticInfo_get_AppInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppDiagnosticInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppDiagnosticInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppDiagnosticInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppDiagnosticInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppDiagnosticInfo) },
        { },
    };

    static PyType_Spec type_spec_AppDiagnosticInfo =
    {
        "_winrt_Windows_System.AppDiagnosticInfo",
        sizeof(py::wrapper::Windows::System::AppDiagnosticInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppDiagnosticInfo
    };

    // ----- AppDiagnosticInfoWatcher class --------------------
    static constexpr const char* const type_name_AppDiagnosticInfoWatcher = "AppDiagnosticInfoWatcher";

    static PyObject* _new_AppDiagnosticInfoWatcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppDiagnosticInfoWatcher);
        return nullptr;
    }

    static void _dealloc_AppDiagnosticInfoWatcher(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppDiagnosticInfoWatcher_Start(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppDiagnosticInfoWatcher", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfoWatcher_Stop(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppDiagnosticInfoWatcher", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfoWatcher_get_Status(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppDiagnosticInfoWatcher", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfoWatcher_add_Added(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppDiagnosticInfoWatcher", L"Added"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::AppDiagnosticInfoWatcher, winrt::Windows::System::AppDiagnosticInfoWatcherEventArgs>>(arg);

            return py::convert(self->obj.Added(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfoWatcher_remove_Added(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppDiagnosticInfoWatcher", L"Added"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Added(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfoWatcher_add_EnumerationCompleted(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppDiagnosticInfoWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::AppDiagnosticInfoWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfoWatcher_remove_EnumerationCompleted(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppDiagnosticInfoWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfoWatcher_add_Removed(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppDiagnosticInfoWatcher", L"Removed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::AppDiagnosticInfoWatcher, winrt::Windows::System::AppDiagnosticInfoWatcherEventArgs>>(arg);

            return py::convert(self->obj.Removed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfoWatcher_remove_Removed(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppDiagnosticInfoWatcher", L"Removed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Removed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfoWatcher_add_Stopped(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppDiagnosticInfoWatcher", L"Stopped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::AppDiagnosticInfoWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfoWatcher_remove_Stopped(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppDiagnosticInfoWatcher", L"Stopped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppDiagnosticInfoWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppDiagnosticInfoWatcher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppDiagnosticInfoWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppDiagnosticInfoWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppDiagnosticInfoWatcher[] = {
        { "start", reinterpret_cast<PyCFunction>(AppDiagnosticInfoWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AppDiagnosticInfoWatcher_Stop), METH_VARARGS, nullptr },
        { "add_added", reinterpret_cast<PyCFunction>(AppDiagnosticInfoWatcher_add_Added), METH_O, nullptr },
        { "remove_added", reinterpret_cast<PyCFunction>(AppDiagnosticInfoWatcher_remove_Added), METH_O, nullptr },
        { "add_enumeration_completed", reinterpret_cast<PyCFunction>(AppDiagnosticInfoWatcher_add_EnumerationCompleted), METH_O, nullptr },
        { "remove_enumeration_completed", reinterpret_cast<PyCFunction>(AppDiagnosticInfoWatcher_remove_EnumerationCompleted), METH_O, nullptr },
        { "add_removed", reinterpret_cast<PyCFunction>(AppDiagnosticInfoWatcher_add_Removed), METH_O, nullptr },
        { "remove_removed", reinterpret_cast<PyCFunction>(AppDiagnosticInfoWatcher_remove_Removed), METH_O, nullptr },
        { "add_stopped", reinterpret_cast<PyCFunction>(AppDiagnosticInfoWatcher_add_Stopped), METH_O, nullptr },
        { "remove_stopped", reinterpret_cast<PyCFunction>(AppDiagnosticInfoWatcher_remove_Stopped), METH_O, nullptr },
        { "_assign_array_", _assign_array_AppDiagnosticInfoWatcher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppDiagnosticInfoWatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppDiagnosticInfoWatcher[] = {
        { "status", reinterpret_cast<getter>(AppDiagnosticInfoWatcher_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppDiagnosticInfoWatcher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppDiagnosticInfoWatcher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppDiagnosticInfoWatcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppDiagnosticInfoWatcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppDiagnosticInfoWatcher) },
        { },
    };

    static PyType_Spec type_spec_AppDiagnosticInfoWatcher =
    {
        "_winrt_Windows_System.AppDiagnosticInfoWatcher",
        sizeof(py::wrapper::Windows::System::AppDiagnosticInfoWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppDiagnosticInfoWatcher
    };

    // ----- AppDiagnosticInfoWatcherEventArgs class --------------------
    static constexpr const char* const type_name_AppDiagnosticInfoWatcherEventArgs = "AppDiagnosticInfoWatcherEventArgs";

    static PyObject* _new_AppDiagnosticInfoWatcherEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppDiagnosticInfoWatcherEventArgs);
        return nullptr;
    }

    static void _dealloc_AppDiagnosticInfoWatcherEventArgs(py::wrapper::Windows::System::AppDiagnosticInfoWatcherEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppDiagnosticInfoWatcherEventArgs_get_AppDiagnosticInfo(py::wrapper::Windows::System::AppDiagnosticInfoWatcherEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppDiagnosticInfoWatcherEventArgs", L"AppDiagnosticInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppDiagnosticInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppDiagnosticInfoWatcherEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppDiagnosticInfoWatcherEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppDiagnosticInfoWatcherEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppDiagnosticInfoWatcherEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppDiagnosticInfoWatcherEventArgs[] = {
        { "_assign_array_", _assign_array_AppDiagnosticInfoWatcherEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppDiagnosticInfoWatcherEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppDiagnosticInfoWatcherEventArgs[] = {
        { "app_diagnostic_info", reinterpret_cast<getter>(AppDiagnosticInfoWatcherEventArgs_get_AppDiagnosticInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppDiagnosticInfoWatcherEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppDiagnosticInfoWatcherEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppDiagnosticInfoWatcherEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppDiagnosticInfoWatcherEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppDiagnosticInfoWatcherEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AppDiagnosticInfoWatcherEventArgs =
    {
        "_winrt_Windows_System.AppDiagnosticInfoWatcherEventArgs",
        sizeof(py::wrapper::Windows::System::AppDiagnosticInfoWatcherEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppDiagnosticInfoWatcherEventArgs
    };

    // ----- AppExecutionStateChangeResult class --------------------
    static constexpr const char* const type_name_AppExecutionStateChangeResult = "AppExecutionStateChangeResult";

    static PyObject* _new_AppExecutionStateChangeResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppExecutionStateChangeResult);
        return nullptr;
    }

    static void _dealloc_AppExecutionStateChangeResult(py::wrapper::Windows::System::AppExecutionStateChangeResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppExecutionStateChangeResult_get_ExtendedError(py::wrapper::Windows::System::AppExecutionStateChangeResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppExecutionStateChangeResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppExecutionStateChangeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppExecutionStateChangeResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppExecutionStateChangeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppExecutionStateChangeResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppExecutionStateChangeResult[] = {
        { "_assign_array_", _assign_array_AppExecutionStateChangeResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppExecutionStateChangeResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppExecutionStateChangeResult[] = {
        { "extended_error", reinterpret_cast<getter>(AppExecutionStateChangeResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppExecutionStateChangeResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppExecutionStateChangeResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppExecutionStateChangeResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppExecutionStateChangeResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppExecutionStateChangeResult) },
        { },
    };

    static PyType_Spec type_spec_AppExecutionStateChangeResult =
    {
        "_winrt_Windows_System.AppExecutionStateChangeResult",
        sizeof(py::wrapper::Windows::System::AppExecutionStateChangeResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppExecutionStateChangeResult
    };

    // ----- AppMemoryReport class --------------------
    static constexpr const char* const type_name_AppMemoryReport = "AppMemoryReport";

    static PyObject* _new_AppMemoryReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppMemoryReport);
        return nullptr;
    }

    static void _dealloc_AppMemoryReport(py::wrapper::Windows::System::AppMemoryReport* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppMemoryReport_get_PeakPrivateCommitUsage(py::wrapper::Windows::System::AppMemoryReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppMemoryReport", L"PeakPrivateCommitUsage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PeakPrivateCommitUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppMemoryReport_get_PrivateCommitUsage(py::wrapper::Windows::System::AppMemoryReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppMemoryReport", L"PrivateCommitUsage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PrivateCommitUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppMemoryReport_get_TotalCommitLimit(py::wrapper::Windows::System::AppMemoryReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppMemoryReport", L"TotalCommitLimit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TotalCommitLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppMemoryReport_get_TotalCommitUsage(py::wrapper::Windows::System::AppMemoryReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppMemoryReport", L"TotalCommitUsage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TotalCommitUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppMemoryReport_get_ExpectedTotalCommitLimit(py::wrapper::Windows::System::AppMemoryReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppMemoryReport", L"ExpectedTotalCommitLimit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpectedTotalCommitLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppMemoryReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppMemoryReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppMemoryReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppMemoryReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppMemoryReport[] = {
        { "_assign_array_", _assign_array_AppMemoryReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppMemoryReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppMemoryReport[] = {
        { "peak_private_commit_usage", reinterpret_cast<getter>(AppMemoryReport_get_PeakPrivateCommitUsage), nullptr, nullptr, nullptr },
        { "private_commit_usage", reinterpret_cast<getter>(AppMemoryReport_get_PrivateCommitUsage), nullptr, nullptr, nullptr },
        { "total_commit_limit", reinterpret_cast<getter>(AppMemoryReport_get_TotalCommitLimit), nullptr, nullptr, nullptr },
        { "total_commit_usage", reinterpret_cast<getter>(AppMemoryReport_get_TotalCommitUsage), nullptr, nullptr, nullptr },
        { "expected_total_commit_limit", reinterpret_cast<getter>(AppMemoryReport_get_ExpectedTotalCommitLimit), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppMemoryReport[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppMemoryReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppMemoryReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppMemoryReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppMemoryReport) },
        { },
    };

    static PyType_Spec type_spec_AppMemoryReport =
    {
        "_winrt_Windows_System.AppMemoryReport",
        sizeof(py::wrapper::Windows::System::AppMemoryReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppMemoryReport
    };

    // ----- AppMemoryUsageLimitChangingEventArgs class --------------------
    static constexpr const char* const type_name_AppMemoryUsageLimitChangingEventArgs = "AppMemoryUsageLimitChangingEventArgs";

    static PyObject* _new_AppMemoryUsageLimitChangingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppMemoryUsageLimitChangingEventArgs);
        return nullptr;
    }

    static void _dealloc_AppMemoryUsageLimitChangingEventArgs(py::wrapper::Windows::System::AppMemoryUsageLimitChangingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppMemoryUsageLimitChangingEventArgs_get_NewLimit(py::wrapper::Windows::System::AppMemoryUsageLimitChangingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppMemoryUsageLimitChangingEventArgs", L"NewLimit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NewLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppMemoryUsageLimitChangingEventArgs_get_OldLimit(py::wrapper::Windows::System::AppMemoryUsageLimitChangingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppMemoryUsageLimitChangingEventArgs", L"OldLimit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OldLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppMemoryUsageLimitChangingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppMemoryUsageLimitChangingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppMemoryUsageLimitChangingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppMemoryUsageLimitChangingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppMemoryUsageLimitChangingEventArgs[] = {
        { "_assign_array_", _assign_array_AppMemoryUsageLimitChangingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppMemoryUsageLimitChangingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppMemoryUsageLimitChangingEventArgs[] = {
        { "new_limit", reinterpret_cast<getter>(AppMemoryUsageLimitChangingEventArgs_get_NewLimit), nullptr, nullptr, nullptr },
        { "old_limit", reinterpret_cast<getter>(AppMemoryUsageLimitChangingEventArgs_get_OldLimit), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppMemoryUsageLimitChangingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppMemoryUsageLimitChangingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppMemoryUsageLimitChangingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppMemoryUsageLimitChangingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppMemoryUsageLimitChangingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AppMemoryUsageLimitChangingEventArgs =
    {
        "_winrt_Windows_System.AppMemoryUsageLimitChangingEventArgs",
        sizeof(py::wrapper::Windows::System::AppMemoryUsageLimitChangingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppMemoryUsageLimitChangingEventArgs
    };

    // ----- AppResourceGroupBackgroundTaskReport class --------------------
    static constexpr const char* const type_name_AppResourceGroupBackgroundTaskReport = "AppResourceGroupBackgroundTaskReport";

    static PyObject* _new_AppResourceGroupBackgroundTaskReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppResourceGroupBackgroundTaskReport);
        return nullptr;
    }

    static void _dealloc_AppResourceGroupBackgroundTaskReport(py::wrapper::Windows::System::AppResourceGroupBackgroundTaskReport* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppResourceGroupBackgroundTaskReport_get_EntryPoint(py::wrapper::Windows::System::AppResourceGroupBackgroundTaskReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupBackgroundTaskReport", L"EntryPoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EntryPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupBackgroundTaskReport_get_Name(py::wrapper::Windows::System::AppResourceGroupBackgroundTaskReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupBackgroundTaskReport", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupBackgroundTaskReport_get_TaskId(py::wrapper::Windows::System::AppResourceGroupBackgroundTaskReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupBackgroundTaskReport", L"TaskId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TaskId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupBackgroundTaskReport_get_Trigger(py::wrapper::Windows::System::AppResourceGroupBackgroundTaskReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupBackgroundTaskReport", L"Trigger"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Trigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppResourceGroupBackgroundTaskReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppResourceGroupBackgroundTaskReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppResourceGroupBackgroundTaskReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppResourceGroupBackgroundTaskReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppResourceGroupBackgroundTaskReport[] = {
        { "_assign_array_", _assign_array_AppResourceGroupBackgroundTaskReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppResourceGroupBackgroundTaskReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppResourceGroupBackgroundTaskReport[] = {
        { "entry_point", reinterpret_cast<getter>(AppResourceGroupBackgroundTaskReport_get_EntryPoint), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(AppResourceGroupBackgroundTaskReport_get_Name), nullptr, nullptr, nullptr },
        { "task_id", reinterpret_cast<getter>(AppResourceGroupBackgroundTaskReport_get_TaskId), nullptr, nullptr, nullptr },
        { "trigger", reinterpret_cast<getter>(AppResourceGroupBackgroundTaskReport_get_Trigger), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppResourceGroupBackgroundTaskReport[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppResourceGroupBackgroundTaskReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppResourceGroupBackgroundTaskReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppResourceGroupBackgroundTaskReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppResourceGroupBackgroundTaskReport) },
        { },
    };

    static PyType_Spec type_spec_AppResourceGroupBackgroundTaskReport =
    {
        "_winrt_Windows_System.AppResourceGroupBackgroundTaskReport",
        sizeof(py::wrapper::Windows::System::AppResourceGroupBackgroundTaskReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppResourceGroupBackgroundTaskReport
    };

    // ----- AppResourceGroupInfo class --------------------
    static constexpr const char* const type_name_AppResourceGroupInfo = "AppResourceGroupInfo";

    static PyObject* _new_AppResourceGroupInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppResourceGroupInfo);
        return nullptr;
    }

    static void _dealloc_AppResourceGroupInfo(py::wrapper::Windows::System::AppResourceGroupInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppResourceGroupInfo_GetBackgroundTaskReports(py::wrapper::Windows::System::AppResourceGroupInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppResourceGroupInfo", L"GetBackgroundTaskReports", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetBackgroundTaskReports());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfo_GetMemoryReport(py::wrapper::Windows::System::AppResourceGroupInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppResourceGroupInfo", L"GetMemoryReport", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetMemoryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfo_GetProcessDiagnosticInfos(py::wrapper::Windows::System::AppResourceGroupInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppResourceGroupInfo", L"GetProcessDiagnosticInfos", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetProcessDiagnosticInfos());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfo_GetStateReport(py::wrapper::Windows::System::AppResourceGroupInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppResourceGroupInfo", L"GetStateReport", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetStateReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfo_StartResumeAsync(py::wrapper::Windows::System::AppResourceGroupInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppResourceGroupInfo", L"StartResumeAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.StartResumeAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfo_StartSuspendAsync(py::wrapper::Windows::System::AppResourceGroupInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppResourceGroupInfo", L"StartSuspendAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.StartSuspendAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfo_StartTerminateAsync(py::wrapper::Windows::System::AppResourceGroupInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppResourceGroupInfo", L"StartTerminateAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.StartTerminateAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfo_get_InstanceId(py::wrapper::Windows::System::AppResourceGroupInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupInfo", L"InstanceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InstanceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfo_get_IsShared(py::wrapper::Windows::System::AppResourceGroupInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupInfo", L"IsShared"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsShared());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppResourceGroupInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppResourceGroupInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppResourceGroupInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppResourceGroupInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppResourceGroupInfo[] = {
        { "get_background_task_reports", reinterpret_cast<PyCFunction>(AppResourceGroupInfo_GetBackgroundTaskReports), METH_VARARGS, nullptr },
        { "get_memory_report", reinterpret_cast<PyCFunction>(AppResourceGroupInfo_GetMemoryReport), METH_VARARGS, nullptr },
        { "get_process_diagnostic_infos", reinterpret_cast<PyCFunction>(AppResourceGroupInfo_GetProcessDiagnosticInfos), METH_VARARGS, nullptr },
        { "get_state_report", reinterpret_cast<PyCFunction>(AppResourceGroupInfo_GetStateReport), METH_VARARGS, nullptr },
        { "start_resume_async", reinterpret_cast<PyCFunction>(AppResourceGroupInfo_StartResumeAsync), METH_VARARGS, nullptr },
        { "start_suspend_async", reinterpret_cast<PyCFunction>(AppResourceGroupInfo_StartSuspendAsync), METH_VARARGS, nullptr },
        { "start_terminate_async", reinterpret_cast<PyCFunction>(AppResourceGroupInfo_StartTerminateAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppResourceGroupInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppResourceGroupInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppResourceGroupInfo[] = {
        { "instance_id", reinterpret_cast<getter>(AppResourceGroupInfo_get_InstanceId), nullptr, nullptr, nullptr },
        { "is_shared", reinterpret_cast<getter>(AppResourceGroupInfo_get_IsShared), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppResourceGroupInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppResourceGroupInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppResourceGroupInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppResourceGroupInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppResourceGroupInfo) },
        { },
    };

    static PyType_Spec type_spec_AppResourceGroupInfo =
    {
        "_winrt_Windows_System.AppResourceGroupInfo",
        sizeof(py::wrapper::Windows::System::AppResourceGroupInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppResourceGroupInfo
    };

    // ----- AppResourceGroupInfoWatcher class --------------------
    static constexpr const char* const type_name_AppResourceGroupInfoWatcher = "AppResourceGroupInfoWatcher";

    static PyObject* _new_AppResourceGroupInfoWatcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppResourceGroupInfoWatcher);
        return nullptr;
    }

    static void _dealloc_AppResourceGroupInfoWatcher(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppResourceGroupInfoWatcher_Start(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppResourceGroupInfoWatcher", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_Stop(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppResourceGroupInfoWatcher", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_get_Status(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupInfoWatcher", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_add_Added(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppResourceGroupInfoWatcher", L"Added"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::AppResourceGroupInfoWatcher, winrt::Windows::System::AppResourceGroupInfoWatcherEventArgs>>(arg);

            return py::convert(self->obj.Added(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_remove_Added(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppResourceGroupInfoWatcher", L"Added"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Added(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_add_EnumerationCompleted(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppResourceGroupInfoWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::AppResourceGroupInfoWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_remove_EnumerationCompleted(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppResourceGroupInfoWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_add_ExecutionStateChanged(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppResourceGroupInfoWatcher", L"ExecutionStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::AppResourceGroupInfoWatcher, winrt::Windows::System::AppResourceGroupInfoWatcherExecutionStateChangedEventArgs>>(arg);

            return py::convert(self->obj.ExecutionStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_remove_ExecutionStateChanged(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppResourceGroupInfoWatcher", L"ExecutionStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ExecutionStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_add_Removed(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppResourceGroupInfoWatcher", L"Removed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::AppResourceGroupInfoWatcher, winrt::Windows::System::AppResourceGroupInfoWatcherEventArgs>>(arg);

            return py::convert(self->obj.Removed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_remove_Removed(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppResourceGroupInfoWatcher", L"Removed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Removed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_add_Stopped(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppResourceGroupInfoWatcher", L"Stopped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::AppResourceGroupInfoWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_remove_Stopped(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.AppResourceGroupInfoWatcher", L"Stopped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppResourceGroupInfoWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppResourceGroupInfoWatcher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppResourceGroupInfoWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppResourceGroupInfoWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppResourceGroupInfoWatcher[] = {
        { "start", reinterpret_cast<PyCFunction>(AppResourceGroupInfoWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AppResourceGroupInfoWatcher_Stop), METH_VARARGS, nullptr },
        { "add_added", reinterpret_cast<PyCFunction>(AppResourceGroupInfoWatcher_add_Added), METH_O, nullptr },
        { "remove_added", reinterpret_cast<PyCFunction>(AppResourceGroupInfoWatcher_remove_Added), METH_O, nullptr },
        { "add_enumeration_completed", reinterpret_cast<PyCFunction>(AppResourceGroupInfoWatcher_add_EnumerationCompleted), METH_O, nullptr },
        { "remove_enumeration_completed", reinterpret_cast<PyCFunction>(AppResourceGroupInfoWatcher_remove_EnumerationCompleted), METH_O, nullptr },
        { "add_execution_state_changed", reinterpret_cast<PyCFunction>(AppResourceGroupInfoWatcher_add_ExecutionStateChanged), METH_O, nullptr },
        { "remove_execution_state_changed", reinterpret_cast<PyCFunction>(AppResourceGroupInfoWatcher_remove_ExecutionStateChanged), METH_O, nullptr },
        { "add_removed", reinterpret_cast<PyCFunction>(AppResourceGroupInfoWatcher_add_Removed), METH_O, nullptr },
        { "remove_removed", reinterpret_cast<PyCFunction>(AppResourceGroupInfoWatcher_remove_Removed), METH_O, nullptr },
        { "add_stopped", reinterpret_cast<PyCFunction>(AppResourceGroupInfoWatcher_add_Stopped), METH_O, nullptr },
        { "remove_stopped", reinterpret_cast<PyCFunction>(AppResourceGroupInfoWatcher_remove_Stopped), METH_O, nullptr },
        { "_assign_array_", _assign_array_AppResourceGroupInfoWatcher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppResourceGroupInfoWatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppResourceGroupInfoWatcher[] = {
        { "status", reinterpret_cast<getter>(AppResourceGroupInfoWatcher_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppResourceGroupInfoWatcher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppResourceGroupInfoWatcher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppResourceGroupInfoWatcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppResourceGroupInfoWatcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppResourceGroupInfoWatcher) },
        { },
    };

    static PyType_Spec type_spec_AppResourceGroupInfoWatcher =
    {
        "_winrt_Windows_System.AppResourceGroupInfoWatcher",
        sizeof(py::wrapper::Windows::System::AppResourceGroupInfoWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppResourceGroupInfoWatcher
    };

    // ----- AppResourceGroupInfoWatcherEventArgs class --------------------
    static constexpr const char* const type_name_AppResourceGroupInfoWatcherEventArgs = "AppResourceGroupInfoWatcherEventArgs";

    static PyObject* _new_AppResourceGroupInfoWatcherEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppResourceGroupInfoWatcherEventArgs);
        return nullptr;
    }

    static void _dealloc_AppResourceGroupInfoWatcherEventArgs(py::wrapper::Windows::System::AppResourceGroupInfoWatcherEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppResourceGroupInfoWatcherEventArgs_get_AppDiagnosticInfos(py::wrapper::Windows::System::AppResourceGroupInfoWatcherEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupInfoWatcherEventArgs", L"AppDiagnosticInfos"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppDiagnosticInfos());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcherEventArgs_get_AppResourceGroupInfo(py::wrapper::Windows::System::AppResourceGroupInfoWatcherEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupInfoWatcherEventArgs", L"AppResourceGroupInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppResourceGroupInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppResourceGroupInfoWatcherEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppResourceGroupInfoWatcherEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppResourceGroupInfoWatcherEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppResourceGroupInfoWatcherEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppResourceGroupInfoWatcherEventArgs[] = {
        { "_assign_array_", _assign_array_AppResourceGroupInfoWatcherEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppResourceGroupInfoWatcherEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppResourceGroupInfoWatcherEventArgs[] = {
        { "app_diagnostic_infos", reinterpret_cast<getter>(AppResourceGroupInfoWatcherEventArgs_get_AppDiagnosticInfos), nullptr, nullptr, nullptr },
        { "app_resource_group_info", reinterpret_cast<getter>(AppResourceGroupInfoWatcherEventArgs_get_AppResourceGroupInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppResourceGroupInfoWatcherEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppResourceGroupInfoWatcherEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppResourceGroupInfoWatcherEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppResourceGroupInfoWatcherEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppResourceGroupInfoWatcherEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AppResourceGroupInfoWatcherEventArgs =
    {
        "_winrt_Windows_System.AppResourceGroupInfoWatcherEventArgs",
        sizeof(py::wrapper::Windows::System::AppResourceGroupInfoWatcherEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppResourceGroupInfoWatcherEventArgs
    };

    // ----- AppResourceGroupInfoWatcherExecutionStateChangedEventArgs class --------------------
    static constexpr const char* const type_name_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs = "AppResourceGroupInfoWatcherExecutionStateChangedEventArgs";

    static PyObject* _new_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs(py::wrapper::Windows::System::AppResourceGroupInfoWatcherExecutionStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppResourceGroupInfoWatcherExecutionStateChangedEventArgs_get_AppDiagnosticInfos(py::wrapper::Windows::System::AppResourceGroupInfoWatcherExecutionStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupInfoWatcherExecutionStateChangedEventArgs", L"AppDiagnosticInfos"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppDiagnosticInfos());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcherExecutionStateChangedEventArgs_get_AppResourceGroupInfo(py::wrapper::Windows::System::AppResourceGroupInfoWatcherExecutionStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupInfoWatcherExecutionStateChangedEventArgs", L"AppResourceGroupInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppResourceGroupInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppResourceGroupInfoWatcherExecutionStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppResourceGroupInfoWatcherExecutionStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs[] = {
        { "app_diagnostic_infos", reinterpret_cast<getter>(AppResourceGroupInfoWatcherExecutionStateChangedEventArgs_get_AppDiagnosticInfos), nullptr, nullptr, nullptr },
        { "app_resource_group_info", reinterpret_cast<getter>(AppResourceGroupInfoWatcherExecutionStateChangedEventArgs_get_AppResourceGroupInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs =
    {
        "_winrt_Windows_System.AppResourceGroupInfoWatcherExecutionStateChangedEventArgs",
        sizeof(py::wrapper::Windows::System::AppResourceGroupInfoWatcherExecutionStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs
    };

    // ----- AppResourceGroupMemoryReport class --------------------
    static constexpr const char* const type_name_AppResourceGroupMemoryReport = "AppResourceGroupMemoryReport";

    static PyObject* _new_AppResourceGroupMemoryReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppResourceGroupMemoryReport);
        return nullptr;
    }

    static void _dealloc_AppResourceGroupMemoryReport(py::wrapper::Windows::System::AppResourceGroupMemoryReport* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppResourceGroupMemoryReport_get_CommitUsageLevel(py::wrapper::Windows::System::AppResourceGroupMemoryReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupMemoryReport", L"CommitUsageLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CommitUsageLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupMemoryReport_get_CommitUsageLimit(py::wrapper::Windows::System::AppResourceGroupMemoryReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupMemoryReport", L"CommitUsageLimit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CommitUsageLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupMemoryReport_get_PrivateCommitUsage(py::wrapper::Windows::System::AppResourceGroupMemoryReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupMemoryReport", L"PrivateCommitUsage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PrivateCommitUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupMemoryReport_get_TotalCommitUsage(py::wrapper::Windows::System::AppResourceGroupMemoryReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupMemoryReport", L"TotalCommitUsage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TotalCommitUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppResourceGroupMemoryReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppResourceGroupMemoryReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppResourceGroupMemoryReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppResourceGroupMemoryReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppResourceGroupMemoryReport[] = {
        { "_assign_array_", _assign_array_AppResourceGroupMemoryReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppResourceGroupMemoryReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppResourceGroupMemoryReport[] = {
        { "commit_usage_level", reinterpret_cast<getter>(AppResourceGroupMemoryReport_get_CommitUsageLevel), nullptr, nullptr, nullptr },
        { "commit_usage_limit", reinterpret_cast<getter>(AppResourceGroupMemoryReport_get_CommitUsageLimit), nullptr, nullptr, nullptr },
        { "private_commit_usage", reinterpret_cast<getter>(AppResourceGroupMemoryReport_get_PrivateCommitUsage), nullptr, nullptr, nullptr },
        { "total_commit_usage", reinterpret_cast<getter>(AppResourceGroupMemoryReport_get_TotalCommitUsage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppResourceGroupMemoryReport[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppResourceGroupMemoryReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppResourceGroupMemoryReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppResourceGroupMemoryReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppResourceGroupMemoryReport) },
        { },
    };

    static PyType_Spec type_spec_AppResourceGroupMemoryReport =
    {
        "_winrt_Windows_System.AppResourceGroupMemoryReport",
        sizeof(py::wrapper::Windows::System::AppResourceGroupMemoryReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppResourceGroupMemoryReport
    };

    // ----- AppResourceGroupStateReport class --------------------
    static constexpr const char* const type_name_AppResourceGroupStateReport = "AppResourceGroupStateReport";

    static PyObject* _new_AppResourceGroupStateReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppResourceGroupStateReport);
        return nullptr;
    }

    static void _dealloc_AppResourceGroupStateReport(py::wrapper::Windows::System::AppResourceGroupStateReport* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppResourceGroupStateReport_get_EnergyQuotaState(py::wrapper::Windows::System::AppResourceGroupStateReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupStateReport", L"EnergyQuotaState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EnergyQuotaState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupStateReport_get_ExecutionState(py::wrapper::Windows::System::AppResourceGroupStateReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppResourceGroupStateReport", L"ExecutionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppResourceGroupStateReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppResourceGroupStateReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppResourceGroupStateReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppResourceGroupStateReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppResourceGroupStateReport[] = {
        { "_assign_array_", _assign_array_AppResourceGroupStateReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppResourceGroupStateReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppResourceGroupStateReport[] = {
        { "energy_quota_state", reinterpret_cast<getter>(AppResourceGroupStateReport_get_EnergyQuotaState), nullptr, nullptr, nullptr },
        { "execution_state", reinterpret_cast<getter>(AppResourceGroupStateReport_get_ExecutionState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppResourceGroupStateReport[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppResourceGroupStateReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppResourceGroupStateReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppResourceGroupStateReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppResourceGroupStateReport) },
        { },
    };

    static PyType_Spec type_spec_AppResourceGroupStateReport =
    {
        "_winrt_Windows_System.AppResourceGroupStateReport",
        sizeof(py::wrapper::Windows::System::AppResourceGroupStateReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppResourceGroupStateReport
    };

    // ----- AppUriHandlerHost class --------------------
    static constexpr const char* const type_name_AppUriHandlerHost = "AppUriHandlerHost";

    static PyObject* _new_AppUriHandlerHost(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::System::AppUriHandlerHost instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::System::AppUriHandlerHost instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppUriHandlerHost(py::wrapper::Windows::System::AppUriHandlerHost* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppUriHandlerHost_get_Name(py::wrapper::Windows::System::AppUriHandlerHost* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppUriHandlerHost", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppUriHandlerHost_put_Name(py::wrapper::Windows::System::AppUriHandlerHost* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppUriHandlerHost", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppUriHandlerHost_get_IsEnabled(py::wrapper::Windows::System::AppUriHandlerHost* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppUriHandlerHost", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppUriHandlerHost_put_IsEnabled(py::wrapper::Windows::System::AppUriHandlerHost* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppUriHandlerHost", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AppUriHandlerHost(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppUriHandlerHost>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppUriHandlerHost(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppUriHandlerHost>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppUriHandlerHost[] = {
        { "_assign_array_", _assign_array_AppUriHandlerHost, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppUriHandlerHost), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppUriHandlerHost[] = {
        { "name", reinterpret_cast<getter>(AppUriHandlerHost_get_Name), reinterpret_cast<setter>(AppUriHandlerHost_put_Name), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(AppUriHandlerHost_get_IsEnabled), reinterpret_cast<setter>(AppUriHandlerHost_put_IsEnabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppUriHandlerHost[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppUriHandlerHost) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppUriHandlerHost) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppUriHandlerHost) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppUriHandlerHost) },
        { },
    };

    static PyType_Spec type_spec_AppUriHandlerHost =
    {
        "_winrt_Windows_System.AppUriHandlerHost",
        sizeof(py::wrapper::Windows::System::AppUriHandlerHost),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppUriHandlerHost
    };

    // ----- AppUriHandlerRegistration class --------------------
    static constexpr const char* const type_name_AppUriHandlerRegistration = "AppUriHandlerRegistration";

    static PyObject* _new_AppUriHandlerRegistration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppUriHandlerRegistration);
        return nullptr;
    }

    static void _dealloc_AppUriHandlerRegistration(py::wrapper::Windows::System::AppUriHandlerRegistration* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppUriHandlerRegistration_GetAllHosts(py::wrapper::Windows::System::AppUriHandlerRegistration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppUriHandlerRegistration", L"GetAllHosts", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAllHosts());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistration_GetAppAddedHostsAsync(py::wrapper::Windows::System::AppUriHandlerRegistration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppUriHandlerRegistration", L"GetAppAddedHostsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAppAddedHostsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistration_SetAppAddedHostsAsync(py::wrapper::Windows::System::AppUriHandlerRegistration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppUriHandlerRegistration", L"SetAppAddedHostsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::System::AppUriHandlerHost>>(args, 0);

                return py::convert(self->obj.SetAppAddedHostsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistration_UpdateHosts(py::wrapper::Windows::System::AppUriHandlerRegistration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppUriHandlerRegistration", L"UpdateHosts", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::System::AppUriHandlerHost>>(args, 0);

                self->obj.UpdateHosts(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistration_get_Name(py::wrapper::Windows::System::AppUriHandlerRegistration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppUriHandlerRegistration", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistration_get_User(py::wrapper::Windows::System::AppUriHandlerRegistration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppUriHandlerRegistration", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistration_get_PackageFamilyName(py::wrapper::Windows::System::AppUriHandlerRegistration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppUriHandlerRegistration", L"PackageFamilyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppUriHandlerRegistration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppUriHandlerRegistration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppUriHandlerRegistration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppUriHandlerRegistration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppUriHandlerRegistration[] = {
        { "get_all_hosts", reinterpret_cast<PyCFunction>(AppUriHandlerRegistration_GetAllHosts), METH_VARARGS, nullptr },
        { "get_app_added_hosts_async", reinterpret_cast<PyCFunction>(AppUriHandlerRegistration_GetAppAddedHostsAsync), METH_VARARGS, nullptr },
        { "set_app_added_hosts_async", reinterpret_cast<PyCFunction>(AppUriHandlerRegistration_SetAppAddedHostsAsync), METH_VARARGS, nullptr },
        { "update_hosts", reinterpret_cast<PyCFunction>(AppUriHandlerRegistration_UpdateHosts), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppUriHandlerRegistration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppUriHandlerRegistration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppUriHandlerRegistration[] = {
        { "name", reinterpret_cast<getter>(AppUriHandlerRegistration_get_Name), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(AppUriHandlerRegistration_get_User), nullptr, nullptr, nullptr },
        { "package_family_name", reinterpret_cast<getter>(AppUriHandlerRegistration_get_PackageFamilyName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppUriHandlerRegistration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppUriHandlerRegistration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppUriHandlerRegistration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppUriHandlerRegistration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppUriHandlerRegistration) },
        { },
    };

    static PyType_Spec type_spec_AppUriHandlerRegistration =
    {
        "_winrt_Windows_System.AppUriHandlerRegistration",
        sizeof(py::wrapper::Windows::System::AppUriHandlerRegistration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppUriHandlerRegistration
    };

    // ----- AppUriHandlerRegistrationManager class --------------------
    static constexpr const char* const type_name_AppUriHandlerRegistrationManager = "AppUriHandlerRegistrationManager";

    static PyObject* _new_AppUriHandlerRegistrationManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppUriHandlerRegistrationManager);
        return nullptr;
    }

    static void _dealloc_AppUriHandlerRegistrationManager(py::wrapper::Windows::System::AppUriHandlerRegistrationManager* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppUriHandlerRegistrationManager_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppUriHandlerRegistrationManager", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::System::AppUriHandlerRegistrationManager::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistrationManager_GetForPackage(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppUriHandlerRegistrationManager", L"GetForPackage", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::System::AppUriHandlerRegistrationManager::GetForPackage(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistrationManager_GetForPackageForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppUriHandlerRegistrationManager", L"GetForPackageForUser", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::User>(args, 1);

                return py::convert(winrt::Windows::System::AppUriHandlerRegistrationManager::GetForPackageForUser(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistrationManager_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppUriHandlerRegistrationManager", L"GetForUser", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::System::AppUriHandlerRegistrationManager::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistrationManager_TryGetRegistration(py::wrapper::Windows::System::AppUriHandlerRegistrationManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.AppUriHandlerRegistrationManager", L"TryGetRegistration", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryGetRegistration(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistrationManager_get_User(py::wrapper::Windows::System::AppUriHandlerRegistrationManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppUriHandlerRegistrationManager", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistrationManager_get_PackageFamilyName(py::wrapper::Windows::System::AppUriHandlerRegistrationManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.AppUriHandlerRegistrationManager", L"PackageFamilyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppUriHandlerRegistrationManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::AppUriHandlerRegistrationManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppUriHandlerRegistrationManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppUriHandlerRegistrationManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppUriHandlerRegistrationManager[] = {
        { "get_default", reinterpret_cast<PyCFunction>(AppUriHandlerRegistrationManager_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_package", reinterpret_cast<PyCFunction>(AppUriHandlerRegistrationManager_GetForPackage), METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_package_for_user", reinterpret_cast<PyCFunction>(AppUriHandlerRegistrationManager_GetForPackageForUser), METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_user", reinterpret_cast<PyCFunction>(AppUriHandlerRegistrationManager_GetForUser), METH_VARARGS | METH_STATIC, nullptr },
        { "try_get_registration", reinterpret_cast<PyCFunction>(AppUriHandlerRegistrationManager_TryGetRegistration), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppUriHandlerRegistrationManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppUriHandlerRegistrationManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppUriHandlerRegistrationManager[] = {
        { "user", reinterpret_cast<getter>(AppUriHandlerRegistrationManager_get_User), nullptr, nullptr, nullptr },
        { "package_family_name", reinterpret_cast<getter>(AppUriHandlerRegistrationManager_get_PackageFamilyName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppUriHandlerRegistrationManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppUriHandlerRegistrationManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppUriHandlerRegistrationManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppUriHandlerRegistrationManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppUriHandlerRegistrationManager) },
        { },
    };

    static PyType_Spec type_spec_AppUriHandlerRegistrationManager =
    {
        "_winrt_Windows_System.AppUriHandlerRegistrationManager",
        sizeof(py::wrapper::Windows::System::AppUriHandlerRegistrationManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppUriHandlerRegistrationManager
    };

    // ----- DateTimeSettings class --------------------
    static constexpr const char* const type_name_DateTimeSettings = "DateTimeSettings";

    static PyObject* _new_DateTimeSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DateTimeSettings);
        return nullptr;
    }

    static PyObject* DateTimeSettings_SetSystemDateTime(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.DateTimeSettings", L"SetSystemDateTime", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

                winrt::Windows::System::DateTimeSettings::SetSystemDateTime(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_DateTimeSettings[] = {
        { "set_system_date_time", reinterpret_cast<PyCFunction>(DateTimeSettings_SetSystemDateTime), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DateTimeSettings[] = {
        { }
    };

    static PyType_Slot _type_slots_DateTimeSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DateTimeSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DateTimeSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DateTimeSettings) },
        { },
    };

    static PyType_Spec type_spec_DateTimeSettings =
    {
        "_winrt_Windows_System.DateTimeSettings",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DateTimeSettings
    };

    // ----- DispatcherQueue class --------------------
    static constexpr const char* const type_name_DispatcherQueue = "DispatcherQueue";

    static PyObject* _new_DispatcherQueue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DispatcherQueue);
        return nullptr;
    }

    static void _dealloc_DispatcherQueue(py::wrapper::Windows::System::DispatcherQueue* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DispatcherQueue_CreateTimer(py::wrapper::Windows::System::DispatcherQueue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.DispatcherQueue", L"CreateTimer", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateTimer());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DispatcherQueue_GetForCurrentThread(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.DispatcherQueue", L"GetForCurrentThread", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::System::DispatcherQueue::GetForCurrentThread());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DispatcherQueue_TryEnqueue(py::wrapper::Windows::System::DispatcherQueue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.DispatcherQueue", L"TryEnqueue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::DispatcherQueueHandler>(args, 0);

                return py::convert(self->obj.TryEnqueue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.DispatcherQueue", L"TryEnqueue", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::DispatcherQueuePriority>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::DispatcherQueueHandler>(args, 1);

                return py::convert(self->obj.TryEnqueue(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DispatcherQueue_get_HasThreadAccess(py::wrapper::Windows::System::DispatcherQueue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.DispatcherQueue", L"HasThreadAccess"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasThreadAccess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DispatcherQueue_add_ShutdownCompleted(py::wrapper::Windows::System::DispatcherQueue* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.DispatcherQueue", L"ShutdownCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::DispatcherQueue, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ShutdownCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DispatcherQueue_remove_ShutdownCompleted(py::wrapper::Windows::System::DispatcherQueue* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.DispatcherQueue", L"ShutdownCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ShutdownCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DispatcherQueue_add_ShutdownStarting(py::wrapper::Windows::System::DispatcherQueue* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.DispatcherQueue", L"ShutdownStarting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::DispatcherQueue, winrt::Windows::System::DispatcherQueueShutdownStartingEventArgs>>(arg);

            return py::convert(self->obj.ShutdownStarting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DispatcherQueue_remove_ShutdownStarting(py::wrapper::Windows::System::DispatcherQueue* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.DispatcherQueue", L"ShutdownStarting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ShutdownStarting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DispatcherQueue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::DispatcherQueue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DispatcherQueue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::DispatcherQueue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DispatcherQueue[] = {
        { "create_timer", reinterpret_cast<PyCFunction>(DispatcherQueue_CreateTimer), METH_VARARGS, nullptr },
        { "get_for_current_thread", reinterpret_cast<PyCFunction>(DispatcherQueue_GetForCurrentThread), METH_VARARGS | METH_STATIC, nullptr },
        { "try_enqueue", reinterpret_cast<PyCFunction>(DispatcherQueue_TryEnqueue), METH_VARARGS, nullptr },
        { "add_shutdown_completed", reinterpret_cast<PyCFunction>(DispatcherQueue_add_ShutdownCompleted), METH_O, nullptr },
        { "remove_shutdown_completed", reinterpret_cast<PyCFunction>(DispatcherQueue_remove_ShutdownCompleted), METH_O, nullptr },
        { "add_shutdown_starting", reinterpret_cast<PyCFunction>(DispatcherQueue_add_ShutdownStarting), METH_O, nullptr },
        { "remove_shutdown_starting", reinterpret_cast<PyCFunction>(DispatcherQueue_remove_ShutdownStarting), METH_O, nullptr },
        { "_assign_array_", _assign_array_DispatcherQueue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DispatcherQueue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DispatcherQueue[] = {
        { "has_thread_access", reinterpret_cast<getter>(DispatcherQueue_get_HasThreadAccess), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DispatcherQueue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DispatcherQueue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DispatcherQueue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DispatcherQueue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DispatcherQueue) },
        { },
    };

    static PyType_Spec type_spec_DispatcherQueue =
    {
        "_winrt_Windows_System.DispatcherQueue",
        sizeof(py::wrapper::Windows::System::DispatcherQueue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DispatcherQueue
    };

    // ----- DispatcherQueueController class --------------------
    static constexpr const char* const type_name_DispatcherQueueController = "DispatcherQueueController";

    static PyObject* _new_DispatcherQueueController(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DispatcherQueueController);
        return nullptr;
    }

    static void _dealloc_DispatcherQueueController(py::wrapper::Windows::System::DispatcherQueueController* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DispatcherQueueController_CreateOnDedicatedThread(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.DispatcherQueueController", L"CreateOnDedicatedThread", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::System::DispatcherQueueController::CreateOnDedicatedThread());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DispatcherQueueController_ShutdownQueueAsync(py::wrapper::Windows::System::DispatcherQueueController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.DispatcherQueueController", L"ShutdownQueueAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ShutdownQueueAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DispatcherQueueController_get_DispatcherQueue(py::wrapper::Windows::System::DispatcherQueueController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.DispatcherQueueController", L"DispatcherQueue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DispatcherQueue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DispatcherQueueController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::DispatcherQueueController>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DispatcherQueueController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::DispatcherQueueController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DispatcherQueueController[] = {
        { "create_on_dedicated_thread", reinterpret_cast<PyCFunction>(DispatcherQueueController_CreateOnDedicatedThread), METH_VARARGS | METH_STATIC, nullptr },
        { "shutdown_queue_async", reinterpret_cast<PyCFunction>(DispatcherQueueController_ShutdownQueueAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DispatcherQueueController, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DispatcherQueueController), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DispatcherQueueController[] = {
        { "dispatcher_queue", reinterpret_cast<getter>(DispatcherQueueController_get_DispatcherQueue), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DispatcherQueueController[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DispatcherQueueController) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DispatcherQueueController) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DispatcherQueueController) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DispatcherQueueController) },
        { },
    };

    static PyType_Spec type_spec_DispatcherQueueController =
    {
        "_winrt_Windows_System.DispatcherQueueController",
        sizeof(py::wrapper::Windows::System::DispatcherQueueController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DispatcherQueueController
    };

    // ----- DispatcherQueueShutdownStartingEventArgs class --------------------
    static constexpr const char* const type_name_DispatcherQueueShutdownStartingEventArgs = "DispatcherQueueShutdownStartingEventArgs";

    static PyObject* _new_DispatcherQueueShutdownStartingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DispatcherQueueShutdownStartingEventArgs);
        return nullptr;
    }

    static void _dealloc_DispatcherQueueShutdownStartingEventArgs(py::wrapper::Windows::System::DispatcherQueueShutdownStartingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DispatcherQueueShutdownStartingEventArgs_GetDeferral(py::wrapper::Windows::System::DispatcherQueueShutdownStartingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.DispatcherQueueShutdownStartingEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_DispatcherQueueShutdownStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::DispatcherQueueShutdownStartingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DispatcherQueueShutdownStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::DispatcherQueueShutdownStartingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DispatcherQueueShutdownStartingEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(DispatcherQueueShutdownStartingEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DispatcherQueueShutdownStartingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DispatcherQueueShutdownStartingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DispatcherQueueShutdownStartingEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_DispatcherQueueShutdownStartingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DispatcherQueueShutdownStartingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DispatcherQueueShutdownStartingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DispatcherQueueShutdownStartingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DispatcherQueueShutdownStartingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DispatcherQueueShutdownStartingEventArgs =
    {
        "_winrt_Windows_System.DispatcherQueueShutdownStartingEventArgs",
        sizeof(py::wrapper::Windows::System::DispatcherQueueShutdownStartingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DispatcherQueueShutdownStartingEventArgs
    };

    // ----- DispatcherQueueTimer class --------------------
    static constexpr const char* const type_name_DispatcherQueueTimer = "DispatcherQueueTimer";

    static PyObject* _new_DispatcherQueueTimer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DispatcherQueueTimer);
        return nullptr;
    }

    static void _dealloc_DispatcherQueueTimer(py::wrapper::Windows::System::DispatcherQueueTimer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DispatcherQueueTimer_Start(py::wrapper::Windows::System::DispatcherQueueTimer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.DispatcherQueueTimer", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DispatcherQueueTimer_Stop(py::wrapper::Windows::System::DispatcherQueueTimer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.DispatcherQueueTimer", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DispatcherQueueTimer_get_IsRepeating(py::wrapper::Windows::System::DispatcherQueueTimer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.DispatcherQueueTimer", L"IsRepeating"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsRepeating());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DispatcherQueueTimer_put_IsRepeating(py::wrapper::Windows::System::DispatcherQueueTimer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.DispatcherQueueTimer", L"IsRepeating"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsRepeating(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DispatcherQueueTimer_get_Interval(py::wrapper::Windows::System::DispatcherQueueTimer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.DispatcherQueueTimer", L"Interval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Interval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DispatcherQueueTimer_put_Interval(py::wrapper::Windows::System::DispatcherQueueTimer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.DispatcherQueueTimer", L"Interval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Interval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DispatcherQueueTimer_get_IsRunning(py::wrapper::Windows::System::DispatcherQueueTimer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.DispatcherQueueTimer", L"IsRunning"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsRunning());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DispatcherQueueTimer_add_Tick(py::wrapper::Windows::System::DispatcherQueueTimer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.DispatcherQueueTimer", L"Tick"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::DispatcherQueueTimer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Tick(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DispatcherQueueTimer_remove_Tick(py::wrapper::Windows::System::DispatcherQueueTimer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.DispatcherQueueTimer", L"Tick"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Tick(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DispatcherQueueTimer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::DispatcherQueueTimer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DispatcherQueueTimer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::DispatcherQueueTimer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DispatcherQueueTimer[] = {
        { "start", reinterpret_cast<PyCFunction>(DispatcherQueueTimer_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(DispatcherQueueTimer_Stop), METH_VARARGS, nullptr },
        { "add_tick", reinterpret_cast<PyCFunction>(DispatcherQueueTimer_add_Tick), METH_O, nullptr },
        { "remove_tick", reinterpret_cast<PyCFunction>(DispatcherQueueTimer_remove_Tick), METH_O, nullptr },
        { "_assign_array_", _assign_array_DispatcherQueueTimer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DispatcherQueueTimer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DispatcherQueueTimer[] = {
        { "is_repeating", reinterpret_cast<getter>(DispatcherQueueTimer_get_IsRepeating), reinterpret_cast<setter>(DispatcherQueueTimer_put_IsRepeating), nullptr, nullptr },
        { "interval", reinterpret_cast<getter>(DispatcherQueueTimer_get_Interval), reinterpret_cast<setter>(DispatcherQueueTimer_put_Interval), nullptr, nullptr },
        { "is_running", reinterpret_cast<getter>(DispatcherQueueTimer_get_IsRunning), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DispatcherQueueTimer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DispatcherQueueTimer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DispatcherQueueTimer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DispatcherQueueTimer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DispatcherQueueTimer) },
        { },
    };

    static PyType_Spec type_spec_DispatcherQueueTimer =
    {
        "_winrt_Windows_System.DispatcherQueueTimer",
        sizeof(py::wrapper::Windows::System::DispatcherQueueTimer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DispatcherQueueTimer
    };

    // ----- FolderLauncherOptions class --------------------
    static constexpr const char* const type_name_FolderLauncherOptions = "FolderLauncherOptions";

    static PyObject* _new_FolderLauncherOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::System::FolderLauncherOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FolderLauncherOptions(py::wrapper::Windows::System::FolderLauncherOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FolderLauncherOptions_get_ItemsToSelect(py::wrapper::Windows::System::FolderLauncherOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.FolderLauncherOptions", L"ItemsToSelect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ItemsToSelect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FolderLauncherOptions_get_DesiredRemainingView(py::wrapper::Windows::System::FolderLauncherOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.FolderLauncherOptions", L"DesiredRemainingView"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredRemainingView());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FolderLauncherOptions_put_DesiredRemainingView(py::wrapper::Windows::System::FolderLauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.FolderLauncherOptions", L"DesiredRemainingView"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::ViewSizePreference>(arg);

            self->obj.DesiredRemainingView(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_FolderLauncherOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::FolderLauncherOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FolderLauncherOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::FolderLauncherOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FolderLauncherOptions[] = {
        { "_assign_array_", _assign_array_FolderLauncherOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FolderLauncherOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FolderLauncherOptions[] = {
        { "items_to_select", reinterpret_cast<getter>(FolderLauncherOptions_get_ItemsToSelect), nullptr, nullptr, nullptr },
        { "desired_remaining_view", reinterpret_cast<getter>(FolderLauncherOptions_get_DesiredRemainingView), reinterpret_cast<setter>(FolderLauncherOptions_put_DesiredRemainingView), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FolderLauncherOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FolderLauncherOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FolderLauncherOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FolderLauncherOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FolderLauncherOptions) },
        { },
    };

    static PyType_Spec type_spec_FolderLauncherOptions =
    {
        "_winrt_Windows_System.FolderLauncherOptions",
        sizeof(py::wrapper::Windows::System::FolderLauncherOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FolderLauncherOptions
    };

    // ----- KnownUserProperties class --------------------
    static constexpr const char* const type_name_KnownUserProperties = "KnownUserProperties";

    static PyObject* _new_KnownUserProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KnownUserProperties);
        return nullptr;
    }

    static PyObject* KnownUserProperties_get_AccountName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.KnownUserProperties", L"AccountName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::KnownUserProperties::AccountName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUserProperties_get_DisplayName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.KnownUserProperties", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::KnownUserProperties::DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUserProperties_get_DomainName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.KnownUserProperties", L"DomainName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::KnownUserProperties::DomainName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUserProperties_get_FirstName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.KnownUserProperties", L"FirstName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::KnownUserProperties::FirstName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUserProperties_get_GuestHost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.KnownUserProperties", L"GuestHost"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::KnownUserProperties::GuestHost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUserProperties_get_LastName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.KnownUserProperties", L"LastName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::KnownUserProperties::LastName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUserProperties_get_PrincipalName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.KnownUserProperties", L"PrincipalName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::KnownUserProperties::PrincipalName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUserProperties_get_ProviderName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.KnownUserProperties", L"ProviderName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::KnownUserProperties::ProviderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUserProperties_get_SessionInitiationProtocolUri(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.KnownUserProperties", L"SessionInitiationProtocolUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::KnownUserProperties::SessionInitiationProtocolUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUserProperties_get_AgeEnforcementRegion(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.KnownUserProperties", L"AgeEnforcementRegion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::KnownUserProperties::AgeEnforcementRegion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownUserProperties[] = {
        { }
    };

    static PyGetSetDef _getset_KnownUserProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownUserProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownUserProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownUserProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownUserProperties) },
        { },
    };

    static PyType_Spec type_spec_KnownUserProperties =
    {
        "_winrt_Windows_System.KnownUserProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownUserProperties
    };

    static PyGetSetDef getset_KnownUserProperties_Meta[] = {
        { "account_name", reinterpret_cast<getter>(KnownUserProperties_get_AccountName), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(KnownUserProperties_get_DisplayName), nullptr, nullptr, nullptr },
        { "domain_name", reinterpret_cast<getter>(KnownUserProperties_get_DomainName), nullptr, nullptr, nullptr },
        { "first_name", reinterpret_cast<getter>(KnownUserProperties_get_FirstName), nullptr, nullptr, nullptr },
        { "guest_host", reinterpret_cast<getter>(KnownUserProperties_get_GuestHost), nullptr, nullptr, nullptr },
        { "last_name", reinterpret_cast<getter>(KnownUserProperties_get_LastName), nullptr, nullptr, nullptr },
        { "principal_name", reinterpret_cast<getter>(KnownUserProperties_get_PrincipalName), nullptr, nullptr, nullptr },
        { "provider_name", reinterpret_cast<getter>(KnownUserProperties_get_ProviderName), nullptr, nullptr, nullptr },
        { "session_initiation_protocol_uri", reinterpret_cast<getter>(KnownUserProperties_get_SessionInitiationProtocolUri), nullptr, nullptr, nullptr },
        { "age_enforcement_region", reinterpret_cast<getter>(KnownUserProperties_get_AgeEnforcementRegion), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_KnownUserProperties_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownUserProperties_Meta) },
        { }
    };

    static PyType_Spec type_spec_KnownUserProperties_Meta =
    {
        "_winrt_Windows_System.KnownUserProperties_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownUserProperties_Meta
    };

    // ----- LaunchUriResult class --------------------
    static constexpr const char* const type_name_LaunchUriResult = "LaunchUriResult";

    static PyObject* _new_LaunchUriResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LaunchUriResult);
        return nullptr;
    }

    static void _dealloc_LaunchUriResult(py::wrapper::Windows::System::LaunchUriResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LaunchUriResult_get_Result(py::wrapper::Windows::System::LaunchUriResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LaunchUriResult", L"Result"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Result());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LaunchUriResult_get_Status(py::wrapper::Windows::System::LaunchUriResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LaunchUriResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LaunchUriResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::LaunchUriResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LaunchUriResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::LaunchUriResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LaunchUriResult[] = {
        { "_assign_array_", _assign_array_LaunchUriResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LaunchUriResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LaunchUriResult[] = {
        { "result", reinterpret_cast<getter>(LaunchUriResult_get_Result), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(LaunchUriResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LaunchUriResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LaunchUriResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LaunchUriResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LaunchUriResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LaunchUriResult) },
        { },
    };

    static PyType_Spec type_spec_LaunchUriResult =
    {
        "_winrt_Windows_System.LaunchUriResult",
        sizeof(py::wrapper::Windows::System::LaunchUriResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LaunchUriResult
    };

    // ----- Launcher class --------------------
    static constexpr const char* const type_name_Launcher = "Launcher";

    static PyObject* _new_Launcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_Launcher);
        return nullptr;
    }

    static PyObject* Launcher_FindAppUriHandlersAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"FindAppUriHandlersAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(winrt::Windows::System::Launcher::FindAppUriHandlersAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_FindFileHandlersAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"FindFileHandlersAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::System::Launcher::FindFileHandlersAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_FindUriSchemeHandlersAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"FindUriSchemeHandlersAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::System::Launcher::FindUriSchemeHandlersAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"FindUriSchemeHandlersAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::LaunchQuerySupportType>(args, 1);

                return py::convert(winrt::Windows::System::Launcher::FindUriSchemeHandlersAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_LaunchFileAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchFileAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(winrt::Windows::System::Launcher::LaunchFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchFileAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::LauncherOptions>(args, 1);

                return py::convert(winrt::Windows::System::Launcher::LaunchFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_LaunchFolderAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchFolderAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);

                return py::convert(winrt::Windows::System::Launcher::LaunchFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchFolderAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::FolderLauncherOptions>(args, 1);

                return py::convert(winrt::Windows::System::Launcher::LaunchFolderAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_LaunchFolderPathAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchFolderPathAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::System::Launcher::LaunchFolderPathAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchFolderPathAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::FolderLauncherOptions>(args, 1);

                return py::convert(winrt::Windows::System::Launcher::LaunchFolderPathAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_LaunchFolderPathForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchFolderPathForUserAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::System::Launcher::LaunchFolderPathForUserAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchFolderPathForUserAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::System::FolderLauncherOptions>(args, 2);

                return py::convert(winrt::Windows::System::Launcher::LaunchFolderPathForUserAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_LaunchUriAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchUriAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(winrt::Windows::System::Launcher::LaunchUriAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchUriAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::LauncherOptions>(args, 1);

                return py::convert(winrt::Windows::System::Launcher::LaunchUriAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchUriAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::LauncherOptions>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 2);

                return py::convert(winrt::Windows::System::Launcher::LaunchUriAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_LaunchUriForResultsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchUriForResultsAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::LauncherOptions>(args, 1);

                return py::convert(winrt::Windows::System::Launcher::LaunchUriForResultsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchUriForResultsAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::LauncherOptions>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 2);

                return py::convert(winrt::Windows::System::Launcher::LaunchUriForResultsAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_LaunchUriForResultsForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchUriForResultsForUserAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::System::LauncherOptions>(args, 2);

                return py::convert(winrt::Windows::System::Launcher::LaunchUriForResultsForUserAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchUriForResultsForUserAsync", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::System::LauncherOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 3);

                return py::convert(winrt::Windows::System::Launcher::LaunchUriForResultsForUserAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_LaunchUriForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchUriForUserAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);

                return py::convert(winrt::Windows::System::Launcher::LaunchUriForUserAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchUriForUserAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::System::LauncherOptions>(args, 2);

                return py::convert(winrt::Windows::System::Launcher::LaunchUriForUserAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"LaunchUriForUserAsync", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::System::LauncherOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 3);

                return py::convert(winrt::Windows::System::Launcher::LaunchUriForUserAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_QueryAppUriSupportAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"QueryAppUriSupportAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(winrt::Windows::System::Launcher::QueryAppUriSupportAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"QueryAppUriSupportAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::System::Launcher::QueryAppUriSupportAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_QueryFileSupportAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"QueryFileSupportAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);

                return py::convert(winrt::Windows::System::Launcher::QueryFileSupportAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"QueryFileSupportAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::System::Launcher::QueryFileSupportAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_QueryUriSupportAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"QueryUriSupportAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::LaunchQuerySupportType>(args, 1);

                return py::convert(winrt::Windows::System::Launcher::QueryUriSupportAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Launcher", L"QueryUriSupportAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::LaunchQuerySupportType>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(winrt::Windows::System::Launcher::QueryUriSupportAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_Launcher[] = {
        { "find_app_uri_handlers_async", reinterpret_cast<PyCFunction>(Launcher_FindAppUriHandlersAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "find_file_handlers_async", reinterpret_cast<PyCFunction>(Launcher_FindFileHandlersAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "find_uri_scheme_handlers_async", reinterpret_cast<PyCFunction>(Launcher_FindUriSchemeHandlersAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "launch_file_async", reinterpret_cast<PyCFunction>(Launcher_LaunchFileAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "launch_folder_async", reinterpret_cast<PyCFunction>(Launcher_LaunchFolderAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "launch_folder_path_async", reinterpret_cast<PyCFunction>(Launcher_LaunchFolderPathAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "launch_folder_path_for_user_async", reinterpret_cast<PyCFunction>(Launcher_LaunchFolderPathForUserAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "launch_uri_async", reinterpret_cast<PyCFunction>(Launcher_LaunchUriAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "launch_uri_for_results_async", reinterpret_cast<PyCFunction>(Launcher_LaunchUriForResultsAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "launch_uri_for_results_for_user_async", reinterpret_cast<PyCFunction>(Launcher_LaunchUriForResultsForUserAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "launch_uri_for_user_async", reinterpret_cast<PyCFunction>(Launcher_LaunchUriForUserAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "query_app_uri_support_async", reinterpret_cast<PyCFunction>(Launcher_QueryAppUriSupportAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "query_file_support_async", reinterpret_cast<PyCFunction>(Launcher_QueryFileSupportAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "query_uri_support_async", reinterpret_cast<PyCFunction>(Launcher_QueryUriSupportAsync), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Launcher[] = {
        { }
    };

    static PyType_Slot _type_slots_Launcher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Launcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Launcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Launcher) },
        { },
    };

    static PyType_Spec type_spec_Launcher =
    {
        "_winrt_Windows_System.Launcher",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Launcher
    };

    // ----- LauncherOptions class --------------------
    static constexpr const char* const type_name_LauncherOptions = "LauncherOptions";

    static PyObject* _new_LauncherOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::System::LauncherOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LauncherOptions(py::wrapper::Windows::System::LauncherOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LauncherOptions_get_TreatAsUntrusted(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"TreatAsUntrusted"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TreatAsUntrusted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherOptions_put_TreatAsUntrusted(py::wrapper::Windows::System::LauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"TreatAsUntrusted"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.TreatAsUntrusted(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherOptions_get_PreferredApplicationPackageFamilyName(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"PreferredApplicationPackageFamilyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreferredApplicationPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherOptions_put_PreferredApplicationPackageFamilyName(py::wrapper::Windows::System::LauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"PreferredApplicationPackageFamilyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PreferredApplicationPackageFamilyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherOptions_get_PreferredApplicationDisplayName(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"PreferredApplicationDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreferredApplicationDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherOptions_put_PreferredApplicationDisplayName(py::wrapper::Windows::System::LauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"PreferredApplicationDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PreferredApplicationDisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherOptions_get_FallbackUri(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"FallbackUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FallbackUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherOptions_put_FallbackUri(py::wrapper::Windows::System::LauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"FallbackUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.FallbackUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherOptions_get_DisplayApplicationPicker(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"DisplayApplicationPicker"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayApplicationPicker());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherOptions_put_DisplayApplicationPicker(py::wrapper::Windows::System::LauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"DisplayApplicationPicker"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DisplayApplicationPicker(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherOptions_get_ContentType(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"ContentType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherOptions_put_ContentType(py::wrapper::Windows::System::LauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"ContentType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContentType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherOptions_get_UI(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"UI"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LauncherOptions_get_TargetApplicationPackageFamilyName(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"TargetApplicationPackageFamilyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TargetApplicationPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherOptions_put_TargetApplicationPackageFamilyName(py::wrapper::Windows::System::LauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"TargetApplicationPackageFamilyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TargetApplicationPackageFamilyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherOptions_get_NeighboringFilesQuery(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"NeighboringFilesQuery"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NeighboringFilesQuery());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherOptions_put_NeighboringFilesQuery(py::wrapper::Windows::System::LauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"NeighboringFilesQuery"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::StorageFileQueryResult>(arg);

            self->obj.NeighboringFilesQuery(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherOptions_get_IgnoreAppUriHandlers(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"IgnoreAppUriHandlers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IgnoreAppUriHandlers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherOptions_put_IgnoreAppUriHandlers(py::wrapper::Windows::System::LauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"IgnoreAppUriHandlers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IgnoreAppUriHandlers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherOptions_get_LimitPickerToCurrentAppAndAppUriHandlers(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"LimitPickerToCurrentAppAndAppUriHandlers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LimitPickerToCurrentAppAndAppUriHandlers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherOptions_put_LimitPickerToCurrentAppAndAppUriHandlers(py::wrapper::Windows::System::LauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"LimitPickerToCurrentAppAndAppUriHandlers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.LimitPickerToCurrentAppAndAppUriHandlers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherOptions_get_DesiredRemainingView(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"DesiredRemainingView"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredRemainingView());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherOptions_put_DesiredRemainingView(py::wrapper::Windows::System::LauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherOptions", L"DesiredRemainingView"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::ViewSizePreference>(arg);

            self->obj.DesiredRemainingView(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_LauncherOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::LauncherOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LauncherOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::LauncherOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LauncherOptions[] = {
        { "_assign_array_", _assign_array_LauncherOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LauncherOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LauncherOptions[] = {
        { "treat_as_untrusted", reinterpret_cast<getter>(LauncherOptions_get_TreatAsUntrusted), reinterpret_cast<setter>(LauncherOptions_put_TreatAsUntrusted), nullptr, nullptr },
        { "preferred_application_package_family_name", reinterpret_cast<getter>(LauncherOptions_get_PreferredApplicationPackageFamilyName), reinterpret_cast<setter>(LauncherOptions_put_PreferredApplicationPackageFamilyName), nullptr, nullptr },
        { "preferred_application_display_name", reinterpret_cast<getter>(LauncherOptions_get_PreferredApplicationDisplayName), reinterpret_cast<setter>(LauncherOptions_put_PreferredApplicationDisplayName), nullptr, nullptr },
        { "fallback_uri", reinterpret_cast<getter>(LauncherOptions_get_FallbackUri), reinterpret_cast<setter>(LauncherOptions_put_FallbackUri), nullptr, nullptr },
        { "display_application_picker", reinterpret_cast<getter>(LauncherOptions_get_DisplayApplicationPicker), reinterpret_cast<setter>(LauncherOptions_put_DisplayApplicationPicker), nullptr, nullptr },
        { "content_type", reinterpret_cast<getter>(LauncherOptions_get_ContentType), reinterpret_cast<setter>(LauncherOptions_put_ContentType), nullptr, nullptr },
        { "u_i", reinterpret_cast<getter>(LauncherOptions_get_UI), nullptr, nullptr, nullptr },
        { "target_application_package_family_name", reinterpret_cast<getter>(LauncherOptions_get_TargetApplicationPackageFamilyName), reinterpret_cast<setter>(LauncherOptions_put_TargetApplicationPackageFamilyName), nullptr, nullptr },
        { "neighboring_files_query", reinterpret_cast<getter>(LauncherOptions_get_NeighboringFilesQuery), reinterpret_cast<setter>(LauncherOptions_put_NeighboringFilesQuery), nullptr, nullptr },
        { "ignore_app_uri_handlers", reinterpret_cast<getter>(LauncherOptions_get_IgnoreAppUriHandlers), reinterpret_cast<setter>(LauncherOptions_put_IgnoreAppUriHandlers), nullptr, nullptr },
        { "limit_picker_to_current_app_and_app_uri_handlers", reinterpret_cast<getter>(LauncherOptions_get_LimitPickerToCurrentAppAndAppUriHandlers), reinterpret_cast<setter>(LauncherOptions_put_LimitPickerToCurrentAppAndAppUriHandlers), nullptr, nullptr },
        { "desired_remaining_view", reinterpret_cast<getter>(LauncherOptions_get_DesiredRemainingView), reinterpret_cast<setter>(LauncherOptions_put_DesiredRemainingView), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LauncherOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LauncherOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LauncherOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LauncherOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LauncherOptions) },
        { },
    };

    static PyType_Spec type_spec_LauncherOptions =
    {
        "_winrt_Windows_System.LauncherOptions",
        sizeof(py::wrapper::Windows::System::LauncherOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LauncherOptions
    };

    // ----- LauncherUIOptions class --------------------
    static constexpr const char* const type_name_LauncherUIOptions = "LauncherUIOptions";

    static PyObject* _new_LauncherUIOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LauncherUIOptions);
        return nullptr;
    }

    static void _dealloc_LauncherUIOptions(py::wrapper::Windows::System::LauncherUIOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LauncherUIOptions_get_SelectionRect(py::wrapper::Windows::System::LauncherUIOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherUIOptions", L"SelectionRect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectionRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherUIOptions_put_SelectionRect(py::wrapper::Windows::System::LauncherUIOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherUIOptions", L"SelectionRect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Rect>>(arg);

            self->obj.SelectionRect(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherUIOptions_get_PreferredPlacement(py::wrapper::Windows::System::LauncherUIOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherUIOptions", L"PreferredPlacement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreferredPlacement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherUIOptions_put_PreferredPlacement(py::wrapper::Windows::System::LauncherUIOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherUIOptions", L"PreferredPlacement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Popups::Placement>(arg);

            self->obj.PreferredPlacement(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherUIOptions_get_InvocationPoint(py::wrapper::Windows::System::LauncherUIOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherUIOptions", L"InvocationPoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InvocationPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherUIOptions_put_InvocationPoint(py::wrapper::Windows::System::LauncherUIOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.LauncherUIOptions", L"InvocationPoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Point>>(arg);

            self->obj.InvocationPoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_LauncherUIOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::LauncherUIOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LauncherUIOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::LauncherUIOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LauncherUIOptions[] = {
        { "_assign_array_", _assign_array_LauncherUIOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LauncherUIOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LauncherUIOptions[] = {
        { "selection_rect", reinterpret_cast<getter>(LauncherUIOptions_get_SelectionRect), reinterpret_cast<setter>(LauncherUIOptions_put_SelectionRect), nullptr, nullptr },
        { "preferred_placement", reinterpret_cast<getter>(LauncherUIOptions_get_PreferredPlacement), reinterpret_cast<setter>(LauncherUIOptions_put_PreferredPlacement), nullptr, nullptr },
        { "invocation_point", reinterpret_cast<getter>(LauncherUIOptions_get_InvocationPoint), reinterpret_cast<setter>(LauncherUIOptions_put_InvocationPoint), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LauncherUIOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LauncherUIOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LauncherUIOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LauncherUIOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LauncherUIOptions) },
        { },
    };

    static PyType_Spec type_spec_LauncherUIOptions =
    {
        "_winrt_Windows_System.LauncherUIOptions",
        sizeof(py::wrapper::Windows::System::LauncherUIOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LauncherUIOptions
    };

    // ----- MemoryManager class --------------------
    static constexpr const char* const type_name_MemoryManager = "MemoryManager";

    static PyObject* _new_MemoryManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MemoryManager);
        return nullptr;
    }

    static PyObject* MemoryManager_GetAppMemoryReport(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.MemoryManager", L"GetAppMemoryReport", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::System::MemoryManager::GetAppMemoryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MemoryManager_GetProcessMemoryReport(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.MemoryManager", L"GetProcessMemoryReport", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::System::MemoryManager::GetProcessMemoryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MemoryManager_TrySetAppMemoryUsageLimit(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.MemoryManager", L"TrySetAppMemoryUsageLimit", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(winrt::Windows::System::MemoryManager::TrySetAppMemoryUsageLimit(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MemoryManager_get_AppMemoryUsage(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.MemoryManager", L"AppMemoryUsage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::MemoryManager::AppMemoryUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MemoryManager_get_AppMemoryUsageLevel(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.MemoryManager", L"AppMemoryUsageLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::MemoryManager::AppMemoryUsageLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MemoryManager_get_AppMemoryUsageLimit(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.MemoryManager", L"AppMemoryUsageLimit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::MemoryManager::AppMemoryUsageLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MemoryManager_get_ExpectedAppMemoryUsageLimit(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.MemoryManager", L"ExpectedAppMemoryUsageLimit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::MemoryManager::ExpectedAppMemoryUsageLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MemoryManager_add_AppMemoryUsageDecreased(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.MemoryManager", L"AppMemoryUsageDecreased"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::System::MemoryManager::AppMemoryUsageDecreased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MemoryManager_remove_AppMemoryUsageDecreased(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.MemoryManager", L"AppMemoryUsageDecreased"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::System::MemoryManager::AppMemoryUsageDecreased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MemoryManager_add_AppMemoryUsageIncreased(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.MemoryManager", L"AppMemoryUsageIncreased"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::System::MemoryManager::AppMemoryUsageIncreased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MemoryManager_remove_AppMemoryUsageIncreased(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.MemoryManager", L"AppMemoryUsageIncreased"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::System::MemoryManager::AppMemoryUsageIncreased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MemoryManager_add_AppMemoryUsageLimitChanging(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.MemoryManager", L"AppMemoryUsageLimitChanging"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::System::AppMemoryUsageLimitChangingEventArgs>>(arg);

            return py::convert(winrt::Windows::System::MemoryManager::AppMemoryUsageLimitChanging(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MemoryManager_remove_AppMemoryUsageLimitChanging(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.MemoryManager", L"AppMemoryUsageLimitChanging"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::System::MemoryManager::AppMemoryUsageLimitChanging(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MemoryManager[] = {
        { "get_app_memory_report", reinterpret_cast<PyCFunction>(MemoryManager_GetAppMemoryReport), METH_VARARGS | METH_STATIC, nullptr },
        { "get_process_memory_report", reinterpret_cast<PyCFunction>(MemoryManager_GetProcessMemoryReport), METH_VARARGS | METH_STATIC, nullptr },
        { "try_set_app_memory_usage_limit", reinterpret_cast<PyCFunction>(MemoryManager_TrySetAppMemoryUsageLimit), METH_VARARGS | METH_STATIC, nullptr },
        { "add_app_memory_usage_decreased", reinterpret_cast<PyCFunction>(MemoryManager_add_AppMemoryUsageDecreased), METH_O | METH_STATIC, nullptr },
        { "remove_app_memory_usage_decreased", reinterpret_cast<PyCFunction>(MemoryManager_remove_AppMemoryUsageDecreased), METH_O | METH_STATIC, nullptr },
        { "add_app_memory_usage_increased", reinterpret_cast<PyCFunction>(MemoryManager_add_AppMemoryUsageIncreased), METH_O | METH_STATIC, nullptr },
        { "remove_app_memory_usage_increased", reinterpret_cast<PyCFunction>(MemoryManager_remove_AppMemoryUsageIncreased), METH_O | METH_STATIC, nullptr },
        { "add_app_memory_usage_limit_changing", reinterpret_cast<PyCFunction>(MemoryManager_add_AppMemoryUsageLimitChanging), METH_O | METH_STATIC, nullptr },
        { "remove_app_memory_usage_limit_changing", reinterpret_cast<PyCFunction>(MemoryManager_remove_AppMemoryUsageLimitChanging), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MemoryManager[] = {
        { }
    };

    static PyType_Slot _type_slots_MemoryManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MemoryManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MemoryManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MemoryManager) },
        { },
    };

    static PyType_Spec type_spec_MemoryManager =
    {
        "_winrt_Windows_System.MemoryManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MemoryManager
    };

    static PyGetSetDef getset_MemoryManager_Meta[] = {
        { "app_memory_usage", reinterpret_cast<getter>(MemoryManager_get_AppMemoryUsage), nullptr, nullptr, nullptr },
        { "app_memory_usage_level", reinterpret_cast<getter>(MemoryManager_get_AppMemoryUsageLevel), nullptr, nullptr, nullptr },
        { "app_memory_usage_limit", reinterpret_cast<getter>(MemoryManager_get_AppMemoryUsageLimit), nullptr, nullptr, nullptr },
        { "expected_app_memory_usage_limit", reinterpret_cast<getter>(MemoryManager_get_ExpectedAppMemoryUsageLimit), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_MemoryManager_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MemoryManager_Meta) },
        { }
    };

    static PyType_Spec type_spec_MemoryManager_Meta =
    {
        "_winrt_Windows_System.MemoryManager_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MemoryManager_Meta
    };

    // ----- ProcessLauncher class --------------------
    static constexpr const char* const type_name_ProcessLauncher = "ProcessLauncher";

    static PyObject* _new_ProcessLauncher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ProcessLauncher);
        return nullptr;
    }

    static PyObject* ProcessLauncher_RunToCompletionAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.ProcessLauncher", L"RunToCompletionAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::System::ProcessLauncher::RunToCompletionAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.ProcessLauncher", L"RunToCompletionAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::System::ProcessLauncherOptions>(args, 2);

                return py::convert(winrt::Windows::System::ProcessLauncher::RunToCompletionAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessLauncher[] = {
        { "run_to_completion_async", reinterpret_cast<PyCFunction>(ProcessLauncher_RunToCompletionAsync), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessLauncher[] = {
        { }
    };

    static PyType_Slot _type_slots_ProcessLauncher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessLauncher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessLauncher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessLauncher) },
        { },
    };

    static PyType_Spec type_spec_ProcessLauncher =
    {
        "_winrt_Windows_System.ProcessLauncher",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessLauncher
    };

    // ----- ProcessLauncherOptions class --------------------
    static constexpr const char* const type_name_ProcessLauncherOptions = "ProcessLauncherOptions";

    static PyObject* _new_ProcessLauncherOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::System::ProcessLauncherOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ProcessLauncherOptions(py::wrapper::Windows::System::ProcessLauncherOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProcessLauncherOptions_get_WorkingDirectory(py::wrapper::Windows::System::ProcessLauncherOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.ProcessLauncherOptions", L"WorkingDirectory"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WorkingDirectory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProcessLauncherOptions_put_WorkingDirectory(py::wrapper::Windows::System::ProcessLauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.ProcessLauncherOptions", L"WorkingDirectory"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.WorkingDirectory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProcessLauncherOptions_get_StandardOutput(py::wrapper::Windows::System::ProcessLauncherOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.ProcessLauncherOptions", L"StandardOutput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StandardOutput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProcessLauncherOptions_put_StandardOutput(py::wrapper::Windows::System::ProcessLauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.ProcessLauncherOptions", L"StandardOutput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(arg);

            self->obj.StandardOutput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProcessLauncherOptions_get_StandardInput(py::wrapper::Windows::System::ProcessLauncherOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.ProcessLauncherOptions", L"StandardInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StandardInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProcessLauncherOptions_put_StandardInput(py::wrapper::Windows::System::ProcessLauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.ProcessLauncherOptions", L"StandardInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(arg);

            self->obj.StandardInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProcessLauncherOptions_get_StandardError(py::wrapper::Windows::System::ProcessLauncherOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.ProcessLauncherOptions", L"StandardError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StandardError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProcessLauncherOptions_put_StandardError(py::wrapper::Windows::System::ProcessLauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.ProcessLauncherOptions", L"StandardError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(arg);

            self->obj.StandardError(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ProcessLauncherOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::ProcessLauncherOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProcessLauncherOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::ProcessLauncherOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessLauncherOptions[] = {
        { "_assign_array_", _assign_array_ProcessLauncherOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessLauncherOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessLauncherOptions[] = {
        { "working_directory", reinterpret_cast<getter>(ProcessLauncherOptions_get_WorkingDirectory), reinterpret_cast<setter>(ProcessLauncherOptions_put_WorkingDirectory), nullptr, nullptr },
        { "standard_output", reinterpret_cast<getter>(ProcessLauncherOptions_get_StandardOutput), reinterpret_cast<setter>(ProcessLauncherOptions_put_StandardOutput), nullptr, nullptr },
        { "standard_input", reinterpret_cast<getter>(ProcessLauncherOptions_get_StandardInput), reinterpret_cast<setter>(ProcessLauncherOptions_put_StandardInput), nullptr, nullptr },
        { "standard_error", reinterpret_cast<getter>(ProcessLauncherOptions_get_StandardError), reinterpret_cast<setter>(ProcessLauncherOptions_put_StandardError), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProcessLauncherOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessLauncherOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProcessLauncherOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessLauncherOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessLauncherOptions) },
        { },
    };

    static PyType_Spec type_spec_ProcessLauncherOptions =
    {
        "_winrt_Windows_System.ProcessLauncherOptions",
        sizeof(py::wrapper::Windows::System::ProcessLauncherOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessLauncherOptions
    };

    // ----- ProcessLauncherResult class --------------------
    static constexpr const char* const type_name_ProcessLauncherResult = "ProcessLauncherResult";

    static PyObject* _new_ProcessLauncherResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ProcessLauncherResult);
        return nullptr;
    }

    static void _dealloc_ProcessLauncherResult(py::wrapper::Windows::System::ProcessLauncherResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProcessLauncherResult_get_ExitCode(py::wrapper::Windows::System::ProcessLauncherResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.ProcessLauncherResult", L"ExitCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExitCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProcessLauncherResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::ProcessLauncherResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProcessLauncherResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::ProcessLauncherResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessLauncherResult[] = {
        { "_assign_array_", _assign_array_ProcessLauncherResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessLauncherResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessLauncherResult[] = {
        { "exit_code", reinterpret_cast<getter>(ProcessLauncherResult_get_ExitCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProcessLauncherResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessLauncherResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProcessLauncherResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessLauncherResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessLauncherResult) },
        { },
    };

    static PyType_Spec type_spec_ProcessLauncherResult =
    {
        "_winrt_Windows_System.ProcessLauncherResult",
        sizeof(py::wrapper::Windows::System::ProcessLauncherResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessLauncherResult
    };

    // ----- ProcessMemoryReport class --------------------
    static constexpr const char* const type_name_ProcessMemoryReport = "ProcessMemoryReport";

    static PyObject* _new_ProcessMemoryReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ProcessMemoryReport);
        return nullptr;
    }

    static void _dealloc_ProcessMemoryReport(py::wrapper::Windows::System::ProcessMemoryReport* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProcessMemoryReport_get_PrivateWorkingSetUsage(py::wrapper::Windows::System::ProcessMemoryReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.ProcessMemoryReport", L"PrivateWorkingSetUsage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PrivateWorkingSetUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryReport_get_TotalWorkingSetUsage(py::wrapper::Windows::System::ProcessMemoryReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.ProcessMemoryReport", L"TotalWorkingSetUsage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TotalWorkingSetUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProcessMemoryReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::ProcessMemoryReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProcessMemoryReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::ProcessMemoryReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessMemoryReport[] = {
        { "_assign_array_", _assign_array_ProcessMemoryReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessMemoryReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessMemoryReport[] = {
        { "private_working_set_usage", reinterpret_cast<getter>(ProcessMemoryReport_get_PrivateWorkingSetUsage), nullptr, nullptr, nullptr },
        { "total_working_set_usage", reinterpret_cast<getter>(ProcessMemoryReport_get_TotalWorkingSetUsage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProcessMemoryReport[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessMemoryReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProcessMemoryReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessMemoryReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessMemoryReport) },
        { },
    };

    static PyType_Spec type_spec_ProcessMemoryReport =
    {
        "_winrt_Windows_System.ProcessMemoryReport",
        sizeof(py::wrapper::Windows::System::ProcessMemoryReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessMemoryReport
    };

    // ----- ProtocolForResultsOperation class --------------------
    static constexpr const char* const type_name_ProtocolForResultsOperation = "ProtocolForResultsOperation";

    static PyObject* _new_ProtocolForResultsOperation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ProtocolForResultsOperation);
        return nullptr;
    }

    static void _dealloc_ProtocolForResultsOperation(py::wrapper::Windows::System::ProtocolForResultsOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProtocolForResultsOperation_ReportCompleted(py::wrapper::Windows::System::ProtocolForResultsOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.ProtocolForResultsOperation", L"ReportCompleted", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 0);

                self->obj.ReportCompleted(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProtocolForResultsOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::ProtocolForResultsOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProtocolForResultsOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::ProtocolForResultsOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProtocolForResultsOperation[] = {
        { "report_completed", reinterpret_cast<PyCFunction>(ProtocolForResultsOperation_ReportCompleted), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ProtocolForResultsOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProtocolForResultsOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProtocolForResultsOperation[] = {
        { }
    };

    static PyType_Slot _type_slots_ProtocolForResultsOperation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProtocolForResultsOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProtocolForResultsOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProtocolForResultsOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProtocolForResultsOperation) },
        { },
    };

    static PyType_Spec type_spec_ProtocolForResultsOperation =
    {
        "_winrt_Windows_System.ProtocolForResultsOperation",
        sizeof(py::wrapper::Windows::System::ProtocolForResultsOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProtocolForResultsOperation
    };

    // ----- RemoteLauncher class --------------------
    static constexpr const char* const type_name_RemoteLauncher = "RemoteLauncher";

    static PyObject* _new_RemoteLauncher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteLauncher);
        return nullptr;
    }

    static PyObject* RemoteLauncher_LaunchUriAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteLauncher", L"LaunchUriAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystemConnectionRequest>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);

                return py::convert(winrt::Windows::System::RemoteLauncher::LaunchUriAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteLauncher", L"LaunchUriAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystemConnectionRequest>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::System::RemoteLauncherOptions>(args, 2);

                return py::convert(winrt::Windows::System::RemoteLauncher::LaunchUriAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteLauncher", L"LaunchUriAsync", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystemConnectionRequest>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::System::RemoteLauncherOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 3);

                return py::convert(winrt::Windows::System::RemoteLauncher::LaunchUriAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteLauncher[] = {
        { "launch_uri_async", reinterpret_cast<PyCFunction>(RemoteLauncher_LaunchUriAsync), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteLauncher[] = {
        { }
    };

    static PyType_Slot _type_slots_RemoteLauncher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteLauncher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteLauncher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteLauncher) },
        { },
    };

    static PyType_Spec type_spec_RemoteLauncher =
    {
        "_winrt_Windows_System.RemoteLauncher",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteLauncher
    };

    // ----- RemoteLauncherOptions class --------------------
    static constexpr const char* const type_name_RemoteLauncherOptions = "RemoteLauncherOptions";

    static PyObject* _new_RemoteLauncherOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::System::RemoteLauncherOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RemoteLauncherOptions(py::wrapper::Windows::System::RemoteLauncherOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteLauncherOptions_get_FallbackUri(py::wrapper::Windows::System::RemoteLauncherOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteLauncherOptions", L"FallbackUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FallbackUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RemoteLauncherOptions_put_FallbackUri(py::wrapper::Windows::System::RemoteLauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteLauncherOptions", L"FallbackUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.FallbackUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RemoteLauncherOptions_get_PreferredAppIds(py::wrapper::Windows::System::RemoteLauncherOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteLauncherOptions", L"PreferredAppIds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreferredAppIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteLauncherOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteLauncherOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteLauncherOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteLauncherOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteLauncherOptions[] = {
        { "_assign_array_", _assign_array_RemoteLauncherOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteLauncherOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteLauncherOptions[] = {
        { "fallback_uri", reinterpret_cast<getter>(RemoteLauncherOptions_get_FallbackUri), reinterpret_cast<setter>(RemoteLauncherOptions_put_FallbackUri), nullptr, nullptr },
        { "preferred_app_ids", reinterpret_cast<getter>(RemoteLauncherOptions_get_PreferredAppIds), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteLauncherOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteLauncherOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteLauncherOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteLauncherOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteLauncherOptions) },
        { },
    };

    static PyType_Spec type_spec_RemoteLauncherOptions =
    {
        "_winrt_Windows_System.RemoteLauncherOptions",
        sizeof(py::wrapper::Windows::System::RemoteLauncherOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteLauncherOptions
    };

    // ----- ShutdownManager class --------------------
    static constexpr const char* const type_name_ShutdownManager = "ShutdownManager";

    static PyObject* _new_ShutdownManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ShutdownManager);
        return nullptr;
    }

    static PyObject* ShutdownManager_BeginShutdown(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.ShutdownManager", L"BeginShutdown", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::ShutdownKind>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                winrt::Windows::System::ShutdownManager::BeginShutdown(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ShutdownManager_CancelShutdown(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.ShutdownManager", L"CancelShutdown", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::Windows::System::ShutdownManager::CancelShutdown();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ShutdownManager_EnterPowerState(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.ShutdownManager", L"EnterPowerState", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::PowerState>(args, 0);

                winrt::Windows::System::ShutdownManager::EnterPowerState(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.ShutdownManager", L"EnterPowerState", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::PowerState>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                winrt::Windows::System::ShutdownManager::EnterPowerState(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ShutdownManager_IsPowerStateSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.ShutdownManager", L"IsPowerStateSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::PowerState>(args, 0);

                return py::convert(winrt::Windows::System::ShutdownManager::IsPowerStateSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_ShutdownManager[] = {
        { "begin_shutdown", reinterpret_cast<PyCFunction>(ShutdownManager_BeginShutdown), METH_VARARGS | METH_STATIC, nullptr },
        { "cancel_shutdown", reinterpret_cast<PyCFunction>(ShutdownManager_CancelShutdown), METH_VARARGS | METH_STATIC, nullptr },
        { "enter_power_state", reinterpret_cast<PyCFunction>(ShutdownManager_EnterPowerState), METH_VARARGS | METH_STATIC, nullptr },
        { "is_power_state_supported", reinterpret_cast<PyCFunction>(ShutdownManager_IsPowerStateSupported), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ShutdownManager[] = {
        { }
    };

    static PyType_Slot _type_slots_ShutdownManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ShutdownManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ShutdownManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ShutdownManager) },
        { },
    };

    static PyType_Spec type_spec_ShutdownManager =
    {
        "_winrt_Windows_System.ShutdownManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ShutdownManager
    };

    // ----- TimeZoneSettings class --------------------
    static constexpr const char* const type_name_TimeZoneSettings = "TimeZoneSettings";

    static PyObject* _new_TimeZoneSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TimeZoneSettings);
        return nullptr;
    }

    static PyObject* TimeZoneSettings_AutoUpdateTimeZoneAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.TimeZoneSettings", L"AutoUpdateTimeZoneAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                return py::convert(winrt::Windows::System::TimeZoneSettings::AutoUpdateTimeZoneAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimeZoneSettings_ChangeTimeZoneByDisplayName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.TimeZoneSettings", L"ChangeTimeZoneByDisplayName", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::System::TimeZoneSettings::ChangeTimeZoneByDisplayName(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimeZoneSettings_get_CanChangeTimeZone(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.TimeZoneSettings", L"CanChangeTimeZone"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::TimeZoneSettings::CanChangeTimeZone());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimeZoneSettings_get_CurrentTimeZoneDisplayName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.TimeZoneSettings", L"CurrentTimeZoneDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::TimeZoneSettings::CurrentTimeZoneDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimeZoneSettings_get_SupportedTimeZoneDisplayNames(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.TimeZoneSettings", L"SupportedTimeZoneDisplayNames"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::TimeZoneSettings::SupportedTimeZoneDisplayNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimeZoneSettings[] = {
        { "auto_update_time_zone_async", reinterpret_cast<PyCFunction>(TimeZoneSettings_AutoUpdateTimeZoneAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "change_time_zone_by_display_name", reinterpret_cast<PyCFunction>(TimeZoneSettings_ChangeTimeZoneByDisplayName), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimeZoneSettings[] = {
        { }
    };

    static PyType_Slot _type_slots_TimeZoneSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimeZoneSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimeZoneSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimeZoneSettings) },
        { },
    };

    static PyType_Spec type_spec_TimeZoneSettings =
    {
        "_winrt_Windows_System.TimeZoneSettings",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimeZoneSettings
    };

    static PyGetSetDef getset_TimeZoneSettings_Meta[] = {
        { "can_change_time_zone", reinterpret_cast<getter>(TimeZoneSettings_get_CanChangeTimeZone), nullptr, nullptr, nullptr },
        { "current_time_zone_display_name", reinterpret_cast<getter>(TimeZoneSettings_get_CurrentTimeZoneDisplayName), nullptr, nullptr, nullptr },
        { "supported_time_zone_display_names", reinterpret_cast<getter>(TimeZoneSettings_get_SupportedTimeZoneDisplayNames), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_TimeZoneSettings_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TimeZoneSettings_Meta) },
        { }
    };

    static PyType_Spec type_spec_TimeZoneSettings_Meta =
    {
        "_winrt_Windows_System.TimeZoneSettings_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TimeZoneSettings_Meta
    };

    // ----- User class --------------------
    static constexpr const char* const type_name_User = "User";

    static PyObject* _new_User(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_User);
        return nullptr;
    }

    static void _dealloc_User(py::wrapper::Windows::System::User* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* User_CheckUserAgeConsentGroupAsync(py::wrapper::Windows::System::User* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.User", L"CheckUserAgeConsentGroupAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::UserAgeConsentGroup>(args, 0);

                return py::convert(self->obj.CheckUserAgeConsentGroupAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* User_CreateWatcher(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.User", L"CreateWatcher", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::System::User::CreateWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* User_FindAllAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.User", L"FindAllAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::System::User::FindAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.User", L"FindAllAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::UserType>(args, 0);

                return py::convert(winrt::Windows::System::User::FindAllAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.User", L"FindAllAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::UserType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::UserAuthenticationStatus>(args, 1);

                return py::convert(winrt::Windows::System::User::FindAllAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* User_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.User", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::System::User::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* User_GetFromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.User", L"GetFromId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::System::User::GetFromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* User_GetPictureAsync(py::wrapper::Windows::System::User* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.User", L"GetPictureAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::UserPictureSize>(args, 0);

                return py::convert(self->obj.GetPictureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* User_GetPropertiesAsync(py::wrapper::Windows::System::User* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.User", L"GetPropertiesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetPropertiesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* User_GetPropertyAsync(py::wrapper::Windows::System::User* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.User", L"GetPropertyAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetPropertyAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* User_get_AuthenticationStatus(py::wrapper::Windows::System::User* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.User", L"AuthenticationStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AuthenticationStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* User_get_NonRoamableId(py::wrapper::Windows::System::User* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.User", L"NonRoamableId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NonRoamableId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* User_get_Type(py::wrapper::Windows::System::User* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.User", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_User(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::User>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_User(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::User>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_User[] = {
        { "check_user_age_consent_group_async", reinterpret_cast<PyCFunction>(User_CheckUserAgeConsentGroupAsync), METH_VARARGS, nullptr },
        { "create_watcher", reinterpret_cast<PyCFunction>(User_CreateWatcher), METH_VARARGS | METH_STATIC, nullptr },
        { "find_all_async", reinterpret_cast<PyCFunction>(User_FindAllAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(User_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "get_from_id", reinterpret_cast<PyCFunction>(User_GetFromId), METH_VARARGS | METH_STATIC, nullptr },
        { "get_picture_async", reinterpret_cast<PyCFunction>(User_GetPictureAsync), METH_VARARGS, nullptr },
        { "get_properties_async", reinterpret_cast<PyCFunction>(User_GetPropertiesAsync), METH_VARARGS, nullptr },
        { "get_property_async", reinterpret_cast<PyCFunction>(User_GetPropertyAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_User, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_User), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_User[] = {
        { "authentication_status", reinterpret_cast<getter>(User_get_AuthenticationStatus), nullptr, nullptr, nullptr },
        { "non_roamable_id", reinterpret_cast<getter>(User_get_NonRoamableId), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(User_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_User[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_User) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_User) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_User) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_User) },
        { },
    };

    static PyType_Spec type_spec_User =
    {
        "_winrt_Windows_System.User",
        sizeof(py::wrapper::Windows::System::User),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_User
    };

    // ----- UserAuthenticationStatusChangeDeferral class --------------------
    static constexpr const char* const type_name_UserAuthenticationStatusChangeDeferral = "UserAuthenticationStatusChangeDeferral";

    static PyObject* _new_UserAuthenticationStatusChangeDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UserAuthenticationStatusChangeDeferral);
        return nullptr;
    }

    static void _dealloc_UserAuthenticationStatusChangeDeferral(py::wrapper::Windows::System::UserAuthenticationStatusChangeDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UserAuthenticationStatusChangeDeferral_Complete(py::wrapper::Windows::System::UserAuthenticationStatusChangeDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.UserAuthenticationStatusChangeDeferral", L"Complete", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_UserAuthenticationStatusChangeDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::UserAuthenticationStatusChangeDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UserAuthenticationStatusChangeDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::UserAuthenticationStatusChangeDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserAuthenticationStatusChangeDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(UserAuthenticationStatusChangeDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_UserAuthenticationStatusChangeDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UserAuthenticationStatusChangeDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UserAuthenticationStatusChangeDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_UserAuthenticationStatusChangeDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UserAuthenticationStatusChangeDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UserAuthenticationStatusChangeDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UserAuthenticationStatusChangeDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UserAuthenticationStatusChangeDeferral) },
        { },
    };

    static PyType_Spec type_spec_UserAuthenticationStatusChangeDeferral =
    {
        "_winrt_Windows_System.UserAuthenticationStatusChangeDeferral",
        sizeof(py::wrapper::Windows::System::UserAuthenticationStatusChangeDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserAuthenticationStatusChangeDeferral
    };

    // ----- UserAuthenticationStatusChangingEventArgs class --------------------
    static constexpr const char* const type_name_UserAuthenticationStatusChangingEventArgs = "UserAuthenticationStatusChangingEventArgs";

    static PyObject* _new_UserAuthenticationStatusChangingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UserAuthenticationStatusChangingEventArgs);
        return nullptr;
    }

    static void _dealloc_UserAuthenticationStatusChangingEventArgs(py::wrapper::Windows::System::UserAuthenticationStatusChangingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UserAuthenticationStatusChangingEventArgs_GetDeferral(py::wrapper::Windows::System::UserAuthenticationStatusChangingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.UserAuthenticationStatusChangingEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserAuthenticationStatusChangingEventArgs_get_CurrentStatus(py::wrapper::Windows::System::UserAuthenticationStatusChangingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.UserAuthenticationStatusChangingEventArgs", L"CurrentStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserAuthenticationStatusChangingEventArgs_get_NewStatus(py::wrapper::Windows::System::UserAuthenticationStatusChangingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.UserAuthenticationStatusChangingEventArgs", L"NewStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NewStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserAuthenticationStatusChangingEventArgs_get_User(py::wrapper::Windows::System::UserAuthenticationStatusChangingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.UserAuthenticationStatusChangingEventArgs", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UserAuthenticationStatusChangingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::UserAuthenticationStatusChangingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UserAuthenticationStatusChangingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::UserAuthenticationStatusChangingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserAuthenticationStatusChangingEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(UserAuthenticationStatusChangingEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_UserAuthenticationStatusChangingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UserAuthenticationStatusChangingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UserAuthenticationStatusChangingEventArgs[] = {
        { "current_status", reinterpret_cast<getter>(UserAuthenticationStatusChangingEventArgs_get_CurrentStatus), nullptr, nullptr, nullptr },
        { "new_status", reinterpret_cast<getter>(UserAuthenticationStatusChangingEventArgs_get_NewStatus), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(UserAuthenticationStatusChangingEventArgs_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UserAuthenticationStatusChangingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UserAuthenticationStatusChangingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UserAuthenticationStatusChangingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UserAuthenticationStatusChangingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UserAuthenticationStatusChangingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_UserAuthenticationStatusChangingEventArgs =
    {
        "_winrt_Windows_System.UserAuthenticationStatusChangingEventArgs",
        sizeof(py::wrapper::Windows::System::UserAuthenticationStatusChangingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserAuthenticationStatusChangingEventArgs
    };

    // ----- UserChangedEventArgs class --------------------
    static constexpr const char* const type_name_UserChangedEventArgs = "UserChangedEventArgs";

    static PyObject* _new_UserChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UserChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_UserChangedEventArgs(py::wrapper::Windows::System::UserChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UserChangedEventArgs_get_User(py::wrapper::Windows::System::UserChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.UserChangedEventArgs", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserChangedEventArgs_get_ChangedPropertyKinds(py::wrapper::Windows::System::UserChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.UserChangedEventArgs", L"ChangedPropertyKinds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChangedPropertyKinds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UserChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::UserChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UserChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::UserChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserChangedEventArgs[] = {
        { "_assign_array_", _assign_array_UserChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UserChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UserChangedEventArgs[] = {
        { "user", reinterpret_cast<getter>(UserChangedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "changed_property_kinds", reinterpret_cast<getter>(UserChangedEventArgs_get_ChangedPropertyKinds), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UserChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UserChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UserChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UserChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UserChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_UserChangedEventArgs =
    {
        "_winrt_Windows_System.UserChangedEventArgs",
        sizeof(py::wrapper::Windows::System::UserChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserChangedEventArgs
    };

    // ----- UserDeviceAssociation class --------------------
    static constexpr const char* const type_name_UserDeviceAssociation = "UserDeviceAssociation";

    static PyObject* _new_UserDeviceAssociation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UserDeviceAssociation);
        return nullptr;
    }

    static PyObject* UserDeviceAssociation_FindUserFromDeviceId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.UserDeviceAssociation", L"FindUserFromDeviceId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::System::UserDeviceAssociation::FindUserFromDeviceId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserDeviceAssociation_add_UserDeviceAssociationChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.UserDeviceAssociation", L"UserDeviceAssociationChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::System::UserDeviceAssociationChangedEventArgs>>(arg);

            return py::convert(winrt::Windows::System::UserDeviceAssociation::UserDeviceAssociationChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDeviceAssociation_remove_UserDeviceAssociationChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.UserDeviceAssociation", L"UserDeviceAssociationChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::System::UserDeviceAssociation::UserDeviceAssociationChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserDeviceAssociation[] = {
        { "find_user_from_device_id", reinterpret_cast<PyCFunction>(UserDeviceAssociation_FindUserFromDeviceId), METH_VARARGS | METH_STATIC, nullptr },
        { "add_user_device_association_changed", reinterpret_cast<PyCFunction>(UserDeviceAssociation_add_UserDeviceAssociationChanged), METH_O | METH_STATIC, nullptr },
        { "remove_user_device_association_changed", reinterpret_cast<PyCFunction>(UserDeviceAssociation_remove_UserDeviceAssociationChanged), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UserDeviceAssociation[] = {
        { }
    };

    static PyType_Slot _type_slots_UserDeviceAssociation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UserDeviceAssociation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UserDeviceAssociation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UserDeviceAssociation) },
        { },
    };

    static PyType_Spec type_spec_UserDeviceAssociation =
    {
        "_winrt_Windows_System.UserDeviceAssociation",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserDeviceAssociation
    };

    // ----- UserDeviceAssociationChangedEventArgs class --------------------
    static constexpr const char* const type_name_UserDeviceAssociationChangedEventArgs = "UserDeviceAssociationChangedEventArgs";

    static PyObject* _new_UserDeviceAssociationChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UserDeviceAssociationChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_UserDeviceAssociationChangedEventArgs(py::wrapper::Windows::System::UserDeviceAssociationChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UserDeviceAssociationChangedEventArgs_get_DeviceId(py::wrapper::Windows::System::UserDeviceAssociationChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.UserDeviceAssociationChangedEventArgs", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDeviceAssociationChangedEventArgs_get_NewUser(py::wrapper::Windows::System::UserDeviceAssociationChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.UserDeviceAssociationChangedEventArgs", L"NewUser"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NewUser());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDeviceAssociationChangedEventArgs_get_OldUser(py::wrapper::Windows::System::UserDeviceAssociationChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.UserDeviceAssociationChangedEventArgs", L"OldUser"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OldUser());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UserDeviceAssociationChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::UserDeviceAssociationChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UserDeviceAssociationChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::UserDeviceAssociationChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserDeviceAssociationChangedEventArgs[] = {
        { "_assign_array_", _assign_array_UserDeviceAssociationChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UserDeviceAssociationChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UserDeviceAssociationChangedEventArgs[] = {
        { "device_id", reinterpret_cast<getter>(UserDeviceAssociationChangedEventArgs_get_DeviceId), nullptr, nullptr, nullptr },
        { "new_user", reinterpret_cast<getter>(UserDeviceAssociationChangedEventArgs_get_NewUser), nullptr, nullptr, nullptr },
        { "old_user", reinterpret_cast<getter>(UserDeviceAssociationChangedEventArgs_get_OldUser), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UserDeviceAssociationChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UserDeviceAssociationChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UserDeviceAssociationChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UserDeviceAssociationChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UserDeviceAssociationChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_UserDeviceAssociationChangedEventArgs =
    {
        "_winrt_Windows_System.UserDeviceAssociationChangedEventArgs",
        sizeof(py::wrapper::Windows::System::UserDeviceAssociationChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserDeviceAssociationChangedEventArgs
    };

    // ----- UserPicker class --------------------
    static constexpr const char* const type_name_UserPicker = "UserPicker";

    static PyObject* _new_UserPicker(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::System::UserPicker instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_UserPicker(py::wrapper::Windows::System::UserPicker* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UserPicker_IsSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.UserPicker", L"IsSupported", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::System::UserPicker::IsSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserPicker_PickSingleUserAsync(py::wrapper::Windows::System::UserPicker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.UserPicker", L"PickSingleUserAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.PickSingleUserAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserPicker_get_SuggestedSelectedUser(py::wrapper::Windows::System::UserPicker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.UserPicker", L"SuggestedSelectedUser"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SuggestedSelectedUser());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UserPicker_put_SuggestedSelectedUser(py::wrapper::Windows::System::UserPicker* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.UserPicker", L"SuggestedSelectedUser"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::User>(arg);

            self->obj.SuggestedSelectedUser(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UserPicker_get_AllowGuestAccounts(py::wrapper::Windows::System::UserPicker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.UserPicker", L"AllowGuestAccounts"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowGuestAccounts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UserPicker_put_AllowGuestAccounts(py::wrapper::Windows::System::UserPicker* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.UserPicker", L"AllowGuestAccounts"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowGuestAccounts(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_UserPicker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::UserPicker>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UserPicker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::UserPicker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserPicker[] = {
        { "is_supported", reinterpret_cast<PyCFunction>(UserPicker_IsSupported), METH_VARARGS | METH_STATIC, nullptr },
        { "pick_single_user_async", reinterpret_cast<PyCFunction>(UserPicker_PickSingleUserAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_UserPicker, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UserPicker), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UserPicker[] = {
        { "suggested_selected_user", reinterpret_cast<getter>(UserPicker_get_SuggestedSelectedUser), reinterpret_cast<setter>(UserPicker_put_SuggestedSelectedUser), nullptr, nullptr },
        { "allow_guest_accounts", reinterpret_cast<getter>(UserPicker_get_AllowGuestAccounts), reinterpret_cast<setter>(UserPicker_put_AllowGuestAccounts), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UserPicker[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UserPicker) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UserPicker) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UserPicker) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UserPicker) },
        { },
    };

    static PyType_Spec type_spec_UserPicker =
    {
        "_winrt_Windows_System.UserPicker",
        sizeof(py::wrapper::Windows::System::UserPicker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserPicker
    };

    // ----- UserWatcher class --------------------
    static constexpr const char* const type_name_UserWatcher = "UserWatcher";

    static PyObject* _new_UserWatcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UserWatcher);
        return nullptr;
    }

    static void _dealloc_UserWatcher(py::wrapper::Windows::System::UserWatcher* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UserWatcher_Start(py::wrapper::Windows::System::UserWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.UserWatcher", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserWatcher_Stop(py::wrapper::Windows::System::UserWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.UserWatcher", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserWatcher_get_Status(py::wrapper::Windows::System::UserWatcher* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.UserWatcher", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_add_Added(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.UserWatcher", L"Added"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::UserWatcher, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert(self->obj.Added(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_remove_Added(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.UserWatcher", L"Added"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Added(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_add_AuthenticationStatusChanged(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.UserWatcher", L"AuthenticationStatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::UserWatcher, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert(self->obj.AuthenticationStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_remove_AuthenticationStatusChanged(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.UserWatcher", L"AuthenticationStatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AuthenticationStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_add_AuthenticationStatusChanging(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.UserWatcher", L"AuthenticationStatusChanging"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::UserWatcher, winrt::Windows::System::UserAuthenticationStatusChangingEventArgs>>(arg);

            return py::convert(self->obj.AuthenticationStatusChanging(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_remove_AuthenticationStatusChanging(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.UserWatcher", L"AuthenticationStatusChanging"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AuthenticationStatusChanging(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_add_EnumerationCompleted(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.UserWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::UserWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_remove_EnumerationCompleted(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.UserWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_add_Removed(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.UserWatcher", L"Removed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::UserWatcher, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert(self->obj.Removed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_remove_Removed(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.UserWatcher", L"Removed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Removed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_add_Stopped(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.UserWatcher", L"Stopped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::UserWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_remove_Stopped(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.UserWatcher", L"Stopped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_add_Updated(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.UserWatcher", L"Updated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::UserWatcher, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert(self->obj.Updated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_remove_Updated(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.UserWatcher", L"Updated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Updated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UserWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::UserWatcher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UserWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::UserWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserWatcher[] = {
        { "start", reinterpret_cast<PyCFunction>(UserWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(UserWatcher_Stop), METH_VARARGS, nullptr },
        { "add_added", reinterpret_cast<PyCFunction>(UserWatcher_add_Added), METH_O, nullptr },
        { "remove_added", reinterpret_cast<PyCFunction>(UserWatcher_remove_Added), METH_O, nullptr },
        { "add_authentication_status_changed", reinterpret_cast<PyCFunction>(UserWatcher_add_AuthenticationStatusChanged), METH_O, nullptr },
        { "remove_authentication_status_changed", reinterpret_cast<PyCFunction>(UserWatcher_remove_AuthenticationStatusChanged), METH_O, nullptr },
        { "add_authentication_status_changing", reinterpret_cast<PyCFunction>(UserWatcher_add_AuthenticationStatusChanging), METH_O, nullptr },
        { "remove_authentication_status_changing", reinterpret_cast<PyCFunction>(UserWatcher_remove_AuthenticationStatusChanging), METH_O, nullptr },
        { "add_enumeration_completed", reinterpret_cast<PyCFunction>(UserWatcher_add_EnumerationCompleted), METH_O, nullptr },
        { "remove_enumeration_completed", reinterpret_cast<PyCFunction>(UserWatcher_remove_EnumerationCompleted), METH_O, nullptr },
        { "add_removed", reinterpret_cast<PyCFunction>(UserWatcher_add_Removed), METH_O, nullptr },
        { "remove_removed", reinterpret_cast<PyCFunction>(UserWatcher_remove_Removed), METH_O, nullptr },
        { "add_stopped", reinterpret_cast<PyCFunction>(UserWatcher_add_Stopped), METH_O, nullptr },
        { "remove_stopped", reinterpret_cast<PyCFunction>(UserWatcher_remove_Stopped), METH_O, nullptr },
        { "add_updated", reinterpret_cast<PyCFunction>(UserWatcher_add_Updated), METH_O, nullptr },
        { "remove_updated", reinterpret_cast<PyCFunction>(UserWatcher_remove_Updated), METH_O, nullptr },
        { "_assign_array_", _assign_array_UserWatcher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UserWatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UserWatcher[] = {
        { "status", reinterpret_cast<getter>(UserWatcher_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UserWatcher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UserWatcher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UserWatcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UserWatcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UserWatcher) },
        { },
    };

    static PyType_Spec type_spec_UserWatcher =
    {
        "_winrt_Windows_System.UserWatcher",
        sizeof(py::wrapper::Windows::System::UserWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserWatcher
    };

    // ----- ILauncherViewOptions interface --------------------
    static constexpr const char* const type_name_ILauncherViewOptions = "ILauncherViewOptions";

    static PyObject* _new_ILauncherViewOptions(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_ILauncherViewOptions);
        return nullptr;
    }

    static void _dealloc_ILauncherViewOptions(py::wrapper::Windows::System::ILauncherViewOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ILauncherViewOptions_get_DesiredRemainingView(py::wrapper::Windows::System::ILauncherViewOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.ILauncherViewOptions", L"DesiredRemainingView"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredRemainingView());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ILauncherViewOptions_put_DesiredRemainingView(py::wrapper::Windows::System::ILauncherViewOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.ILauncherViewOptions", L"DesiredRemainingView"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::ViewSizePreference>(arg);

            self->obj.DesiredRemainingView(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ILauncherViewOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::ILauncherViewOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ILauncherViewOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::ILauncherViewOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILauncherViewOptions[] = {
        { "_assign_array_", _assign_array_ILauncherViewOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ILauncherViewOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ILauncherViewOptions[] = {
        { "desired_remaining_view", reinterpret_cast<getter>(ILauncherViewOptions_get_DesiredRemainingView), reinterpret_cast<setter>(ILauncherViewOptions_put_DesiredRemainingView), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ILauncherViewOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ILauncherViewOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ILauncherViewOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ILauncherViewOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ILauncherViewOptions) },
        { },
    };

    static PyType_Spec type_spec_ILauncherViewOptions =
    {
        "_winrt_Windows_System.ILauncherViewOptions",
        sizeof(py::wrapper::Windows::System::ILauncherViewOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILauncherViewOptions
    };

    // ----- Windows.System Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::System");


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_AppActivationResult);
        Py_VISIT(state->type_AppDiagnosticInfo);
        Py_VISIT(state->type_AppDiagnosticInfoWatcher);
        Py_VISIT(state->type_AppDiagnosticInfoWatcherEventArgs);
        Py_VISIT(state->type_AppExecutionStateChangeResult);
        Py_VISIT(state->type_AppMemoryReport);
        Py_VISIT(state->type_AppMemoryUsageLimitChangingEventArgs);
        Py_VISIT(state->type_AppResourceGroupBackgroundTaskReport);
        Py_VISIT(state->type_AppResourceGroupInfo);
        Py_VISIT(state->type_AppResourceGroupInfoWatcher);
        Py_VISIT(state->type_AppResourceGroupInfoWatcherEventArgs);
        Py_VISIT(state->type_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs);
        Py_VISIT(state->type_AppResourceGroupMemoryReport);
        Py_VISIT(state->type_AppResourceGroupStateReport);
        Py_VISIT(state->type_AppUriHandlerHost);
        Py_VISIT(state->type_AppUriHandlerRegistration);
        Py_VISIT(state->type_AppUriHandlerRegistrationManager);
        Py_VISIT(state->type_DateTimeSettings);
        Py_VISIT(state->type_DispatcherQueue);
        Py_VISIT(state->type_DispatcherQueueController);
        Py_VISIT(state->type_DispatcherQueueShutdownStartingEventArgs);
        Py_VISIT(state->type_DispatcherQueueTimer);
        Py_VISIT(state->type_FolderLauncherOptions);
        Py_VISIT(state->type_KnownUserProperties);
        Py_VISIT(state->type_LaunchUriResult);
        Py_VISIT(state->type_Launcher);
        Py_VISIT(state->type_LauncherOptions);
        Py_VISIT(state->type_LauncherUIOptions);
        Py_VISIT(state->type_MemoryManager);
        Py_VISIT(state->type_ProcessLauncher);
        Py_VISIT(state->type_ProcessLauncherOptions);
        Py_VISIT(state->type_ProcessLauncherResult);
        Py_VISIT(state->type_ProcessMemoryReport);
        Py_VISIT(state->type_ProtocolForResultsOperation);
        Py_VISIT(state->type_RemoteLauncher);
        Py_VISIT(state->type_RemoteLauncherOptions);
        Py_VISIT(state->type_ShutdownManager);
        Py_VISIT(state->type_TimeZoneSettings);
        Py_VISIT(state->type_User);
        Py_VISIT(state->type_UserAuthenticationStatusChangeDeferral);
        Py_VISIT(state->type_UserAuthenticationStatusChangingEventArgs);
        Py_VISIT(state->type_UserChangedEventArgs);
        Py_VISIT(state->type_UserDeviceAssociation);
        Py_VISIT(state->type_UserDeviceAssociationChangedEventArgs);
        Py_VISIT(state->type_UserPicker);
        Py_VISIT(state->type_UserWatcher);
        Py_VISIT(state->type_ILauncherViewOptions);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_AppActivationResult);
        Py_CLEAR(state->type_AppDiagnosticInfo);
        Py_CLEAR(state->type_AppDiagnosticInfoWatcher);
        Py_CLEAR(state->type_AppDiagnosticInfoWatcherEventArgs);
        Py_CLEAR(state->type_AppExecutionStateChangeResult);
        Py_CLEAR(state->type_AppMemoryReport);
        Py_CLEAR(state->type_AppMemoryUsageLimitChangingEventArgs);
        Py_CLEAR(state->type_AppResourceGroupBackgroundTaskReport);
        Py_CLEAR(state->type_AppResourceGroupInfo);
        Py_CLEAR(state->type_AppResourceGroupInfoWatcher);
        Py_CLEAR(state->type_AppResourceGroupInfoWatcherEventArgs);
        Py_CLEAR(state->type_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs);
        Py_CLEAR(state->type_AppResourceGroupMemoryReport);
        Py_CLEAR(state->type_AppResourceGroupStateReport);
        Py_CLEAR(state->type_AppUriHandlerHost);
        Py_CLEAR(state->type_AppUriHandlerRegistration);
        Py_CLEAR(state->type_AppUriHandlerRegistrationManager);
        Py_CLEAR(state->type_DateTimeSettings);
        Py_CLEAR(state->type_DispatcherQueue);
        Py_CLEAR(state->type_DispatcherQueueController);
        Py_CLEAR(state->type_DispatcherQueueShutdownStartingEventArgs);
        Py_CLEAR(state->type_DispatcherQueueTimer);
        Py_CLEAR(state->type_FolderLauncherOptions);
        Py_CLEAR(state->type_KnownUserProperties);
        Py_CLEAR(state->type_LaunchUriResult);
        Py_CLEAR(state->type_Launcher);
        Py_CLEAR(state->type_LauncherOptions);
        Py_CLEAR(state->type_LauncherUIOptions);
        Py_CLEAR(state->type_MemoryManager);
        Py_CLEAR(state->type_ProcessLauncher);
        Py_CLEAR(state->type_ProcessLauncherOptions);
        Py_CLEAR(state->type_ProcessLauncherResult);
        Py_CLEAR(state->type_ProcessMemoryReport);
        Py_CLEAR(state->type_ProtocolForResultsOperation);
        Py_CLEAR(state->type_RemoteLauncher);
        Py_CLEAR(state->type_RemoteLauncherOptions);
        Py_CLEAR(state->type_ShutdownManager);
        Py_CLEAR(state->type_TimeZoneSettings);
        Py_CLEAR(state->type_User);
        Py_CLEAR(state->type_UserAuthenticationStatusChangeDeferral);
        Py_CLEAR(state->type_UserAuthenticationStatusChangingEventArgs);
        Py_CLEAR(state->type_UserChangedEventArgs);
        Py_CLEAR(state->type_UserDeviceAssociation);
        Py_CLEAR(state->type_UserDeviceAssociationChangedEventArgs);
        Py_CLEAR(state->type_UserPicker);
        Py_CLEAR(state->type_UserWatcher);
        Py_CLEAR(state->type_ILauncherViewOptions);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_Windows_System",
           module_doc,
           sizeof(module_state),
           nullptr,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::System

PyMODINIT_FUNC PyInit__winrt_Windows_System(void) noexcept
{
    using namespace py::cpp::Windows::System;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    WINRT_ASSERT(state);

    state->type_AppActivationResult = py::register_python_type(module.get(), type_name_AppActivationResult, &type_spec_AppActivationResult, object_bases.get(), nullptr);
    if (!state->type_AppActivationResult)
    {
        return nullptr;
    }

    state->type_AppDiagnosticInfo = py::register_python_type(module.get(), type_name_AppDiagnosticInfo, &type_spec_AppDiagnosticInfo, object_bases.get(), nullptr);
    if (!state->type_AppDiagnosticInfo)
    {
        return nullptr;
    }

    state->type_AppDiagnosticInfoWatcher = py::register_python_type(module.get(), type_name_AppDiagnosticInfoWatcher, &type_spec_AppDiagnosticInfoWatcher, object_bases.get(), nullptr);
    if (!state->type_AppDiagnosticInfoWatcher)
    {
        return nullptr;
    }

    state->type_AppDiagnosticInfoWatcherEventArgs = py::register_python_type(module.get(), type_name_AppDiagnosticInfoWatcherEventArgs, &type_spec_AppDiagnosticInfoWatcherEventArgs, object_bases.get(), nullptr);
    if (!state->type_AppDiagnosticInfoWatcherEventArgs)
    {
        return nullptr;
    }

    state->type_AppExecutionStateChangeResult = py::register_python_type(module.get(), type_name_AppExecutionStateChangeResult, &type_spec_AppExecutionStateChangeResult, object_bases.get(), nullptr);
    if (!state->type_AppExecutionStateChangeResult)
    {
        return nullptr;
    }

    state->type_AppMemoryReport = py::register_python_type(module.get(), type_name_AppMemoryReport, &type_spec_AppMemoryReport, object_bases.get(), nullptr);
    if (!state->type_AppMemoryReport)
    {
        return nullptr;
    }

    state->type_AppMemoryUsageLimitChangingEventArgs = py::register_python_type(module.get(), type_name_AppMemoryUsageLimitChangingEventArgs, &type_spec_AppMemoryUsageLimitChangingEventArgs, object_bases.get(), nullptr);
    if (!state->type_AppMemoryUsageLimitChangingEventArgs)
    {
        return nullptr;
    }

    state->type_AppResourceGroupBackgroundTaskReport = py::register_python_type(module.get(), type_name_AppResourceGroupBackgroundTaskReport, &type_spec_AppResourceGroupBackgroundTaskReport, object_bases.get(), nullptr);
    if (!state->type_AppResourceGroupBackgroundTaskReport)
    {
        return nullptr;
    }

    state->type_AppResourceGroupInfo = py::register_python_type(module.get(), type_name_AppResourceGroupInfo, &type_spec_AppResourceGroupInfo, object_bases.get(), nullptr);
    if (!state->type_AppResourceGroupInfo)
    {
        return nullptr;
    }

    state->type_AppResourceGroupInfoWatcher = py::register_python_type(module.get(), type_name_AppResourceGroupInfoWatcher, &type_spec_AppResourceGroupInfoWatcher, object_bases.get(), nullptr);
    if (!state->type_AppResourceGroupInfoWatcher)
    {
        return nullptr;
    }

    state->type_AppResourceGroupInfoWatcherEventArgs = py::register_python_type(module.get(), type_name_AppResourceGroupInfoWatcherEventArgs, &type_spec_AppResourceGroupInfoWatcherEventArgs, object_bases.get(), nullptr);
    if (!state->type_AppResourceGroupInfoWatcherEventArgs)
    {
        return nullptr;
    }

    state->type_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs = py::register_python_type(module.get(), type_name_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs, &type_spec_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs, object_bases.get(), nullptr);
    if (!state->type_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs)
    {
        return nullptr;
    }

    state->type_AppResourceGroupMemoryReport = py::register_python_type(module.get(), type_name_AppResourceGroupMemoryReport, &type_spec_AppResourceGroupMemoryReport, object_bases.get(), nullptr);
    if (!state->type_AppResourceGroupMemoryReport)
    {
        return nullptr;
    }

    state->type_AppResourceGroupStateReport = py::register_python_type(module.get(), type_name_AppResourceGroupStateReport, &type_spec_AppResourceGroupStateReport, object_bases.get(), nullptr);
    if (!state->type_AppResourceGroupStateReport)
    {
        return nullptr;
    }

    state->type_AppUriHandlerHost = py::register_python_type(module.get(), type_name_AppUriHandlerHost, &type_spec_AppUriHandlerHost, object_bases.get(), nullptr);
    if (!state->type_AppUriHandlerHost)
    {
        return nullptr;
    }

    state->type_AppUriHandlerRegistration = py::register_python_type(module.get(), type_name_AppUriHandlerRegistration, &type_spec_AppUriHandlerRegistration, object_bases.get(), nullptr);
    if (!state->type_AppUriHandlerRegistration)
    {
        return nullptr;
    }

    state->type_AppUriHandlerRegistrationManager = py::register_python_type(module.get(), type_name_AppUriHandlerRegistrationManager, &type_spec_AppUriHandlerRegistrationManager, object_bases.get(), nullptr);
    if (!state->type_AppUriHandlerRegistrationManager)
    {
        return nullptr;
    }

    state->type_DateTimeSettings = py::register_python_type(module.get(), type_name_DateTimeSettings, &type_spec_DateTimeSettings, object_bases.get(), nullptr);
    if (!state->type_DateTimeSettings)
    {
        return nullptr;
    }

    state->type_DispatcherQueue = py::register_python_type(module.get(), type_name_DispatcherQueue, &type_spec_DispatcherQueue, object_bases.get(), nullptr);
    if (!state->type_DispatcherQueue)
    {
        return nullptr;
    }

    state->type_DispatcherQueueController = py::register_python_type(module.get(), type_name_DispatcherQueueController, &type_spec_DispatcherQueueController, object_bases.get(), nullptr);
    if (!state->type_DispatcherQueueController)
    {
        return nullptr;
    }

    state->type_DispatcherQueueShutdownStartingEventArgs = py::register_python_type(module.get(), type_name_DispatcherQueueShutdownStartingEventArgs, &type_spec_DispatcherQueueShutdownStartingEventArgs, object_bases.get(), nullptr);
    if (!state->type_DispatcherQueueShutdownStartingEventArgs)
    {
        return nullptr;
    }

    state->type_DispatcherQueueTimer = py::register_python_type(module.get(), type_name_DispatcherQueueTimer, &type_spec_DispatcherQueueTimer, object_bases.get(), nullptr);
    if (!state->type_DispatcherQueueTimer)
    {
        return nullptr;
    }

    state->type_FolderLauncherOptions = py::register_python_type(module.get(), type_name_FolderLauncherOptions, &type_spec_FolderLauncherOptions, object_bases.get(), nullptr);
    if (!state->type_FolderLauncherOptions)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownUserProperties_Meta{PyType_FromSpec(&type_spec_KnownUserProperties_Meta)};
    if (!type_KnownUserProperties_Meta)
    {
        return nullptr;
    }

    state->type_KnownUserProperties = py::register_python_type(module.get(), type_name_KnownUserProperties, &type_spec_KnownUserProperties, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KnownUserProperties_Meta.get()));
    if (!state->type_KnownUserProperties)
    {
        return nullptr;
    }

    state->type_LaunchUriResult = py::register_python_type(module.get(), type_name_LaunchUriResult, &type_spec_LaunchUriResult, object_bases.get(), nullptr);
    if (!state->type_LaunchUriResult)
    {
        return nullptr;
    }

    state->type_Launcher = py::register_python_type(module.get(), type_name_Launcher, &type_spec_Launcher, object_bases.get(), nullptr);
    if (!state->type_Launcher)
    {
        return nullptr;
    }

    state->type_LauncherOptions = py::register_python_type(module.get(), type_name_LauncherOptions, &type_spec_LauncherOptions, object_bases.get(), nullptr);
    if (!state->type_LauncherOptions)
    {
        return nullptr;
    }

    state->type_LauncherUIOptions = py::register_python_type(module.get(), type_name_LauncherUIOptions, &type_spec_LauncherUIOptions, object_bases.get(), nullptr);
    if (!state->type_LauncherUIOptions)
    {
        return nullptr;
    }

    py::pyobj_handle type_MemoryManager_Meta{PyType_FromSpec(&type_spec_MemoryManager_Meta)};
    if (!type_MemoryManager_Meta)
    {
        return nullptr;
    }

    state->type_MemoryManager = py::register_python_type(module.get(), type_name_MemoryManager, &type_spec_MemoryManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MemoryManager_Meta.get()));
    if (!state->type_MemoryManager)
    {
        return nullptr;
    }

    state->type_ProcessLauncher = py::register_python_type(module.get(), type_name_ProcessLauncher, &type_spec_ProcessLauncher, object_bases.get(), nullptr);
    if (!state->type_ProcessLauncher)
    {
        return nullptr;
    }

    state->type_ProcessLauncherOptions = py::register_python_type(module.get(), type_name_ProcessLauncherOptions, &type_spec_ProcessLauncherOptions, object_bases.get(), nullptr);
    if (!state->type_ProcessLauncherOptions)
    {
        return nullptr;
    }

    state->type_ProcessLauncherResult = py::register_python_type(module.get(), type_name_ProcessLauncherResult, &type_spec_ProcessLauncherResult, object_bases.get(), nullptr);
    if (!state->type_ProcessLauncherResult)
    {
        return nullptr;
    }

    state->type_ProcessMemoryReport = py::register_python_type(module.get(), type_name_ProcessMemoryReport, &type_spec_ProcessMemoryReport, object_bases.get(), nullptr);
    if (!state->type_ProcessMemoryReport)
    {
        return nullptr;
    }

    state->type_ProtocolForResultsOperation = py::register_python_type(module.get(), type_name_ProtocolForResultsOperation, &type_spec_ProtocolForResultsOperation, object_bases.get(), nullptr);
    if (!state->type_ProtocolForResultsOperation)
    {
        return nullptr;
    }

    state->type_RemoteLauncher = py::register_python_type(module.get(), type_name_RemoteLauncher, &type_spec_RemoteLauncher, object_bases.get(), nullptr);
    if (!state->type_RemoteLauncher)
    {
        return nullptr;
    }

    state->type_RemoteLauncherOptions = py::register_python_type(module.get(), type_name_RemoteLauncherOptions, &type_spec_RemoteLauncherOptions, object_bases.get(), nullptr);
    if (!state->type_RemoteLauncherOptions)
    {
        return nullptr;
    }

    state->type_ShutdownManager = py::register_python_type(module.get(), type_name_ShutdownManager, &type_spec_ShutdownManager, object_bases.get(), nullptr);
    if (!state->type_ShutdownManager)
    {
        return nullptr;
    }

    py::pyobj_handle type_TimeZoneSettings_Meta{PyType_FromSpec(&type_spec_TimeZoneSettings_Meta)};
    if (!type_TimeZoneSettings_Meta)
    {
        return nullptr;
    }

    state->type_TimeZoneSettings = py::register_python_type(module.get(), type_name_TimeZoneSettings, &type_spec_TimeZoneSettings, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TimeZoneSettings_Meta.get()));
    if (!state->type_TimeZoneSettings)
    {
        return nullptr;
    }

    state->type_User = py::register_python_type(module.get(), type_name_User, &type_spec_User, object_bases.get(), nullptr);
    if (!state->type_User)
    {
        return nullptr;
    }

    state->type_UserAuthenticationStatusChangeDeferral = py::register_python_type(module.get(), type_name_UserAuthenticationStatusChangeDeferral, &type_spec_UserAuthenticationStatusChangeDeferral, object_bases.get(), nullptr);
    if (!state->type_UserAuthenticationStatusChangeDeferral)
    {
        return nullptr;
    }

    state->type_UserAuthenticationStatusChangingEventArgs = py::register_python_type(module.get(), type_name_UserAuthenticationStatusChangingEventArgs, &type_spec_UserAuthenticationStatusChangingEventArgs, object_bases.get(), nullptr);
    if (!state->type_UserAuthenticationStatusChangingEventArgs)
    {
        return nullptr;
    }

    state->type_UserChangedEventArgs = py::register_python_type(module.get(), type_name_UserChangedEventArgs, &type_spec_UserChangedEventArgs, object_bases.get(), nullptr);
    if (!state->type_UserChangedEventArgs)
    {
        return nullptr;
    }

    state->type_UserDeviceAssociation = py::register_python_type(module.get(), type_name_UserDeviceAssociation, &type_spec_UserDeviceAssociation, object_bases.get(), nullptr);
    if (!state->type_UserDeviceAssociation)
    {
        return nullptr;
    }

    state->type_UserDeviceAssociationChangedEventArgs = py::register_python_type(module.get(), type_name_UserDeviceAssociationChangedEventArgs, &type_spec_UserDeviceAssociationChangedEventArgs, object_bases.get(), nullptr);
    if (!state->type_UserDeviceAssociationChangedEventArgs)
    {
        return nullptr;
    }

    state->type_UserPicker = py::register_python_type(module.get(), type_name_UserPicker, &type_spec_UserPicker, object_bases.get(), nullptr);
    if (!state->type_UserPicker)
    {
        return nullptr;
    }

    state->type_UserWatcher = py::register_python_type(module.get(), type_name_UserWatcher, &type_spec_UserWatcher, object_bases.get(), nullptr);
    if (!state->type_UserWatcher)
    {
        return nullptr;
    }

    state->type_ILauncherViewOptions = py::register_python_type(module.get(), type_name_ILauncherViewOptions, &type_spec_ILauncherViewOptions, object_bases.get(), nullptr);
    if (!state->type_ILauncherViewOptions)
    {
        return nullptr;
    }


    return module.detach();
}

PyTypeObject* py::winrt_type<winrt::Windows::System::AppActivationResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppActivationResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::AppActivationResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::AppDiagnosticInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppDiagnosticInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::AppDiagnosticInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::AppDiagnosticInfoWatcher>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppDiagnosticInfoWatcher;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::AppDiagnosticInfoWatcher is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::AppDiagnosticInfoWatcherEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppDiagnosticInfoWatcherEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::AppDiagnosticInfoWatcherEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::AppExecutionStateChangeResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppExecutionStateChangeResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::AppExecutionStateChangeResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::AppMemoryReport>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppMemoryReport;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::AppMemoryReport is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::AppMemoryUsageLimitChangingEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppMemoryUsageLimitChangingEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::AppMemoryUsageLimitChangingEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::AppResourceGroupBackgroundTaskReport>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppResourceGroupBackgroundTaskReport;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::AppResourceGroupBackgroundTaskReport is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::AppResourceGroupInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppResourceGroupInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::AppResourceGroupInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::AppResourceGroupInfoWatcher>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppResourceGroupInfoWatcher;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::AppResourceGroupInfoWatcher is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::AppResourceGroupInfoWatcherEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppResourceGroupInfoWatcherEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::AppResourceGroupInfoWatcherEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::AppResourceGroupInfoWatcherExecutionStateChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::AppResourceGroupInfoWatcherExecutionStateChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::AppResourceGroupMemoryReport>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppResourceGroupMemoryReport;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::AppResourceGroupMemoryReport is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::AppResourceGroupStateReport>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppResourceGroupStateReport;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::AppResourceGroupStateReport is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::AppUriHandlerHost>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppUriHandlerHost;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::AppUriHandlerHost is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::AppUriHandlerRegistration>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppUriHandlerRegistration;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::AppUriHandlerRegistration is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::AppUriHandlerRegistrationManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppUriHandlerRegistrationManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::AppUriHandlerRegistrationManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::DateTimeSettings>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DateTimeSettings;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::DateTimeSettings is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::DispatcherQueue>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DispatcherQueue;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::DispatcherQueue is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::DispatcherQueueController>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DispatcherQueueController;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::DispatcherQueueController is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::DispatcherQueueShutdownStartingEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DispatcherQueueShutdownStartingEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::DispatcherQueueShutdownStartingEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::DispatcherQueueTimer>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DispatcherQueueTimer;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::DispatcherQueueTimer is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::FolderLauncherOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FolderLauncherOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::FolderLauncherOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::KnownUserProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KnownUserProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::KnownUserProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::LaunchUriResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LaunchUriResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::LaunchUriResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::Launcher>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_Launcher;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Launcher is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::LauncherOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LauncherOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::LauncherOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::LauncherUIOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LauncherUIOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::LauncherUIOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::MemoryManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MemoryManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::MemoryManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::ProcessLauncher>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProcessLauncher;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::ProcessLauncher is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::ProcessLauncherOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProcessLauncherOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::ProcessLauncherOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::ProcessLauncherResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProcessLauncherResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::ProcessLauncherResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::ProcessMemoryReport>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProcessMemoryReport;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::ProcessMemoryReport is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::ProtocolForResultsOperation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProtocolForResultsOperation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::ProtocolForResultsOperation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::RemoteLauncher>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_RemoteLauncher;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::RemoteLauncher is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::RemoteLauncherOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_RemoteLauncherOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::RemoteLauncherOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::ShutdownManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ShutdownManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::ShutdownManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::TimeZoneSettings>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimeZoneSettings;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::TimeZoneSettings is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::User>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_User;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::User is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::UserAuthenticationStatusChangeDeferral>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UserAuthenticationStatusChangeDeferral;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::UserAuthenticationStatusChangeDeferral is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::UserAuthenticationStatusChangingEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UserAuthenticationStatusChangingEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::UserAuthenticationStatusChangingEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::UserChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UserChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::UserChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::UserDeviceAssociation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UserDeviceAssociation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::UserDeviceAssociation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::UserDeviceAssociationChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UserDeviceAssociationChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::UserDeviceAssociationChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::UserPicker>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UserPicker;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::UserPicker is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::UserWatcher>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UserWatcher;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::UserWatcher is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::ILauncherViewOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ILauncherViewOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::ILauncherViewOptions is not registered");
        return nullptr;
    }

    return python_type;
}
