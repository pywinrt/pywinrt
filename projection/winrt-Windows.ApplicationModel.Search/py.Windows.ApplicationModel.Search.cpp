// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

#include "py.Windows.ApplicationModel.Search.h"


namespace py::cpp::Windows::ApplicationModel::Search
{
    // ----- LocalContentSuggestionSettings class --------------------

    static PyObject* _new_LocalContentSuggestionSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Search::LocalContentSuggestionSettings instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LocalContentSuggestionSettings(py::wrapper::Windows::ApplicationModel::Search::LocalContentSuggestionSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LocalContentSuggestionSettings_get_Enabled(py::wrapper::Windows::ApplicationModel::Search::LocalContentSuggestionSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.LocalContentSuggestionSettings", L"Enabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LocalContentSuggestionSettings_put_Enabled(py::wrapper::Windows::ApplicationModel::Search::LocalContentSuggestionSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.LocalContentSuggestionSettings", L"Enabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LocalContentSuggestionSettings_get_AqsFilter(py::wrapper::Windows::ApplicationModel::Search::LocalContentSuggestionSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.LocalContentSuggestionSettings", L"AqsFilter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AqsFilter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LocalContentSuggestionSettings_put_AqsFilter(py::wrapper::Windows::ApplicationModel::Search::LocalContentSuggestionSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.LocalContentSuggestionSettings", L"AqsFilter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AqsFilter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LocalContentSuggestionSettings_get_Locations(py::wrapper::Windows::ApplicationModel::Search::LocalContentSuggestionSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.LocalContentSuggestionSettings", L"Locations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Locations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LocalContentSuggestionSettings_get_PropertiesToMatch(py::wrapper::Windows::ApplicationModel::Search::LocalContentSuggestionSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.LocalContentSuggestionSettings", L"PropertiesToMatch"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PropertiesToMatch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LocalContentSuggestionSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::LocalContentSuggestionSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LocalContentSuggestionSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::LocalContentSuggestionSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LocalContentSuggestionSettings[] = {
        { "_assign_array_", _assign_array_LocalContentSuggestionSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LocalContentSuggestionSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LocalContentSuggestionSettings[] = {
        { "enabled", reinterpret_cast<getter>(LocalContentSuggestionSettings_get_Enabled), reinterpret_cast<setter>(LocalContentSuggestionSettings_put_Enabled), nullptr, nullptr },
        { "aqs_filter", reinterpret_cast<getter>(LocalContentSuggestionSettings_get_AqsFilter), reinterpret_cast<setter>(LocalContentSuggestionSettings_put_AqsFilter), nullptr, nullptr },
        { "locations", reinterpret_cast<getter>(LocalContentSuggestionSettings_get_Locations), nullptr, nullptr, nullptr },
        { "properties_to_match", reinterpret_cast<getter>(LocalContentSuggestionSettings_get_PropertiesToMatch), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LocalContentSuggestionSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LocalContentSuggestionSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LocalContentSuggestionSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LocalContentSuggestionSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LocalContentSuggestionSettings) },
        { },
    };

    static PyType_Spec type_spec_LocalContentSuggestionSettings =
    {
        "winrt._winrt_windows_applicationmodel_search.LocalContentSuggestionSettings",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::LocalContentSuggestionSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LocalContentSuggestionSettings
    };

    // ----- SearchPane class --------------------

    static PyObject* _new_SearchPane(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPane>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPane>::type_name);
        return nullptr;
    }

    static void _dealloc_SearchPane(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchPane_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchPane", L"GetForCurrentView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Search::SearchPane::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchPane_HideThisApplication(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchPane", L"HideThisApplication", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::Windows::ApplicationModel::Search::SearchPane::HideThisApplication();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchPane_SetLocalContentSuggestionSettings(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchPane", L"SetLocalContentSuggestionSettings", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Search::LocalContentSuggestionSettings>(args, 0);

                self->obj.SetLocalContentSuggestionSettings(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchPane_Show(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchPane", L"Show", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Show();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchPane", L"Show", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Show(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchPane_TrySetQueryText(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchPane", L"TrySetQueryText", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TrySetQueryText(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchPane_get_ShowOnKeyboardInput(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPane", L"ShowOnKeyboardInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShowOnKeyboardInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SearchPane_put_ShowOnKeyboardInput(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPane", L"ShowOnKeyboardInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShowOnKeyboardInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SearchPane_get_SearchHistoryEnabled(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPane", L"SearchHistoryEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SearchHistoryEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SearchPane_put_SearchHistoryEnabled(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPane", L"SearchHistoryEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.SearchHistoryEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SearchPane_get_SearchHistoryContext(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPane", L"SearchHistoryContext"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SearchHistoryContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SearchPane_put_SearchHistoryContext(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPane", L"SearchHistoryContext"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SearchHistoryContext(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SearchPane_get_PlaceholderText(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPane", L"PlaceholderText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlaceholderText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SearchPane_put_PlaceholderText(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPane", L"PlaceholderText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PlaceholderText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SearchPane_get_Language(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPane", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_get_QueryText(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPane", L"QueryText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.QueryText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_get_Visible(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPane", L"Visible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Visible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_add_QueryChanged(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Search.SearchPane", L"QueryChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Search::SearchPane, winrt::Windows::ApplicationModel::Search::SearchPaneQueryChangedEventArgs>>(arg);

            return py::convert(self->obj.QueryChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_remove_QueryChanged(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Search.SearchPane", L"QueryChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.QueryChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_add_QuerySubmitted(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Search.SearchPane", L"QuerySubmitted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Search::SearchPane, winrt::Windows::ApplicationModel::Search::SearchPaneQuerySubmittedEventArgs>>(arg);

            return py::convert(self->obj.QuerySubmitted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_remove_QuerySubmitted(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Search.SearchPane", L"QuerySubmitted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.QuerySubmitted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_add_ResultSuggestionChosen(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Search.SearchPane", L"ResultSuggestionChosen"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Search::SearchPane, winrt::Windows::ApplicationModel::Search::SearchPaneResultSuggestionChosenEventArgs>>(arg);

            return py::convert(self->obj.ResultSuggestionChosen(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_remove_ResultSuggestionChosen(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Search.SearchPane", L"ResultSuggestionChosen"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ResultSuggestionChosen(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_add_SuggestionsRequested(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Search.SearchPane", L"SuggestionsRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Search::SearchPane, winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestedEventArgs>>(arg);

            return py::convert(self->obj.SuggestionsRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_remove_SuggestionsRequested(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Search.SearchPane", L"SuggestionsRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SuggestionsRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_add_VisibilityChanged(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Search.SearchPane", L"VisibilityChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Search::SearchPane, winrt::Windows::ApplicationModel::Search::SearchPaneVisibilityChangedEventArgs>>(arg);

            return py::convert(self->obj.VisibilityChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_remove_VisibilityChanged(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Search.SearchPane", L"VisibilityChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VisibilityChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchPane(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchPane>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchPane(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchPane>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchPane[] = {
        { "set_local_content_suggestion_settings", reinterpret_cast<PyCFunction>(SearchPane_SetLocalContentSuggestionSettings), METH_VARARGS, nullptr },
        { "show", reinterpret_cast<PyCFunction>(SearchPane_Show), METH_VARARGS, nullptr },
        { "try_set_query_text", reinterpret_cast<PyCFunction>(SearchPane_TrySetQueryText), METH_VARARGS, nullptr },
        { "add_query_changed", reinterpret_cast<PyCFunction>(SearchPane_add_QueryChanged), METH_O, nullptr },
        { "remove_query_changed", reinterpret_cast<PyCFunction>(SearchPane_remove_QueryChanged), METH_O, nullptr },
        { "add_query_submitted", reinterpret_cast<PyCFunction>(SearchPane_add_QuerySubmitted), METH_O, nullptr },
        { "remove_query_submitted", reinterpret_cast<PyCFunction>(SearchPane_remove_QuerySubmitted), METH_O, nullptr },
        { "add_result_suggestion_chosen", reinterpret_cast<PyCFunction>(SearchPane_add_ResultSuggestionChosen), METH_O, nullptr },
        { "remove_result_suggestion_chosen", reinterpret_cast<PyCFunction>(SearchPane_remove_ResultSuggestionChosen), METH_O, nullptr },
        { "add_suggestions_requested", reinterpret_cast<PyCFunction>(SearchPane_add_SuggestionsRequested), METH_O, nullptr },
        { "remove_suggestions_requested", reinterpret_cast<PyCFunction>(SearchPane_remove_SuggestionsRequested), METH_O, nullptr },
        { "add_visibility_changed", reinterpret_cast<PyCFunction>(SearchPane_add_VisibilityChanged), METH_O, nullptr },
        { "remove_visibility_changed", reinterpret_cast<PyCFunction>(SearchPane_remove_VisibilityChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_SearchPane, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchPane), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SearchPane[] = {
        { "show_on_keyboard_input", reinterpret_cast<getter>(SearchPane_get_ShowOnKeyboardInput), reinterpret_cast<setter>(SearchPane_put_ShowOnKeyboardInput), nullptr, nullptr },
        { "search_history_enabled", reinterpret_cast<getter>(SearchPane_get_SearchHistoryEnabled), reinterpret_cast<setter>(SearchPane_put_SearchHistoryEnabled), nullptr, nullptr },
        { "search_history_context", reinterpret_cast<getter>(SearchPane_get_SearchHistoryContext), reinterpret_cast<setter>(SearchPane_put_SearchHistoryContext), nullptr, nullptr },
        { "placeholder_text", reinterpret_cast<getter>(SearchPane_get_PlaceholderText), reinterpret_cast<setter>(SearchPane_put_PlaceholderText), nullptr, nullptr },
        { "language", reinterpret_cast<getter>(SearchPane_get_Language), nullptr, nullptr, nullptr },
        { "query_text", reinterpret_cast<getter>(SearchPane_get_QueryText), nullptr, nullptr, nullptr },
        { "visible", reinterpret_cast<getter>(SearchPane_get_Visible), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SearchPane[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchPane) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchPane) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchPane) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchPane) },
        { },
    };

    static PyType_Spec type_spec_SearchPane =
    {
        "winrt._winrt_windows_applicationmodel_search.SearchPane",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchPane),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchPane
    };

    static PyGetSetDef getset_SearchPane_Static[] = {
        { }
    };

    static PyMethodDef methods_SearchPane_Static[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(SearchPane_GetForCurrentView), METH_VARARGS, nullptr },
        { "hide_this_application", reinterpret_cast<PyCFunction>(SearchPane_HideThisApplication), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_SearchPane_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SearchPane_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SearchPane_Static) },
        { }
    };

    static PyType_Spec type_spec_SearchPane_Static =
    {
        "winrt._winrt_windows_applicationmodel_search.SearchPane_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SearchPane_Static
    };

    // ----- SearchPaneQueryChangedEventArgs class --------------------

    static PyObject* _new_SearchPaneQueryChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPaneQueryChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPaneQueryChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SearchPaneQueryChangedEventArgs(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQueryChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchPaneQueryChangedEventArgs_get_Language(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQueryChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneQueryChangedEventArgs", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPaneQueryChangedEventArgs_get_LinguisticDetails(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQueryChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneQueryChangedEventArgs", L"LinguisticDetails"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LinguisticDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPaneQueryChangedEventArgs_get_QueryText(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQueryChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneQueryChangedEventArgs", L"QueryText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.QueryText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchPaneQueryChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchPaneQueryChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchPaneQueryChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchPaneQueryChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchPaneQueryChangedEventArgs[] = {
        { "_assign_array_", _assign_array_SearchPaneQueryChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchPaneQueryChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SearchPaneQueryChangedEventArgs[] = {
        { "language", reinterpret_cast<getter>(SearchPaneQueryChangedEventArgs_get_Language), nullptr, nullptr, nullptr },
        { "linguistic_details", reinterpret_cast<getter>(SearchPaneQueryChangedEventArgs_get_LinguisticDetails), nullptr, nullptr, nullptr },
        { "query_text", reinterpret_cast<getter>(SearchPaneQueryChangedEventArgs_get_QueryText), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SearchPaneQueryChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchPaneQueryChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchPaneQueryChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchPaneQueryChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchPaneQueryChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SearchPaneQueryChangedEventArgs =
    {
        "winrt._winrt_windows_applicationmodel_search.SearchPaneQueryChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQueryChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchPaneQueryChangedEventArgs
    };

    // ----- SearchPaneQueryLinguisticDetails class --------------------

    static PyObject* _new_SearchPaneQueryLinguisticDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPaneQueryLinguisticDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPaneQueryLinguisticDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_SearchPaneQueryLinguisticDetails(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQueryLinguisticDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchPaneQueryLinguisticDetails_get_QueryTextAlternatives(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQueryLinguisticDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneQueryLinguisticDetails", L"QueryTextAlternatives"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.QueryTextAlternatives());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPaneQueryLinguisticDetails_get_QueryTextCompositionLength(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQueryLinguisticDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneQueryLinguisticDetails", L"QueryTextCompositionLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.QueryTextCompositionLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPaneQueryLinguisticDetails_get_QueryTextCompositionStart(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQueryLinguisticDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneQueryLinguisticDetails", L"QueryTextCompositionStart"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.QueryTextCompositionStart());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchPaneQueryLinguisticDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchPaneQueryLinguisticDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchPaneQueryLinguisticDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchPaneQueryLinguisticDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchPaneQueryLinguisticDetails[] = {
        { "_assign_array_", _assign_array_SearchPaneQueryLinguisticDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchPaneQueryLinguisticDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SearchPaneQueryLinguisticDetails[] = {
        { "query_text_alternatives", reinterpret_cast<getter>(SearchPaneQueryLinguisticDetails_get_QueryTextAlternatives), nullptr, nullptr, nullptr },
        { "query_text_composition_length", reinterpret_cast<getter>(SearchPaneQueryLinguisticDetails_get_QueryTextCompositionLength), nullptr, nullptr, nullptr },
        { "query_text_composition_start", reinterpret_cast<getter>(SearchPaneQueryLinguisticDetails_get_QueryTextCompositionStart), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SearchPaneQueryLinguisticDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchPaneQueryLinguisticDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchPaneQueryLinguisticDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchPaneQueryLinguisticDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchPaneQueryLinguisticDetails) },
        { },
    };

    static PyType_Spec type_spec_SearchPaneQueryLinguisticDetails =
    {
        "winrt._winrt_windows_applicationmodel_search.SearchPaneQueryLinguisticDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQueryLinguisticDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchPaneQueryLinguisticDetails
    };

    // ----- SearchPaneQuerySubmittedEventArgs class --------------------

    static PyObject* _new_SearchPaneQuerySubmittedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPaneQuerySubmittedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPaneQuerySubmittedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SearchPaneQuerySubmittedEventArgs(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQuerySubmittedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchPaneQuerySubmittedEventArgs_get_Language(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQuerySubmittedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneQuerySubmittedEventArgs", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPaneQuerySubmittedEventArgs_get_QueryText(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQuerySubmittedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneQuerySubmittedEventArgs", L"QueryText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.QueryText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPaneQuerySubmittedEventArgs_get_LinguisticDetails(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQuerySubmittedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneQuerySubmittedEventArgs", L"LinguisticDetails"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LinguisticDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchPaneQuerySubmittedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchPaneQuerySubmittedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchPaneQuerySubmittedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchPaneQuerySubmittedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchPaneQuerySubmittedEventArgs[] = {
        { "_assign_array_", _assign_array_SearchPaneQuerySubmittedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchPaneQuerySubmittedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SearchPaneQuerySubmittedEventArgs[] = {
        { "language", reinterpret_cast<getter>(SearchPaneQuerySubmittedEventArgs_get_Language), nullptr, nullptr, nullptr },
        { "query_text", reinterpret_cast<getter>(SearchPaneQuerySubmittedEventArgs_get_QueryText), nullptr, nullptr, nullptr },
        { "linguistic_details", reinterpret_cast<getter>(SearchPaneQuerySubmittedEventArgs_get_LinguisticDetails), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SearchPaneQuerySubmittedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchPaneQuerySubmittedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchPaneQuerySubmittedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchPaneQuerySubmittedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchPaneQuerySubmittedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SearchPaneQuerySubmittedEventArgs =
    {
        "winrt._winrt_windows_applicationmodel_search.SearchPaneQuerySubmittedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQuerySubmittedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchPaneQuerySubmittedEventArgs
    };

    // ----- SearchPaneResultSuggestionChosenEventArgs class --------------------

    static PyObject* _new_SearchPaneResultSuggestionChosenEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPaneResultSuggestionChosenEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPaneResultSuggestionChosenEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SearchPaneResultSuggestionChosenEventArgs(py::wrapper::Windows::ApplicationModel::Search::SearchPaneResultSuggestionChosenEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchPaneResultSuggestionChosenEventArgs_get_Tag(py::wrapper::Windows::ApplicationModel::Search::SearchPaneResultSuggestionChosenEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneResultSuggestionChosenEventArgs", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchPaneResultSuggestionChosenEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchPaneResultSuggestionChosenEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchPaneResultSuggestionChosenEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchPaneResultSuggestionChosenEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchPaneResultSuggestionChosenEventArgs[] = {
        { "_assign_array_", _assign_array_SearchPaneResultSuggestionChosenEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchPaneResultSuggestionChosenEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SearchPaneResultSuggestionChosenEventArgs[] = {
        { "tag", reinterpret_cast<getter>(SearchPaneResultSuggestionChosenEventArgs_get_Tag), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SearchPaneResultSuggestionChosenEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchPaneResultSuggestionChosenEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchPaneResultSuggestionChosenEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchPaneResultSuggestionChosenEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchPaneResultSuggestionChosenEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SearchPaneResultSuggestionChosenEventArgs =
    {
        "winrt._winrt_windows_applicationmodel_search.SearchPaneResultSuggestionChosenEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchPaneResultSuggestionChosenEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchPaneResultSuggestionChosenEventArgs
    };

    // ----- SearchPaneSuggestionsRequest class --------------------

    static PyObject* _new_SearchPaneSuggestionsRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_SearchPaneSuggestionsRequest(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchPaneSuggestionsRequest_GetDeferral(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchPaneSuggestionsRequest", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchPaneSuggestionsRequest_get_IsCanceled(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneSuggestionsRequest", L"IsCanceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCanceled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPaneSuggestionsRequest_get_SearchSuggestionCollection(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneSuggestionsRequest", L"SearchSuggestionCollection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SearchSuggestionCollection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchPaneSuggestionsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchPaneSuggestionsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchPaneSuggestionsRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(SearchPaneSuggestionsRequest_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SearchPaneSuggestionsRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchPaneSuggestionsRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SearchPaneSuggestionsRequest[] = {
        { "is_canceled", reinterpret_cast<getter>(SearchPaneSuggestionsRequest_get_IsCanceled), nullptr, nullptr, nullptr },
        { "search_suggestion_collection", reinterpret_cast<getter>(SearchPaneSuggestionsRequest_get_SearchSuggestionCollection), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SearchPaneSuggestionsRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchPaneSuggestionsRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchPaneSuggestionsRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchPaneSuggestionsRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchPaneSuggestionsRequest) },
        { },
    };

    static PyType_Spec type_spec_SearchPaneSuggestionsRequest =
    {
        "winrt._winrt_windows_applicationmodel_search.SearchPaneSuggestionsRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchPaneSuggestionsRequest
    };

    // ----- SearchPaneSuggestionsRequestDeferral class --------------------

    static PyObject* _new_SearchPaneSuggestionsRequestDeferral(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestDeferral>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestDeferral>::type_name);
        return nullptr;
    }

    static void _dealloc_SearchPaneSuggestionsRequestDeferral(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchPaneSuggestionsRequestDeferral_Complete(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestDeferral", L"Complete", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchPaneSuggestionsRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchPaneSuggestionsRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchPaneSuggestionsRequestDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(SearchPaneSuggestionsRequestDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SearchPaneSuggestionsRequestDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchPaneSuggestionsRequestDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SearchPaneSuggestionsRequestDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_SearchPaneSuggestionsRequestDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchPaneSuggestionsRequestDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchPaneSuggestionsRequestDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchPaneSuggestionsRequestDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchPaneSuggestionsRequestDeferral) },
        { },
    };

    static PyType_Spec type_spec_SearchPaneSuggestionsRequestDeferral =
    {
        "winrt._winrt_windows_applicationmodel_search.SearchPaneSuggestionsRequestDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchPaneSuggestionsRequestDeferral
    };

    // ----- SearchPaneSuggestionsRequestedEventArgs class --------------------

    static PyObject* _new_SearchPaneSuggestionsRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SearchPaneSuggestionsRequestedEventArgs(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchPaneSuggestionsRequestedEventArgs_get_Language(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPaneSuggestionsRequestedEventArgs_get_LinguisticDetails(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs", L"LinguisticDetails"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LinguisticDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPaneSuggestionsRequestedEventArgs_get_QueryText(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs", L"QueryText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.QueryText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPaneSuggestionsRequestedEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchPaneSuggestionsRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchPaneSuggestionsRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchPaneSuggestionsRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_SearchPaneSuggestionsRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchPaneSuggestionsRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SearchPaneSuggestionsRequestedEventArgs[] = {
        { "language", reinterpret_cast<getter>(SearchPaneSuggestionsRequestedEventArgs_get_Language), nullptr, nullptr, nullptr },
        { "linguistic_details", reinterpret_cast<getter>(SearchPaneSuggestionsRequestedEventArgs_get_LinguisticDetails), nullptr, nullptr, nullptr },
        { "query_text", reinterpret_cast<getter>(SearchPaneSuggestionsRequestedEventArgs_get_QueryText), nullptr, nullptr, nullptr },
        { "request", reinterpret_cast<getter>(SearchPaneSuggestionsRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SearchPaneSuggestionsRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchPaneSuggestionsRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchPaneSuggestionsRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchPaneSuggestionsRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchPaneSuggestionsRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SearchPaneSuggestionsRequestedEventArgs =
    {
        "winrt._winrt_windows_applicationmodel_search.SearchPaneSuggestionsRequestedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchPaneSuggestionsRequestedEventArgs
    };

    // ----- SearchPaneVisibilityChangedEventArgs class --------------------

    static PyObject* _new_SearchPaneVisibilityChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPaneVisibilityChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPaneVisibilityChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SearchPaneVisibilityChangedEventArgs(py::wrapper::Windows::ApplicationModel::Search::SearchPaneVisibilityChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchPaneVisibilityChangedEventArgs_get_Visible(py::wrapper::Windows::ApplicationModel::Search::SearchPaneVisibilityChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneVisibilityChangedEventArgs", L"Visible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Visible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchPaneVisibilityChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchPaneVisibilityChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchPaneVisibilityChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchPaneVisibilityChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchPaneVisibilityChangedEventArgs[] = {
        { "_assign_array_", _assign_array_SearchPaneVisibilityChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchPaneVisibilityChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SearchPaneVisibilityChangedEventArgs[] = {
        { "visible", reinterpret_cast<getter>(SearchPaneVisibilityChangedEventArgs_get_Visible), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SearchPaneVisibilityChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchPaneVisibilityChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchPaneVisibilityChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchPaneVisibilityChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchPaneVisibilityChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SearchPaneVisibilityChangedEventArgs =
    {
        "winrt._winrt_windows_applicationmodel_search.SearchPaneVisibilityChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchPaneVisibilityChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchPaneVisibilityChangedEventArgs
    };

    // ----- SearchQueryLinguisticDetails class --------------------

    static PyObject* _new_SearchQueryLinguisticDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                winrt::Windows::ApplicationModel::Search::SearchQueryLinguisticDetails instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SearchQueryLinguisticDetails(py::wrapper::Windows::ApplicationModel::Search::SearchQueryLinguisticDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchQueryLinguisticDetails_get_QueryTextAlternatives(py::wrapper::Windows::ApplicationModel::Search::SearchQueryLinguisticDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchQueryLinguisticDetails", L"QueryTextAlternatives"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.QueryTextAlternatives());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchQueryLinguisticDetails_get_QueryTextCompositionLength(py::wrapper::Windows::ApplicationModel::Search::SearchQueryLinguisticDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchQueryLinguisticDetails", L"QueryTextCompositionLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.QueryTextCompositionLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchQueryLinguisticDetails_get_QueryTextCompositionStart(py::wrapper::Windows::ApplicationModel::Search::SearchQueryLinguisticDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchQueryLinguisticDetails", L"QueryTextCompositionStart"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.QueryTextCompositionStart());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchQueryLinguisticDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchQueryLinguisticDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchQueryLinguisticDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchQueryLinguisticDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchQueryLinguisticDetails[] = {
        { "_assign_array_", _assign_array_SearchQueryLinguisticDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchQueryLinguisticDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SearchQueryLinguisticDetails[] = {
        { "query_text_alternatives", reinterpret_cast<getter>(SearchQueryLinguisticDetails_get_QueryTextAlternatives), nullptr, nullptr, nullptr },
        { "query_text_composition_length", reinterpret_cast<getter>(SearchQueryLinguisticDetails_get_QueryTextCompositionLength), nullptr, nullptr, nullptr },
        { "query_text_composition_start", reinterpret_cast<getter>(SearchQueryLinguisticDetails_get_QueryTextCompositionStart), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SearchQueryLinguisticDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchQueryLinguisticDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchQueryLinguisticDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchQueryLinguisticDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchQueryLinguisticDetails) },
        { },
    };

    static PyType_Spec type_spec_SearchQueryLinguisticDetails =
    {
        "winrt._winrt_windows_applicationmodel_search.SearchQueryLinguisticDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchQueryLinguisticDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchQueryLinguisticDetails
    };

    // ----- SearchSuggestionCollection class --------------------

    static PyObject* _new_SearchSuggestionCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Search::SearchSuggestionCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Search::SearchSuggestionCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_SearchSuggestionCollection(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchSuggestionCollection_AppendQuerySuggestion(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchSuggestionCollection", L"AppendQuerySuggestion", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.AppendQuerySuggestion(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchSuggestionCollection_AppendQuerySuggestions(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchSuggestionCollection", L"AppendQuerySuggestions", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                self->obj.AppendQuerySuggestions(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchSuggestionCollection_AppendResultSuggestion(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchSuggestionCollection", L"AppendResultSuggestion", 5))
            {
                py::set_arg_count_version_error(5);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);

                self->obj.AppendResultSuggestion(param0, param1, param2, param3, param4);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchSuggestionCollection_AppendSearchSeparator(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchSuggestionCollection", L"AppendSearchSeparator", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.AppendSearchSeparator(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchSuggestionCollection_get_Size(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchSuggestionCollection", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchSuggestionCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchSuggestionCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchSuggestionCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchSuggestionCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchSuggestionCollection[] = {
        { "append_query_suggestion", reinterpret_cast<PyCFunction>(SearchSuggestionCollection_AppendQuerySuggestion), METH_VARARGS, nullptr },
        { "append_query_suggestions", reinterpret_cast<PyCFunction>(SearchSuggestionCollection_AppendQuerySuggestions), METH_VARARGS, nullptr },
        { "append_result_suggestion", reinterpret_cast<PyCFunction>(SearchSuggestionCollection_AppendResultSuggestion), METH_VARARGS, nullptr },
        { "append_search_separator", reinterpret_cast<PyCFunction>(SearchSuggestionCollection_AppendSearchSeparator), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SearchSuggestionCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchSuggestionCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SearchSuggestionCollection[] = {
        { "size", reinterpret_cast<getter>(SearchSuggestionCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SearchSuggestionCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchSuggestionCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchSuggestionCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchSuggestionCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchSuggestionCollection) },
        { },
    };

    static PyType_Spec type_spec_SearchSuggestionCollection =
    {
        "winrt._winrt_windows_applicationmodel_search.SearchSuggestionCollection",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchSuggestionCollection
    };

    // ----- SearchSuggestionsRequest class --------------------

    static PyObject* _new_SearchSuggestionsRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Search::SearchSuggestionsRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Search::SearchSuggestionsRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_SearchSuggestionsRequest(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionsRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchSuggestionsRequest_GetDeferral(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionsRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchSuggestionsRequest", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchSuggestionsRequest_get_IsCanceled(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionsRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchSuggestionsRequest", L"IsCanceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCanceled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchSuggestionsRequest_get_SearchSuggestionCollection(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionsRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchSuggestionsRequest", L"SearchSuggestionCollection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SearchSuggestionCollection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchSuggestionsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchSuggestionsRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchSuggestionsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchSuggestionsRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchSuggestionsRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(SearchSuggestionsRequest_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SearchSuggestionsRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchSuggestionsRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SearchSuggestionsRequest[] = {
        { "is_canceled", reinterpret_cast<getter>(SearchSuggestionsRequest_get_IsCanceled), nullptr, nullptr, nullptr },
        { "search_suggestion_collection", reinterpret_cast<getter>(SearchSuggestionsRequest_get_SearchSuggestionCollection), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SearchSuggestionsRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchSuggestionsRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchSuggestionsRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchSuggestionsRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchSuggestionsRequest) },
        { },
    };

    static PyType_Spec type_spec_SearchSuggestionsRequest =
    {
        "winrt._winrt_windows_applicationmodel_search.SearchSuggestionsRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionsRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchSuggestionsRequest
    };

    // ----- SearchSuggestionsRequestDeferral class --------------------

    static PyObject* _new_SearchSuggestionsRequestDeferral(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Search::SearchSuggestionsRequestDeferral>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Search::SearchSuggestionsRequestDeferral>::type_name);
        return nullptr;
    }

    static void _dealloc_SearchSuggestionsRequestDeferral(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionsRequestDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchSuggestionsRequestDeferral_Complete(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionsRequestDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchSuggestionsRequestDeferral", L"Complete", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchSuggestionsRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchSuggestionsRequestDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchSuggestionsRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchSuggestionsRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchSuggestionsRequestDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(SearchSuggestionsRequestDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SearchSuggestionsRequestDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchSuggestionsRequestDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SearchSuggestionsRequestDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_SearchSuggestionsRequestDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchSuggestionsRequestDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchSuggestionsRequestDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchSuggestionsRequestDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchSuggestionsRequestDeferral) },
        { },
    };

    static PyType_Spec type_spec_SearchSuggestionsRequestDeferral =
    {
        "winrt._winrt_windows_applicationmodel_search.SearchSuggestionsRequestDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionsRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchSuggestionsRequestDeferral
    };

    // ----- ISearchPaneQueryChangedEventArgs interface --------------------

    static PyObject* _new_ISearchPaneQueryChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Search::ISearchPaneQueryChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Search::ISearchPaneQueryChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ISearchPaneQueryChangedEventArgs(py::wrapper::Windows::ApplicationModel::Search::ISearchPaneQueryChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISearchPaneQueryChangedEventArgs_get_Language(py::wrapper::Windows::ApplicationModel::Search::ISearchPaneQueryChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.ISearchPaneQueryChangedEventArgs", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISearchPaneQueryChangedEventArgs_get_LinguisticDetails(py::wrapper::Windows::ApplicationModel::Search::ISearchPaneQueryChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.ISearchPaneQueryChangedEventArgs", L"LinguisticDetails"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LinguisticDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISearchPaneQueryChangedEventArgs_get_QueryText(py::wrapper::Windows::ApplicationModel::Search::ISearchPaneQueryChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.ISearchPaneQueryChangedEventArgs", L"QueryText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.QueryText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ISearchPaneQueryChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::ISearchPaneQueryChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISearchPaneQueryChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::ISearchPaneQueryChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISearchPaneQueryChangedEventArgs[] = {
        { "_assign_array_", _assign_array_ISearchPaneQueryChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISearchPaneQueryChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISearchPaneQueryChangedEventArgs[] = {
        { "language", reinterpret_cast<getter>(ISearchPaneQueryChangedEventArgs_get_Language), nullptr, nullptr, nullptr },
        { "linguistic_details", reinterpret_cast<getter>(ISearchPaneQueryChangedEventArgs_get_LinguisticDetails), nullptr, nullptr, nullptr },
        { "query_text", reinterpret_cast<getter>(ISearchPaneQueryChangedEventArgs_get_QueryText), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ISearchPaneQueryChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISearchPaneQueryChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISearchPaneQueryChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISearchPaneQueryChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISearchPaneQueryChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ISearchPaneQueryChangedEventArgs =
    {
        "winrt._winrt_windows_applicationmodel_search.ISearchPaneQueryChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::ISearchPaneQueryChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISearchPaneQueryChangedEventArgs
    };

    // ----- Windows.ApplicationModel.Search Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::ApplicationModel::Search");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_applicationmodel_search",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::ApplicationModel::Search

PyMODINIT_FUNC PyInit__winrt_windows_applicationmodel_search(void) noexcept
{
    using namespace py::cpp::Windows::ApplicationModel::Search;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LocalContentSuggestionSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SearchPane_Static{PyType_FromSpec(&type_spec_SearchPane_Static)};
    if (!type_SearchPane_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SearchPane, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SearchPane_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SearchPaneQueryChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SearchPaneQueryLinguisticDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SearchPaneQuerySubmittedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SearchPaneResultSuggestionChosenEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SearchPaneSuggestionsRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SearchPaneSuggestionsRequestDeferral, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SearchPaneSuggestionsRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SearchPaneVisibilityChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SearchQueryLinguisticDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SearchSuggestionCollection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SearchSuggestionsRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SearchSuggestionsRequestDeferral, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ISearchPaneQueryChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
