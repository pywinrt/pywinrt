// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

#include "py.Windows.Media.Control.h"


namespace py::cpp::Windows::Media::Control
{
    // ----- CurrentSessionChangedEventArgs class --------------------

    static PyObject* _new_CurrentSessionChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Control::CurrentSessionChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Control::CurrentSessionChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CurrentSessionChangedEventArgs(py::wrapper::Windows::Media::Control::CurrentSessionChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CurrentSessionChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Control::CurrentSessionChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CurrentSessionChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Control::CurrentSessionChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CurrentSessionChangedEventArgs[] = {
        { "_assign_array_", _assign_array_CurrentSessionChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CurrentSessionChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CurrentSessionChangedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_CurrentSessionChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CurrentSessionChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CurrentSessionChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CurrentSessionChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CurrentSessionChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CurrentSessionChangedEventArgs =
    {
        "winrt._winrt_windows_media_control.CurrentSessionChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Control::CurrentSessionChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CurrentSessionChangedEventArgs
    };

    // ----- GlobalSystemMediaTransportControlsSession class --------------------

    static PyObject* _new_GlobalSystemMediaTransportControlsSession(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSession>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSession>::type_name);
        return nullptr;
    }

    static void _dealloc_GlobalSystemMediaTransportControlsSession(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_GetPlaybackInfo(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"GetPlaybackInfo", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetPlaybackInfo());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_GetTimelineProperties(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"GetTimelineProperties", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetTimelineProperties());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_TryChangeAutoRepeatModeAsync(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TryChangeAutoRepeatModeAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaPlaybackAutoRepeatMode>(args, 0);

                return py::convert(self->obj.TryChangeAutoRepeatModeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_TryChangeChannelDownAsync(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TryChangeChannelDownAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryChangeChannelDownAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_TryChangeChannelUpAsync(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TryChangeChannelUpAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryChangeChannelUpAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_TryChangePlaybackPositionAsync(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TryChangePlaybackPositionAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int64_t>(args, 0);

                return py::convert(self->obj.TryChangePlaybackPositionAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_TryChangePlaybackRateAsync(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TryChangePlaybackRateAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(self->obj.TryChangePlaybackRateAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_TryChangeShuffleActiveAsync(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TryChangeShuffleActiveAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.TryChangeShuffleActiveAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_TryFastForwardAsync(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TryFastForwardAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryFastForwardAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_TryGetMediaPropertiesAsync(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TryGetMediaPropertiesAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryGetMediaPropertiesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_TryPauseAsync(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TryPauseAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryPauseAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_TryPlayAsync(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TryPlayAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryPlayAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_TryRecordAsync(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TryRecordAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryRecordAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_TryRewindAsync(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TryRewindAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryRewindAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_TrySkipNextAsync(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TrySkipNextAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TrySkipNextAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_TrySkipPreviousAsync(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TrySkipPreviousAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TrySkipPreviousAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_TryStopAsync(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TryStopAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryStopAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_TryTogglePlayPauseAsync(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TryTogglePlayPauseAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryTogglePlayPauseAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_get_SourceAppUserModelId(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"SourceAppUserModelId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceAppUserModelId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_add_MediaPropertiesChanged(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"MediaPropertiesChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSession, winrt::Windows::Media::Control::MediaPropertiesChangedEventArgs>>(arg);

            return py::convert(self->obj.MediaPropertiesChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_remove_MediaPropertiesChanged(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"MediaPropertiesChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MediaPropertiesChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_add_PlaybackInfoChanged(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"PlaybackInfoChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSession, winrt::Windows::Media::Control::PlaybackInfoChangedEventArgs>>(arg);

            return py::convert(self->obj.PlaybackInfoChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_remove_PlaybackInfoChanged(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"PlaybackInfoChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PlaybackInfoChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_add_TimelinePropertiesChanged(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TimelinePropertiesChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSession, winrt::Windows::Media::Control::TimelinePropertiesChangedEventArgs>>(arg);

            return py::convert(self->obj.TimelinePropertiesChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_remove_TimelinePropertiesChanged(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TimelinePropertiesChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TimelinePropertiesChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GlobalSystemMediaTransportControlsSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GlobalSystemMediaTransportControlsSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GlobalSystemMediaTransportControlsSession[] = {
        { "get_playback_info", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_GetPlaybackInfo), METH_VARARGS, nullptr },
        { "get_timeline_properties", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_GetTimelineProperties), METH_VARARGS, nullptr },
        { "try_change_auto_repeat_mode_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_TryChangeAutoRepeatModeAsync), METH_VARARGS, nullptr },
        { "try_change_channel_down_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_TryChangeChannelDownAsync), METH_VARARGS, nullptr },
        { "try_change_channel_up_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_TryChangeChannelUpAsync), METH_VARARGS, nullptr },
        { "try_change_playback_position_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_TryChangePlaybackPositionAsync), METH_VARARGS, nullptr },
        { "try_change_playback_rate_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_TryChangePlaybackRateAsync), METH_VARARGS, nullptr },
        { "try_change_shuffle_active_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_TryChangeShuffleActiveAsync), METH_VARARGS, nullptr },
        { "try_fast_forward_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_TryFastForwardAsync), METH_VARARGS, nullptr },
        { "try_get_media_properties_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_TryGetMediaPropertiesAsync), METH_VARARGS, nullptr },
        { "try_pause_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_TryPauseAsync), METH_VARARGS, nullptr },
        { "try_play_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_TryPlayAsync), METH_VARARGS, nullptr },
        { "try_record_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_TryRecordAsync), METH_VARARGS, nullptr },
        { "try_rewind_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_TryRewindAsync), METH_VARARGS, nullptr },
        { "try_skip_next_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_TrySkipNextAsync), METH_VARARGS, nullptr },
        { "try_skip_previous_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_TrySkipPreviousAsync), METH_VARARGS, nullptr },
        { "try_stop_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_TryStopAsync), METH_VARARGS, nullptr },
        { "try_toggle_play_pause_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_TryTogglePlayPauseAsync), METH_VARARGS, nullptr },
        { "add_media_properties_changed", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_add_MediaPropertiesChanged), METH_O, nullptr },
        { "remove_media_properties_changed", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_remove_MediaPropertiesChanged), METH_O, nullptr },
        { "add_playback_info_changed", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_add_PlaybackInfoChanged), METH_O, nullptr },
        { "remove_playback_info_changed", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_remove_PlaybackInfoChanged), METH_O, nullptr },
        { "add_timeline_properties_changed", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_add_TimelinePropertiesChanged), METH_O, nullptr },
        { "remove_timeline_properties_changed", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_remove_TimelinePropertiesChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_GlobalSystemMediaTransportControlsSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GlobalSystemMediaTransportControlsSession), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GlobalSystemMediaTransportControlsSession[] = {
        { "source_app_user_model_id", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSession_get_SourceAppUserModelId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GlobalSystemMediaTransportControlsSession[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GlobalSystemMediaTransportControlsSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GlobalSystemMediaTransportControlsSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GlobalSystemMediaTransportControlsSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GlobalSystemMediaTransportControlsSession) },
        { },
    };

    static PyType_Spec type_spec_GlobalSystemMediaTransportControlsSession =
    {
        "winrt._winrt_windows_media_control.GlobalSystemMediaTransportControlsSession",
        sizeof(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GlobalSystemMediaTransportControlsSession
    };

    // ----- GlobalSystemMediaTransportControlsSessionManager class --------------------

    static PyObject* _new_GlobalSystemMediaTransportControlsSessionManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionManager>::type_name);
        return nullptr;
    }

    static void _dealloc_GlobalSystemMediaTransportControlsSessionManager(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionManager_GetCurrentSession(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionManager", L"GetCurrentSession", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentSession());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionManager_GetSessions(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionManager", L"GetSessions", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetSessions());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionManager_RequestAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionManager", L"RequestAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionManager::RequestAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionManager_add_CurrentSessionChanged(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionManager", L"CurrentSessionChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionManager, winrt::Windows::Media::Control::CurrentSessionChangedEventArgs>>(arg);

            return py::convert(self->obj.CurrentSessionChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionManager_remove_CurrentSessionChanged(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionManager", L"CurrentSessionChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CurrentSessionChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionManager_add_SessionsChanged(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionManager", L"SessionsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionManager, winrt::Windows::Media::Control::SessionsChangedEventArgs>>(arg);

            return py::convert(self->obj.SessionsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionManager_remove_SessionsChanged(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionManager", L"SessionsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SessionsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GlobalSystemMediaTransportControlsSessionManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GlobalSystemMediaTransportControlsSessionManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GlobalSystemMediaTransportControlsSessionManager[] = {
        { "get_current_session", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSessionManager_GetCurrentSession), METH_VARARGS, nullptr },
        { "get_sessions", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSessionManager_GetSessions), METH_VARARGS, nullptr },
        { "add_current_session_changed", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSessionManager_add_CurrentSessionChanged), METH_O, nullptr },
        { "remove_current_session_changed", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSessionManager_remove_CurrentSessionChanged), METH_O, nullptr },
        { "add_sessions_changed", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSessionManager_add_SessionsChanged), METH_O, nullptr },
        { "remove_sessions_changed", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSessionManager_remove_SessionsChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_GlobalSystemMediaTransportControlsSessionManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GlobalSystemMediaTransportControlsSessionManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GlobalSystemMediaTransportControlsSessionManager[] = {
        { }
    };

    static PyType_Slot _type_slots_GlobalSystemMediaTransportControlsSessionManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GlobalSystemMediaTransportControlsSessionManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GlobalSystemMediaTransportControlsSessionManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GlobalSystemMediaTransportControlsSessionManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GlobalSystemMediaTransportControlsSessionManager) },
        { },
    };

    static PyType_Spec type_spec_GlobalSystemMediaTransportControlsSessionManager =
    {
        "winrt._winrt_windows_media_control.GlobalSystemMediaTransportControlsSessionManager",
        sizeof(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GlobalSystemMediaTransportControlsSessionManager
    };

    static PyGetSetDef getset_GlobalSystemMediaTransportControlsSessionManager_Static[] = {
        { }
    };

    static PyMethodDef methods_GlobalSystemMediaTransportControlsSessionManager_Static[] = {
        { "request_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSessionManager_RequestAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_GlobalSystemMediaTransportControlsSessionManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GlobalSystemMediaTransportControlsSessionManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GlobalSystemMediaTransportControlsSessionManager_Static) },
        { }
    };

    static PyType_Spec type_spec_GlobalSystemMediaTransportControlsSessionManager_Static =
    {
        "winrt._winrt_windows_media_control.GlobalSystemMediaTransportControlsSessionManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GlobalSystemMediaTransportControlsSessionManager_Static
    };

    // ----- GlobalSystemMediaTransportControlsSessionMediaProperties class --------------------

    static PyObject* _new_GlobalSystemMediaTransportControlsSessionMediaProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionMediaProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionMediaProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_GlobalSystemMediaTransportControlsSessionMediaProperties(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionMediaProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionMediaProperties_get_AlbumArtist(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionMediaProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionMediaProperties", L"AlbumArtist"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AlbumArtist());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionMediaProperties_get_AlbumTitle(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionMediaProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionMediaProperties", L"AlbumTitle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AlbumTitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionMediaProperties_get_AlbumTrackCount(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionMediaProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionMediaProperties", L"AlbumTrackCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AlbumTrackCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionMediaProperties_get_Artist(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionMediaProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionMediaProperties", L"Artist"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Artist());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionMediaProperties_get_Genres(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionMediaProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionMediaProperties", L"Genres"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Genres());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionMediaProperties_get_PlaybackType(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionMediaProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionMediaProperties", L"PlaybackType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlaybackType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionMediaProperties_get_Subtitle(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionMediaProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionMediaProperties", L"Subtitle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Subtitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionMediaProperties_get_Thumbnail(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionMediaProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionMediaProperties", L"Thumbnail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionMediaProperties_get_Title(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionMediaProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionMediaProperties", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionMediaProperties_get_TrackNumber(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionMediaProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionMediaProperties", L"TrackNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TrackNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GlobalSystemMediaTransportControlsSessionMediaProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionMediaProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GlobalSystemMediaTransportControlsSessionMediaProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionMediaProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GlobalSystemMediaTransportControlsSessionMediaProperties[] = {
        { "_assign_array_", _assign_array_GlobalSystemMediaTransportControlsSessionMediaProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GlobalSystemMediaTransportControlsSessionMediaProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GlobalSystemMediaTransportControlsSessionMediaProperties[] = {
        { "album_artist", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionMediaProperties_get_AlbumArtist), nullptr, nullptr, nullptr },
        { "album_title", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionMediaProperties_get_AlbumTitle), nullptr, nullptr, nullptr },
        { "album_track_count", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionMediaProperties_get_AlbumTrackCount), nullptr, nullptr, nullptr },
        { "artist", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionMediaProperties_get_Artist), nullptr, nullptr, nullptr },
        { "genres", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionMediaProperties_get_Genres), nullptr, nullptr, nullptr },
        { "playback_type", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionMediaProperties_get_PlaybackType), nullptr, nullptr, nullptr },
        { "subtitle", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionMediaProperties_get_Subtitle), nullptr, nullptr, nullptr },
        { "thumbnail", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionMediaProperties_get_Thumbnail), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionMediaProperties_get_Title), nullptr, nullptr, nullptr },
        { "track_number", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionMediaProperties_get_TrackNumber), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GlobalSystemMediaTransportControlsSessionMediaProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GlobalSystemMediaTransportControlsSessionMediaProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GlobalSystemMediaTransportControlsSessionMediaProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GlobalSystemMediaTransportControlsSessionMediaProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GlobalSystemMediaTransportControlsSessionMediaProperties) },
        { },
    };

    static PyType_Spec type_spec_GlobalSystemMediaTransportControlsSessionMediaProperties =
    {
        "winrt._winrt_windows_media_control.GlobalSystemMediaTransportControlsSessionMediaProperties",
        sizeof(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionMediaProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GlobalSystemMediaTransportControlsSessionMediaProperties
    };

    // ----- GlobalSystemMediaTransportControlsSessionPlaybackControls class --------------------

    static PyObject* _new_GlobalSystemMediaTransportControlsSessionPlaybackControls(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls>::type_name);
        return nullptr;
    }

    static void _dealloc_GlobalSystemMediaTransportControlsSessionPlaybackControls(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsChannelDownEnabled(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackControls", L"IsChannelDownEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsChannelDownEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsChannelUpEnabled(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackControls", L"IsChannelUpEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsChannelUpEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsFastForwardEnabled(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackControls", L"IsFastForwardEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsFastForwardEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsNextEnabled(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackControls", L"IsNextEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsNextEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsPauseEnabled(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackControls", L"IsPauseEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPauseEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsPlayEnabled(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackControls", L"IsPlayEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPlayEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsPlayPauseToggleEnabled(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackControls", L"IsPlayPauseToggleEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPlayPauseToggleEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsPlaybackPositionEnabled(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackControls", L"IsPlaybackPositionEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPlaybackPositionEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsPlaybackRateEnabled(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackControls", L"IsPlaybackRateEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPlaybackRateEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsPreviousEnabled(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackControls", L"IsPreviousEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPreviousEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsRecordEnabled(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackControls", L"IsRecordEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsRecordEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsRepeatEnabled(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackControls", L"IsRepeatEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsRepeatEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsRewindEnabled(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackControls", L"IsRewindEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsRewindEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsShuffleEnabled(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackControls", L"IsShuffleEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsShuffleEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsStopEnabled(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackControls", L"IsStopEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStopEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GlobalSystemMediaTransportControlsSessionPlaybackControls(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GlobalSystemMediaTransportControlsSessionPlaybackControls(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GlobalSystemMediaTransportControlsSessionPlaybackControls[] = {
        { "_assign_array_", _assign_array_GlobalSystemMediaTransportControlsSessionPlaybackControls, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GlobalSystemMediaTransportControlsSessionPlaybackControls), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GlobalSystemMediaTransportControlsSessionPlaybackControls[] = {
        { "is_channel_down_enabled", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsChannelDownEnabled), nullptr, nullptr, nullptr },
        { "is_channel_up_enabled", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsChannelUpEnabled), nullptr, nullptr, nullptr },
        { "is_fast_forward_enabled", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsFastForwardEnabled), nullptr, nullptr, nullptr },
        { "is_next_enabled", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsNextEnabled), nullptr, nullptr, nullptr },
        { "is_pause_enabled", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsPauseEnabled), nullptr, nullptr, nullptr },
        { "is_play_enabled", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsPlayEnabled), nullptr, nullptr, nullptr },
        { "is_play_pause_toggle_enabled", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsPlayPauseToggleEnabled), nullptr, nullptr, nullptr },
        { "is_playback_position_enabled", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsPlaybackPositionEnabled), nullptr, nullptr, nullptr },
        { "is_playback_rate_enabled", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsPlaybackRateEnabled), nullptr, nullptr, nullptr },
        { "is_previous_enabled", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsPreviousEnabled), nullptr, nullptr, nullptr },
        { "is_record_enabled", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsRecordEnabled), nullptr, nullptr, nullptr },
        { "is_repeat_enabled", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsRepeatEnabled), nullptr, nullptr, nullptr },
        { "is_rewind_enabled", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsRewindEnabled), nullptr, nullptr, nullptr },
        { "is_shuffle_enabled", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsShuffleEnabled), nullptr, nullptr, nullptr },
        { "is_stop_enabled", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsStopEnabled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GlobalSystemMediaTransportControlsSessionPlaybackControls[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GlobalSystemMediaTransportControlsSessionPlaybackControls) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GlobalSystemMediaTransportControlsSessionPlaybackControls) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GlobalSystemMediaTransportControlsSessionPlaybackControls) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GlobalSystemMediaTransportControlsSessionPlaybackControls) },
        { },
    };

    static PyType_Spec type_spec_GlobalSystemMediaTransportControlsSessionPlaybackControls =
    {
        "winrt._winrt_windows_media_control.GlobalSystemMediaTransportControlsSessionPlaybackControls",
        sizeof(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GlobalSystemMediaTransportControlsSessionPlaybackControls
    };

    // ----- GlobalSystemMediaTransportControlsSessionPlaybackInfo class --------------------

    static PyObject* _new_GlobalSystemMediaTransportControlsSessionPlaybackInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_GlobalSystemMediaTransportControlsSessionPlaybackInfo(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackInfo_get_AutoRepeatMode(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackInfo", L"AutoRepeatMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutoRepeatMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackInfo_get_Controls(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackInfo", L"Controls"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Controls());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackInfo_get_IsShuffleActive(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackInfo", L"IsShuffleActive"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsShuffleActive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackInfo_get_PlaybackRate(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackInfo", L"PlaybackRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlaybackRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackInfo_get_PlaybackStatus(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackInfo", L"PlaybackStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlaybackStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackInfo_get_PlaybackType(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackInfo", L"PlaybackType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlaybackType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GlobalSystemMediaTransportControlsSessionPlaybackInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GlobalSystemMediaTransportControlsSessionPlaybackInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GlobalSystemMediaTransportControlsSessionPlaybackInfo[] = {
        { "_assign_array_", _assign_array_GlobalSystemMediaTransportControlsSessionPlaybackInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GlobalSystemMediaTransportControlsSessionPlaybackInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GlobalSystemMediaTransportControlsSessionPlaybackInfo[] = {
        { "auto_repeat_mode", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackInfo_get_AutoRepeatMode), nullptr, nullptr, nullptr },
        { "controls", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackInfo_get_Controls), nullptr, nullptr, nullptr },
        { "is_shuffle_active", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackInfo_get_IsShuffleActive), nullptr, nullptr, nullptr },
        { "playback_rate", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackInfo_get_PlaybackRate), nullptr, nullptr, nullptr },
        { "playback_status", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackInfo_get_PlaybackStatus), nullptr, nullptr, nullptr },
        { "playback_type", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackInfo_get_PlaybackType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GlobalSystemMediaTransportControlsSessionPlaybackInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GlobalSystemMediaTransportControlsSessionPlaybackInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GlobalSystemMediaTransportControlsSessionPlaybackInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GlobalSystemMediaTransportControlsSessionPlaybackInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GlobalSystemMediaTransportControlsSessionPlaybackInfo) },
        { },
    };

    static PyType_Spec type_spec_GlobalSystemMediaTransportControlsSessionPlaybackInfo =
    {
        "winrt._winrt_windows_media_control.GlobalSystemMediaTransportControlsSessionPlaybackInfo",
        sizeof(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GlobalSystemMediaTransportControlsSessionPlaybackInfo
    };

    // ----- GlobalSystemMediaTransportControlsSessionTimelineProperties class --------------------

    static PyObject* _new_GlobalSystemMediaTransportControlsSessionTimelineProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionTimelineProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionTimelineProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_GlobalSystemMediaTransportControlsSessionTimelineProperties(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionTimelineProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionTimelineProperties_get_EndTime(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionTimelineProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionTimelineProperties", L"EndTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionTimelineProperties_get_LastUpdatedTime(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionTimelineProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionTimelineProperties", L"LastUpdatedTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LastUpdatedTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionTimelineProperties_get_MaxSeekTime(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionTimelineProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionTimelineProperties", L"MaxSeekTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxSeekTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionTimelineProperties_get_MinSeekTime(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionTimelineProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionTimelineProperties", L"MinSeekTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinSeekTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionTimelineProperties_get_Position(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionTimelineProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionTimelineProperties", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionTimelineProperties_get_StartTime(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionTimelineProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionTimelineProperties", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GlobalSystemMediaTransportControlsSessionTimelineProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionTimelineProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GlobalSystemMediaTransportControlsSessionTimelineProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionTimelineProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GlobalSystemMediaTransportControlsSessionTimelineProperties[] = {
        { "_assign_array_", _assign_array_GlobalSystemMediaTransportControlsSessionTimelineProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GlobalSystemMediaTransportControlsSessionTimelineProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GlobalSystemMediaTransportControlsSessionTimelineProperties[] = {
        { "end_time", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionTimelineProperties_get_EndTime), nullptr, nullptr, nullptr },
        { "last_updated_time", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionTimelineProperties_get_LastUpdatedTime), nullptr, nullptr, nullptr },
        { "max_seek_time", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionTimelineProperties_get_MaxSeekTime), nullptr, nullptr, nullptr },
        { "min_seek_time", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionTimelineProperties_get_MinSeekTime), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionTimelineProperties_get_Position), nullptr, nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionTimelineProperties_get_StartTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GlobalSystemMediaTransportControlsSessionTimelineProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GlobalSystemMediaTransportControlsSessionTimelineProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GlobalSystemMediaTransportControlsSessionTimelineProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GlobalSystemMediaTransportControlsSessionTimelineProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GlobalSystemMediaTransportControlsSessionTimelineProperties) },
        { },
    };

    static PyType_Spec type_spec_GlobalSystemMediaTransportControlsSessionTimelineProperties =
    {
        "winrt._winrt_windows_media_control.GlobalSystemMediaTransportControlsSessionTimelineProperties",
        sizeof(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionTimelineProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GlobalSystemMediaTransportControlsSessionTimelineProperties
    };

    // ----- MediaPropertiesChangedEventArgs class --------------------

    static PyObject* _new_MediaPropertiesChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Control::MediaPropertiesChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Control::MediaPropertiesChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaPropertiesChangedEventArgs(py::wrapper::Windows::Media::Control::MediaPropertiesChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MediaPropertiesChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Control::MediaPropertiesChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPropertiesChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Control::MediaPropertiesChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPropertiesChangedEventArgs[] = {
        { "_assign_array_", _assign_array_MediaPropertiesChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPropertiesChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPropertiesChangedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaPropertiesChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPropertiesChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPropertiesChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPropertiesChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPropertiesChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaPropertiesChangedEventArgs =
    {
        "winrt._winrt_windows_media_control.MediaPropertiesChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Control::MediaPropertiesChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPropertiesChangedEventArgs
    };

    // ----- PlaybackInfoChangedEventArgs class --------------------

    static PyObject* _new_PlaybackInfoChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Control::PlaybackInfoChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Control::PlaybackInfoChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PlaybackInfoChangedEventArgs(py::wrapper::Windows::Media::Control::PlaybackInfoChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PlaybackInfoChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Control::PlaybackInfoChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlaybackInfoChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Control::PlaybackInfoChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlaybackInfoChangedEventArgs[] = {
        { "_assign_array_", _assign_array_PlaybackInfoChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlaybackInfoChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlaybackInfoChangedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_PlaybackInfoChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlaybackInfoChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlaybackInfoChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlaybackInfoChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlaybackInfoChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PlaybackInfoChangedEventArgs =
    {
        "winrt._winrt_windows_media_control.PlaybackInfoChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Control::PlaybackInfoChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlaybackInfoChangedEventArgs
    };

    // ----- SessionsChangedEventArgs class --------------------

    static PyObject* _new_SessionsChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Control::SessionsChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Control::SessionsChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SessionsChangedEventArgs(py::wrapper::Windows::Media::Control::SessionsChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SessionsChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Control::SessionsChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SessionsChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Control::SessionsChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SessionsChangedEventArgs[] = {
        { "_assign_array_", _assign_array_SessionsChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SessionsChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SessionsChangedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_SessionsChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SessionsChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SessionsChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SessionsChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SessionsChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SessionsChangedEventArgs =
    {
        "winrt._winrt_windows_media_control.SessionsChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Control::SessionsChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SessionsChangedEventArgs
    };

    // ----- TimelinePropertiesChangedEventArgs class --------------------

    static PyObject* _new_TimelinePropertiesChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Control::TimelinePropertiesChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Control::TimelinePropertiesChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_TimelinePropertiesChangedEventArgs(py::wrapper::Windows::Media::Control::TimelinePropertiesChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TimelinePropertiesChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Control::TimelinePropertiesChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimelinePropertiesChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Control::TimelinePropertiesChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimelinePropertiesChangedEventArgs[] = {
        { "_assign_array_", _assign_array_TimelinePropertiesChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimelinePropertiesChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimelinePropertiesChangedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_TimelinePropertiesChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimelinePropertiesChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimelinePropertiesChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimelinePropertiesChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimelinePropertiesChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_TimelinePropertiesChangedEventArgs =
    {
        "winrt._winrt_windows_media_control.TimelinePropertiesChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Control::TimelinePropertiesChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimelinePropertiesChangedEventArgs
    };

    // ----- Windows.Media.Control Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Media::Control");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_media_control",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Media::Control

PyMODINIT_FUNC PyInit__winrt_windows_media_control(void) noexcept
{
    using namespace py::cpp::Windows::Media::Control;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CurrentSessionChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GlobalSystemMediaTransportControlsSession, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_GlobalSystemMediaTransportControlsSessionManager_Static{PyType_FromSpec(&type_spec_GlobalSystemMediaTransportControlsSessionManager_Static)};
    if (!type_GlobalSystemMediaTransportControlsSessionManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GlobalSystemMediaTransportControlsSessionManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GlobalSystemMediaTransportControlsSessionManager_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GlobalSystemMediaTransportControlsSessionMediaProperties, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GlobalSystemMediaTransportControlsSessionPlaybackControls, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GlobalSystemMediaTransportControlsSessionPlaybackInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GlobalSystemMediaTransportControlsSessionTimelineProperties, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaPropertiesChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PlaybackInfoChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SessionsChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TimelinePropertiesChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
