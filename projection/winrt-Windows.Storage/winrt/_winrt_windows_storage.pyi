# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.2.0

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.foundation as windows_foundation
import winrt.windows.foundation.collections as windows_foundation_collections
import winrt.windows.storage.fileproperties as windows_storage_fileproperties
import winrt.windows.storage.provider as windows_storage_provider
import winrt.windows.storage.search as windows_storage_search
import winrt.windows.storage.streams as windows_storage_streams
import winrt.windows.system as windows_system

from winrt.windows.storage import ApplicationDataCreateDisposition, ApplicationDataLocality, CreationCollisionOption, FileAccessMode, FileAttributes, KnownFolderId, KnownFoldersAccessStatus, KnownLibraryId, NameCollisionOption, StorageDeleteOption, StorageItemTypes, StorageLibraryChangeType, StorageOpenOptions, StreamedFileFailureMode
from winrt.windows.storage import ApplicationDataSetVersionHandler, StreamedFileDataRequestedHandler

Self = typing.TypeVar('Self')

@typing.final
class AppDataPaths_Static(type):
    def get_default(cls) -> typing.Optional[AppDataPaths]: ...
    def get_for_user(cls, user: typing.Optional[windows_system.User], /) -> typing.Optional[AppDataPaths]: ...

@typing.final
class AppDataPaths(winrt.system.Object, metaclass=AppDataPaths_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppDataPaths: ...
    @_property
    def cookies(self) -> str: ...
    @_property
    def desktop(self) -> str: ...
    @_property
    def documents(self) -> str: ...
    @_property
    def favorites(self) -> str: ...
    @_property
    def history(self) -> str: ...
    @_property
    def internet_cache(self) -> str: ...
    @_property
    def local_app_data(self) -> str: ...
    @_property
    def program_data(self) -> str: ...
    @_property
    def roaming_app_data(self) -> str: ...

@typing.final
class ApplicationData_Static(type):
    def get_for_user_async(cls, user: typing.Optional[windows_system.User], /) -> windows_foundation.IAsyncOperation[ApplicationData]: ...
    @_property
    def current(cls) -> typing.Optional[ApplicationData]: ...

@typing.final
class ApplicationData(winrt.system.Object, metaclass=ApplicationData_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ApplicationData: ...
    @typing.overload
    def clear_async(self) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def clear_async(self, locality: ApplicationDataLocality, /) -> windows_foundation.IAsyncAction: ...
    def clear_publisher_cache_folder_async(self, folder_name: str, /) -> windows_foundation.IAsyncAction: ...
    def close(self) -> None: ...
    def get_publisher_cache_folder(self, folder_name: str, /) -> typing.Optional[StorageFolder]: ...
    def set_version_async(self, desired_version: winrt.system.UInt32, handler: typing.Optional[ApplicationDataSetVersionHandler], /) -> windows_foundation.IAsyncAction: ...
    def signal_data_changed(self) -> None: ...
    def add_data_changed(self, handler: windows_foundation.TypedEventHandler[ApplicationData, winrt.system.Object], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_data_changed(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def local_folder(self) -> typing.Optional[StorageFolder]: ...
    @_property
    def local_settings(self) -> typing.Optional[ApplicationDataContainer]: ...
    @_property
    def roaming_folder(self) -> typing.Optional[StorageFolder]: ...
    @_property
    def roaming_settings(self) -> typing.Optional[ApplicationDataContainer]: ...
    @_property
    def roaming_storage_quota(self) -> winrt.system.UInt64: ...
    @_property
    def temporary_folder(self) -> typing.Optional[StorageFolder]: ...
    @_property
    def version(self) -> winrt.system.UInt32: ...
    @_property
    def local_cache_folder(self) -> typing.Optional[StorageFolder]: ...
    @_property
    def shared_local_folder(self) -> typing.Optional[StorageFolder]: ...

@typing.final
class ApplicationDataCompositeValue(winrt.system.Object, winrt._winrt.MutableMapping[str, winrt.system.Object]):
    def __len__(self) -> int: ...
    def __iter__(self) -> typing.Iterator[str]: ...
    def __contains__(self, key: object) -> bool: ...
    def __getitem__(self, key: str) -> winrt.system.Object: ...
    def __setitem__(self, key: str, value: winrt.system.Object) -> None: ...
    def __delitem__(self, key: str) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ApplicationDataCompositeValue: ...
    def __new__(cls: typing.Type[ApplicationDataCompositeValue]) -> ApplicationDataCompositeValue: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[windows_foundation_collections.IIterator[windows_foundation_collections.IKeyValuePair[str, winrt.system.Object]]]: ...
    def get_view(self) -> typing.Optional[windows_foundation_collections.IMapView[str, winrt.system.Object]]: ...
    def has_key(self, key: str, /) -> bool: ...
    def insert(self, key: str, value: typing.Optional[winrt.system.Object], /) -> bool: ...
    def lookup(self, key: str, /) -> typing.Optional[winrt.system.Object]: ...
    def remove(self, key: str, /) -> None: ...
    def add_map_changed(self, vhnd: windows_foundation_collections.MapChangedEventHandler[str, winrt.system.Object], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_map_changed(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class ApplicationDataContainer(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ApplicationDataContainer: ...
    def close(self) -> None: ...
    def create_container(self, name: str, disposition: ApplicationDataCreateDisposition, /) -> typing.Optional[ApplicationDataContainer]: ...
    def delete_container(self, name: str, /) -> None: ...
    @_property
    def containers(self) -> typing.Optional[windows_foundation_collections.IMapView[str, ApplicationDataContainer]]: ...
    @_property
    def locality(self) -> ApplicationDataLocality: ...
    @_property
    def name(self) -> str: ...
    @_property
    def values(self) -> typing.Optional[windows_foundation_collections.IPropertySet]: ...

@typing.final
class ApplicationDataContainerSettings(winrt.system.Object, winrt._winrt.MutableMapping[str, winrt.system.Object]):
    def __len__(self) -> int: ...
    def __iter__(self) -> typing.Iterator[str]: ...
    def __contains__(self, key: object) -> bool: ...
    def __getitem__(self, key: str) -> winrt.system.Object: ...
    def __setitem__(self, key: str, value: winrt.system.Object) -> None: ...
    def __delitem__(self, key: str) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ApplicationDataContainerSettings: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[windows_foundation_collections.IIterator[windows_foundation_collections.IKeyValuePair[str, winrt.system.Object]]]: ...
    def get_view(self) -> typing.Optional[windows_foundation_collections.IMapView[str, winrt.system.Object]]: ...
    def has_key(self, key: str, /) -> bool: ...
    def insert(self, key: str, value: typing.Optional[winrt.system.Object], /) -> bool: ...
    def lookup(self, key: str, /) -> typing.Optional[winrt.system.Object]: ...
    def remove(self, key: str, /) -> None: ...
    def add_map_changed(self, vhnd: windows_foundation_collections.MapChangedEventHandler[str, winrt.system.Object], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_map_changed(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class CachedFileManager_Static(type):
    def complete_updates_async(cls, file: typing.Optional[IStorageFile], /) -> windows_foundation.IAsyncOperation[windows_storage_provider.FileUpdateStatus]: ...
    def defer_updates(cls, file: typing.Optional[IStorageFile], /) -> None: ...

@typing.final
class CachedFileManager(winrt.system.Object, metaclass=CachedFileManager_Static):
    pass

@typing.final
class DownloadsFolder_Static(type):
    @typing.overload
    def create_file_async(cls, desired_name: str, /) -> windows_foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def create_file_async(cls, desired_name: str, option: CreationCollisionOption, /) -> windows_foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def create_file_for_user_async(cls, user: typing.Optional[windows_system.User], desired_name: str, /) -> windows_foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def create_file_for_user_async(cls, user: typing.Optional[windows_system.User], desired_name: str, option: CreationCollisionOption, /) -> windows_foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def create_folder_async(cls, desired_name: str, /) -> windows_foundation.IAsyncOperation[StorageFolder]: ...
    @typing.overload
    def create_folder_async(cls, desired_name: str, option: CreationCollisionOption, /) -> windows_foundation.IAsyncOperation[StorageFolder]: ...
    @typing.overload
    def create_folder_for_user_async(cls, user: typing.Optional[windows_system.User], desired_name: str, /) -> windows_foundation.IAsyncOperation[StorageFolder]: ...
    @typing.overload
    def create_folder_for_user_async(cls, user: typing.Optional[windows_system.User], desired_name: str, option: CreationCollisionOption, /) -> windows_foundation.IAsyncOperation[StorageFolder]: ...

@typing.final
class DownloadsFolder(winrt.system.Object, metaclass=DownloadsFolder_Static):
    pass

@typing.final
class FileIO_Static(type):
    @typing.overload
    def append_lines_async(cls, file: typing.Optional[IStorageFile], lines: typing.Iterable[str], /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def append_lines_async(cls, file: typing.Optional[IStorageFile], lines: typing.Iterable[str], encoding: windows_storage_streams.UnicodeEncoding, /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def append_text_async(cls, file: typing.Optional[IStorageFile], contents: str, /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def append_text_async(cls, file: typing.Optional[IStorageFile], contents: str, encoding: windows_storage_streams.UnicodeEncoding, /) -> windows_foundation.IAsyncAction: ...
    def read_buffer_async(cls, file: typing.Optional[IStorageFile], /) -> windows_foundation.IAsyncOperation[windows_storage_streams.IBuffer]: ...
    @typing.overload
    def read_lines_async(cls, file: typing.Optional[IStorageFile], /) -> windows_foundation.IAsyncOperation[windows_foundation_collections.IVector[str]]: ...
    @typing.overload
    def read_lines_async(cls, file: typing.Optional[IStorageFile], encoding: windows_storage_streams.UnicodeEncoding, /) -> windows_foundation.IAsyncOperation[windows_foundation_collections.IVector[str]]: ...
    @typing.overload
    def read_text_async(cls, file: typing.Optional[IStorageFile], /) -> windows_foundation.IAsyncOperation[str]: ...
    @typing.overload
    def read_text_async(cls, file: typing.Optional[IStorageFile], encoding: windows_storage_streams.UnicodeEncoding, /) -> windows_foundation.IAsyncOperation[str]: ...
    def write_buffer_async(cls, file: typing.Optional[IStorageFile], buffer: typing.Optional[windows_storage_streams.IBuffer], /) -> windows_foundation.IAsyncAction: ...
    def write_bytes_async(cls, file: typing.Optional[IStorageFile], buffer: winrt.system.Array[winrt.system.UInt8], /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def write_lines_async(cls, file: typing.Optional[IStorageFile], lines: typing.Iterable[str], /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def write_lines_async(cls, file: typing.Optional[IStorageFile], lines: typing.Iterable[str], encoding: windows_storage_streams.UnicodeEncoding, /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def write_text_async(cls, file: typing.Optional[IStorageFile], contents: str, /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def write_text_async(cls, file: typing.Optional[IStorageFile], contents: str, encoding: windows_storage_streams.UnicodeEncoding, /) -> windows_foundation.IAsyncAction: ...

@typing.final
class FileIO(winrt.system.Object, metaclass=FileIO_Static):
    pass

@typing.final
class KnownFolders_Static(type):
    def get_folder_async(cls, folder_id: KnownFolderId, /) -> windows_foundation.IAsyncOperation[StorageFolder]: ...
    def get_folder_for_user_async(cls, user: typing.Optional[windows_system.User], folder_id: KnownFolderId, /) -> windows_foundation.IAsyncOperation[StorageFolder]: ...
    def request_access_async(cls, folder_id: KnownFolderId, /) -> windows_foundation.IAsyncOperation[KnownFoldersAccessStatus]: ...
    def request_access_for_user_async(cls, user: typing.Optional[windows_system.User], folder_id: KnownFolderId, /) -> windows_foundation.IAsyncOperation[KnownFoldersAccessStatus]: ...
    @_property
    def camera_roll(cls) -> typing.Optional[StorageFolder]: ...
    @_property
    def playlists(cls) -> typing.Optional[StorageFolder]: ...
    @_property
    def saved_pictures(cls) -> typing.Optional[StorageFolder]: ...
    @_property
    def documents_library(cls) -> typing.Optional[StorageFolder]: ...
    @_property
    def home_group(cls) -> typing.Optional[StorageFolder]: ...
    @_property
    def media_server_devices(cls) -> typing.Optional[StorageFolder]: ...
    @_property
    def music_library(cls) -> typing.Optional[StorageFolder]: ...
    @_property
    def pictures_library(cls) -> typing.Optional[StorageFolder]: ...
    @_property
    def removable_devices(cls) -> typing.Optional[StorageFolder]: ...
    @_property
    def videos_library(cls) -> typing.Optional[StorageFolder]: ...
    @_property
    def app_captures(cls) -> typing.Optional[StorageFolder]: ...
    @_property
    def objects3_d(cls) -> typing.Optional[StorageFolder]: ...
    @_property
    def recorded_calls(cls) -> typing.Optional[StorageFolder]: ...

@typing.final
class KnownFolders(winrt.system.Object, metaclass=KnownFolders_Static):
    pass

@typing.final
class PathIO_Static(type):
    @typing.overload
    def append_lines_async(cls, absolute_path: str, lines: typing.Iterable[str], /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def append_lines_async(cls, absolute_path: str, lines: typing.Iterable[str], encoding: windows_storage_streams.UnicodeEncoding, /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def append_text_async(cls, absolute_path: str, contents: str, /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def append_text_async(cls, absolute_path: str, contents: str, encoding: windows_storage_streams.UnicodeEncoding, /) -> windows_foundation.IAsyncAction: ...
    def read_buffer_async(cls, absolute_path: str, /) -> windows_foundation.IAsyncOperation[windows_storage_streams.IBuffer]: ...
    @typing.overload
    def read_lines_async(cls, absolute_path: str, /) -> windows_foundation.IAsyncOperation[windows_foundation_collections.IVector[str]]: ...
    @typing.overload
    def read_lines_async(cls, absolute_path: str, encoding: windows_storage_streams.UnicodeEncoding, /) -> windows_foundation.IAsyncOperation[windows_foundation_collections.IVector[str]]: ...
    @typing.overload
    def read_text_async(cls, absolute_path: str, /) -> windows_foundation.IAsyncOperation[str]: ...
    @typing.overload
    def read_text_async(cls, absolute_path: str, encoding: windows_storage_streams.UnicodeEncoding, /) -> windows_foundation.IAsyncOperation[str]: ...
    def write_buffer_async(cls, absolute_path: str, buffer: typing.Optional[windows_storage_streams.IBuffer], /) -> windows_foundation.IAsyncAction: ...
    def write_bytes_async(cls, absolute_path: str, buffer: winrt.system.Array[winrt.system.UInt8], /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def write_lines_async(cls, absolute_path: str, lines: typing.Iterable[str], /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def write_lines_async(cls, absolute_path: str, lines: typing.Iterable[str], encoding: windows_storage_streams.UnicodeEncoding, /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def write_text_async(cls, absolute_path: str, contents: str, /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def write_text_async(cls, absolute_path: str, contents: str, encoding: windows_storage_streams.UnicodeEncoding, /) -> windows_foundation.IAsyncAction: ...

@typing.final
class PathIO(winrt.system.Object, metaclass=PathIO_Static):
    pass

@typing.final
class SetVersionDeferral(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SetVersionDeferral: ...
    def complete(self) -> None: ...

@typing.final
class SetVersionRequest(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SetVersionRequest: ...
    def get_deferral(self) -> typing.Optional[SetVersionDeferral]: ...
    @_property
    def current_version(self) -> winrt.system.UInt32: ...
    @_property
    def desired_version(self) -> winrt.system.UInt32: ...

@typing.final
class StorageFile_Static(type):
    def create_streamed_file_async(cls, display_name_with_extension: str, data_requested: typing.Optional[StreamedFileDataRequestedHandler], thumbnail: typing.Optional[windows_storage_streams.IRandomAccessStreamReference], /) -> windows_foundation.IAsyncOperation[StorageFile]: ...
    def create_streamed_file_from_uri_async(cls, display_name_with_extension: str, uri: typing.Optional[windows_foundation.Uri], thumbnail: typing.Optional[windows_storage_streams.IRandomAccessStreamReference], /) -> windows_foundation.IAsyncOperation[StorageFile]: ...
    def get_file_from_application_uri_async(cls, uri: typing.Optional[windows_foundation.Uri], /) -> windows_foundation.IAsyncOperation[StorageFile]: ...
    def get_file_from_path_async(cls, path: str, /) -> windows_foundation.IAsyncOperation[StorageFile]: ...
    def get_file_from_path_for_user_async(cls, user: typing.Optional[windows_system.User], path: str, /) -> windows_foundation.IAsyncOperation[StorageFile]: ...
    def replace_with_streamed_file_async(cls, file_to_replace: typing.Optional[IStorageFile], data_requested: typing.Optional[StreamedFileDataRequestedHandler], thumbnail: typing.Optional[windows_storage_streams.IRandomAccessStreamReference], /) -> windows_foundation.IAsyncOperation[StorageFile]: ...
    def replace_with_streamed_file_from_uri_async(cls, file_to_replace: typing.Optional[IStorageFile], uri: typing.Optional[windows_foundation.Uri], thumbnail: typing.Optional[windows_storage_streams.IRandomAccessStreamReference], /) -> windows_foundation.IAsyncOperation[StorageFile]: ...

@typing.final
class StorageFile(winrt.system.Object, metaclass=StorageFile_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageFile: ...
    def copy_and_replace_async(self, file_to_replace: typing.Optional[IStorageFile], /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def copy_async(self, destination_folder: typing.Optional[IStorageFolder], /) -> windows_foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def copy_async(self, destination_folder: typing.Optional[IStorageFolder], desired_new_name: str, /) -> windows_foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def copy_async(self, destination_folder: typing.Optional[IStorageFolder], desired_new_name: str, option: NameCollisionOption, /) -> windows_foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def delete_async(self) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def delete_async(self, option: StorageDeleteOption, /) -> windows_foundation.IAsyncAction: ...
    def get_basic_properties_async(self) -> windows_foundation.IAsyncOperation[windows_storage_fileproperties.BasicProperties]: ...
    def get_parent_async(self) -> windows_foundation.IAsyncOperation[StorageFolder]: ...
    @typing.overload
    def get_scaled_image_as_thumbnail_async(self, mode: windows_storage_fileproperties.ThumbnailMode, /) -> windows_foundation.IAsyncOperation[windows_storage_fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_scaled_image_as_thumbnail_async(self, mode: windows_storage_fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, /) -> windows_foundation.IAsyncOperation[windows_storage_fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_scaled_image_as_thumbnail_async(self, mode: windows_storage_fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, options: windows_storage_fileproperties.ThumbnailOptions, /) -> windows_foundation.IAsyncOperation[windows_storage_fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: windows_storage_fileproperties.ThumbnailMode, /) -> windows_foundation.IAsyncOperation[windows_storage_fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: windows_storage_fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, /) -> windows_foundation.IAsyncOperation[windows_storage_fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: windows_storage_fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, options: windows_storage_fileproperties.ThumbnailOptions, /) -> windows_foundation.IAsyncOperation[windows_storage_fileproperties.StorageItemThumbnail]: ...
    def is_equal(self, item: typing.Optional[IStorageItem], /) -> bool: ...
    def is_of_type(self, type: StorageItemTypes, /) -> bool: ...
    def move_and_replace_async(self, file_to_replace: typing.Optional[IStorageFile], /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def move_async(self, destination_folder: typing.Optional[IStorageFolder], /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def move_async(self, destination_folder: typing.Optional[IStorageFolder], desired_new_name: str, /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def move_async(self, destination_folder: typing.Optional[IStorageFolder], desired_new_name: str, option: NameCollisionOption, /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def open_async(self, access_mode: FileAccessMode, /) -> windows_foundation.IAsyncOperation[windows_storage_streams.IRandomAccessStream]: ...
    @typing.overload
    def open_async(self, access_mode: FileAccessMode, options: StorageOpenOptions, /) -> windows_foundation.IAsyncOperation[windows_storage_streams.IRandomAccessStream]: ...
    def open_read_async(self) -> windows_foundation.IAsyncOperation[windows_storage_streams.IRandomAccessStreamWithContentType]: ...
    def open_sequential_read_async(self) -> windows_foundation.IAsyncOperation[windows_storage_streams.IInputStream]: ...
    @typing.overload
    def open_transacted_write_async(self) -> windows_foundation.IAsyncOperation[StorageStreamTransaction]: ...
    @typing.overload
    def open_transacted_write_async(self, options: StorageOpenOptions, /) -> windows_foundation.IAsyncOperation[StorageStreamTransaction]: ...
    @typing.overload
    def rename_async(self, desired_name: str, /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def rename_async(self, desired_name: str, option: NameCollisionOption, /) -> windows_foundation.IAsyncAction: ...
    @_property
    def content_type(self) -> str: ...
    @_property
    def file_type(self) -> str: ...
    @_property
    def is_available(self) -> bool: ...
    @_property
    def attributes(self) -> FileAttributes: ...
    @_property
    def date_created(self) -> datetime.datetime: ...
    @_property
    def name(self) -> str: ...
    @_property
    def path(self) -> str: ...
    @_property
    def display_name(self) -> str: ...
    @_property
    def display_type(self) -> str: ...
    @_property
    def folder_relative_id(self) -> str: ...
    @_property
    def properties(self) -> typing.Optional[windows_storage_fileproperties.StorageItemContentProperties]: ...
    @_property
    def provider(self) -> typing.Optional[StorageProvider]: ...

@typing.final
class StorageFolder_Static(type):
    def get_folder_from_path_async(cls, path: str, /) -> windows_foundation.IAsyncOperation[StorageFolder]: ...
    def get_folder_from_path_for_user_async(cls, user: typing.Optional[windows_system.User], path: str, /) -> windows_foundation.IAsyncOperation[StorageFolder]: ...

@typing.final
class StorageFolder(winrt.system.Object, metaclass=StorageFolder_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageFolder: ...
    def are_query_options_supported(self, query_options: typing.Optional[windows_storage_search.QueryOptions], /) -> bool: ...
    @typing.overload
    def create_file_async(self, desired_name: str, /) -> windows_foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def create_file_async(self, desired_name: str, options: CreationCollisionOption, /) -> windows_foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def create_file_query(self) -> typing.Optional[windows_storage_search.StorageFileQueryResult]: ...
    @typing.overload
    def create_file_query(self, query: windows_storage_search.CommonFileQuery, /) -> typing.Optional[windows_storage_search.StorageFileQueryResult]: ...
    def create_file_query_with_options(self, query_options: typing.Optional[windows_storage_search.QueryOptions], /) -> typing.Optional[windows_storage_search.StorageFileQueryResult]: ...
    @typing.overload
    def create_folder_async(self, desired_name: str, /) -> windows_foundation.IAsyncOperation[StorageFolder]: ...
    @typing.overload
    def create_folder_async(self, desired_name: str, options: CreationCollisionOption, /) -> windows_foundation.IAsyncOperation[StorageFolder]: ...
    @typing.overload
    def create_folder_query(self) -> typing.Optional[windows_storage_search.StorageFolderQueryResult]: ...
    @typing.overload
    def create_folder_query(self, query: windows_storage_search.CommonFolderQuery, /) -> typing.Optional[windows_storage_search.StorageFolderQueryResult]: ...
    def create_folder_query_with_options(self, query_options: typing.Optional[windows_storage_search.QueryOptions], /) -> typing.Optional[windows_storage_search.StorageFolderQueryResult]: ...
    def create_item_query(self) -> typing.Optional[windows_storage_search.StorageItemQueryResult]: ...
    def create_item_query_with_options(self, query_options: typing.Optional[windows_storage_search.QueryOptions], /) -> typing.Optional[windows_storage_search.StorageItemQueryResult]: ...
    @typing.overload
    def delete_async(self) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def delete_async(self, option: StorageDeleteOption, /) -> windows_foundation.IAsyncAction: ...
    def get_basic_properties_async(self) -> windows_foundation.IAsyncOperation[windows_storage_fileproperties.BasicProperties]: ...
    def get_file_async(self, name: str, /) -> windows_foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def get_files_async(self) -> windows_foundation.IAsyncOperation[windows_foundation_collections.IVectorView[StorageFile]]: ...
    @typing.overload
    def get_files_async(self, query: windows_storage_search.CommonFileQuery, /) -> windows_foundation.IAsyncOperation[windows_foundation_collections.IVectorView[StorageFile]]: ...
    @typing.overload
    def get_files_async(self, query: windows_storage_search.CommonFileQuery, start_index: winrt.system.UInt32, max_items_to_retrieve: winrt.system.UInt32, /) -> windows_foundation.IAsyncOperation[windows_foundation_collections.IVectorView[StorageFile]]: ...
    def get_folder_async(self, name: str, /) -> windows_foundation.IAsyncOperation[StorageFolder]: ...
    @typing.overload
    def get_folders_async(self) -> windows_foundation.IAsyncOperation[windows_foundation_collections.IVectorView[StorageFolder]]: ...
    @typing.overload
    def get_folders_async(self, query: windows_storage_search.CommonFolderQuery, /) -> windows_foundation.IAsyncOperation[windows_foundation_collections.IVectorView[StorageFolder]]: ...
    @typing.overload
    def get_folders_async(self, query: windows_storage_search.CommonFolderQuery, start_index: winrt.system.UInt32, max_items_to_retrieve: winrt.system.UInt32, /) -> windows_foundation.IAsyncOperation[windows_foundation_collections.IVectorView[StorageFolder]]: ...
    def get_indexed_state_async(self) -> windows_foundation.IAsyncOperation[windows_storage_search.IndexedState]: ...
    def get_item_async(self, name: str, /) -> windows_foundation.IAsyncOperation[IStorageItem]: ...
    @typing.overload
    def get_items_async(self) -> windows_foundation.IAsyncOperation[windows_foundation_collections.IVectorView[IStorageItem]]: ...
    @typing.overload
    def get_items_async(self, start_index: winrt.system.UInt32, max_items_to_retrieve: winrt.system.UInt32, /) -> windows_foundation.IAsyncOperation[windows_foundation_collections.IVectorView[IStorageItem]]: ...
    def get_parent_async(self) -> windows_foundation.IAsyncOperation[StorageFolder]: ...
    @typing.overload
    def get_scaled_image_as_thumbnail_async(self, mode: windows_storage_fileproperties.ThumbnailMode, /) -> windows_foundation.IAsyncOperation[windows_storage_fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_scaled_image_as_thumbnail_async(self, mode: windows_storage_fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, /) -> windows_foundation.IAsyncOperation[windows_storage_fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_scaled_image_as_thumbnail_async(self, mode: windows_storage_fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, options: windows_storage_fileproperties.ThumbnailOptions, /) -> windows_foundation.IAsyncOperation[windows_storage_fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: windows_storage_fileproperties.ThumbnailMode, /) -> windows_foundation.IAsyncOperation[windows_storage_fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: windows_storage_fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, /) -> windows_foundation.IAsyncOperation[windows_storage_fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: windows_storage_fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, options: windows_storage_fileproperties.ThumbnailOptions, /) -> windows_foundation.IAsyncOperation[windows_storage_fileproperties.StorageItemThumbnail]: ...
    def is_common_file_query_supported(self, query: windows_storage_search.CommonFileQuery, /) -> bool: ...
    def is_common_folder_query_supported(self, query: windows_storage_search.CommonFolderQuery, /) -> bool: ...
    def is_equal(self, item: typing.Optional[IStorageItem], /) -> bool: ...
    def is_of_type(self, type: StorageItemTypes, /) -> bool: ...
    @typing.overload
    def rename_async(self, desired_name: str, /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def rename_async(self, desired_name: str, option: NameCollisionOption, /) -> windows_foundation.IAsyncAction: ...
    def try_get_change_tracker(self) -> typing.Optional[StorageLibraryChangeTracker]: ...
    def try_get_item_async(self, name: str, /) -> windows_foundation.IAsyncOperation[IStorageItem]: ...
    @_property
    def attributes(self) -> FileAttributes: ...
    @_property
    def date_created(self) -> datetime.datetime: ...
    @_property
    def name(self) -> str: ...
    @_property
    def path(self) -> str: ...
    @_property
    def display_name(self) -> str: ...
    @_property
    def display_type(self) -> str: ...
    @_property
    def folder_relative_id(self) -> str: ...
    @_property
    def properties(self) -> typing.Optional[windows_storage_fileproperties.StorageItemContentProperties]: ...
    @_property
    def provider(self) -> typing.Optional[StorageProvider]: ...

@typing.final
class StorageLibrary_Static(type):
    def get_library_async(cls, library_id: KnownLibraryId, /) -> windows_foundation.IAsyncOperation[StorageLibrary]: ...
    def get_library_for_user_async(cls, user: typing.Optional[windows_system.User], library_id: KnownLibraryId, /) -> windows_foundation.IAsyncOperation[StorageLibrary]: ...

@typing.final
class StorageLibrary(winrt.system.Object, metaclass=StorageLibrary_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageLibrary: ...
    def are_folder_suggestions_available_async(self) -> windows_foundation.IAsyncOperation[bool]: ...
    def request_add_folder_async(self) -> windows_foundation.IAsyncOperation[StorageFolder]: ...
    def request_remove_folder_async(self, folder: typing.Optional[StorageFolder], /) -> windows_foundation.IAsyncOperation[bool]: ...
    def add_definition_changed(self, handler: windows_foundation.TypedEventHandler[StorageLibrary, winrt.system.Object], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_definition_changed(self, event_cookie: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def folders(self) -> typing.Optional[windows_foundation_collections.IObservableVector[StorageFolder]]: ...
    @_property
    def save_folder(self) -> typing.Optional[StorageFolder]: ...
    @_property
    def change_tracker(self) -> typing.Optional[StorageLibraryChangeTracker]: ...

@typing.final
class StorageLibraryChange(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageLibraryChange: ...
    def get_storage_item_async(self) -> windows_foundation.IAsyncOperation[IStorageItem]: ...
    def is_of_type(self, type: StorageItemTypes, /) -> bool: ...
    @_property
    def change_type(self) -> StorageLibraryChangeType: ...
    @_property
    def path(self) -> str: ...
    @_property
    def previous_path(self) -> str: ...

@typing.final
class StorageLibraryChangeReader(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageLibraryChangeReader: ...
    def accept_changes_async(self) -> windows_foundation.IAsyncAction: ...
    def get_last_change_id(self) -> winrt.system.UInt64: ...
    def read_batch_async(self) -> windows_foundation.IAsyncOperation[windows_foundation_collections.IVectorView[StorageLibraryChange]]: ...

@typing.final
class StorageLibraryChangeTracker(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageLibraryChangeTracker: ...
    def disable(self) -> None: ...
    @typing.overload
    def enable(self) -> None: ...
    @typing.overload
    def enable(self, options: typing.Optional[StorageLibraryChangeTrackerOptions], /) -> None: ...
    def get_change_reader(self) -> typing.Optional[StorageLibraryChangeReader]: ...
    def reset(self) -> None: ...

@typing.final
class StorageLibraryChangeTrackerOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageLibraryChangeTrackerOptions: ...
    def __new__(cls: typing.Type[StorageLibraryChangeTrackerOptions]) -> StorageLibraryChangeTrackerOptions: ...
    @_property
    def track_change_details(self) -> bool: ...
    @track_change_details.setter
    def track_change_details(self, value: bool) -> None: ...

@typing.final
class StorageLibraryLastChangeId_Static(type):
    @_property
    def unknown(cls) -> winrt.system.UInt64: ...

@typing.final
class StorageLibraryLastChangeId(winrt.system.Object, metaclass=StorageLibraryLastChangeId_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageLibraryLastChangeId: ...

@typing.final
class StorageProvider(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageProvider: ...
    def is_property_supported_for_partial_file_async(self, property_canonical_name: str, /) -> windows_foundation.IAsyncOperation[bool]: ...
    @_property
    def display_name(self) -> str: ...
    @_property
    def id(self) -> str: ...

@typing.final
class StorageStreamTransaction(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageStreamTransaction: ...
    def close(self) -> None: ...
    def commit_async(self) -> windows_foundation.IAsyncAction: ...
    @_property
    def stream(self) -> typing.Optional[windows_storage_streams.IRandomAccessStream]: ...

@typing.final
class StreamedFileDataRequest(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StreamedFileDataRequest: ...
    def close(self) -> None: ...
    def fail_and_close(self, failure_mode: StreamedFileFailureMode, /) -> None: ...
    def flush_async(self) -> windows_foundation.IAsyncOperation[bool]: ...
    def write_async(self, buffer: typing.Optional[windows_storage_streams.IBuffer], /) -> windows_foundation.IAsyncOperationWithProgress[winrt.system.UInt32, winrt.system.UInt32]: ...

@typing.final
class SystemAudioProperties(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemAudioProperties: ...
    @_property
    def encoding_bitrate(self) -> str: ...

@typing.final
class SystemDataPaths_Static(type):
    def get_default(cls) -> typing.Optional[SystemDataPaths]: ...

@typing.final
class SystemDataPaths(winrt.system.Object, metaclass=SystemDataPaths_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemDataPaths: ...
    @_property
    def fonts(self) -> str: ...
    @_property
    def program_data(self) -> str: ...
    @_property
    def public(self) -> str: ...
    @_property
    def public_desktop(self) -> str: ...
    @_property
    def public_documents(self) -> str: ...
    @_property
    def public_downloads(self) -> str: ...
    @_property
    def public_music(self) -> str: ...
    @_property
    def public_pictures(self) -> str: ...
    @_property
    def public_videos(self) -> str: ...
    @_property
    def system(self) -> str: ...
    @_property
    def system_arm(self) -> str: ...
    @_property
    def system_host(self) -> str: ...
    @_property
    def system_x64(self) -> str: ...
    @_property
    def system_x86(self) -> str: ...
    @_property
    def user_profiles(self) -> str: ...
    @_property
    def windows(self) -> str: ...

@typing.final
class SystemGPSProperties(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemGPSProperties: ...
    @_property
    def latitude_decimal(self) -> str: ...
    @_property
    def longitude_decimal(self) -> str: ...

@typing.final
class SystemImageProperties(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemImageProperties: ...
    @_property
    def horizontal_size(self) -> str: ...
    @_property
    def vertical_size(self) -> str: ...

@typing.final
class SystemMediaProperties(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemMediaProperties: ...
    @_property
    def duration(self) -> str: ...
    @_property
    def producer(self) -> str: ...
    @_property
    def publisher(self) -> str: ...
    @_property
    def sub_title(self) -> str: ...
    @_property
    def writer(self) -> str: ...
    @_property
    def year(self) -> str: ...

@typing.final
class SystemMusicProperties(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemMusicProperties: ...
    @_property
    def album_artist(self) -> str: ...
    @_property
    def album_title(self) -> str: ...
    @_property
    def artist(self) -> str: ...
    @_property
    def composer(self) -> str: ...
    @_property
    def conductor(self) -> str: ...
    @_property
    def display_artist(self) -> str: ...
    @_property
    def genre(self) -> str: ...
    @_property
    def track_number(self) -> str: ...

@typing.final
class SystemPhotoProperties(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemPhotoProperties: ...
    @_property
    def camera_manufacturer(self) -> str: ...
    @_property
    def camera_model(self) -> str: ...
    @_property
    def date_taken(self) -> str: ...
    @_property
    def orientation(self) -> str: ...
    @_property
    def people_names(self) -> str: ...

@typing.final
class SystemProperties_Static(type):
    @_property
    def audio(cls) -> typing.Optional[SystemAudioProperties]: ...
    @_property
    def author(cls) -> str: ...
    @_property
    def comment(cls) -> str: ...
    @_property
    def g_p_s(cls) -> typing.Optional[SystemGPSProperties]: ...
    @_property
    def image(cls) -> typing.Optional[SystemImageProperties]: ...
    @_property
    def item_name_display(cls) -> str: ...
    @_property
    def keywords(cls) -> str: ...
    @_property
    def media(cls) -> typing.Optional[SystemMediaProperties]: ...
    @_property
    def music(cls) -> typing.Optional[SystemMusicProperties]: ...
    @_property
    def photo(cls) -> typing.Optional[SystemPhotoProperties]: ...
    @_property
    def rating(cls) -> str: ...
    @_property
    def title(cls) -> str: ...
    @_property
    def video(cls) -> typing.Optional[SystemVideoProperties]: ...

@typing.final
class SystemProperties(winrt.system.Object, metaclass=SystemProperties_Static):
    pass

@typing.final
class SystemVideoProperties(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemVideoProperties: ...
    @_property
    def director(self) -> str: ...
    @_property
    def frame_height(self) -> str: ...
    @_property
    def frame_width(self) -> str: ...
    @_property
    def orientation(self) -> str: ...
    @_property
    def total_bitrate(self) -> str: ...

@typing.final
class UserDataPaths_Static(type):
    def get_default(cls) -> typing.Optional[UserDataPaths]: ...
    def get_for_user(cls, user: typing.Optional[windows_system.User], /) -> typing.Optional[UserDataPaths]: ...

@typing.final
class UserDataPaths(winrt.system.Object, metaclass=UserDataPaths_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UserDataPaths: ...
    @_property
    def camera_roll(self) -> str: ...
    @_property
    def cookies(self) -> str: ...
    @_property
    def desktop(self) -> str: ...
    @_property
    def documents(self) -> str: ...
    @_property
    def downloads(self) -> str: ...
    @_property
    def favorites(self) -> str: ...
    @_property
    def history(self) -> str: ...
    @_property
    def internet_cache(self) -> str: ...
    @_property
    def local_app_data(self) -> str: ...
    @_property
    def local_app_data_low(self) -> str: ...
    @_property
    def music(self) -> str: ...
    @_property
    def pictures(self) -> str: ...
    @_property
    def profile(self) -> str: ...
    @_property
    def recent(self) -> str: ...
    @_property
    def roaming_app_data(self) -> str: ...
    @_property
    def saved_pictures(self) -> str: ...
    @_property
    def screenshots(self) -> str: ...
    @_property
    def templates(self) -> str: ...
    @_property
    def videos(self) -> str: ...

@typing.final
class IStorageFile(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStorageFile: ...
    def copy_and_replace_async(self, file_to_replace: typing.Optional[IStorageFile], /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def copy_async(self, destination_folder: typing.Optional[IStorageFolder], /) -> windows_foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def copy_async(self, destination_folder: typing.Optional[IStorageFolder], desired_new_name: str, /) -> windows_foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def copy_async(self, destination_folder: typing.Optional[IStorageFolder], desired_new_name: str, option: NameCollisionOption, /) -> windows_foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def delete_async(self) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def delete_async(self, option: StorageDeleteOption, /) -> windows_foundation.IAsyncAction: ...
    def get_basic_properties_async(self) -> windows_foundation.IAsyncOperation[windows_storage_fileproperties.BasicProperties]: ...
    def is_of_type(self, type: StorageItemTypes, /) -> bool: ...
    def move_and_replace_async(self, file_to_replace: typing.Optional[IStorageFile], /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def move_async(self, destination_folder: typing.Optional[IStorageFolder], /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def move_async(self, destination_folder: typing.Optional[IStorageFolder], desired_new_name: str, /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def move_async(self, destination_folder: typing.Optional[IStorageFolder], desired_new_name: str, option: NameCollisionOption, /) -> windows_foundation.IAsyncAction: ...
    def open_async(self, access_mode: FileAccessMode, /) -> windows_foundation.IAsyncOperation[windows_storage_streams.IRandomAccessStream]: ...
    def open_read_async(self) -> windows_foundation.IAsyncOperation[windows_storage_streams.IRandomAccessStreamWithContentType]: ...
    def open_sequential_read_async(self) -> windows_foundation.IAsyncOperation[windows_storage_streams.IInputStream]: ...
    def open_transacted_write_async(self) -> windows_foundation.IAsyncOperation[StorageStreamTransaction]: ...
    @typing.overload
    def rename_async(self, desired_name: str, /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def rename_async(self, desired_name: str, option: NameCollisionOption, /) -> windows_foundation.IAsyncAction: ...
    @_property
    def content_type(self) -> str: ...
    @_property
    def file_type(self) -> str: ...
    @_property
    def attributes(self) -> FileAttributes: ...
    @_property
    def date_created(self) -> datetime.datetime: ...
    @_property
    def name(self) -> str: ...
    @_property
    def path(self) -> str: ...

@typing.final
class IStorageFile2(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStorageFile2: ...
    def open_async(self, access_mode: FileAccessMode, options: StorageOpenOptions, /) -> windows_foundation.IAsyncOperation[windows_storage_streams.IRandomAccessStream]: ...
    def open_transacted_write_async(self, options: StorageOpenOptions, /) -> windows_foundation.IAsyncOperation[StorageStreamTransaction]: ...

@typing.final
class IStorageFilePropertiesWithAvailability(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStorageFilePropertiesWithAvailability: ...
    @_property
    def is_available(self) -> bool: ...

@typing.final
class IStorageFolder(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStorageFolder: ...
    @typing.overload
    def create_file_async(self, desired_name: str, /) -> windows_foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def create_file_async(self, desired_name: str, options: CreationCollisionOption, /) -> windows_foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def create_folder_async(self, desired_name: str, /) -> windows_foundation.IAsyncOperation[StorageFolder]: ...
    @typing.overload
    def create_folder_async(self, desired_name: str, options: CreationCollisionOption, /) -> windows_foundation.IAsyncOperation[StorageFolder]: ...
    @typing.overload
    def delete_async(self) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def delete_async(self, option: StorageDeleteOption, /) -> windows_foundation.IAsyncAction: ...
    def get_basic_properties_async(self) -> windows_foundation.IAsyncOperation[windows_storage_fileproperties.BasicProperties]: ...
    def get_file_async(self, name: str, /) -> windows_foundation.IAsyncOperation[StorageFile]: ...
    def get_files_async(self) -> windows_foundation.IAsyncOperation[windows_foundation_collections.IVectorView[StorageFile]]: ...
    def get_folder_async(self, name: str, /) -> windows_foundation.IAsyncOperation[StorageFolder]: ...
    def get_folders_async(self) -> windows_foundation.IAsyncOperation[windows_foundation_collections.IVectorView[StorageFolder]]: ...
    def get_item_async(self, name: str, /) -> windows_foundation.IAsyncOperation[IStorageItem]: ...
    def get_items_async(self) -> windows_foundation.IAsyncOperation[windows_foundation_collections.IVectorView[IStorageItem]]: ...
    def is_of_type(self, type: StorageItemTypes, /) -> bool: ...
    @typing.overload
    def rename_async(self, desired_name: str, /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def rename_async(self, desired_name: str, option: NameCollisionOption, /) -> windows_foundation.IAsyncAction: ...
    @_property
    def attributes(self) -> FileAttributes: ...
    @_property
    def date_created(self) -> datetime.datetime: ...
    @_property
    def name(self) -> str: ...
    @_property
    def path(self) -> str: ...

@typing.final
class IStorageFolder2(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStorageFolder2: ...
    def try_get_item_async(self, name: str, /) -> windows_foundation.IAsyncOperation[IStorageItem]: ...

@typing.final
class IStorageItem(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStorageItem: ...
    @typing.overload
    def delete_async(self) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def delete_async(self, option: StorageDeleteOption, /) -> windows_foundation.IAsyncAction: ...
    def get_basic_properties_async(self) -> windows_foundation.IAsyncOperation[windows_storage_fileproperties.BasicProperties]: ...
    def is_of_type(self, type: StorageItemTypes, /) -> bool: ...
    @typing.overload
    def rename_async(self, desired_name: str, /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def rename_async(self, desired_name: str, option: NameCollisionOption, /) -> windows_foundation.IAsyncAction: ...
    @_property
    def attributes(self) -> FileAttributes: ...
    @_property
    def date_created(self) -> datetime.datetime: ...
    @_property
    def name(self) -> str: ...
    @_property
    def path(self) -> str: ...

@typing.final
class IStorageItem2(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStorageItem2: ...
    @typing.overload
    def delete_async(self) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def delete_async(self, option: StorageDeleteOption, /) -> windows_foundation.IAsyncAction: ...
    def get_basic_properties_async(self) -> windows_foundation.IAsyncOperation[windows_storage_fileproperties.BasicProperties]: ...
    def get_parent_async(self) -> windows_foundation.IAsyncOperation[StorageFolder]: ...
    def is_equal(self, item: typing.Optional[IStorageItem], /) -> bool: ...
    def is_of_type(self, type: StorageItemTypes, /) -> bool: ...
    @typing.overload
    def rename_async(self, desired_name: str, /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def rename_async(self, desired_name: str, option: NameCollisionOption, /) -> windows_foundation.IAsyncAction: ...
    @_property
    def attributes(self) -> FileAttributes: ...
    @_property
    def date_created(self) -> datetime.datetime: ...
    @_property
    def name(self) -> str: ...
    @_property
    def path(self) -> str: ...

@typing.final
class IStorageItemProperties(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStorageItemProperties: ...
    @typing.overload
    def get_thumbnail_async(self, mode: windows_storage_fileproperties.ThumbnailMode, /) -> windows_foundation.IAsyncOperation[windows_storage_fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: windows_storage_fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, /) -> windows_foundation.IAsyncOperation[windows_storage_fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: windows_storage_fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, options: windows_storage_fileproperties.ThumbnailOptions, /) -> windows_foundation.IAsyncOperation[windows_storage_fileproperties.StorageItemThumbnail]: ...
    @_property
    def display_name(self) -> str: ...
    @_property
    def display_type(self) -> str: ...
    @_property
    def folder_relative_id(self) -> str: ...
    @_property
    def properties(self) -> typing.Optional[windows_storage_fileproperties.StorageItemContentProperties]: ...

@typing.final
class IStorageItemProperties2(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStorageItemProperties2: ...
    @typing.overload
    def get_scaled_image_as_thumbnail_async(self, mode: windows_storage_fileproperties.ThumbnailMode, /) -> windows_foundation.IAsyncOperation[windows_storage_fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_scaled_image_as_thumbnail_async(self, mode: windows_storage_fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, /) -> windows_foundation.IAsyncOperation[windows_storage_fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_scaled_image_as_thumbnail_async(self, mode: windows_storage_fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, options: windows_storage_fileproperties.ThumbnailOptions, /) -> windows_foundation.IAsyncOperation[windows_storage_fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: windows_storage_fileproperties.ThumbnailMode, /) -> windows_foundation.IAsyncOperation[windows_storage_fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: windows_storage_fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, /) -> windows_foundation.IAsyncOperation[windows_storage_fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: windows_storage_fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, options: windows_storage_fileproperties.ThumbnailOptions, /) -> windows_foundation.IAsyncOperation[windows_storage_fileproperties.StorageItemThumbnail]: ...
    @_property
    def display_name(self) -> str: ...
    @_property
    def display_type(self) -> str: ...
    @_property
    def folder_relative_id(self) -> str: ...
    @_property
    def properties(self) -> typing.Optional[windows_storage_fileproperties.StorageItemContentProperties]: ...

@typing.final
class IStorageItemPropertiesWithProvider(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStorageItemPropertiesWithProvider: ...
    @typing.overload
    def get_thumbnail_async(self, mode: windows_storage_fileproperties.ThumbnailMode, /) -> windows_foundation.IAsyncOperation[windows_storage_fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: windows_storage_fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, /) -> windows_foundation.IAsyncOperation[windows_storage_fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: windows_storage_fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, options: windows_storage_fileproperties.ThumbnailOptions, /) -> windows_foundation.IAsyncOperation[windows_storage_fileproperties.StorageItemThumbnail]: ...
    @_property
    def provider(self) -> typing.Optional[StorageProvider]: ...
    @_property
    def display_name(self) -> str: ...
    @_property
    def display_type(self) -> str: ...
    @_property
    def folder_relative_id(self) -> str: ...
    @_property
    def properties(self) -> typing.Optional[windows_storage_fileproperties.StorageItemContentProperties]: ...

@typing.final
class IStreamedFileDataRequest(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStreamedFileDataRequest: ...
    def fail_and_close(self, failure_mode: StreamedFileFailureMode, /) -> None: ...

