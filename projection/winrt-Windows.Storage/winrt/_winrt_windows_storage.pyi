# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.storage.fileproperties
import winrt.windows.storage.provider
import winrt.windows.storage.search
import winrt.windows.storage.streams
import winrt.windows.system

from winrt.windows.storage import ApplicationDataCreateDisposition, ApplicationDataLocality, CreationCollisionOption, FileAccessMode, FileAttributes, KnownFolderId, KnownFoldersAccessStatus, KnownLibraryId, NameCollisionOption, StorageDeleteOption, StorageItemTypes, StorageLibraryChangeType, StorageOpenOptions, StreamedFileFailureMode
from winrt.windows.storage import ApplicationDataSetVersionHandler, StreamedFileDataRequestedHandler

Self = typing.TypeVar('Self')

@typing.final
class AppDataPaths_Static(type):
    def get_default(cls) -> typing.Optional[AppDataPaths]: ...
    def get_for_user(cls, user: typing.Optional[winrt.windows.system.User], /) -> typing.Optional[AppDataPaths]: ...

@typing.final
class AppDataPaths(winrt.system.Object, metaclass=AppDataPaths_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppDataPaths: ...
    @_property
    def cookies(self) -> str: ...
    @_property
    def desktop(self) -> str: ...
    @_property
    def documents(self) -> str: ...
    @_property
    def favorites(self) -> str: ...
    @_property
    def history(self) -> str: ...
    @_property
    def internet_cache(self) -> str: ...
    @_property
    def local_app_data(self) -> str: ...
    @_property
    def program_data(self) -> str: ...
    @_property
    def roaming_app_data(self) -> str: ...

@typing.final
class ApplicationData_Static(type):
    def get_for_user_async(cls, user: typing.Optional[winrt.windows.system.User], /) -> winrt.windows.foundation.IAsyncOperation[ApplicationData]: ...
    @_property
    def current(cls) -> typing.Optional[ApplicationData]: ...

@typing.final
class ApplicationData(winrt.system.Object, metaclass=ApplicationData_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ApplicationData: ...
    @typing.overload
    def clear_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def clear_async(self, locality: ApplicationDataLocality, /) -> winrt.windows.foundation.IAsyncAction: ...
    def clear_publisher_cache_folder_async(self, folder_name: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    def close(self) -> None: ...
    def get_publisher_cache_folder(self, folder_name: str, /) -> typing.Optional[StorageFolder]: ...
    def set_version_async(self, desired_version: winrt.system.UInt32, handler: typing.Optional[ApplicationDataSetVersionHandler], /) -> winrt.windows.foundation.IAsyncAction: ...
    def signal_data_changed(self) -> None: ...
    def add_data_changed(self, handler: winrt.windows.foundation.TypedEventHandler[ApplicationData, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_data_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def local_folder(self) -> typing.Optional[StorageFolder]: ...
    @_property
    def local_settings(self) -> typing.Optional[ApplicationDataContainer]: ...
    @_property
    def roaming_folder(self) -> typing.Optional[StorageFolder]: ...
    @_property
    def roaming_settings(self) -> typing.Optional[ApplicationDataContainer]: ...
    @_property
    def roaming_storage_quota(self) -> winrt.system.UInt64: ...
    @_property
    def temporary_folder(self) -> typing.Optional[StorageFolder]: ...
    @_property
    def version(self) -> winrt.system.UInt32: ...
    @_property
    def local_cache_folder(self) -> typing.Optional[StorageFolder]: ...
    @_property
    def shared_local_folder(self) -> typing.Optional[StorageFolder]: ...

@typing.final
class ApplicationDataCompositeValue(winrt.system.Object, winrt._winrt.MutableMapping[str, winrt.system.Object]):
    def __len__(self) -> int: ...
    def __iter__(self) -> typing.Iterator[str]: ...
    def __contains__(self, key: object) -> bool:...
    def __setitem__(self, key: str, value: winrt.system.Object) -> None: ...
    def __getitem__(self, key: str) -> winrt.system.Object: ...
    def __delitem__(self, key: str) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ApplicationDataCompositeValue: ...
    def __new__(cls: typing.Type[ApplicationDataCompositeValue]) -> ApplicationDataCompositeValue:...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[winrt.windows.foundation.collections.IKeyValuePair[str, winrt.system.Object]]]: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]: ...
    def has_key(self, key: str, /) -> bool: ...
    def insert(self, key: str, value: typing.Optional[winrt.system.Object], /) -> bool: ...
    def lookup(self, key: str, /) -> typing.Optional[winrt.system.Object]: ...
    def remove(self, key: str, /) -> None: ...
    def add_map_changed(self, vhnd: winrt.windows.foundation.collections.MapChangedEventHandler[str, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_map_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class ApplicationDataContainer(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ApplicationDataContainer: ...
    def close(self) -> None: ...
    def create_container(self, name: str, disposition: ApplicationDataCreateDisposition, /) -> typing.Optional[ApplicationDataContainer]: ...
    def delete_container(self, name: str, /) -> None: ...
    @_property
    def containers(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[str, ApplicationDataContainer]]: ...
    @_property
    def locality(self) -> ApplicationDataLocality: ...
    @_property
    def name(self) -> str: ...
    @_property
    def values(self) -> typing.Optional[winrt.windows.foundation.collections.IPropertySet]: ...

@typing.final
class ApplicationDataContainerSettings(winrt.system.Object, winrt._winrt.MutableMapping[str, winrt.system.Object]):
    def __len__(self) -> int: ...
    def __iter__(self) -> typing.Iterator[str]: ...
    def __contains__(self, key: object) -> bool:...
    def __setitem__(self, key: str, value: winrt.system.Object) -> None: ...
    def __getitem__(self, key: str) -> winrt.system.Object: ...
    def __delitem__(self, key: str) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ApplicationDataContainerSettings: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[winrt.windows.foundation.collections.IKeyValuePair[str, winrt.system.Object]]]: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]: ...
    def has_key(self, key: str, /) -> bool: ...
    def insert(self, key: str, value: typing.Optional[winrt.system.Object], /) -> bool: ...
    def lookup(self, key: str, /) -> typing.Optional[winrt.system.Object]: ...
    def remove(self, key: str, /) -> None: ...
    def add_map_changed(self, vhnd: winrt.windows.foundation.collections.MapChangedEventHandler[str, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_map_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class CachedFileManager_Static(type):
    def complete_updates_async(cls, file: typing.Optional[IStorageFile], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.provider.FileUpdateStatus]: ...
    def defer_updates(cls, file: typing.Optional[IStorageFile], /) -> None: ...

@typing.final
class CachedFileManager(winrt.system.Object, metaclass=CachedFileManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CachedFileManager: ...

@typing.final
class DownloadsFolder_Static(type):
    @typing.overload
    def create_file_async(cls, desired_name: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def create_file_async(cls, desired_name: str, option: CreationCollisionOption, /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def create_file_for_user_async(cls, user: typing.Optional[winrt.windows.system.User], desired_name: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def create_file_for_user_async(cls, user: typing.Optional[winrt.windows.system.User], desired_name: str, option: CreationCollisionOption, /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def create_folder_async(cls, desired_name: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...
    @typing.overload
    def create_folder_async(cls, desired_name: str, option: CreationCollisionOption, /) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...
    @typing.overload
    def create_folder_for_user_async(cls, user: typing.Optional[winrt.windows.system.User], desired_name: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...
    @typing.overload
    def create_folder_for_user_async(cls, user: typing.Optional[winrt.windows.system.User], desired_name: str, option: CreationCollisionOption, /) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...

@typing.final
class DownloadsFolder(winrt.system.Object, metaclass=DownloadsFolder_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DownloadsFolder: ...

@typing.final
class FileIO_Static(type):
    @typing.overload
    def append_lines_async(cls, file: typing.Optional[IStorageFile], lines: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def append_lines_async(cls, file: typing.Optional[IStorageFile], lines: typing.Iterable[str], encoding: winrt.windows.storage.streams.UnicodeEncoding, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def append_text_async(cls, file: typing.Optional[IStorageFile], contents: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def append_text_async(cls, file: typing.Optional[IStorageFile], contents: str, encoding: winrt.windows.storage.streams.UnicodeEncoding, /) -> winrt.windows.foundation.IAsyncAction: ...
    def read_buffer_async(cls, file: typing.Optional[IStorageFile], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IBuffer]: ...
    @typing.overload
    def read_lines_async(cls, file: typing.Optional[IStorageFile], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVector[str]]: ...
    @typing.overload
    def read_lines_async(cls, file: typing.Optional[IStorageFile], encoding: winrt.windows.storage.streams.UnicodeEncoding, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVector[str]]: ...
    @typing.overload
    def read_text_async(cls, file: typing.Optional[IStorageFile], /) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    @typing.overload
    def read_text_async(cls, file: typing.Optional[IStorageFile], encoding: winrt.windows.storage.streams.UnicodeEncoding, /) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    def write_buffer_async(cls, file: typing.Optional[IStorageFile], buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> winrt.windows.foundation.IAsyncAction: ...
    def write_bytes_async(cls, file: typing.Optional[IStorageFile], buffer: winrt.system.Array[winrt.system.UInt8], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def write_lines_async(cls, file: typing.Optional[IStorageFile], lines: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def write_lines_async(cls, file: typing.Optional[IStorageFile], lines: typing.Iterable[str], encoding: winrt.windows.storage.streams.UnicodeEncoding, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def write_text_async(cls, file: typing.Optional[IStorageFile], contents: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def write_text_async(cls, file: typing.Optional[IStorageFile], contents: str, encoding: winrt.windows.storage.streams.UnicodeEncoding, /) -> winrt.windows.foundation.IAsyncAction: ...

@typing.final
class FileIO(winrt.system.Object, metaclass=FileIO_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FileIO: ...

@typing.final
class KnownFolders_Static(type):
    def get_folder_async(cls, folder_id: KnownFolderId, /) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...
    def get_folder_for_user_async(cls, user: typing.Optional[winrt.windows.system.User], folder_id: KnownFolderId, /) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...
    def request_access_async(cls, folder_id: KnownFolderId, /) -> winrt.windows.foundation.IAsyncOperation[KnownFoldersAccessStatus]: ...
    def request_access_for_user_async(cls, user: typing.Optional[winrt.windows.system.User], folder_id: KnownFolderId, /) -> winrt.windows.foundation.IAsyncOperation[KnownFoldersAccessStatus]: ...
    @_property
    def camera_roll(cls) -> typing.Optional[StorageFolder]: ...
    @_property
    def playlists(cls) -> typing.Optional[StorageFolder]: ...
    @_property
    def saved_pictures(cls) -> typing.Optional[StorageFolder]: ...
    @_property
    def documents_library(cls) -> typing.Optional[StorageFolder]: ...
    @_property
    def home_group(cls) -> typing.Optional[StorageFolder]: ...
    @_property
    def media_server_devices(cls) -> typing.Optional[StorageFolder]: ...
    @_property
    def music_library(cls) -> typing.Optional[StorageFolder]: ...
    @_property
    def pictures_library(cls) -> typing.Optional[StorageFolder]: ...
    @_property
    def removable_devices(cls) -> typing.Optional[StorageFolder]: ...
    @_property
    def videos_library(cls) -> typing.Optional[StorageFolder]: ...
    @_property
    def app_captures(cls) -> typing.Optional[StorageFolder]: ...
    @_property
    def objects3_d(cls) -> typing.Optional[StorageFolder]: ...
    @_property
    def recorded_calls(cls) -> typing.Optional[StorageFolder]: ...

@typing.final
class KnownFolders(winrt.system.Object, metaclass=KnownFolders_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KnownFolders: ...

@typing.final
class PathIO_Static(type):
    @typing.overload
    def append_lines_async(cls, absolute_path: str, lines: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def append_lines_async(cls, absolute_path: str, lines: typing.Iterable[str], encoding: winrt.windows.storage.streams.UnicodeEncoding, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def append_text_async(cls, absolute_path: str, contents: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def append_text_async(cls, absolute_path: str, contents: str, encoding: winrt.windows.storage.streams.UnicodeEncoding, /) -> winrt.windows.foundation.IAsyncAction: ...
    def read_buffer_async(cls, absolute_path: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IBuffer]: ...
    @typing.overload
    def read_lines_async(cls, absolute_path: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVector[str]]: ...
    @typing.overload
    def read_lines_async(cls, absolute_path: str, encoding: winrt.windows.storage.streams.UnicodeEncoding, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVector[str]]: ...
    @typing.overload
    def read_text_async(cls, absolute_path: str, /) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    @typing.overload
    def read_text_async(cls, absolute_path: str, encoding: winrt.windows.storage.streams.UnicodeEncoding, /) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    def write_buffer_async(cls, absolute_path: str, buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> winrt.windows.foundation.IAsyncAction: ...
    def write_bytes_async(cls, absolute_path: str, buffer: winrt.system.Array[winrt.system.UInt8], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def write_lines_async(cls, absolute_path: str, lines: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def write_lines_async(cls, absolute_path: str, lines: typing.Iterable[str], encoding: winrt.windows.storage.streams.UnicodeEncoding, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def write_text_async(cls, absolute_path: str, contents: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def write_text_async(cls, absolute_path: str, contents: str, encoding: winrt.windows.storage.streams.UnicodeEncoding, /) -> winrt.windows.foundation.IAsyncAction: ...

@typing.final
class PathIO(winrt.system.Object, metaclass=PathIO_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PathIO: ...

@typing.final
class SetVersionDeferral(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SetVersionDeferral: ...
    def complete(self) -> None: ...

@typing.final
class SetVersionRequest(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SetVersionRequest: ...
    def get_deferral(self) -> typing.Optional[SetVersionDeferral]: ...
    @_property
    def current_version(self) -> winrt.system.UInt32: ...
    @_property
    def desired_version(self) -> winrt.system.UInt32: ...

@typing.final
class StorageFile_Static(type):
    def create_streamed_file_async(cls, display_name_with_extension: str, data_requested: typing.Optional[StreamedFileDataRequestedHandler], thumbnail: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference], /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    def create_streamed_file_from_uri_async(cls, display_name_with_extension: str, uri: typing.Optional[winrt.windows.foundation.Uri], thumbnail: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference], /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    def get_file_from_application_uri_async(cls, uri: typing.Optional[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    def get_file_from_path_async(cls, path: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    def get_file_from_path_for_user_async(cls, user: typing.Optional[winrt.windows.system.User], path: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    def replace_with_streamed_file_async(cls, file_to_replace: typing.Optional[IStorageFile], data_requested: typing.Optional[StreamedFileDataRequestedHandler], thumbnail: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference], /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    def replace_with_streamed_file_from_uri_async(cls, file_to_replace: typing.Optional[IStorageFile], uri: typing.Optional[winrt.windows.foundation.Uri], thumbnail: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference], /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...

@typing.final
class StorageFile(winrt.system.Object, metaclass=StorageFile_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageFile: ...
    def copy_and_replace_async(self, file_to_replace: typing.Optional[IStorageFile], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def copy_async(self, destination_folder: typing.Optional[IStorageFolder], /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def copy_async(self, destination_folder: typing.Optional[IStorageFolder], desired_new_name: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def copy_async(self, destination_folder: typing.Optional[IStorageFolder], desired_new_name: str, option: NameCollisionOption, /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def delete_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def delete_async(self, option: StorageDeleteOption, /) -> winrt.windows.foundation.IAsyncAction: ...
    def get_basic_properties_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.BasicProperties]: ...
    def get_parent_async(self) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...
    @typing.overload
    def get_scaled_image_as_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_scaled_image_as_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_scaled_image_as_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, options: winrt.windows.storage.fileproperties.ThumbnailOptions, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, options: winrt.windows.storage.fileproperties.ThumbnailOptions, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    def is_equal(self, item: typing.Optional[IStorageItem], /) -> bool: ...
    def is_of_type(self, type: StorageItemTypes, /) -> bool: ...
    def move_and_replace_async(self, file_to_replace: typing.Optional[IStorageFile], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def move_async(self, destination_folder: typing.Optional[IStorageFolder], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def move_async(self, destination_folder: typing.Optional[IStorageFolder], desired_new_name: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def move_async(self, destination_folder: typing.Optional[IStorageFolder], desired_new_name: str, option: NameCollisionOption, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def open_async(self, access_mode: FileAccessMode, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IRandomAccessStream]: ...
    @typing.overload
    def open_async(self, access_mode: FileAccessMode, options: StorageOpenOptions, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IRandomAccessStream]: ...
    def open_read_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IRandomAccessStreamWithContentType]: ...
    def open_sequential_read_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IInputStream]: ...
    @typing.overload
    def open_transacted_write_async(self) -> winrt.windows.foundation.IAsyncOperation[StorageStreamTransaction]: ...
    @typing.overload
    def open_transacted_write_async(self, options: StorageOpenOptions, /) -> winrt.windows.foundation.IAsyncOperation[StorageStreamTransaction]: ...
    @typing.overload
    def rename_async(self, desired_name: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def rename_async(self, desired_name: str, option: NameCollisionOption, /) -> winrt.windows.foundation.IAsyncAction: ...
    @_property
    def content_type(self) -> str: ...
    @_property
    def file_type(self) -> str: ...
    @_property
    def is_available(self) -> bool: ...
    @_property
    def attributes(self) -> FileAttributes: ...
    @_property
    def date_created(self) -> datetime.datetime: ...
    @_property
    def name(self) -> str: ...
    @_property
    def path(self) -> str: ...
    @_property
    def display_name(self) -> str: ...
    @_property
    def display_type(self) -> str: ...
    @_property
    def folder_relative_id(self) -> str: ...
    @_property
    def properties(self) -> typing.Optional[winrt.windows.storage.fileproperties.StorageItemContentProperties]: ...
    @_property
    def provider(self) -> typing.Optional[StorageProvider]: ...

@typing.final
class StorageFolder_Static(type):
    def get_folder_from_path_async(cls, path: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...
    def get_folder_from_path_for_user_async(cls, user: typing.Optional[winrt.windows.system.User], path: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...

@typing.final
class StorageFolder(winrt.system.Object, metaclass=StorageFolder_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageFolder: ...
    def are_query_options_supported(self, query_options: typing.Optional[winrt.windows.storage.search.QueryOptions], /) -> bool: ...
    @typing.overload
    def create_file_async(self, desired_name: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def create_file_async(self, desired_name: str, options: CreationCollisionOption, /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def create_file_query(self) -> typing.Optional[winrt.windows.storage.search.StorageFileQueryResult]: ...
    @typing.overload
    def create_file_query(self, query: winrt.windows.storage.search.CommonFileQuery, /) -> typing.Optional[winrt.windows.storage.search.StorageFileQueryResult]: ...
    def create_file_query_with_options(self, query_options: typing.Optional[winrt.windows.storage.search.QueryOptions], /) -> typing.Optional[winrt.windows.storage.search.StorageFileQueryResult]: ...
    @typing.overload
    def create_folder_async(self, desired_name: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...
    @typing.overload
    def create_folder_async(self, desired_name: str, options: CreationCollisionOption, /) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...
    @typing.overload
    def create_folder_query(self) -> typing.Optional[winrt.windows.storage.search.StorageFolderQueryResult]: ...
    @typing.overload
    def create_folder_query(self, query: winrt.windows.storage.search.CommonFolderQuery, /) -> typing.Optional[winrt.windows.storage.search.StorageFolderQueryResult]: ...
    def create_folder_query_with_options(self, query_options: typing.Optional[winrt.windows.storage.search.QueryOptions], /) -> typing.Optional[winrt.windows.storage.search.StorageFolderQueryResult]: ...
    def create_item_query(self) -> typing.Optional[winrt.windows.storage.search.StorageItemQueryResult]: ...
    def create_item_query_with_options(self, query_options: typing.Optional[winrt.windows.storage.search.QueryOptions], /) -> typing.Optional[winrt.windows.storage.search.StorageItemQueryResult]: ...
    @typing.overload
    def delete_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def delete_async(self, option: StorageDeleteOption, /) -> winrt.windows.foundation.IAsyncAction: ...
    def get_basic_properties_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.BasicProperties]: ...
    def get_file_async(self, name: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def get_files_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[StorageFile]]: ...
    @typing.overload
    def get_files_async(self, query: winrt.windows.storage.search.CommonFileQuery, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[StorageFile]]: ...
    @typing.overload
    def get_files_async(self, query: winrt.windows.storage.search.CommonFileQuery, start_index: winrt.system.UInt32, max_items_to_retrieve: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[StorageFile]]: ...
    def get_folder_async(self, name: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...
    @typing.overload
    def get_folders_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[StorageFolder]]: ...
    @typing.overload
    def get_folders_async(self, query: winrt.windows.storage.search.CommonFolderQuery, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[StorageFolder]]: ...
    @typing.overload
    def get_folders_async(self, query: winrt.windows.storage.search.CommonFolderQuery, start_index: winrt.system.UInt32, max_items_to_retrieve: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[StorageFolder]]: ...
    def get_indexed_state_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.search.IndexedState]: ...
    def get_item_async(self, name: str, /) -> winrt.windows.foundation.IAsyncOperation[IStorageItem]: ...
    @typing.overload
    def get_items_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[IStorageItem]]: ...
    @typing.overload
    def get_items_async(self, start_index: winrt.system.UInt32, max_items_to_retrieve: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[IStorageItem]]: ...
    def get_parent_async(self) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...
    @typing.overload
    def get_scaled_image_as_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_scaled_image_as_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_scaled_image_as_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, options: winrt.windows.storage.fileproperties.ThumbnailOptions, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, options: winrt.windows.storage.fileproperties.ThumbnailOptions, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    def is_common_file_query_supported(self, query: winrt.windows.storage.search.CommonFileQuery, /) -> bool: ...
    def is_common_folder_query_supported(self, query: winrt.windows.storage.search.CommonFolderQuery, /) -> bool: ...
    def is_equal(self, item: typing.Optional[IStorageItem], /) -> bool: ...
    def is_of_type(self, type: StorageItemTypes, /) -> bool: ...
    @typing.overload
    def rename_async(self, desired_name: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def rename_async(self, desired_name: str, option: NameCollisionOption, /) -> winrt.windows.foundation.IAsyncAction: ...
    def try_get_change_tracker(self) -> typing.Optional[StorageLibraryChangeTracker]: ...
    def try_get_item_async(self, name: str, /) -> winrt.windows.foundation.IAsyncOperation[IStorageItem]: ...
    @_property
    def attributes(self) -> FileAttributes: ...
    @_property
    def date_created(self) -> datetime.datetime: ...
    @_property
    def name(self) -> str: ...
    @_property
    def path(self) -> str: ...
    @_property
    def display_name(self) -> str: ...
    @_property
    def display_type(self) -> str: ...
    @_property
    def folder_relative_id(self) -> str: ...
    @_property
    def properties(self) -> typing.Optional[winrt.windows.storage.fileproperties.StorageItemContentProperties]: ...
    @_property
    def provider(self) -> typing.Optional[StorageProvider]: ...

@typing.final
class StorageLibrary_Static(type):
    def get_library_async(cls, library_id: KnownLibraryId, /) -> winrt.windows.foundation.IAsyncOperation[StorageLibrary]: ...
    def get_library_for_user_async(cls, user: typing.Optional[winrt.windows.system.User], library_id: KnownLibraryId, /) -> winrt.windows.foundation.IAsyncOperation[StorageLibrary]: ...

@typing.final
class StorageLibrary(winrt.system.Object, metaclass=StorageLibrary_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageLibrary: ...
    def are_folder_suggestions_available_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def request_add_folder_async(self) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...
    def request_remove_folder_async(self, folder: typing.Optional[StorageFolder], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def add_definition_changed(self, handler: winrt.windows.foundation.TypedEventHandler[StorageLibrary, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_definition_changed(self, event_cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def folders(self) -> typing.Optional[winrt.windows.foundation.collections.IObservableVector[StorageFolder]]: ...
    @_property
    def save_folder(self) -> typing.Optional[StorageFolder]: ...
    @_property
    def change_tracker(self) -> typing.Optional[StorageLibraryChangeTracker]: ...

@typing.final
class StorageLibraryChange(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageLibraryChange: ...
    def get_storage_item_async(self) -> winrt.windows.foundation.IAsyncOperation[IStorageItem]: ...
    def is_of_type(self, type: StorageItemTypes, /) -> bool: ...
    @_property
    def change_type(self) -> StorageLibraryChangeType: ...
    @_property
    def path(self) -> str: ...
    @_property
    def previous_path(self) -> str: ...

@typing.final
class StorageLibraryChangeReader(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageLibraryChangeReader: ...
    def accept_changes_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def get_last_change_id(self) -> winrt.system.UInt64: ...
    def read_batch_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[StorageLibraryChange]]: ...

@typing.final
class StorageLibraryChangeTracker(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageLibraryChangeTracker: ...
    def disable(self) -> None: ...
    @typing.overload
    def enable(self) -> None: ...
    @typing.overload
    def enable(self, options: typing.Optional[StorageLibraryChangeTrackerOptions], /) -> None: ...
    def get_change_reader(self) -> typing.Optional[StorageLibraryChangeReader]: ...
    def reset(self) -> None: ...

@typing.final
class StorageLibraryChangeTrackerOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageLibraryChangeTrackerOptions: ...
    def __new__(cls: typing.Type[StorageLibraryChangeTrackerOptions]) -> StorageLibraryChangeTrackerOptions:...
    @_property
    def track_change_details(self) -> bool: ...
    @track_change_details.setter
    def track_change_details(self, value: bool) -> None: ...

@typing.final
class StorageLibraryLastChangeId_Static(type):
    @_property
    def unknown(cls) -> winrt.system.UInt64: ...

@typing.final
class StorageLibraryLastChangeId(winrt.system.Object, metaclass=StorageLibraryLastChangeId_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageLibraryLastChangeId: ...

@typing.final
class StorageProvider(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageProvider: ...
    def is_property_supported_for_partial_file_async(self, property_canonical_name: str, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @_property
    def display_name(self) -> str: ...
    @_property
    def id(self) -> str: ...

@typing.final
class StorageStreamTransaction(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageStreamTransaction: ...
    def close(self) -> None: ...
    def commit_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    @_property
    def stream(self) -> typing.Optional[winrt.windows.storage.streams.IRandomAccessStream]: ...

@typing.final
class StreamedFileDataRequest(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StreamedFileDataRequest: ...
    def close(self) -> None: ...
    def fail_and_close(self, failure_mode: StreamedFileFailureMode, /) -> None: ...
    def flush_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def write_async(self, buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[winrt.system.UInt32, winrt.system.UInt32]: ...

@typing.final
class SystemAudioProperties(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemAudioProperties: ...
    @_property
    def encoding_bitrate(self) -> str: ...

@typing.final
class SystemDataPaths_Static(type):
    def get_default(cls) -> typing.Optional[SystemDataPaths]: ...

@typing.final
class SystemDataPaths(winrt.system.Object, metaclass=SystemDataPaths_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemDataPaths: ...
    @_property
    def fonts(self) -> str: ...
    @_property
    def program_data(self) -> str: ...
    @_property
    def public(self) -> str: ...
    @_property
    def public_desktop(self) -> str: ...
    @_property
    def public_documents(self) -> str: ...
    @_property
    def public_downloads(self) -> str: ...
    @_property
    def public_music(self) -> str: ...
    @_property
    def public_pictures(self) -> str: ...
    @_property
    def public_videos(self) -> str: ...
    @_property
    def system(self) -> str: ...
    @_property
    def system_arm(self) -> str: ...
    @_property
    def system_host(self) -> str: ...
    @_property
    def system_x64(self) -> str: ...
    @_property
    def system_x86(self) -> str: ...
    @_property
    def user_profiles(self) -> str: ...
    @_property
    def windows(self) -> str: ...

@typing.final
class SystemGPSProperties(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemGPSProperties: ...
    @_property
    def latitude_decimal(self) -> str: ...
    @_property
    def longitude_decimal(self) -> str: ...

@typing.final
class SystemImageProperties(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemImageProperties: ...
    @_property
    def horizontal_size(self) -> str: ...
    @_property
    def vertical_size(self) -> str: ...

@typing.final
class SystemMediaProperties(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemMediaProperties: ...
    @_property
    def duration(self) -> str: ...
    @_property
    def producer(self) -> str: ...
    @_property
    def publisher(self) -> str: ...
    @_property
    def sub_title(self) -> str: ...
    @_property
    def writer(self) -> str: ...
    @_property
    def year(self) -> str: ...

@typing.final
class SystemMusicProperties(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemMusicProperties: ...
    @_property
    def album_artist(self) -> str: ...
    @_property
    def album_title(self) -> str: ...
    @_property
    def artist(self) -> str: ...
    @_property
    def composer(self) -> str: ...
    @_property
    def conductor(self) -> str: ...
    @_property
    def display_artist(self) -> str: ...
    @_property
    def genre(self) -> str: ...
    @_property
    def track_number(self) -> str: ...

@typing.final
class SystemPhotoProperties(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemPhotoProperties: ...
    @_property
    def camera_manufacturer(self) -> str: ...
    @_property
    def camera_model(self) -> str: ...
    @_property
    def date_taken(self) -> str: ...
    @_property
    def orientation(self) -> str: ...
    @_property
    def people_names(self) -> str: ...

@typing.final
class SystemProperties_Static(type):
    @_property
    def audio(cls) -> typing.Optional[SystemAudioProperties]: ...
    @_property
    def author(cls) -> str: ...
    @_property
    def comment(cls) -> str: ...
    @_property
    def g_p_s(cls) -> typing.Optional[SystemGPSProperties]: ...
    @_property
    def image(cls) -> typing.Optional[SystemImageProperties]: ...
    @_property
    def item_name_display(cls) -> str: ...
    @_property
    def keywords(cls) -> str: ...
    @_property
    def media(cls) -> typing.Optional[SystemMediaProperties]: ...
    @_property
    def music(cls) -> typing.Optional[SystemMusicProperties]: ...
    @_property
    def photo(cls) -> typing.Optional[SystemPhotoProperties]: ...
    @_property
    def rating(cls) -> str: ...
    @_property
    def title(cls) -> str: ...
    @_property
    def video(cls) -> typing.Optional[SystemVideoProperties]: ...

@typing.final
class SystemProperties(winrt.system.Object, metaclass=SystemProperties_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemProperties: ...

@typing.final
class SystemVideoProperties(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemVideoProperties: ...
    @_property
    def director(self) -> str: ...
    @_property
    def frame_height(self) -> str: ...
    @_property
    def frame_width(self) -> str: ...
    @_property
    def orientation(self) -> str: ...
    @_property
    def total_bitrate(self) -> str: ...

@typing.final
class UserDataPaths_Static(type):
    def get_default(cls) -> typing.Optional[UserDataPaths]: ...
    def get_for_user(cls, user: typing.Optional[winrt.windows.system.User], /) -> typing.Optional[UserDataPaths]: ...

@typing.final
class UserDataPaths(winrt.system.Object, metaclass=UserDataPaths_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UserDataPaths: ...
    @_property
    def camera_roll(self) -> str: ...
    @_property
    def cookies(self) -> str: ...
    @_property
    def desktop(self) -> str: ...
    @_property
    def documents(self) -> str: ...
    @_property
    def downloads(self) -> str: ...
    @_property
    def favorites(self) -> str: ...
    @_property
    def history(self) -> str: ...
    @_property
    def internet_cache(self) -> str: ...
    @_property
    def local_app_data(self) -> str: ...
    @_property
    def local_app_data_low(self) -> str: ...
    @_property
    def music(self) -> str: ...
    @_property
    def pictures(self) -> str: ...
    @_property
    def profile(self) -> str: ...
    @_property
    def recent(self) -> str: ...
    @_property
    def roaming_app_data(self) -> str: ...
    @_property
    def saved_pictures(self) -> str: ...
    @_property
    def screenshots(self) -> str: ...
    @_property
    def templates(self) -> str: ...
    @_property
    def videos(self) -> str: ...

@typing.final
class IStorageFile(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStorageFile: ...
    def copy_and_replace_async(self, file_to_replace: typing.Optional[IStorageFile], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def copy_async(self, destination_folder: typing.Optional[IStorageFolder], /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def copy_async(self, destination_folder: typing.Optional[IStorageFolder], desired_new_name: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def copy_async(self, destination_folder: typing.Optional[IStorageFolder], desired_new_name: str, option: NameCollisionOption, /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def delete_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def delete_async(self, option: StorageDeleteOption, /) -> winrt.windows.foundation.IAsyncAction: ...
    def get_basic_properties_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.BasicProperties]: ...
    def is_of_type(self, type: StorageItemTypes, /) -> bool: ...
    def move_and_replace_async(self, file_to_replace: typing.Optional[IStorageFile], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def move_async(self, destination_folder: typing.Optional[IStorageFolder], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def move_async(self, destination_folder: typing.Optional[IStorageFolder], desired_new_name: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def move_async(self, destination_folder: typing.Optional[IStorageFolder], desired_new_name: str, option: NameCollisionOption, /) -> winrt.windows.foundation.IAsyncAction: ...
    def open_async(self, access_mode: FileAccessMode, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IRandomAccessStream]: ...
    def open_read_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IRandomAccessStreamWithContentType]: ...
    def open_sequential_read_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IInputStream]: ...
    def open_transacted_write_async(self) -> winrt.windows.foundation.IAsyncOperation[StorageStreamTransaction]: ...
    @typing.overload
    def rename_async(self, desired_name: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def rename_async(self, desired_name: str, option: NameCollisionOption, /) -> winrt.windows.foundation.IAsyncAction: ...
    @_property
    def content_type(self) -> str: ...
    @_property
    def file_type(self) -> str: ...
    @_property
    def attributes(self) -> FileAttributes: ...
    @_property
    def date_created(self) -> datetime.datetime: ...
    @_property
    def name(self) -> str: ...
    @_property
    def path(self) -> str: ...

@typing.final
class IStorageFile2(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStorageFile2: ...
    def open_async(self, access_mode: FileAccessMode, options: StorageOpenOptions, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IRandomAccessStream]: ...
    def open_transacted_write_async(self, options: StorageOpenOptions, /) -> winrt.windows.foundation.IAsyncOperation[StorageStreamTransaction]: ...

@typing.final
class IStorageFilePropertiesWithAvailability(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStorageFilePropertiesWithAvailability: ...
    @_property
    def is_available(self) -> bool: ...

@typing.final
class IStorageFolder(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStorageFolder: ...
    @typing.overload
    def create_file_async(self, desired_name: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def create_file_async(self, desired_name: str, options: CreationCollisionOption, /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def create_folder_async(self, desired_name: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...
    @typing.overload
    def create_folder_async(self, desired_name: str, options: CreationCollisionOption, /) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...
    @typing.overload
    def delete_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def delete_async(self, option: StorageDeleteOption, /) -> winrt.windows.foundation.IAsyncAction: ...
    def get_basic_properties_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.BasicProperties]: ...
    def get_file_async(self, name: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    def get_files_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[StorageFile]]: ...
    def get_folder_async(self, name: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...
    def get_folders_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[StorageFolder]]: ...
    def get_item_async(self, name: str, /) -> winrt.windows.foundation.IAsyncOperation[IStorageItem]: ...
    def get_items_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[IStorageItem]]: ...
    def is_of_type(self, type: StorageItemTypes, /) -> bool: ...
    @typing.overload
    def rename_async(self, desired_name: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def rename_async(self, desired_name: str, option: NameCollisionOption, /) -> winrt.windows.foundation.IAsyncAction: ...
    @_property
    def attributes(self) -> FileAttributes: ...
    @_property
    def date_created(self) -> datetime.datetime: ...
    @_property
    def name(self) -> str: ...
    @_property
    def path(self) -> str: ...

@typing.final
class IStorageFolder2(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStorageFolder2: ...
    def try_get_item_async(self, name: str, /) -> winrt.windows.foundation.IAsyncOperation[IStorageItem]: ...

@typing.final
class IStorageItem(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStorageItem: ...
    @typing.overload
    def delete_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def delete_async(self, option: StorageDeleteOption, /) -> winrt.windows.foundation.IAsyncAction: ...
    def get_basic_properties_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.BasicProperties]: ...
    def is_of_type(self, type: StorageItemTypes, /) -> bool: ...
    @typing.overload
    def rename_async(self, desired_name: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def rename_async(self, desired_name: str, option: NameCollisionOption, /) -> winrt.windows.foundation.IAsyncAction: ...
    @_property
    def attributes(self) -> FileAttributes: ...
    @_property
    def date_created(self) -> datetime.datetime: ...
    @_property
    def name(self) -> str: ...
    @_property
    def path(self) -> str: ...

@typing.final
class IStorageItem2(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStorageItem2: ...
    @typing.overload
    def delete_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def delete_async(self, option: StorageDeleteOption, /) -> winrt.windows.foundation.IAsyncAction: ...
    def get_basic_properties_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.BasicProperties]: ...
    def get_parent_async(self) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...
    def is_equal(self, item: typing.Optional[IStorageItem], /) -> bool: ...
    def is_of_type(self, type: StorageItemTypes, /) -> bool: ...
    @typing.overload
    def rename_async(self, desired_name: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def rename_async(self, desired_name: str, option: NameCollisionOption, /) -> winrt.windows.foundation.IAsyncAction: ...
    @_property
    def attributes(self) -> FileAttributes: ...
    @_property
    def date_created(self) -> datetime.datetime: ...
    @_property
    def name(self) -> str: ...
    @_property
    def path(self) -> str: ...

@typing.final
class IStorageItemProperties(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStorageItemProperties: ...
    @typing.overload
    def get_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, options: winrt.windows.storage.fileproperties.ThumbnailOptions, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @_property
    def display_name(self) -> str: ...
    @_property
    def display_type(self) -> str: ...
    @_property
    def folder_relative_id(self) -> str: ...
    @_property
    def properties(self) -> typing.Optional[winrt.windows.storage.fileproperties.StorageItemContentProperties]: ...

@typing.final
class IStorageItemProperties2(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStorageItemProperties2: ...
    @typing.overload
    def get_scaled_image_as_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_scaled_image_as_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_scaled_image_as_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, options: winrt.windows.storage.fileproperties.ThumbnailOptions, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, options: winrt.windows.storage.fileproperties.ThumbnailOptions, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @_property
    def display_name(self) -> str: ...
    @_property
    def display_type(self) -> str: ...
    @_property
    def folder_relative_id(self) -> str: ...
    @_property
    def properties(self) -> typing.Optional[winrt.windows.storage.fileproperties.StorageItemContentProperties]: ...

@typing.final
class IStorageItemPropertiesWithProvider(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStorageItemPropertiesWithProvider: ...
    @typing.overload
    def get_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, options: winrt.windows.storage.fileproperties.ThumbnailOptions, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @_property
    def provider(self) -> typing.Optional[StorageProvider]: ...
    @_property
    def display_name(self) -> str: ...
    @_property
    def display_type(self) -> str: ...
    @_property
    def folder_relative_id(self) -> str: ...
    @_property
    def properties(self) -> typing.Optional[winrt.windows.storage.fileproperties.StorageItemContentProperties]: ...

@typing.final
class IStreamedFileDataRequest(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStreamedFileDataRequest: ...
    def fail_and_close(self, failure_mode: StreamedFileFailureMode, /) -> None: ...

