// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Storage.h"


namespace py::cpp::Windows::Storage
{
    // ----- AppDataPaths class --------------------

    static PyObject* _new_AppDataPaths(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::AppDataPaths>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::AppDataPaths>::type_name);
        return nullptr;
    }

    static void _dealloc_AppDataPaths(py::wrapper::Windows::Storage::AppDataPaths* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppDataPaths_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.AppDataPaths", L"GetDefault", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Storage::AppDataPaths::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.AppDataPaths", L"GetForUser", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::Storage::AppDataPaths::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_Cookies(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.AppDataPaths", L"Cookies"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Cookies());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_Desktop(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.AppDataPaths", L"Desktop"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Desktop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_Documents(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.AppDataPaths", L"Documents"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Documents());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_Favorites(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.AppDataPaths", L"Favorites"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Favorites());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_History(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.AppDataPaths", L"History"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.History());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_InternetCache(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.AppDataPaths", L"InternetCache"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InternetCache());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_LocalAppData(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.AppDataPaths", L"LocalAppData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalAppData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_ProgramData(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.AppDataPaths", L"ProgramData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProgramData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_RoamingAppData(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.AppDataPaths", L"RoamingAppData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RoamingAppData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppDataPaths(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::AppDataPaths>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppDataPaths(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::AppDataPaths>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppDataPaths[] = {
        { "_assign_array_", _assign_array_AppDataPaths, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppDataPaths), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppDataPaths[] = {
        { "cookies", reinterpret_cast<getter>(AppDataPaths_get_Cookies), nullptr, nullptr, nullptr },
        { "desktop", reinterpret_cast<getter>(AppDataPaths_get_Desktop), nullptr, nullptr, nullptr },
        { "documents", reinterpret_cast<getter>(AppDataPaths_get_Documents), nullptr, nullptr, nullptr },
        { "favorites", reinterpret_cast<getter>(AppDataPaths_get_Favorites), nullptr, nullptr, nullptr },
        { "history", reinterpret_cast<getter>(AppDataPaths_get_History), nullptr, nullptr, nullptr },
        { "internet_cache", reinterpret_cast<getter>(AppDataPaths_get_InternetCache), nullptr, nullptr, nullptr },
        { "local_app_data", reinterpret_cast<getter>(AppDataPaths_get_LocalAppData), nullptr, nullptr, nullptr },
        { "program_data", reinterpret_cast<getter>(AppDataPaths_get_ProgramData), nullptr, nullptr, nullptr },
        { "roaming_app_data", reinterpret_cast<getter>(AppDataPaths_get_RoamingAppData), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppDataPaths[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppDataPaths) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppDataPaths) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppDataPaths) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppDataPaths) },
        { },
    };

    static PyType_Spec type_spec_AppDataPaths =
    {
        "winrt._winrt_windows_storage.AppDataPaths",
        sizeof(py::wrapper::Windows::Storage::AppDataPaths),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppDataPaths
    };

    static PyGetSetDef getset_AppDataPaths_Static[] = {
        { }
    };

    static PyMethodDef methods_AppDataPaths_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(AppDataPaths_GetDefault), METH_VARARGS, nullptr },
        { "get_for_user", reinterpret_cast<PyCFunction>(AppDataPaths_GetForUser), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AppDataPaths_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppDataPaths_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppDataPaths_Static) },
        { }
    };

    static PyType_Spec type_spec_AppDataPaths_Static =
    {
        "winrt._winrt_windows_storage.AppDataPaths_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AppDataPaths_Static
    };

    // ----- ApplicationData class --------------------

    static PyObject* _new_ApplicationData(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::ApplicationData>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::ApplicationData>::type_name);
        return nullptr;
    }

    static void _dealloc_ApplicationData(py::wrapper::Windows::Storage::ApplicationData* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ApplicationData_ClearAsync(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationData", L"ClearAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ClearAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationData", L"ClearAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::ApplicationDataLocality>(args, 0);

                return py::convert(self->obj.ClearAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationData_ClearPublisherCacheFolderAsync(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationData", L"ClearPublisherCacheFolderAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ClearPublisherCacheFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationData_Close(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationData", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationData_GetForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationData", L"GetForUserAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::Storage::ApplicationData::GetForUserAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationData_GetPublisherCacheFolder(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationData", L"GetPublisherCacheFolder", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetPublisherCacheFolder(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationData_SetVersionAsync(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationData", L"SetVersionAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::ApplicationDataSetVersionHandler>(args, 1);

                return py::convert(self->obj.SetVersionAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationData_SignalDataChanged(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationData", L"SignalDataChanged", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.SignalDataChanged();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_LocalFolder(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.ApplicationData", L"LocalFolder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalFolder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_LocalSettings(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.ApplicationData", L"LocalSettings"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_RoamingFolder(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.ApplicationData", L"RoamingFolder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RoamingFolder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_RoamingSettings(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.ApplicationData", L"RoamingSettings"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RoamingSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_RoamingStorageQuota(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.ApplicationData", L"RoamingStorageQuota"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RoamingStorageQuota());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_TemporaryFolder(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.ApplicationData", L"TemporaryFolder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TemporaryFolder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_Version(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.ApplicationData", L"Version"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Version());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_LocalCacheFolder(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.ApplicationData", L"LocalCacheFolder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalCacheFolder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_SharedLocalFolder(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.ApplicationData", L"SharedLocalFolder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SharedLocalFolder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_Current(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.ApplicationData", L"Current"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Storage::ApplicationData::Current());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_add_DataChanged(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.ApplicationData", L"DataChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::ApplicationData, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.DataChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_remove_DataChanged(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.ApplicationData", L"DataChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DataChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ApplicationData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::ApplicationData>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ApplicationData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::ApplicationData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ApplicationData(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_ApplicationData(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ApplicationData[] = {
        { "clear_async", reinterpret_cast<PyCFunction>(ApplicationData_ClearAsync), METH_VARARGS, nullptr },
        { "clear_publisher_cache_folder_async", reinterpret_cast<PyCFunction>(ApplicationData_ClearPublisherCacheFolderAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(ApplicationData_Close), METH_VARARGS, nullptr },
        { "get_publisher_cache_folder", reinterpret_cast<PyCFunction>(ApplicationData_GetPublisherCacheFolder), METH_VARARGS, nullptr },
        { "set_version_async", reinterpret_cast<PyCFunction>(ApplicationData_SetVersionAsync), METH_VARARGS, nullptr },
        { "signal_data_changed", reinterpret_cast<PyCFunction>(ApplicationData_SignalDataChanged), METH_VARARGS, nullptr },
        { "add_data_changed", reinterpret_cast<PyCFunction>(ApplicationData_add_DataChanged), METH_O, nullptr },
        { "remove_data_changed", reinterpret_cast<PyCFunction>(ApplicationData_remove_DataChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ApplicationData, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ApplicationData), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ApplicationData), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ApplicationData), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ApplicationData[] = {
        { "local_folder", reinterpret_cast<getter>(ApplicationData_get_LocalFolder), nullptr, nullptr, nullptr },
        { "local_settings", reinterpret_cast<getter>(ApplicationData_get_LocalSettings), nullptr, nullptr, nullptr },
        { "roaming_folder", reinterpret_cast<getter>(ApplicationData_get_RoamingFolder), nullptr, nullptr, nullptr },
        { "roaming_settings", reinterpret_cast<getter>(ApplicationData_get_RoamingSettings), nullptr, nullptr, nullptr },
        { "roaming_storage_quota", reinterpret_cast<getter>(ApplicationData_get_RoamingStorageQuota), nullptr, nullptr, nullptr },
        { "temporary_folder", reinterpret_cast<getter>(ApplicationData_get_TemporaryFolder), nullptr, nullptr, nullptr },
        { "version", reinterpret_cast<getter>(ApplicationData_get_Version), nullptr, nullptr, nullptr },
        { "local_cache_folder", reinterpret_cast<getter>(ApplicationData_get_LocalCacheFolder), nullptr, nullptr, nullptr },
        { "shared_local_folder", reinterpret_cast<getter>(ApplicationData_get_SharedLocalFolder), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ApplicationData[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ApplicationData) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ApplicationData) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ApplicationData) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ApplicationData) },
        { },
    };

    static PyType_Spec type_spec_ApplicationData =
    {
        "winrt._winrt_windows_storage.ApplicationData",
        sizeof(py::wrapper::Windows::Storage::ApplicationData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationData
    };

    static PyGetSetDef getset_ApplicationData_Static[] = {
        { "current", reinterpret_cast<getter>(ApplicationData_get_Current), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ApplicationData_Static[] = {
        { "get_for_user_async", reinterpret_cast<PyCFunction>(ApplicationData_GetForUserAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_ApplicationData_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ApplicationData_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ApplicationData_Static) },
        { }
    };

    static PyType_Spec type_spec_ApplicationData_Static =
    {
        "winrt._winrt_windows_storage.ApplicationData_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ApplicationData_Static
    };

    // ----- ApplicationDataCompositeValue class --------------------

    static PyObject* _new_ApplicationDataCompositeValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::ApplicationDataCompositeValue instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ApplicationDataCompositeValue(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ApplicationDataCompositeValue_Clear(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataCompositeValue", L"Clear", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_First(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataCompositeValue", L"First", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_GetView(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataCompositeValue", L"GetView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_HasKey(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataCompositeValue", L"HasKey", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_Insert(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataCompositeValue", L"Insert", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Insert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_Lookup(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataCompositeValue", L"Lookup", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_Remove(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataCompositeValue", L"Remove", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_get_Size(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.ApplicationDataCompositeValue", L"Size"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_add_MapChanged(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.ApplicationDataCompositeValue", L"MapChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::MapChangedEventHandler<winrt::hstring, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.MapChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_remove_MapChanged(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.ApplicationDataCompositeValue", L"MapChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MapChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ApplicationDataCompositeValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::ApplicationDataCompositeValue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ApplicationDataCompositeValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::ApplicationDataCompositeValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_ApplicationDataCompositeValue(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self) noexcept
    {
        try
        {
            py::pyobj_handle iter{py::convert(self->obj.First())};

            if (!iter)
            {
                return nullptr;
            }

            return py::wrap_mapping_iter(iter.get());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_contains_ApplicationDataCompositeValue(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* key) noexcept
    {
        try
        {
            return static_cast<int>(self->obj.HasKey(py::convert_to<winrt::hstring>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static Py_ssize_t _map_length_ApplicationDataCompositeValue(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_ApplicationDataCompositeValue(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* key) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);
            auto value = self->obj.TryLookup(_key);

            if (!value) {
                if constexpr (std::is_base_of_v<winrt::Windows::Foundation::IUnknown, decltype(value)>)
                {
                    if (self->obj.HasKey(_key))
                    {
                        Py_RETURN_NONE;
                    }
                }

                PyErr_SetObject(PyExc_KeyError, key);
                return nullptr;
            }

            return py::convert(value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_ApplicationDataCompositeValue(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);

            if (value == nullptr) {
                if (!self->obj.TryRemove(_key)) {
                    PyErr_SetObject(PyExc_KeyError, key);
                    return -1;
                }

                return 0;
            }

            self->obj.Insert(_key, py::convert_to<winrt::Windows::Foundation::IInspectable>(value));

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_ApplicationDataCompositeValue[] = {
        { "clear", reinterpret_cast<PyCFunction>(ApplicationDataCompositeValue_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(ApplicationDataCompositeValue_First), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(ApplicationDataCompositeValue_GetView), METH_VARARGS, nullptr },
        { "has_key", reinterpret_cast<PyCFunction>(ApplicationDataCompositeValue_HasKey), METH_VARARGS, nullptr },
        { "insert", reinterpret_cast<PyCFunction>(ApplicationDataCompositeValue_Insert), METH_VARARGS, nullptr },
        { "lookup", reinterpret_cast<PyCFunction>(ApplicationDataCompositeValue_Lookup), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(ApplicationDataCompositeValue_Remove), METH_VARARGS, nullptr },
        { "add_map_changed", reinterpret_cast<PyCFunction>(ApplicationDataCompositeValue_add_MapChanged), METH_O, nullptr },
        { "remove_map_changed", reinterpret_cast<PyCFunction>(ApplicationDataCompositeValue_remove_MapChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ApplicationDataCompositeValue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ApplicationDataCompositeValue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ApplicationDataCompositeValue[] = {
        { "size", reinterpret_cast<getter>(ApplicationDataCompositeValue_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ApplicationDataCompositeValue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ApplicationDataCompositeValue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ApplicationDataCompositeValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ApplicationDataCompositeValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ApplicationDataCompositeValue) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_ApplicationDataCompositeValue) },
        { Py_sq_contains, reinterpret_cast<void*>(_map_contains_ApplicationDataCompositeValue) },
        { Py_mp_length, reinterpret_cast<void*>(_map_length_ApplicationDataCompositeValue) },
        { Py_mp_subscript, reinterpret_cast<void*>(_map_subscript_ApplicationDataCompositeValue) },
        { Py_mp_ass_subscript, reinterpret_cast<void*>(_map_assign_ApplicationDataCompositeValue) },
        { },
    };

    static PyType_Spec type_spec_ApplicationDataCompositeValue =
    {
        "winrt._winrt_windows_storage.ApplicationDataCompositeValue",
        sizeof(py::wrapper::Windows::Storage::ApplicationDataCompositeValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationDataCompositeValue
    };

    // ----- ApplicationDataContainer class --------------------

    static PyObject* _new_ApplicationDataContainer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::ApplicationDataContainer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::ApplicationDataContainer>::type_name);
        return nullptr;
    }

    static void _dealloc_ApplicationDataContainer(py::wrapper::Windows::Storage::ApplicationDataContainer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ApplicationDataContainer_Close(py::wrapper::Windows::Storage::ApplicationDataContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataContainer", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainer_CreateContainer(py::wrapper::Windows::Storage::ApplicationDataContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataContainer", L"CreateContainer", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::ApplicationDataCreateDisposition>(args, 1);

                return py::convert(self->obj.CreateContainer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainer_DeleteContainer(py::wrapper::Windows::Storage::ApplicationDataContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataContainer", L"DeleteContainer", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.DeleteContainer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainer_get_Containers(py::wrapper::Windows::Storage::ApplicationDataContainer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.ApplicationDataContainer", L"Containers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Containers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainer_get_Locality(py::wrapper::Windows::Storage::ApplicationDataContainer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.ApplicationDataContainer", L"Locality"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Locality());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainer_get_Name(py::wrapper::Windows::Storage::ApplicationDataContainer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.ApplicationDataContainer", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainer_get_Values(py::wrapper::Windows::Storage::ApplicationDataContainer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.ApplicationDataContainer", L"Values"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Values());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ApplicationDataContainer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::ApplicationDataContainer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ApplicationDataContainer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::ApplicationDataContainer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ApplicationDataContainer(py::wrapper::Windows::Storage::ApplicationDataContainer* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_ApplicationDataContainer(py::wrapper::Windows::Storage::ApplicationDataContainer* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ApplicationDataContainer[] = {
        { "close", reinterpret_cast<PyCFunction>(ApplicationDataContainer_Close), METH_VARARGS, nullptr },
        { "create_container", reinterpret_cast<PyCFunction>(ApplicationDataContainer_CreateContainer), METH_VARARGS, nullptr },
        { "delete_container", reinterpret_cast<PyCFunction>(ApplicationDataContainer_DeleteContainer), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ApplicationDataContainer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ApplicationDataContainer), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ApplicationDataContainer), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ApplicationDataContainer), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ApplicationDataContainer[] = {
        { "containers", reinterpret_cast<getter>(ApplicationDataContainer_get_Containers), nullptr, nullptr, nullptr },
        { "locality", reinterpret_cast<getter>(ApplicationDataContainer_get_Locality), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(ApplicationDataContainer_get_Name), nullptr, nullptr, nullptr },
        { "values", reinterpret_cast<getter>(ApplicationDataContainer_get_Values), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ApplicationDataContainer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ApplicationDataContainer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ApplicationDataContainer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ApplicationDataContainer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ApplicationDataContainer) },
        { },
    };

    static PyType_Spec type_spec_ApplicationDataContainer =
    {
        "winrt._winrt_windows_storage.ApplicationDataContainer",
        sizeof(py::wrapper::Windows::Storage::ApplicationDataContainer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationDataContainer
    };

    // ----- ApplicationDataContainerSettings class --------------------

    static PyObject* _new_ApplicationDataContainerSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::ApplicationDataContainerSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::ApplicationDataContainerSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_ApplicationDataContainerSettings(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ApplicationDataContainerSettings_Clear(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataContainerSettings", L"Clear", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_First(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataContainerSettings", L"First", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_GetView(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataContainerSettings", L"GetView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_HasKey(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataContainerSettings", L"HasKey", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_Insert(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataContainerSettings", L"Insert", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Insert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_Lookup(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataContainerSettings", L"Lookup", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_Remove(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataContainerSettings", L"Remove", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_get_Size(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.ApplicationDataContainerSettings", L"Size"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_add_MapChanged(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.ApplicationDataContainerSettings", L"MapChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::MapChangedEventHandler<winrt::hstring, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.MapChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_remove_MapChanged(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.ApplicationDataContainerSettings", L"MapChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MapChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ApplicationDataContainerSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::ApplicationDataContainerSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ApplicationDataContainerSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::ApplicationDataContainerSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_ApplicationDataContainerSettings(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self) noexcept
    {
        try
        {
            py::pyobj_handle iter{py::convert(self->obj.First())};

            if (!iter)
            {
                return nullptr;
            }

            return py::wrap_mapping_iter(iter.get());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_contains_ApplicationDataContainerSettings(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* key) noexcept
    {
        try
        {
            return static_cast<int>(self->obj.HasKey(py::convert_to<winrt::hstring>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static Py_ssize_t _map_length_ApplicationDataContainerSettings(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_ApplicationDataContainerSettings(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* key) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);
            auto value = self->obj.TryLookup(_key);

            if (!value) {
                if constexpr (std::is_base_of_v<winrt::Windows::Foundation::IUnknown, decltype(value)>)
                {
                    if (self->obj.HasKey(_key))
                    {
                        Py_RETURN_NONE;
                    }
                }

                PyErr_SetObject(PyExc_KeyError, key);
                return nullptr;
            }

            return py::convert(value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_ApplicationDataContainerSettings(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);

            if (value == nullptr) {
                if (!self->obj.TryRemove(_key)) {
                    PyErr_SetObject(PyExc_KeyError, key);
                    return -1;
                }

                return 0;
            }

            self->obj.Insert(_key, py::convert_to<winrt::Windows::Foundation::IInspectable>(value));

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_ApplicationDataContainerSettings[] = {
        { "clear", reinterpret_cast<PyCFunction>(ApplicationDataContainerSettings_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(ApplicationDataContainerSettings_First), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(ApplicationDataContainerSettings_GetView), METH_VARARGS, nullptr },
        { "has_key", reinterpret_cast<PyCFunction>(ApplicationDataContainerSettings_HasKey), METH_VARARGS, nullptr },
        { "insert", reinterpret_cast<PyCFunction>(ApplicationDataContainerSettings_Insert), METH_VARARGS, nullptr },
        { "lookup", reinterpret_cast<PyCFunction>(ApplicationDataContainerSettings_Lookup), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(ApplicationDataContainerSettings_Remove), METH_VARARGS, nullptr },
        { "add_map_changed", reinterpret_cast<PyCFunction>(ApplicationDataContainerSettings_add_MapChanged), METH_O, nullptr },
        { "remove_map_changed", reinterpret_cast<PyCFunction>(ApplicationDataContainerSettings_remove_MapChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ApplicationDataContainerSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ApplicationDataContainerSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ApplicationDataContainerSettings[] = {
        { "size", reinterpret_cast<getter>(ApplicationDataContainerSettings_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ApplicationDataContainerSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ApplicationDataContainerSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ApplicationDataContainerSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ApplicationDataContainerSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ApplicationDataContainerSettings) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_ApplicationDataContainerSettings) },
        { Py_sq_contains, reinterpret_cast<void*>(_map_contains_ApplicationDataContainerSettings) },
        { Py_mp_length, reinterpret_cast<void*>(_map_length_ApplicationDataContainerSettings) },
        { Py_mp_subscript, reinterpret_cast<void*>(_map_subscript_ApplicationDataContainerSettings) },
        { Py_mp_ass_subscript, reinterpret_cast<void*>(_map_assign_ApplicationDataContainerSettings) },
        { },
    };

    static PyType_Spec type_spec_ApplicationDataContainerSettings =
    {
        "winrt._winrt_windows_storage.ApplicationDataContainerSettings",
        sizeof(py::wrapper::Windows::Storage::ApplicationDataContainerSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationDataContainerSettings
    };

    // ----- CachedFileManager class --------------------

    static PyObject* _new_CachedFileManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::CachedFileManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::CachedFileManager>::type_name);
        return nullptr;
    }

    static PyObject* CachedFileManager_CompleteUpdatesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.CachedFileManager", L"CompleteUpdatesAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(winrt::Windows::Storage::CachedFileManager::CompleteUpdatesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CachedFileManager_DeferUpdates(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.CachedFileManager", L"DeferUpdates", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                winrt::Windows::Storage::CachedFileManager::DeferUpdates(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_CachedFileManager[] = {
        { }
    };

    static PyGetSetDef _getset_CachedFileManager[] = {
        { }
    };

    static PyType_Slot _type_slots_CachedFileManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CachedFileManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CachedFileManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CachedFileManager) },
        { },
    };

    static PyType_Spec type_spec_CachedFileManager =
    {
        "winrt._winrt_windows_storage.CachedFileManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CachedFileManager
    };

    static PyGetSetDef getset_CachedFileManager_Static[] = {
        { }
    };

    static PyMethodDef methods_CachedFileManager_Static[] = {
        { "complete_updates_async", reinterpret_cast<PyCFunction>(CachedFileManager_CompleteUpdatesAsync), METH_VARARGS, nullptr },
        { "defer_updates", reinterpret_cast<PyCFunction>(CachedFileManager_DeferUpdates), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_CachedFileManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CachedFileManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CachedFileManager_Static) },
        { }
    };

    static PyType_Spec type_spec_CachedFileManager_Static =
    {
        "winrt._winrt_windows_storage.CachedFileManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CachedFileManager_Static
    };

    // ----- DownloadsFolder class --------------------

    static PyObject* _new_DownloadsFolder(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::DownloadsFolder>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::DownloadsFolder>::type_name);
        return nullptr;
    }

    static PyObject* DownloadsFolder_CreateFileAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.DownloadsFolder", L"CreateFileAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Storage::DownloadsFolder::CreateFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.DownloadsFolder", L"CreateFileAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);

                return py::convert(winrt::Windows::Storage::DownloadsFolder::CreateFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadsFolder_CreateFileForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.DownloadsFolder", L"CreateFileForUserAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Storage::DownloadsFolder::CreateFileForUserAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.DownloadsFolder", L"CreateFileForUserAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 2);

                return py::convert(winrt::Windows::Storage::DownloadsFolder::CreateFileForUserAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadsFolder_CreateFolderAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.DownloadsFolder", L"CreateFolderAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Storage::DownloadsFolder::CreateFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.DownloadsFolder", L"CreateFolderAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);

                return py::convert(winrt::Windows::Storage::DownloadsFolder::CreateFolderAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadsFolder_CreateFolderForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.DownloadsFolder", L"CreateFolderForUserAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Storage::DownloadsFolder::CreateFolderForUserAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.DownloadsFolder", L"CreateFolderForUserAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 2);

                return py::convert(winrt::Windows::Storage::DownloadsFolder::CreateFolderForUserAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_DownloadsFolder[] = {
        { }
    };

    static PyGetSetDef _getset_DownloadsFolder[] = {
        { }
    };

    static PyType_Slot _type_slots_DownloadsFolder[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DownloadsFolder) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DownloadsFolder) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DownloadsFolder) },
        { },
    };

    static PyType_Spec type_spec_DownloadsFolder =
    {
        "winrt._winrt_windows_storage.DownloadsFolder",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DownloadsFolder
    };

    static PyGetSetDef getset_DownloadsFolder_Static[] = {
        { }
    };

    static PyMethodDef methods_DownloadsFolder_Static[] = {
        { "create_file_async", reinterpret_cast<PyCFunction>(DownloadsFolder_CreateFileAsync), METH_VARARGS, nullptr },
        { "create_file_for_user_async", reinterpret_cast<PyCFunction>(DownloadsFolder_CreateFileForUserAsync), METH_VARARGS, nullptr },
        { "create_folder_async", reinterpret_cast<PyCFunction>(DownloadsFolder_CreateFolderAsync), METH_VARARGS, nullptr },
        { "create_folder_for_user_async", reinterpret_cast<PyCFunction>(DownloadsFolder_CreateFolderForUserAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_DownloadsFolder_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DownloadsFolder_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DownloadsFolder_Static) },
        { }
    };

    static PyType_Spec type_spec_DownloadsFolder_Static =
    {
        "winrt._winrt_windows_storage.DownloadsFolder_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DownloadsFolder_Static
    };

    // ----- FileIO class --------------------

    static PyObject* _new_FileIO(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::FileIO>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::FileIO>::type_name);
        return nullptr;
    }

    static PyObject* FileIO_AppendLinesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.FileIO", L"AppendLinesAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(winrt::Windows::Storage::FileIO::AppendLinesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.FileIO", L"AppendLinesAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

                return py::convert(winrt::Windows::Storage::FileIO::AppendLinesAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_AppendTextAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.FileIO", L"AppendTextAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Storage::FileIO::AppendTextAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.FileIO", L"AppendTextAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

                return py::convert(winrt::Windows::Storage::FileIO::AppendTextAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_ReadBufferAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.FileIO", L"ReadBufferAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(winrt::Windows::Storage::FileIO::ReadBufferAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_ReadLinesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.FileIO", L"ReadLinesAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(winrt::Windows::Storage::FileIO::ReadLinesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.FileIO", L"ReadLinesAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 1);

                return py::convert(winrt::Windows::Storage::FileIO::ReadLinesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_ReadTextAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.FileIO", L"ReadTextAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(winrt::Windows::Storage::FileIO::ReadTextAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.FileIO", L"ReadTextAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 1);

                return py::convert(winrt::Windows::Storage::FileIO::ReadTextAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_WriteBufferAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.FileIO", L"WriteBufferAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::Storage::FileIO::WriteBufferAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_WriteBytesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.FileIO", L"WriteBytesAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                return py::convert(winrt::Windows::Storage::FileIO::WriteBytesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_WriteLinesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.FileIO", L"WriteLinesAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(winrt::Windows::Storage::FileIO::WriteLinesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.FileIO", L"WriteLinesAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

                return py::convert(winrt::Windows::Storage::FileIO::WriteLinesAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_WriteTextAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.FileIO", L"WriteTextAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Storage::FileIO::WriteTextAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.FileIO", L"WriteTextAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

                return py::convert(winrt::Windows::Storage::FileIO::WriteTextAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileIO[] = {
        { }
    };

    static PyGetSetDef _getset_FileIO[] = {
        { }
    };

    static PyType_Slot _type_slots_FileIO[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FileIO) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FileIO) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FileIO) },
        { },
    };

    static PyType_Spec type_spec_FileIO =
    {
        "winrt._winrt_windows_storage.FileIO",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileIO
    };

    static PyGetSetDef getset_FileIO_Static[] = {
        { }
    };

    static PyMethodDef methods_FileIO_Static[] = {
        { "append_lines_async", reinterpret_cast<PyCFunction>(FileIO_AppendLinesAsync), METH_VARARGS, nullptr },
        { "append_text_async", reinterpret_cast<PyCFunction>(FileIO_AppendTextAsync), METH_VARARGS, nullptr },
        { "read_buffer_async", reinterpret_cast<PyCFunction>(FileIO_ReadBufferAsync), METH_VARARGS, nullptr },
        { "read_lines_async", reinterpret_cast<PyCFunction>(FileIO_ReadLinesAsync), METH_VARARGS, nullptr },
        { "read_text_async", reinterpret_cast<PyCFunction>(FileIO_ReadTextAsync), METH_VARARGS, nullptr },
        { "write_buffer_async", reinterpret_cast<PyCFunction>(FileIO_WriteBufferAsync), METH_VARARGS, nullptr },
        { "write_bytes_async", reinterpret_cast<PyCFunction>(FileIO_WriteBytesAsync), METH_VARARGS, nullptr },
        { "write_lines_async", reinterpret_cast<PyCFunction>(FileIO_WriteLinesAsync), METH_VARARGS, nullptr },
        { "write_text_async", reinterpret_cast<PyCFunction>(FileIO_WriteTextAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_FileIO_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FileIO_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FileIO_Static) },
        { }
    };

    static PyType_Spec type_spec_FileIO_Static =
    {
        "winrt._winrt_windows_storage.FileIO_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_FileIO_Static
    };

    // ----- KnownFolders class --------------------

    static PyObject* _new_KnownFolders(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::KnownFolders>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::KnownFolders>::type_name);
        return nullptr;
    }

    static PyObject* KnownFolders_GetFolderAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.KnownFolders", L"GetFolderAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::KnownFolderId>(args, 0);

                return py::convert(winrt::Windows::Storage::KnownFolders::GetFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KnownFolders_GetFolderForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.KnownFolders", L"GetFolderForUserAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::KnownFolderId>(args, 1);

                return py::convert(winrt::Windows::Storage::KnownFolders::GetFolderForUserAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KnownFolders_RequestAccessAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.KnownFolders", L"RequestAccessAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::KnownFolderId>(args, 0);

                return py::convert(winrt::Windows::Storage::KnownFolders::RequestAccessAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KnownFolders_RequestAccessForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.KnownFolders", L"RequestAccessForUserAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::KnownFolderId>(args, 1);

                return py::convert(winrt::Windows::Storage::KnownFolders::RequestAccessForUserAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_CameraRoll(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.KnownFolders", L"CameraRoll"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Storage::KnownFolders::CameraRoll());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_Playlists(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.KnownFolders", L"Playlists"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Storage::KnownFolders::Playlists());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_SavedPictures(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.KnownFolders", L"SavedPictures"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Storage::KnownFolders::SavedPictures());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_DocumentsLibrary(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.KnownFolders", L"DocumentsLibrary"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Storage::KnownFolders::DocumentsLibrary());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_HomeGroup(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.KnownFolders", L"HomeGroup"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Storage::KnownFolders::HomeGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_MediaServerDevices(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.KnownFolders", L"MediaServerDevices"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Storage::KnownFolders::MediaServerDevices());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_MusicLibrary(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.KnownFolders", L"MusicLibrary"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Storage::KnownFolders::MusicLibrary());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_PicturesLibrary(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.KnownFolders", L"PicturesLibrary"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Storage::KnownFolders::PicturesLibrary());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_RemovableDevices(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.KnownFolders", L"RemovableDevices"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Storage::KnownFolders::RemovableDevices());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_VideosLibrary(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.KnownFolders", L"VideosLibrary"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Storage::KnownFolders::VideosLibrary());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_AppCaptures(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.KnownFolders", L"AppCaptures"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Storage::KnownFolders::AppCaptures());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_Objects3D(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.KnownFolders", L"Objects3D"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Storage::KnownFolders::Objects3D());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_RecordedCalls(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.KnownFolders", L"RecordedCalls"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Storage::KnownFolders::RecordedCalls());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownFolders[] = {
        { }
    };

    static PyGetSetDef _getset_KnownFolders[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownFolders[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownFolders) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownFolders) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownFolders) },
        { },
    };

    static PyType_Spec type_spec_KnownFolders =
    {
        "winrt._winrt_windows_storage.KnownFolders",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownFolders
    };

    static PyGetSetDef getset_KnownFolders_Static[] = {
        { "camera_roll", reinterpret_cast<getter>(KnownFolders_get_CameraRoll), nullptr, nullptr, nullptr },
        { "playlists", reinterpret_cast<getter>(KnownFolders_get_Playlists), nullptr, nullptr, nullptr },
        { "saved_pictures", reinterpret_cast<getter>(KnownFolders_get_SavedPictures), nullptr, nullptr, nullptr },
        { "documents_library", reinterpret_cast<getter>(KnownFolders_get_DocumentsLibrary), nullptr, nullptr, nullptr },
        { "home_group", reinterpret_cast<getter>(KnownFolders_get_HomeGroup), nullptr, nullptr, nullptr },
        { "media_server_devices", reinterpret_cast<getter>(KnownFolders_get_MediaServerDevices), nullptr, nullptr, nullptr },
        { "music_library", reinterpret_cast<getter>(KnownFolders_get_MusicLibrary), nullptr, nullptr, nullptr },
        { "pictures_library", reinterpret_cast<getter>(KnownFolders_get_PicturesLibrary), nullptr, nullptr, nullptr },
        { "removable_devices", reinterpret_cast<getter>(KnownFolders_get_RemovableDevices), nullptr, nullptr, nullptr },
        { "videos_library", reinterpret_cast<getter>(KnownFolders_get_VideosLibrary), nullptr, nullptr, nullptr },
        { "app_captures", reinterpret_cast<getter>(KnownFolders_get_AppCaptures), nullptr, nullptr, nullptr },
        { "objects3_d", reinterpret_cast<getter>(KnownFolders_get_Objects3D), nullptr, nullptr, nullptr },
        { "recorded_calls", reinterpret_cast<getter>(KnownFolders_get_RecordedCalls), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_KnownFolders_Static[] = {
        { "get_folder_async", reinterpret_cast<PyCFunction>(KnownFolders_GetFolderAsync), METH_VARARGS, nullptr },
        { "get_folder_for_user_async", reinterpret_cast<PyCFunction>(KnownFolders_GetFolderForUserAsync), METH_VARARGS, nullptr },
        { "request_access_async", reinterpret_cast<PyCFunction>(KnownFolders_RequestAccessAsync), METH_VARARGS, nullptr },
        { "request_access_for_user_async", reinterpret_cast<PyCFunction>(KnownFolders_RequestAccessForUserAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_KnownFolders_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownFolders_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_KnownFolders_Static) },
        { }
    };

    static PyType_Spec type_spec_KnownFolders_Static =
    {
        "winrt._winrt_windows_storage.KnownFolders_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownFolders_Static
    };

    // ----- PathIO class --------------------

    static PyObject* _new_PathIO(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::PathIO>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::PathIO>::type_name);
        return nullptr;
    }

    static PyObject* PathIO_AppendLinesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.PathIO", L"AppendLinesAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(winrt::Windows::Storage::PathIO::AppendLinesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.PathIO", L"AppendLinesAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

                return py::convert(winrt::Windows::Storage::PathIO::AppendLinesAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_AppendTextAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.PathIO", L"AppendTextAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Storage::PathIO::AppendTextAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.PathIO", L"AppendTextAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

                return py::convert(winrt::Windows::Storage::PathIO::AppendTextAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_ReadBufferAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.PathIO", L"ReadBufferAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Storage::PathIO::ReadBufferAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_ReadLinesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.PathIO", L"ReadLinesAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Storage::PathIO::ReadLinesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.PathIO", L"ReadLinesAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 1);

                return py::convert(winrt::Windows::Storage::PathIO::ReadLinesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_ReadTextAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.PathIO", L"ReadTextAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Storage::PathIO::ReadTextAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.PathIO", L"ReadTextAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 1);

                return py::convert(winrt::Windows::Storage::PathIO::ReadTextAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_WriteBufferAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.PathIO", L"WriteBufferAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::Storage::PathIO::WriteBufferAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_WriteBytesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.PathIO", L"WriteBytesAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                return py::convert(winrt::Windows::Storage::PathIO::WriteBytesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_WriteLinesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.PathIO", L"WriteLinesAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(winrt::Windows::Storage::PathIO::WriteLinesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.PathIO", L"WriteLinesAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

                return py::convert(winrt::Windows::Storage::PathIO::WriteLinesAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_WriteTextAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.PathIO", L"WriteTextAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Storage::PathIO::WriteTextAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.PathIO", L"WriteTextAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

                return py::convert(winrt::Windows::Storage::PathIO::WriteTextAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_PathIO[] = {
        { }
    };

    static PyGetSetDef _getset_PathIO[] = {
        { }
    };

    static PyType_Slot _type_slots_PathIO[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PathIO) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PathIO) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PathIO) },
        { },
    };

    static PyType_Spec type_spec_PathIO =
    {
        "winrt._winrt_windows_storage.PathIO",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PathIO
    };

    static PyGetSetDef getset_PathIO_Static[] = {
        { }
    };

    static PyMethodDef methods_PathIO_Static[] = {
        { "append_lines_async", reinterpret_cast<PyCFunction>(PathIO_AppendLinesAsync), METH_VARARGS, nullptr },
        { "append_text_async", reinterpret_cast<PyCFunction>(PathIO_AppendTextAsync), METH_VARARGS, nullptr },
        { "read_buffer_async", reinterpret_cast<PyCFunction>(PathIO_ReadBufferAsync), METH_VARARGS, nullptr },
        { "read_lines_async", reinterpret_cast<PyCFunction>(PathIO_ReadLinesAsync), METH_VARARGS, nullptr },
        { "read_text_async", reinterpret_cast<PyCFunction>(PathIO_ReadTextAsync), METH_VARARGS, nullptr },
        { "write_buffer_async", reinterpret_cast<PyCFunction>(PathIO_WriteBufferAsync), METH_VARARGS, nullptr },
        { "write_bytes_async", reinterpret_cast<PyCFunction>(PathIO_WriteBytesAsync), METH_VARARGS, nullptr },
        { "write_lines_async", reinterpret_cast<PyCFunction>(PathIO_WriteLinesAsync), METH_VARARGS, nullptr },
        { "write_text_async", reinterpret_cast<PyCFunction>(PathIO_WriteTextAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_PathIO_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PathIO_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PathIO_Static) },
        { }
    };

    static PyType_Spec type_spec_PathIO_Static =
    {
        "winrt._winrt_windows_storage.PathIO_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PathIO_Static
    };

    // ----- SetVersionDeferral class --------------------

    static PyObject* _new_SetVersionDeferral(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::SetVersionDeferral>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::SetVersionDeferral>::type_name);
        return nullptr;
    }

    static void _dealloc_SetVersionDeferral(py::wrapper::Windows::Storage::SetVersionDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SetVersionDeferral_Complete(py::wrapper::Windows::Storage::SetVersionDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.SetVersionDeferral", L"Complete", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_SetVersionDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::SetVersionDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SetVersionDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SetVersionDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SetVersionDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(SetVersionDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SetVersionDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SetVersionDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SetVersionDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_SetVersionDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SetVersionDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SetVersionDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SetVersionDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SetVersionDeferral) },
        { },
    };

    static PyType_Spec type_spec_SetVersionDeferral =
    {
        "winrt._winrt_windows_storage.SetVersionDeferral",
        sizeof(py::wrapper::Windows::Storage::SetVersionDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SetVersionDeferral
    };

    // ----- SetVersionRequest class --------------------

    static PyObject* _new_SetVersionRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::SetVersionRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::SetVersionRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_SetVersionRequest(py::wrapper::Windows::Storage::SetVersionRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SetVersionRequest_GetDeferral(py::wrapper::Windows::Storage::SetVersionRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.SetVersionRequest", L"GetDeferral", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SetVersionRequest_get_CurrentVersion(py::wrapper::Windows::Storage::SetVersionRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SetVersionRequest", L"CurrentVersion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CurrentVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SetVersionRequest_get_DesiredVersion(py::wrapper::Windows::Storage::SetVersionRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SetVersionRequest", L"DesiredVersion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DesiredVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SetVersionRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::SetVersionRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SetVersionRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SetVersionRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SetVersionRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(SetVersionRequest_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SetVersionRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SetVersionRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SetVersionRequest[] = {
        { "current_version", reinterpret_cast<getter>(SetVersionRequest_get_CurrentVersion), nullptr, nullptr, nullptr },
        { "desired_version", reinterpret_cast<getter>(SetVersionRequest_get_DesiredVersion), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SetVersionRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SetVersionRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SetVersionRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SetVersionRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SetVersionRequest) },
        { },
    };

    static PyType_Spec type_spec_SetVersionRequest =
    {
        "winrt._winrt_windows_storage.SetVersionRequest",
        sizeof(py::wrapper::Windows::Storage::SetVersionRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SetVersionRequest
    };

    // ----- StorageFile class --------------------

    static PyObject* _new_StorageFile(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::StorageFile>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::StorageFile>::type_name);
        return nullptr;
    }

    static void _dealloc_StorageFile(py::wrapper::Windows::Storage::StorageFile* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageFile_CopyAndReplaceAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"CopyAndReplaceAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(self->obj.CopyAndReplaceAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_CopyAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"CopyAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);

                return py::convert(self->obj.CopyAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"CopyAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.CopyAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"CopyAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 2);

                return py::convert(self->obj.CopyAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_CreateStreamedFileAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"CreateStreamedFileAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::StreamedFileDataRequestedHandler>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 2);

                return py::convert(winrt::Windows::Storage::StorageFile::CreateStreamedFileAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_CreateStreamedFileFromUriAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"CreateStreamedFileFromUriAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 2);

                return py::convert(winrt::Windows::Storage::StorageFile::CreateStreamedFileFromUriAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_DeleteAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"DeleteAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"DeleteAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);

                return py::convert(self->obj.DeleteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_GetBasicPropertiesAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"GetBasicPropertiesAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetBasicPropertiesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_GetFileFromApplicationUriAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"GetFileFromApplicationUriAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(winrt::Windows::Storage::StorageFile::GetFileFromApplicationUriAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_GetFileFromPathAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"GetFileFromPathAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Storage::StorageFile::GetFileFromPathAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_GetFileFromPathForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"GetFileFromPathForUserAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Storage::StorageFile::GetFileFromPathForUserAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_GetParentAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"GetParentAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetParentAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_GetScaledImageAsThumbnailAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"GetScaledImageAsThumbnailAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

                return py::convert(self->obj.GetScaledImageAsThumbnailAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"GetScaledImageAsThumbnailAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetScaledImageAsThumbnailAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"GetScaledImageAsThumbnailAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

                return py::convert(self->obj.GetScaledImageAsThumbnailAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_GetThumbnailAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"GetThumbnailAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

                return py::convert(self->obj.GetThumbnailAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"GetThumbnailAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetThumbnailAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"GetThumbnailAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

                return py::convert(self->obj.GetThumbnailAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_IsEqual(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"IsEqual", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageItem>(args, 0);

                return py::convert(self->obj.IsEqual(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_IsOfType(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"IsOfType", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

                return py::convert(self->obj.IsOfType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_MoveAndReplaceAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"MoveAndReplaceAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(self->obj.MoveAndReplaceAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_MoveAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"MoveAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);

                return py::convert(self->obj.MoveAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"MoveAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.MoveAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"MoveAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 2);

                return py::convert(self->obj.MoveAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_OpenAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"OpenAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 0);

                return py::convert(self->obj.OpenAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"OpenAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 1);

                return py::convert(self->obj.OpenAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_OpenReadAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"OpenReadAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.OpenReadAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_OpenSequentialReadAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"OpenSequentialReadAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.OpenSequentialReadAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_OpenTransactedWriteAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"OpenTransactedWriteAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.OpenTransactedWriteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"OpenTransactedWriteAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 0);

                return py::convert(self->obj.OpenTransactedWriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_RenameAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"RenameAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RenameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"RenameAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);

                return py::convert(self->obj.RenameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_ReplaceWithStreamedFileAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"ReplaceWithStreamedFileAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::StreamedFileDataRequestedHandler>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 2);

                return py::convert(winrt::Windows::Storage::StorageFile::ReplaceWithStreamedFileAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_ReplaceWithStreamedFileFromUriAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"ReplaceWithStreamedFileFromUriAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 2);

                return py::convert(winrt::Windows::Storage::StorageFile::ReplaceWithStreamedFileFromUriAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_ContentType(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFile", L"ContentType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_FileType(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFile", L"FileType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FileType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_IsAvailable(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFile", L"IsAvailable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_Attributes(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFile", L"Attributes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Attributes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_DateCreated(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFile", L"DateCreated"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DateCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_Name(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFile", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_Path(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFile", L"Path"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_DisplayName(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFile", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_DisplayType(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFile", L"DisplayType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_FolderRelativeId(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFile", L"FolderRelativeId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FolderRelativeId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_Properties(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFile", L"Properties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_Provider(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFile", L"Provider"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Provider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorageFile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::StorageFile>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageFile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageFile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageFile[] = {
        { "copy_and_replace_async", reinterpret_cast<PyCFunction>(StorageFile_CopyAndReplaceAsync), METH_VARARGS, nullptr },
        { "copy_async", reinterpret_cast<PyCFunction>(StorageFile_CopyAsync), METH_VARARGS, nullptr },
        { "delete_async", reinterpret_cast<PyCFunction>(StorageFile_DeleteAsync), METH_VARARGS, nullptr },
        { "get_basic_properties_async", reinterpret_cast<PyCFunction>(StorageFile_GetBasicPropertiesAsync), METH_VARARGS, nullptr },
        { "get_parent_async", reinterpret_cast<PyCFunction>(StorageFile_GetParentAsync), METH_VARARGS, nullptr },
        { "get_scaled_image_as_thumbnail_async", reinterpret_cast<PyCFunction>(StorageFile_GetScaledImageAsThumbnailAsync), METH_VARARGS, nullptr },
        { "get_thumbnail_async", reinterpret_cast<PyCFunction>(StorageFile_GetThumbnailAsync), METH_VARARGS, nullptr },
        { "is_equal", reinterpret_cast<PyCFunction>(StorageFile_IsEqual), METH_VARARGS, nullptr },
        { "is_of_type", reinterpret_cast<PyCFunction>(StorageFile_IsOfType), METH_VARARGS, nullptr },
        { "move_and_replace_async", reinterpret_cast<PyCFunction>(StorageFile_MoveAndReplaceAsync), METH_VARARGS, nullptr },
        { "move_async", reinterpret_cast<PyCFunction>(StorageFile_MoveAsync), METH_VARARGS, nullptr },
        { "open_async", reinterpret_cast<PyCFunction>(StorageFile_OpenAsync), METH_VARARGS, nullptr },
        { "open_read_async", reinterpret_cast<PyCFunction>(StorageFile_OpenReadAsync), METH_VARARGS, nullptr },
        { "open_sequential_read_async", reinterpret_cast<PyCFunction>(StorageFile_OpenSequentialReadAsync), METH_VARARGS, nullptr },
        { "open_transacted_write_async", reinterpret_cast<PyCFunction>(StorageFile_OpenTransactedWriteAsync), METH_VARARGS, nullptr },
        { "rename_async", reinterpret_cast<PyCFunction>(StorageFile_RenameAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StorageFile, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageFile), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageFile[] = {
        { "content_type", reinterpret_cast<getter>(StorageFile_get_ContentType), nullptr, nullptr, nullptr },
        { "file_type", reinterpret_cast<getter>(StorageFile_get_FileType), nullptr, nullptr, nullptr },
        { "is_available", reinterpret_cast<getter>(StorageFile_get_IsAvailable), nullptr, nullptr, nullptr },
        { "attributes", reinterpret_cast<getter>(StorageFile_get_Attributes), nullptr, nullptr, nullptr },
        { "date_created", reinterpret_cast<getter>(StorageFile_get_DateCreated), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(StorageFile_get_Name), nullptr, nullptr, nullptr },
        { "path", reinterpret_cast<getter>(StorageFile_get_Path), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(StorageFile_get_DisplayName), nullptr, nullptr, nullptr },
        { "display_type", reinterpret_cast<getter>(StorageFile_get_DisplayType), nullptr, nullptr, nullptr },
        { "folder_relative_id", reinterpret_cast<getter>(StorageFile_get_FolderRelativeId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(StorageFile_get_Properties), nullptr, nullptr, nullptr },
        { "provider", reinterpret_cast<getter>(StorageFile_get_Provider), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageFile[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageFile) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageFile) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageFile) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageFile) },
        { },
    };

    static PyType_Spec type_spec_StorageFile =
    {
        "winrt._winrt_windows_storage.StorageFile",
        sizeof(py::wrapper::Windows::Storage::StorageFile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageFile
    };

    static PyGetSetDef getset_StorageFile_Static[] = {
        { }
    };

    static PyMethodDef methods_StorageFile_Static[] = {
        { "create_streamed_file_async", reinterpret_cast<PyCFunction>(StorageFile_CreateStreamedFileAsync), METH_VARARGS, nullptr },
        { "create_streamed_file_from_uri_async", reinterpret_cast<PyCFunction>(StorageFile_CreateStreamedFileFromUriAsync), METH_VARARGS, nullptr },
        { "get_file_from_application_uri_async", reinterpret_cast<PyCFunction>(StorageFile_GetFileFromApplicationUriAsync), METH_VARARGS, nullptr },
        { "get_file_from_path_async", reinterpret_cast<PyCFunction>(StorageFile_GetFileFromPathAsync), METH_VARARGS, nullptr },
        { "get_file_from_path_for_user_async", reinterpret_cast<PyCFunction>(StorageFile_GetFileFromPathForUserAsync), METH_VARARGS, nullptr },
        { "replace_with_streamed_file_async", reinterpret_cast<PyCFunction>(StorageFile_ReplaceWithStreamedFileAsync), METH_VARARGS, nullptr },
        { "replace_with_streamed_file_from_uri_async", reinterpret_cast<PyCFunction>(StorageFile_ReplaceWithStreamedFileFromUriAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_StorageFile_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_StorageFile_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_StorageFile_Static) },
        { }
    };

    static PyType_Spec type_spec_StorageFile_Static =
    {
        "winrt._winrt_windows_storage.StorageFile_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_StorageFile_Static
    };

    // ----- StorageFolder class --------------------

    static PyObject* _new_StorageFolder(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::StorageFolder>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::StorageFolder>::type_name);
        return nullptr;
    }

    static void _dealloc_StorageFolder(py::wrapper::Windows::Storage::StorageFolder* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageFolder_AreQueryOptionsSupported(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"AreQueryOptionsSupported", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);

                return py::convert(self->obj.AreQueryOptionsSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateFileAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"CreateFileAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"CreateFileAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);

                return py::convert(self->obj.CreateFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateFileQuery(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"CreateFileQuery", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateFileQuery());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"CreateFileQuery", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);

                return py::convert(self->obj.CreateFileQuery(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateFileQueryWithOptions(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"CreateFileQueryWithOptions", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);

                return py::convert(self->obj.CreateFileQueryWithOptions(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateFolderAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"CreateFolderAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"CreateFolderAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);

                return py::convert(self->obj.CreateFolderAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateFolderQuery(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"CreateFolderQuery", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateFolderQuery());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"CreateFolderQuery", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);

                return py::convert(self->obj.CreateFolderQuery(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateFolderQueryWithOptions(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"CreateFolderQueryWithOptions", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);

                return py::convert(self->obj.CreateFolderQueryWithOptions(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateItemQuery(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"CreateItemQuery", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateItemQuery());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateItemQueryWithOptions(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"CreateItemQueryWithOptions", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);

                return py::convert(self->obj.CreateItemQueryWithOptions(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_DeleteAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"DeleteAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"DeleteAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);

                return py::convert(self->obj.DeleteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetBasicPropertiesAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetBasicPropertiesAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetBasicPropertiesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetFileAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetFileAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetFilesAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetFilesAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetFilesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetFilesAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);

                return py::convert(self->obj.GetFilesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetFilesAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(self->obj.GetFilesAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetFolderAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetFolderAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetFolderFromPathAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetFolderFromPathAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Storage::StorageFolder::GetFolderFromPathAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetFolderFromPathForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetFolderFromPathForUserAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Storage::StorageFolder::GetFolderFromPathForUserAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetFoldersAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetFoldersAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetFoldersAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetFoldersAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);

                return py::convert(self->obj.GetFoldersAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetFoldersAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(self->obj.GetFoldersAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetIndexedStateAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetIndexedStateAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetIndexedStateAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetItemAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetItemAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetItemAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetItemsAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetItemsAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetItemsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetItemsAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetItemsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetParentAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetParentAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetParentAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetScaledImageAsThumbnailAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetScaledImageAsThumbnailAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

                return py::convert(self->obj.GetScaledImageAsThumbnailAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetScaledImageAsThumbnailAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetScaledImageAsThumbnailAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetScaledImageAsThumbnailAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

                return py::convert(self->obj.GetScaledImageAsThumbnailAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetThumbnailAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetThumbnailAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

                return py::convert(self->obj.GetThumbnailAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetThumbnailAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetThumbnailAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetThumbnailAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

                return py::convert(self->obj.GetThumbnailAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_IsCommonFileQuerySupported(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"IsCommonFileQuerySupported", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);

                return py::convert(self->obj.IsCommonFileQuerySupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_IsCommonFolderQuerySupported(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"IsCommonFolderQuerySupported", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);

                return py::convert(self->obj.IsCommonFolderQuerySupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_IsEqual(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"IsEqual", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageItem>(args, 0);

                return py::convert(self->obj.IsEqual(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_IsOfType(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"IsOfType", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

                return py::convert(self->obj.IsOfType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_RenameAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"RenameAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RenameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"RenameAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);

                return py::convert(self->obj.RenameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_TryGetChangeTracker(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"TryGetChangeTracker", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryGetChangeTracker());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_TryGetItemAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"TryGetItemAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryGetItemAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_Attributes(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFolder", L"Attributes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Attributes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_DateCreated(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFolder", L"DateCreated"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DateCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_Name(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFolder", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_Path(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFolder", L"Path"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_DisplayName(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFolder", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_DisplayType(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFolder", L"DisplayType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_FolderRelativeId(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFolder", L"FolderRelativeId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FolderRelativeId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_Properties(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFolder", L"Properties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_Provider(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFolder", L"Provider"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Provider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorageFolder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::StorageFolder>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageFolder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageFolder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageFolder[] = {
        { "are_query_options_supported", reinterpret_cast<PyCFunction>(StorageFolder_AreQueryOptionsSupported), METH_VARARGS, nullptr },
        { "create_file_async", reinterpret_cast<PyCFunction>(StorageFolder_CreateFileAsync), METH_VARARGS, nullptr },
        { "create_file_query", reinterpret_cast<PyCFunction>(StorageFolder_CreateFileQuery), METH_VARARGS, nullptr },
        { "create_file_query_with_options", reinterpret_cast<PyCFunction>(StorageFolder_CreateFileQueryWithOptions), METH_VARARGS, nullptr },
        { "create_folder_async", reinterpret_cast<PyCFunction>(StorageFolder_CreateFolderAsync), METH_VARARGS, nullptr },
        { "create_folder_query", reinterpret_cast<PyCFunction>(StorageFolder_CreateFolderQuery), METH_VARARGS, nullptr },
        { "create_folder_query_with_options", reinterpret_cast<PyCFunction>(StorageFolder_CreateFolderQueryWithOptions), METH_VARARGS, nullptr },
        { "create_item_query", reinterpret_cast<PyCFunction>(StorageFolder_CreateItemQuery), METH_VARARGS, nullptr },
        { "create_item_query_with_options", reinterpret_cast<PyCFunction>(StorageFolder_CreateItemQueryWithOptions), METH_VARARGS, nullptr },
        { "delete_async", reinterpret_cast<PyCFunction>(StorageFolder_DeleteAsync), METH_VARARGS, nullptr },
        { "get_basic_properties_async", reinterpret_cast<PyCFunction>(StorageFolder_GetBasicPropertiesAsync), METH_VARARGS, nullptr },
        { "get_file_async", reinterpret_cast<PyCFunction>(StorageFolder_GetFileAsync), METH_VARARGS, nullptr },
        { "get_files_async", reinterpret_cast<PyCFunction>(StorageFolder_GetFilesAsync), METH_VARARGS, nullptr },
        { "get_folder_async", reinterpret_cast<PyCFunction>(StorageFolder_GetFolderAsync), METH_VARARGS, nullptr },
        { "get_folders_async", reinterpret_cast<PyCFunction>(StorageFolder_GetFoldersAsync), METH_VARARGS, nullptr },
        { "get_indexed_state_async", reinterpret_cast<PyCFunction>(StorageFolder_GetIndexedStateAsync), METH_VARARGS, nullptr },
        { "get_item_async", reinterpret_cast<PyCFunction>(StorageFolder_GetItemAsync), METH_VARARGS, nullptr },
        { "get_items_async", reinterpret_cast<PyCFunction>(StorageFolder_GetItemsAsync), METH_VARARGS, nullptr },
        { "get_parent_async", reinterpret_cast<PyCFunction>(StorageFolder_GetParentAsync), METH_VARARGS, nullptr },
        { "get_scaled_image_as_thumbnail_async", reinterpret_cast<PyCFunction>(StorageFolder_GetScaledImageAsThumbnailAsync), METH_VARARGS, nullptr },
        { "get_thumbnail_async", reinterpret_cast<PyCFunction>(StorageFolder_GetThumbnailAsync), METH_VARARGS, nullptr },
        { "is_common_file_query_supported", reinterpret_cast<PyCFunction>(StorageFolder_IsCommonFileQuerySupported), METH_VARARGS, nullptr },
        { "is_common_folder_query_supported", reinterpret_cast<PyCFunction>(StorageFolder_IsCommonFolderQuerySupported), METH_VARARGS, nullptr },
        { "is_equal", reinterpret_cast<PyCFunction>(StorageFolder_IsEqual), METH_VARARGS, nullptr },
        { "is_of_type", reinterpret_cast<PyCFunction>(StorageFolder_IsOfType), METH_VARARGS, nullptr },
        { "rename_async", reinterpret_cast<PyCFunction>(StorageFolder_RenameAsync), METH_VARARGS, nullptr },
        { "try_get_change_tracker", reinterpret_cast<PyCFunction>(StorageFolder_TryGetChangeTracker), METH_VARARGS, nullptr },
        { "try_get_item_async", reinterpret_cast<PyCFunction>(StorageFolder_TryGetItemAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StorageFolder, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageFolder), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageFolder[] = {
        { "attributes", reinterpret_cast<getter>(StorageFolder_get_Attributes), nullptr, nullptr, nullptr },
        { "date_created", reinterpret_cast<getter>(StorageFolder_get_DateCreated), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(StorageFolder_get_Name), nullptr, nullptr, nullptr },
        { "path", reinterpret_cast<getter>(StorageFolder_get_Path), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(StorageFolder_get_DisplayName), nullptr, nullptr, nullptr },
        { "display_type", reinterpret_cast<getter>(StorageFolder_get_DisplayType), nullptr, nullptr, nullptr },
        { "folder_relative_id", reinterpret_cast<getter>(StorageFolder_get_FolderRelativeId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(StorageFolder_get_Properties), nullptr, nullptr, nullptr },
        { "provider", reinterpret_cast<getter>(StorageFolder_get_Provider), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageFolder[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageFolder) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageFolder) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageFolder) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageFolder) },
        { },
    };

    static PyType_Spec type_spec_StorageFolder =
    {
        "winrt._winrt_windows_storage.StorageFolder",
        sizeof(py::wrapper::Windows::Storage::StorageFolder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageFolder
    };

    static PyGetSetDef getset_StorageFolder_Static[] = {
        { }
    };

    static PyMethodDef methods_StorageFolder_Static[] = {
        { "get_folder_from_path_async", reinterpret_cast<PyCFunction>(StorageFolder_GetFolderFromPathAsync), METH_VARARGS, nullptr },
        { "get_folder_from_path_for_user_async", reinterpret_cast<PyCFunction>(StorageFolder_GetFolderFromPathForUserAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_StorageFolder_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_StorageFolder_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_StorageFolder_Static) },
        { }
    };

    static PyType_Spec type_spec_StorageFolder_Static =
    {
        "winrt._winrt_windows_storage.StorageFolder_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_StorageFolder_Static
    };

    // ----- StorageLibrary class --------------------

    static PyObject* _new_StorageLibrary(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::StorageLibrary>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::StorageLibrary>::type_name);
        return nullptr;
    }

    static void _dealloc_StorageLibrary(py::wrapper::Windows::Storage::StorageLibrary* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageLibrary_AreFolderSuggestionsAvailableAsync(py::wrapper::Windows::Storage::StorageLibrary* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageLibrary", L"AreFolderSuggestionsAvailableAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.AreFolderSuggestionsAvailableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_GetLibraryAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageLibrary", L"GetLibraryAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::KnownLibraryId>(args, 0);

                return py::convert(winrt::Windows::Storage::StorageLibrary::GetLibraryAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_GetLibraryForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageLibrary", L"GetLibraryForUserAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::KnownLibraryId>(args, 1);

                return py::convert(winrt::Windows::Storage::StorageLibrary::GetLibraryForUserAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_RequestAddFolderAsync(py::wrapper::Windows::Storage::StorageLibrary* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageLibrary", L"RequestAddFolderAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.RequestAddFolderAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_RequestRemoveFolderAsync(py::wrapper::Windows::Storage::StorageLibrary* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageLibrary", L"RequestRemoveFolderAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFolder>(args, 0);

                return py::convert(self->obj.RequestRemoveFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_get_Folders(py::wrapper::Windows::Storage::StorageLibrary* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageLibrary", L"Folders"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Folders());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_get_SaveFolder(py::wrapper::Windows::Storage::StorageLibrary* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageLibrary", L"SaveFolder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SaveFolder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_get_ChangeTracker(py::wrapper::Windows::Storage::StorageLibrary* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageLibrary", L"ChangeTracker"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ChangeTracker());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_add_DefinitionChanged(py::wrapper::Windows::Storage::StorageLibrary* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.StorageLibrary", L"DefinitionChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::StorageLibrary, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.DefinitionChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_remove_DefinitionChanged(py::wrapper::Windows::Storage::StorageLibrary* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.StorageLibrary", L"DefinitionChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DefinitionChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorageLibrary(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::StorageLibrary>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageLibrary(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageLibrary>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageLibrary[] = {
        { "are_folder_suggestions_available_async", reinterpret_cast<PyCFunction>(StorageLibrary_AreFolderSuggestionsAvailableAsync), METH_VARARGS, nullptr },
        { "request_add_folder_async", reinterpret_cast<PyCFunction>(StorageLibrary_RequestAddFolderAsync), METH_VARARGS, nullptr },
        { "request_remove_folder_async", reinterpret_cast<PyCFunction>(StorageLibrary_RequestRemoveFolderAsync), METH_VARARGS, nullptr },
        { "add_definition_changed", reinterpret_cast<PyCFunction>(StorageLibrary_add_DefinitionChanged), METH_O, nullptr },
        { "remove_definition_changed", reinterpret_cast<PyCFunction>(StorageLibrary_remove_DefinitionChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_StorageLibrary, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageLibrary), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageLibrary[] = {
        { "folders", reinterpret_cast<getter>(StorageLibrary_get_Folders), nullptr, nullptr, nullptr },
        { "save_folder", reinterpret_cast<getter>(StorageLibrary_get_SaveFolder), nullptr, nullptr, nullptr },
        { "change_tracker", reinterpret_cast<getter>(StorageLibrary_get_ChangeTracker), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageLibrary[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageLibrary) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageLibrary) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageLibrary) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageLibrary) },
        { },
    };

    static PyType_Spec type_spec_StorageLibrary =
    {
        "winrt._winrt_windows_storage.StorageLibrary",
        sizeof(py::wrapper::Windows::Storage::StorageLibrary),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageLibrary
    };

    static PyGetSetDef getset_StorageLibrary_Static[] = {
        { }
    };

    static PyMethodDef methods_StorageLibrary_Static[] = {
        { "get_library_async", reinterpret_cast<PyCFunction>(StorageLibrary_GetLibraryAsync), METH_VARARGS, nullptr },
        { "get_library_for_user_async", reinterpret_cast<PyCFunction>(StorageLibrary_GetLibraryForUserAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_StorageLibrary_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_StorageLibrary_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_StorageLibrary_Static) },
        { }
    };

    static PyType_Spec type_spec_StorageLibrary_Static =
    {
        "winrt._winrt_windows_storage.StorageLibrary_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_StorageLibrary_Static
    };

    // ----- StorageLibraryChange class --------------------

    static PyObject* _new_StorageLibraryChange(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::StorageLibraryChange>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::StorageLibraryChange>::type_name);
        return nullptr;
    }

    static void _dealloc_StorageLibraryChange(py::wrapper::Windows::Storage::StorageLibraryChange* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageLibraryChange_GetStorageItemAsync(py::wrapper::Windows::Storage::StorageLibraryChange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageLibraryChange", L"GetStorageItemAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetStorageItemAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChange_IsOfType(py::wrapper::Windows::Storage::StorageLibraryChange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageLibraryChange", L"IsOfType", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

                return py::convert(self->obj.IsOfType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChange_get_ChangeType(py::wrapper::Windows::Storage::StorageLibraryChange* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageLibraryChange", L"ChangeType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ChangeType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChange_get_Path(py::wrapper::Windows::Storage::StorageLibraryChange* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageLibraryChange", L"Path"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChange_get_PreviousPath(py::wrapper::Windows::Storage::StorageLibraryChange* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageLibraryChange", L"PreviousPath"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorageLibraryChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::StorageLibraryChange>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageLibraryChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageLibraryChange>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageLibraryChange[] = {
        { "get_storage_item_async", reinterpret_cast<PyCFunction>(StorageLibraryChange_GetStorageItemAsync), METH_VARARGS, nullptr },
        { "is_of_type", reinterpret_cast<PyCFunction>(StorageLibraryChange_IsOfType), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StorageLibraryChange, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageLibraryChange), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageLibraryChange[] = {
        { "change_type", reinterpret_cast<getter>(StorageLibraryChange_get_ChangeType), nullptr, nullptr, nullptr },
        { "path", reinterpret_cast<getter>(StorageLibraryChange_get_Path), nullptr, nullptr, nullptr },
        { "previous_path", reinterpret_cast<getter>(StorageLibraryChange_get_PreviousPath), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageLibraryChange[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageLibraryChange) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageLibraryChange) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageLibraryChange) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageLibraryChange) },
        { },
    };

    static PyType_Spec type_spec_StorageLibraryChange =
    {
        "winrt._winrt_windows_storage.StorageLibraryChange",
        sizeof(py::wrapper::Windows::Storage::StorageLibraryChange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageLibraryChange
    };

    // ----- StorageLibraryChangeReader class --------------------

    static PyObject* _new_StorageLibraryChangeReader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::StorageLibraryChangeReader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::StorageLibraryChangeReader>::type_name);
        return nullptr;
    }

    static void _dealloc_StorageLibraryChangeReader(py::wrapper::Windows::Storage::StorageLibraryChangeReader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageLibraryChangeReader_AcceptChangesAsync(py::wrapper::Windows::Storage::StorageLibraryChangeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageLibraryChangeReader", L"AcceptChangesAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.AcceptChangesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChangeReader_GetLastChangeId(py::wrapper::Windows::Storage::StorageLibraryChangeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageLibraryChangeReader", L"GetLastChangeId", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetLastChangeId());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChangeReader_ReadBatchAsync(py::wrapper::Windows::Storage::StorageLibraryChangeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageLibraryChangeReader", L"ReadBatchAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReadBatchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorageLibraryChangeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::StorageLibraryChangeReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageLibraryChangeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageLibraryChangeReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageLibraryChangeReader[] = {
        { "accept_changes_async", reinterpret_cast<PyCFunction>(StorageLibraryChangeReader_AcceptChangesAsync), METH_VARARGS, nullptr },
        { "get_last_change_id", reinterpret_cast<PyCFunction>(StorageLibraryChangeReader_GetLastChangeId), METH_VARARGS, nullptr },
        { "read_batch_async", reinterpret_cast<PyCFunction>(StorageLibraryChangeReader_ReadBatchAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StorageLibraryChangeReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageLibraryChangeReader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageLibraryChangeReader[] = {
        { }
    };

    static PyType_Slot _type_slots_StorageLibraryChangeReader[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageLibraryChangeReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageLibraryChangeReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageLibraryChangeReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageLibraryChangeReader) },
        { },
    };

    static PyType_Spec type_spec_StorageLibraryChangeReader =
    {
        "winrt._winrt_windows_storage.StorageLibraryChangeReader",
        sizeof(py::wrapper::Windows::Storage::StorageLibraryChangeReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageLibraryChangeReader
    };

    // ----- StorageLibraryChangeTracker class --------------------

    static PyObject* _new_StorageLibraryChangeTracker(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::StorageLibraryChangeTracker>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::StorageLibraryChangeTracker>::type_name);
        return nullptr;
    }

    static void _dealloc_StorageLibraryChangeTracker(py::wrapper::Windows::Storage::StorageLibraryChangeTracker* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageLibraryChangeTracker_Disable(py::wrapper::Windows::Storage::StorageLibraryChangeTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageLibraryChangeTracker", L"Disable", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Disable();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChangeTracker_Enable(py::wrapper::Windows::Storage::StorageLibraryChangeTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageLibraryChangeTracker", L"Enable", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Enable();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageLibraryChangeTracker", L"Enable", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageLibraryChangeTrackerOptions>(args, 0);

                self->obj.Enable(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChangeTracker_GetChangeReader(py::wrapper::Windows::Storage::StorageLibraryChangeTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageLibraryChangeTracker", L"GetChangeReader", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetChangeReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChangeTracker_Reset(py::wrapper::Windows::Storage::StorageLibraryChangeTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageLibraryChangeTracker", L"Reset", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorageLibraryChangeTracker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::StorageLibraryChangeTracker>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageLibraryChangeTracker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageLibraryChangeTracker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageLibraryChangeTracker[] = {
        { "disable", reinterpret_cast<PyCFunction>(StorageLibraryChangeTracker_Disable), METH_VARARGS, nullptr },
        { "enable", reinterpret_cast<PyCFunction>(StorageLibraryChangeTracker_Enable), METH_VARARGS, nullptr },
        { "get_change_reader", reinterpret_cast<PyCFunction>(StorageLibraryChangeTracker_GetChangeReader), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(StorageLibraryChangeTracker_Reset), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StorageLibraryChangeTracker, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageLibraryChangeTracker), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageLibraryChangeTracker[] = {
        { }
    };

    static PyType_Slot _type_slots_StorageLibraryChangeTracker[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageLibraryChangeTracker) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageLibraryChangeTracker) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageLibraryChangeTracker) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageLibraryChangeTracker) },
        { },
    };

    static PyType_Spec type_spec_StorageLibraryChangeTracker =
    {
        "winrt._winrt_windows_storage.StorageLibraryChangeTracker",
        sizeof(py::wrapper::Windows::Storage::StorageLibraryChangeTracker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageLibraryChangeTracker
    };

    // ----- StorageLibraryChangeTrackerOptions class --------------------

    static PyObject* _new_StorageLibraryChangeTrackerOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::StorageLibraryChangeTrackerOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageLibraryChangeTrackerOptions(py::wrapper::Windows::Storage::StorageLibraryChangeTrackerOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageLibraryChangeTrackerOptions_get_TrackChangeDetails(py::wrapper::Windows::Storage::StorageLibraryChangeTrackerOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageLibraryChangeTrackerOptions", L"TrackChangeDetails"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TrackChangeDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageLibraryChangeTrackerOptions_put_TrackChangeDetails(py::wrapper::Windows::Storage::StorageLibraryChangeTrackerOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageLibraryChangeTrackerOptions", L"TrackChangeDetails"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.TrackChangeDetails(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_StorageLibraryChangeTrackerOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::StorageLibraryChangeTrackerOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageLibraryChangeTrackerOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageLibraryChangeTrackerOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageLibraryChangeTrackerOptions[] = {
        { "_assign_array_", _assign_array_StorageLibraryChangeTrackerOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageLibraryChangeTrackerOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageLibraryChangeTrackerOptions[] = {
        { "track_change_details", reinterpret_cast<getter>(StorageLibraryChangeTrackerOptions_get_TrackChangeDetails), reinterpret_cast<setter>(StorageLibraryChangeTrackerOptions_put_TrackChangeDetails), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageLibraryChangeTrackerOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageLibraryChangeTrackerOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageLibraryChangeTrackerOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageLibraryChangeTrackerOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageLibraryChangeTrackerOptions) },
        { },
    };

    static PyType_Spec type_spec_StorageLibraryChangeTrackerOptions =
    {
        "winrt._winrt_windows_storage.StorageLibraryChangeTrackerOptions",
        sizeof(py::wrapper::Windows::Storage::StorageLibraryChangeTrackerOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageLibraryChangeTrackerOptions
    };

    // ----- StorageLibraryLastChangeId class --------------------

    static PyObject* _new_StorageLibraryLastChangeId(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::StorageLibraryLastChangeId>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::StorageLibraryLastChangeId>::type_name);
        return nullptr;
    }

    static void _dealloc_StorageLibraryLastChangeId(py::wrapper::Windows::Storage::StorageLibraryLastChangeId* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageLibraryLastChangeId_get_Unknown(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageLibraryLastChangeId", L"Unknown"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Storage::StorageLibraryLastChangeId::Unknown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorageLibraryLastChangeId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::StorageLibraryLastChangeId>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageLibraryLastChangeId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageLibraryLastChangeId>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageLibraryLastChangeId[] = {
        { "_assign_array_", _assign_array_StorageLibraryLastChangeId, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageLibraryLastChangeId), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageLibraryLastChangeId[] = {
        { }
    };

    static PyType_Slot _type_slots_StorageLibraryLastChangeId[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageLibraryLastChangeId) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageLibraryLastChangeId) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageLibraryLastChangeId) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageLibraryLastChangeId) },
        { },
    };

    static PyType_Spec type_spec_StorageLibraryLastChangeId =
    {
        "winrt._winrt_windows_storage.StorageLibraryLastChangeId",
        sizeof(py::wrapper::Windows::Storage::StorageLibraryLastChangeId),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageLibraryLastChangeId
    };

    static PyGetSetDef getset_StorageLibraryLastChangeId_Static[] = {
        { "unknown", reinterpret_cast<getter>(StorageLibraryLastChangeId_get_Unknown), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_StorageLibraryLastChangeId_Static[] = {
        { }
    };

    static PyType_Slot type_slots_StorageLibraryLastChangeId_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_StorageLibraryLastChangeId_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_StorageLibraryLastChangeId_Static) },
        { }
    };

    static PyType_Spec type_spec_StorageLibraryLastChangeId_Static =
    {
        "winrt._winrt_windows_storage.StorageLibraryLastChangeId_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_StorageLibraryLastChangeId_Static
    };

    // ----- StorageProvider class --------------------

    static PyObject* _new_StorageProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::StorageProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::StorageProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_StorageProvider(py::wrapper::Windows::Storage::StorageProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProvider_IsPropertySupportedForPartialFileAsync(py::wrapper::Windows::Storage::StorageProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageProvider", L"IsPropertySupportedForPartialFileAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsPropertySupportedForPartialFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageProvider_get_DisplayName(py::wrapper::Windows::Storage::StorageProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageProvider", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageProvider_get_Id(py::wrapper::Windows::Storage::StorageProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageProvider", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorageProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::StorageProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProvider[] = {
        { "is_property_supported_for_partial_file_async", reinterpret_cast<PyCFunction>(StorageProvider_IsPropertySupportedForPartialFileAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StorageProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProvider[] = {
        { "display_name", reinterpret_cast<getter>(StorageProvider_get_DisplayName), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(StorageProvider_get_Id), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageProvider) },
        { },
    };

    static PyType_Spec type_spec_StorageProvider =
    {
        "winrt._winrt_windows_storage.StorageProvider",
        sizeof(py::wrapper::Windows::Storage::StorageProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProvider
    };

    // ----- StorageStreamTransaction class --------------------

    static PyObject* _new_StorageStreamTransaction(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::StorageStreamTransaction>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::StorageStreamTransaction>::type_name);
        return nullptr;
    }

    static void _dealloc_StorageStreamTransaction(py::wrapper::Windows::Storage::StorageStreamTransaction* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageStreamTransaction_Close(py::wrapper::Windows::Storage::StorageStreamTransaction* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageStreamTransaction", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageStreamTransaction_CommitAsync(py::wrapper::Windows::Storage::StorageStreamTransaction* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageStreamTransaction", L"CommitAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CommitAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageStreamTransaction_get_Stream(py::wrapper::Windows::Storage::StorageStreamTransaction* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageStreamTransaction", L"Stream"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Stream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorageStreamTransaction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::StorageStreamTransaction>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageStreamTransaction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageStreamTransaction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_StorageStreamTransaction(py::wrapper::Windows::Storage::StorageStreamTransaction* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_StorageStreamTransaction(py::wrapper::Windows::Storage::StorageStreamTransaction* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageStreamTransaction[] = {
        { "close", reinterpret_cast<PyCFunction>(StorageStreamTransaction_Close), METH_VARARGS, nullptr },
        { "commit_async", reinterpret_cast<PyCFunction>(StorageStreamTransaction_CommitAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StorageStreamTransaction, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageStreamTransaction), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_StorageStreamTransaction), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_StorageStreamTransaction), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageStreamTransaction[] = {
        { "stream", reinterpret_cast<getter>(StorageStreamTransaction_get_Stream), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageStreamTransaction[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageStreamTransaction) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageStreamTransaction) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageStreamTransaction) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageStreamTransaction) },
        { },
    };

    static PyType_Spec type_spec_StorageStreamTransaction =
    {
        "winrt._winrt_windows_storage.StorageStreamTransaction",
        sizeof(py::wrapper::Windows::Storage::StorageStreamTransaction),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageStreamTransaction
    };

    // ----- StreamedFileDataRequest class --------------------

    static PyObject* _new_StreamedFileDataRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::StreamedFileDataRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::StreamedFileDataRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_StreamedFileDataRequest(py::wrapper::Windows::Storage::StreamedFileDataRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StreamedFileDataRequest_Close(py::wrapper::Windows::Storage::StreamedFileDataRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StreamedFileDataRequest", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamedFileDataRequest_FailAndClose(py::wrapper::Windows::Storage::StreamedFileDataRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StreamedFileDataRequest", L"FailAndClose", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StreamedFileFailureMode>(args, 0);

                self->obj.FailAndClose(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamedFileDataRequest_FlushAsync(py::wrapper::Windows::Storage::StreamedFileDataRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StreamedFileDataRequest", L"FlushAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamedFileDataRequest_WriteAsync(py::wrapper::Windows::Storage::StreamedFileDataRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StreamedFileDataRequest", L"WriteAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_StreamedFileDataRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::StreamedFileDataRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StreamedFileDataRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StreamedFileDataRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_StreamedFileDataRequest(py::wrapper::Windows::Storage::StreamedFileDataRequest* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_StreamedFileDataRequest(py::wrapper::Windows::Storage::StreamedFileDataRequest* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamedFileDataRequest[] = {
        { "close", reinterpret_cast<PyCFunction>(StreamedFileDataRequest_Close), METH_VARARGS, nullptr },
        { "fail_and_close", reinterpret_cast<PyCFunction>(StreamedFileDataRequest_FailAndClose), METH_VARARGS, nullptr },
        { "flush_async", reinterpret_cast<PyCFunction>(StreamedFileDataRequest_FlushAsync), METH_VARARGS, nullptr },
        { "write_async", reinterpret_cast<PyCFunction>(StreamedFileDataRequest_WriteAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StreamedFileDataRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StreamedFileDataRequest), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_StreamedFileDataRequest), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_StreamedFileDataRequest), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreamedFileDataRequest[] = {
        { }
    };

    static PyType_Slot _type_slots_StreamedFileDataRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StreamedFileDataRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StreamedFileDataRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StreamedFileDataRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StreamedFileDataRequest) },
        { },
    };

    static PyType_Spec type_spec_StreamedFileDataRequest =
    {
        "winrt._winrt_windows_storage.StreamedFileDataRequest",
        sizeof(py::wrapper::Windows::Storage::StreamedFileDataRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamedFileDataRequest
    };

    // ----- SystemAudioProperties class --------------------

    static PyObject* _new_SystemAudioProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::SystemAudioProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::SystemAudioProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemAudioProperties(py::wrapper::Windows::Storage::SystemAudioProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemAudioProperties_get_EncodingBitrate(py::wrapper::Windows::Storage::SystemAudioProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemAudioProperties", L"EncodingBitrate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EncodingBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemAudioProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::SystemAudioProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemAudioProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SystemAudioProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemAudioProperties[] = {
        { "_assign_array_", _assign_array_SystemAudioProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemAudioProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemAudioProperties[] = {
        { "encoding_bitrate", reinterpret_cast<getter>(SystemAudioProperties_get_EncodingBitrate), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemAudioProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemAudioProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemAudioProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemAudioProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemAudioProperties) },
        { },
    };

    static PyType_Spec type_spec_SystemAudioProperties =
    {
        "winrt._winrt_windows_storage.SystemAudioProperties",
        sizeof(py::wrapper::Windows::Storage::SystemAudioProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemAudioProperties
    };

    // ----- SystemDataPaths class --------------------

    static PyObject* _new_SystemDataPaths(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::SystemDataPaths>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::SystemDataPaths>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemDataPaths(py::wrapper::Windows::Storage::SystemDataPaths* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemDataPaths_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.SystemDataPaths", L"GetDefault", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Storage::SystemDataPaths::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_Fonts(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemDataPaths", L"Fonts"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Fonts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_ProgramData(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemDataPaths", L"ProgramData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProgramData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_Public(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemDataPaths", L"Public"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Public());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_PublicDesktop(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemDataPaths", L"PublicDesktop"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PublicDesktop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_PublicDocuments(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemDataPaths", L"PublicDocuments"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PublicDocuments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_PublicDownloads(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemDataPaths", L"PublicDownloads"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PublicDownloads());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_PublicMusic(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemDataPaths", L"PublicMusic"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PublicMusic());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_PublicPictures(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemDataPaths", L"PublicPictures"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PublicPictures());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_PublicVideos(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemDataPaths", L"PublicVideos"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PublicVideos());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_System(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemDataPaths", L"System"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.System());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_SystemArm(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemDataPaths", L"SystemArm"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SystemArm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_SystemHost(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemDataPaths", L"SystemHost"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SystemHost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_SystemX64(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemDataPaths", L"SystemX64"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SystemX64());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_SystemX86(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemDataPaths", L"SystemX86"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SystemX86());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_UserProfiles(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemDataPaths", L"UserProfiles"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UserProfiles());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_Windows(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemDataPaths", L"Windows"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Windows());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemDataPaths(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::SystemDataPaths>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemDataPaths(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SystemDataPaths>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemDataPaths[] = {
        { "_assign_array_", _assign_array_SystemDataPaths, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemDataPaths), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemDataPaths[] = {
        { "fonts", reinterpret_cast<getter>(SystemDataPaths_get_Fonts), nullptr, nullptr, nullptr },
        { "program_data", reinterpret_cast<getter>(SystemDataPaths_get_ProgramData), nullptr, nullptr, nullptr },
        { "public", reinterpret_cast<getter>(SystemDataPaths_get_Public), nullptr, nullptr, nullptr },
        { "public_desktop", reinterpret_cast<getter>(SystemDataPaths_get_PublicDesktop), nullptr, nullptr, nullptr },
        { "public_documents", reinterpret_cast<getter>(SystemDataPaths_get_PublicDocuments), nullptr, nullptr, nullptr },
        { "public_downloads", reinterpret_cast<getter>(SystemDataPaths_get_PublicDownloads), nullptr, nullptr, nullptr },
        { "public_music", reinterpret_cast<getter>(SystemDataPaths_get_PublicMusic), nullptr, nullptr, nullptr },
        { "public_pictures", reinterpret_cast<getter>(SystemDataPaths_get_PublicPictures), nullptr, nullptr, nullptr },
        { "public_videos", reinterpret_cast<getter>(SystemDataPaths_get_PublicVideos), nullptr, nullptr, nullptr },
        { "system", reinterpret_cast<getter>(SystemDataPaths_get_System), nullptr, nullptr, nullptr },
        { "system_arm", reinterpret_cast<getter>(SystemDataPaths_get_SystemArm), nullptr, nullptr, nullptr },
        { "system_host", reinterpret_cast<getter>(SystemDataPaths_get_SystemHost), nullptr, nullptr, nullptr },
        { "system_x64", reinterpret_cast<getter>(SystemDataPaths_get_SystemX64), nullptr, nullptr, nullptr },
        { "system_x86", reinterpret_cast<getter>(SystemDataPaths_get_SystemX86), nullptr, nullptr, nullptr },
        { "user_profiles", reinterpret_cast<getter>(SystemDataPaths_get_UserProfiles), nullptr, nullptr, nullptr },
        { "windows", reinterpret_cast<getter>(SystemDataPaths_get_Windows), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemDataPaths[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemDataPaths) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemDataPaths) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemDataPaths) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemDataPaths) },
        { },
    };

    static PyType_Spec type_spec_SystemDataPaths =
    {
        "winrt._winrt_windows_storage.SystemDataPaths",
        sizeof(py::wrapper::Windows::Storage::SystemDataPaths),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemDataPaths
    };

    static PyGetSetDef getset_SystemDataPaths_Static[] = {
        { }
    };

    static PyMethodDef methods_SystemDataPaths_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(SystemDataPaths_GetDefault), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_SystemDataPaths_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SystemDataPaths_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SystemDataPaths_Static) },
        { }
    };

    static PyType_Spec type_spec_SystemDataPaths_Static =
    {
        "winrt._winrt_windows_storage.SystemDataPaths_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SystemDataPaths_Static
    };

    // ----- SystemGPSProperties class --------------------

    static PyObject* _new_SystemGPSProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::SystemGPSProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::SystemGPSProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemGPSProperties(py::wrapper::Windows::Storage::SystemGPSProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemGPSProperties_get_LatitudeDecimal(py::wrapper::Windows::Storage::SystemGPSProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemGPSProperties", L"LatitudeDecimal"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LatitudeDecimal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemGPSProperties_get_LongitudeDecimal(py::wrapper::Windows::Storage::SystemGPSProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemGPSProperties", L"LongitudeDecimal"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LongitudeDecimal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemGPSProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::SystemGPSProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemGPSProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SystemGPSProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemGPSProperties[] = {
        { "_assign_array_", _assign_array_SystemGPSProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemGPSProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemGPSProperties[] = {
        { "latitude_decimal", reinterpret_cast<getter>(SystemGPSProperties_get_LatitudeDecimal), nullptr, nullptr, nullptr },
        { "longitude_decimal", reinterpret_cast<getter>(SystemGPSProperties_get_LongitudeDecimal), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemGPSProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemGPSProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemGPSProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemGPSProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemGPSProperties) },
        { },
    };

    static PyType_Spec type_spec_SystemGPSProperties =
    {
        "winrt._winrt_windows_storage.SystemGPSProperties",
        sizeof(py::wrapper::Windows::Storage::SystemGPSProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemGPSProperties
    };

    // ----- SystemImageProperties class --------------------

    static PyObject* _new_SystemImageProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::SystemImageProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::SystemImageProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemImageProperties(py::wrapper::Windows::Storage::SystemImageProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemImageProperties_get_HorizontalSize(py::wrapper::Windows::Storage::SystemImageProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemImageProperties", L"HorizontalSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontalSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemImageProperties_get_VerticalSize(py::wrapper::Windows::Storage::SystemImageProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemImageProperties", L"VerticalSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticalSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemImageProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::SystemImageProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemImageProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SystemImageProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemImageProperties[] = {
        { "_assign_array_", _assign_array_SystemImageProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemImageProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemImageProperties[] = {
        { "horizontal_size", reinterpret_cast<getter>(SystemImageProperties_get_HorizontalSize), nullptr, nullptr, nullptr },
        { "vertical_size", reinterpret_cast<getter>(SystemImageProperties_get_VerticalSize), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemImageProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemImageProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemImageProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemImageProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemImageProperties) },
        { },
    };

    static PyType_Spec type_spec_SystemImageProperties =
    {
        "winrt._winrt_windows_storage.SystemImageProperties",
        sizeof(py::wrapper::Windows::Storage::SystemImageProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemImageProperties
    };

    // ----- SystemMediaProperties class --------------------

    static PyObject* _new_SystemMediaProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::SystemMediaProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::SystemMediaProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemMediaProperties(py::wrapper::Windows::Storage::SystemMediaProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemMediaProperties_get_Duration(py::wrapper::Windows::Storage::SystemMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemMediaProperties", L"Duration"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaProperties_get_Producer(py::wrapper::Windows::Storage::SystemMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemMediaProperties", L"Producer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Producer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaProperties_get_Publisher(py::wrapper::Windows::Storage::SystemMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemMediaProperties", L"Publisher"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Publisher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaProperties_get_SubTitle(py::wrapper::Windows::Storage::SystemMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemMediaProperties", L"SubTitle"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SubTitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaProperties_get_Writer(py::wrapper::Windows::Storage::SystemMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemMediaProperties", L"Writer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Writer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaProperties_get_Year(py::wrapper::Windows::Storage::SystemMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemMediaProperties", L"Year"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Year());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemMediaProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::SystemMediaProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemMediaProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SystemMediaProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemMediaProperties[] = {
        { "_assign_array_", _assign_array_SystemMediaProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemMediaProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemMediaProperties[] = {
        { "duration", reinterpret_cast<getter>(SystemMediaProperties_get_Duration), nullptr, nullptr, nullptr },
        { "producer", reinterpret_cast<getter>(SystemMediaProperties_get_Producer), nullptr, nullptr, nullptr },
        { "publisher", reinterpret_cast<getter>(SystemMediaProperties_get_Publisher), nullptr, nullptr, nullptr },
        { "sub_title", reinterpret_cast<getter>(SystemMediaProperties_get_SubTitle), nullptr, nullptr, nullptr },
        { "writer", reinterpret_cast<getter>(SystemMediaProperties_get_Writer), nullptr, nullptr, nullptr },
        { "year", reinterpret_cast<getter>(SystemMediaProperties_get_Year), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemMediaProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemMediaProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemMediaProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemMediaProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemMediaProperties) },
        { },
    };

    static PyType_Spec type_spec_SystemMediaProperties =
    {
        "winrt._winrt_windows_storage.SystemMediaProperties",
        sizeof(py::wrapper::Windows::Storage::SystemMediaProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemMediaProperties
    };

    // ----- SystemMusicProperties class --------------------

    static PyObject* _new_SystemMusicProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::SystemMusicProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::SystemMusicProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemMusicProperties(py::wrapper::Windows::Storage::SystemMusicProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemMusicProperties_get_AlbumArtist(py::wrapper::Windows::Storage::SystemMusicProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemMusicProperties", L"AlbumArtist"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AlbumArtist());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMusicProperties_get_AlbumTitle(py::wrapper::Windows::Storage::SystemMusicProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemMusicProperties", L"AlbumTitle"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AlbumTitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMusicProperties_get_Artist(py::wrapper::Windows::Storage::SystemMusicProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemMusicProperties", L"Artist"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Artist());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMusicProperties_get_Composer(py::wrapper::Windows::Storage::SystemMusicProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemMusicProperties", L"Composer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Composer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMusicProperties_get_Conductor(py::wrapper::Windows::Storage::SystemMusicProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemMusicProperties", L"Conductor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Conductor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMusicProperties_get_DisplayArtist(py::wrapper::Windows::Storage::SystemMusicProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemMusicProperties", L"DisplayArtist"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayArtist());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMusicProperties_get_Genre(py::wrapper::Windows::Storage::SystemMusicProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemMusicProperties", L"Genre"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Genre());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMusicProperties_get_TrackNumber(py::wrapper::Windows::Storage::SystemMusicProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemMusicProperties", L"TrackNumber"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TrackNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemMusicProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::SystemMusicProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemMusicProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SystemMusicProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemMusicProperties[] = {
        { "_assign_array_", _assign_array_SystemMusicProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemMusicProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemMusicProperties[] = {
        { "album_artist", reinterpret_cast<getter>(SystemMusicProperties_get_AlbumArtist), nullptr, nullptr, nullptr },
        { "album_title", reinterpret_cast<getter>(SystemMusicProperties_get_AlbumTitle), nullptr, nullptr, nullptr },
        { "artist", reinterpret_cast<getter>(SystemMusicProperties_get_Artist), nullptr, nullptr, nullptr },
        { "composer", reinterpret_cast<getter>(SystemMusicProperties_get_Composer), nullptr, nullptr, nullptr },
        { "conductor", reinterpret_cast<getter>(SystemMusicProperties_get_Conductor), nullptr, nullptr, nullptr },
        { "display_artist", reinterpret_cast<getter>(SystemMusicProperties_get_DisplayArtist), nullptr, nullptr, nullptr },
        { "genre", reinterpret_cast<getter>(SystemMusicProperties_get_Genre), nullptr, nullptr, nullptr },
        { "track_number", reinterpret_cast<getter>(SystemMusicProperties_get_TrackNumber), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemMusicProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemMusicProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemMusicProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemMusicProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemMusicProperties) },
        { },
    };

    static PyType_Spec type_spec_SystemMusicProperties =
    {
        "winrt._winrt_windows_storage.SystemMusicProperties",
        sizeof(py::wrapper::Windows::Storage::SystemMusicProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemMusicProperties
    };

    // ----- SystemPhotoProperties class --------------------

    static PyObject* _new_SystemPhotoProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::SystemPhotoProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::SystemPhotoProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemPhotoProperties(py::wrapper::Windows::Storage::SystemPhotoProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemPhotoProperties_get_CameraManufacturer(py::wrapper::Windows::Storage::SystemPhotoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemPhotoProperties", L"CameraManufacturer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CameraManufacturer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemPhotoProperties_get_CameraModel(py::wrapper::Windows::Storage::SystemPhotoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemPhotoProperties", L"CameraModel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CameraModel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemPhotoProperties_get_DateTaken(py::wrapper::Windows::Storage::SystemPhotoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemPhotoProperties", L"DateTaken"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DateTaken());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemPhotoProperties_get_Orientation(py::wrapper::Windows::Storage::SystemPhotoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemPhotoProperties", L"Orientation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemPhotoProperties_get_PeopleNames(py::wrapper::Windows::Storage::SystemPhotoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemPhotoProperties", L"PeopleNames"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PeopleNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemPhotoProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::SystemPhotoProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemPhotoProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SystemPhotoProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemPhotoProperties[] = {
        { "_assign_array_", _assign_array_SystemPhotoProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemPhotoProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemPhotoProperties[] = {
        { "camera_manufacturer", reinterpret_cast<getter>(SystemPhotoProperties_get_CameraManufacturer), nullptr, nullptr, nullptr },
        { "camera_model", reinterpret_cast<getter>(SystemPhotoProperties_get_CameraModel), nullptr, nullptr, nullptr },
        { "date_taken", reinterpret_cast<getter>(SystemPhotoProperties_get_DateTaken), nullptr, nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(SystemPhotoProperties_get_Orientation), nullptr, nullptr, nullptr },
        { "people_names", reinterpret_cast<getter>(SystemPhotoProperties_get_PeopleNames), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemPhotoProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemPhotoProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemPhotoProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemPhotoProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemPhotoProperties) },
        { },
    };

    static PyType_Spec type_spec_SystemPhotoProperties =
    {
        "winrt._winrt_windows_storage.SystemPhotoProperties",
        sizeof(py::wrapper::Windows::Storage::SystemPhotoProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemPhotoProperties
    };

    // ----- SystemProperties class --------------------

    static PyObject* _new_SystemProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::SystemProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::SystemProperties>::type_name);
        return nullptr;
    }

    static PyObject* SystemProperties_get_Audio(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemProperties", L"Audio"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Storage::SystemProperties::Audio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Author(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemProperties", L"Author"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Storage::SystemProperties::Author());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Comment(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemProperties", L"Comment"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Storage::SystemProperties::Comment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_GPS(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemProperties", L"GPS"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Storage::SystemProperties::GPS());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Image(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemProperties", L"Image"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Storage::SystemProperties::Image());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_ItemNameDisplay(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemProperties", L"ItemNameDisplay"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Storage::SystemProperties::ItemNameDisplay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Keywords(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemProperties", L"Keywords"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Storage::SystemProperties::Keywords());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Media(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemProperties", L"Media"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Storage::SystemProperties::Media());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Music(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemProperties", L"Music"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Storage::SystemProperties::Music());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Photo(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemProperties", L"Photo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Storage::SystemProperties::Photo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Rating(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemProperties", L"Rating"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Storage::SystemProperties::Rating());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Title(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemProperties", L"Title"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Storage::SystemProperties::Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Video(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemProperties", L"Video"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Storage::SystemProperties::Video());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemProperties[] = {
        { }
    };

    static PyGetSetDef _getset_SystemProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_SystemProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemProperties) },
        { },
    };

    static PyType_Spec type_spec_SystemProperties =
    {
        "winrt._winrt_windows_storage.SystemProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemProperties
    };

    static PyGetSetDef getset_SystemProperties_Static[] = {
        { "audio", reinterpret_cast<getter>(SystemProperties_get_Audio), nullptr, nullptr, nullptr },
        { "author", reinterpret_cast<getter>(SystemProperties_get_Author), nullptr, nullptr, nullptr },
        { "comment", reinterpret_cast<getter>(SystemProperties_get_Comment), nullptr, nullptr, nullptr },
        { "g_p_s", reinterpret_cast<getter>(SystemProperties_get_GPS), nullptr, nullptr, nullptr },
        { "image", reinterpret_cast<getter>(SystemProperties_get_Image), nullptr, nullptr, nullptr },
        { "item_name_display", reinterpret_cast<getter>(SystemProperties_get_ItemNameDisplay), nullptr, nullptr, nullptr },
        { "keywords", reinterpret_cast<getter>(SystemProperties_get_Keywords), nullptr, nullptr, nullptr },
        { "media", reinterpret_cast<getter>(SystemProperties_get_Media), nullptr, nullptr, nullptr },
        { "music", reinterpret_cast<getter>(SystemProperties_get_Music), nullptr, nullptr, nullptr },
        { "photo", reinterpret_cast<getter>(SystemProperties_get_Photo), nullptr, nullptr, nullptr },
        { "rating", reinterpret_cast<getter>(SystemProperties_get_Rating), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(SystemProperties_get_Title), nullptr, nullptr, nullptr },
        { "video", reinterpret_cast<getter>(SystemProperties_get_Video), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_SystemProperties_Static[] = {
        { }
    };

    static PyType_Slot type_slots_SystemProperties_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SystemProperties_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SystemProperties_Static) },
        { }
    };

    static PyType_Spec type_spec_SystemProperties_Static =
    {
        "winrt._winrt_windows_storage.SystemProperties_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SystemProperties_Static
    };

    // ----- SystemVideoProperties class --------------------

    static PyObject* _new_SystemVideoProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::SystemVideoProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::SystemVideoProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemVideoProperties(py::wrapper::Windows::Storage::SystemVideoProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemVideoProperties_get_Director(py::wrapper::Windows::Storage::SystemVideoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemVideoProperties", L"Director"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Director());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemVideoProperties_get_FrameHeight(py::wrapper::Windows::Storage::SystemVideoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemVideoProperties", L"FrameHeight"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FrameHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemVideoProperties_get_FrameWidth(py::wrapper::Windows::Storage::SystemVideoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemVideoProperties", L"FrameWidth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FrameWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemVideoProperties_get_Orientation(py::wrapper::Windows::Storage::SystemVideoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemVideoProperties", L"Orientation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemVideoProperties_get_TotalBitrate(py::wrapper::Windows::Storage::SystemVideoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemVideoProperties", L"TotalBitrate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TotalBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemVideoProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::SystemVideoProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemVideoProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SystemVideoProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemVideoProperties[] = {
        { "_assign_array_", _assign_array_SystemVideoProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemVideoProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemVideoProperties[] = {
        { "director", reinterpret_cast<getter>(SystemVideoProperties_get_Director), nullptr, nullptr, nullptr },
        { "frame_height", reinterpret_cast<getter>(SystemVideoProperties_get_FrameHeight), nullptr, nullptr, nullptr },
        { "frame_width", reinterpret_cast<getter>(SystemVideoProperties_get_FrameWidth), nullptr, nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(SystemVideoProperties_get_Orientation), nullptr, nullptr, nullptr },
        { "total_bitrate", reinterpret_cast<getter>(SystemVideoProperties_get_TotalBitrate), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemVideoProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemVideoProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemVideoProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemVideoProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemVideoProperties) },
        { },
    };

    static PyType_Spec type_spec_SystemVideoProperties =
    {
        "winrt._winrt_windows_storage.SystemVideoProperties",
        sizeof(py::wrapper::Windows::Storage::SystemVideoProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemVideoProperties
    };

    // ----- UserDataPaths class --------------------

    static PyObject* _new_UserDataPaths(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::UserDataPaths>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::UserDataPaths>::type_name);
        return nullptr;
    }

    static void _dealloc_UserDataPaths(py::wrapper::Windows::Storage::UserDataPaths* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UserDataPaths_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.UserDataPaths", L"GetDefault", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Storage::UserDataPaths::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.UserDataPaths", L"GetForUser", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::Storage::UserDataPaths::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_CameraRoll(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"CameraRoll"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CameraRoll());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Cookies(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"Cookies"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Cookies());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Desktop(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"Desktop"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Desktop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Documents(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"Documents"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Documents());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Downloads(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"Downloads"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Downloads());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Favorites(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"Favorites"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Favorites());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_History(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"History"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.History());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_InternetCache(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"InternetCache"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InternetCache());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_LocalAppData(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"LocalAppData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalAppData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_LocalAppDataLow(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"LocalAppDataLow"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalAppDataLow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Music(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"Music"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Music());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Pictures(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"Pictures"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Pictures());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Profile(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"Profile"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Profile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Recent(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"Recent"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Recent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_RoamingAppData(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"RoamingAppData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RoamingAppData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_SavedPictures(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"SavedPictures"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SavedPictures());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Screenshots(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"Screenshots"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Screenshots());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Templates(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"Templates"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Templates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Videos(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"Videos"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Videos());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UserDataPaths(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::UserDataPaths>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UserDataPaths(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::UserDataPaths>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserDataPaths[] = {
        { "_assign_array_", _assign_array_UserDataPaths, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UserDataPaths), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UserDataPaths[] = {
        { "camera_roll", reinterpret_cast<getter>(UserDataPaths_get_CameraRoll), nullptr, nullptr, nullptr },
        { "cookies", reinterpret_cast<getter>(UserDataPaths_get_Cookies), nullptr, nullptr, nullptr },
        { "desktop", reinterpret_cast<getter>(UserDataPaths_get_Desktop), nullptr, nullptr, nullptr },
        { "documents", reinterpret_cast<getter>(UserDataPaths_get_Documents), nullptr, nullptr, nullptr },
        { "downloads", reinterpret_cast<getter>(UserDataPaths_get_Downloads), nullptr, nullptr, nullptr },
        { "favorites", reinterpret_cast<getter>(UserDataPaths_get_Favorites), nullptr, nullptr, nullptr },
        { "history", reinterpret_cast<getter>(UserDataPaths_get_History), nullptr, nullptr, nullptr },
        { "internet_cache", reinterpret_cast<getter>(UserDataPaths_get_InternetCache), nullptr, nullptr, nullptr },
        { "local_app_data", reinterpret_cast<getter>(UserDataPaths_get_LocalAppData), nullptr, nullptr, nullptr },
        { "local_app_data_low", reinterpret_cast<getter>(UserDataPaths_get_LocalAppDataLow), nullptr, nullptr, nullptr },
        { "music", reinterpret_cast<getter>(UserDataPaths_get_Music), nullptr, nullptr, nullptr },
        { "pictures", reinterpret_cast<getter>(UserDataPaths_get_Pictures), nullptr, nullptr, nullptr },
        { "profile", reinterpret_cast<getter>(UserDataPaths_get_Profile), nullptr, nullptr, nullptr },
        { "recent", reinterpret_cast<getter>(UserDataPaths_get_Recent), nullptr, nullptr, nullptr },
        { "roaming_app_data", reinterpret_cast<getter>(UserDataPaths_get_RoamingAppData), nullptr, nullptr, nullptr },
        { "saved_pictures", reinterpret_cast<getter>(UserDataPaths_get_SavedPictures), nullptr, nullptr, nullptr },
        { "screenshots", reinterpret_cast<getter>(UserDataPaths_get_Screenshots), nullptr, nullptr, nullptr },
        { "templates", reinterpret_cast<getter>(UserDataPaths_get_Templates), nullptr, nullptr, nullptr },
        { "videos", reinterpret_cast<getter>(UserDataPaths_get_Videos), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UserDataPaths[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UserDataPaths) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UserDataPaths) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UserDataPaths) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UserDataPaths) },
        { },
    };

    static PyType_Spec type_spec_UserDataPaths =
    {
        "winrt._winrt_windows_storage.UserDataPaths",
        sizeof(py::wrapper::Windows::Storage::UserDataPaths),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserDataPaths
    };

    static PyGetSetDef getset_UserDataPaths_Static[] = {
        { }
    };

    static PyMethodDef methods_UserDataPaths_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(UserDataPaths_GetDefault), METH_VARARGS, nullptr },
        { "get_for_user", reinterpret_cast<PyCFunction>(UserDataPaths_GetForUser), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_UserDataPaths_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_UserDataPaths_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_UserDataPaths_Static) },
        { }
    };

    static PyType_Spec type_spec_UserDataPaths_Static =
    {
        "winrt._winrt_windows_storage.UserDataPaths_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_UserDataPaths_Static
    };

    // ----- IStorageFile interface --------------------

    static PyObject* _new_IStorageFile(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::IStorageFile>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::IStorageFile>::type_name);
        return nullptr;
    }

    static void _dealloc_IStorageFile(py::wrapper::Windows::Storage::IStorageFile* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageFile_CopyAndReplaceAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFile", L"CopyAndReplaceAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(self->obj.CopyAndReplaceAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_CopyAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFile", L"CopyAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);

                return py::convert(self->obj.CopyAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFile", L"CopyAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.CopyAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFile", L"CopyAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 2);

                return py::convert(self->obj.CopyAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_DeleteAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"DeleteAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"DeleteAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);

                return py::convert(self->obj.DeleteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_GetBasicPropertiesAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"GetBasicPropertiesAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetBasicPropertiesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_IsOfType(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"IsOfType", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

                return py::convert(self->obj.IsOfType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_MoveAndReplaceAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFile", L"MoveAndReplaceAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(self->obj.MoveAndReplaceAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_MoveAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFile", L"MoveAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);

                return py::convert(self->obj.MoveAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFile", L"MoveAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.MoveAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFile", L"MoveAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 2);

                return py::convert(self->obj.MoveAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_OpenAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFile", L"OpenAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 0);

                return py::convert(self->obj.OpenAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_OpenReadAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IRandomAccessStreamReference", L"OpenReadAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.OpenReadAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_OpenSequentialReadAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IInputStreamReference", L"OpenSequentialReadAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.OpenSequentialReadAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_OpenTransactedWriteAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFile", L"OpenTransactedWriteAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.OpenTransactedWriteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_RenameAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"RenameAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RenameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"RenameAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);

                return py::convert(self->obj.RenameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_get_ContentType(py::wrapper::Windows::Storage::IStorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageFile", L"ContentType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageFile_get_FileType(py::wrapper::Windows::Storage::IStorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageFile", L"FileType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FileType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageFile_get_Attributes(py::wrapper::Windows::Storage::IStorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItem", L"Attributes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Attributes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageFile_get_DateCreated(py::wrapper::Windows::Storage::IStorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItem", L"DateCreated"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DateCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageFile_get_Name(py::wrapper::Windows::Storage::IStorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItem", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageFile_get_Path(py::wrapper::Windows::Storage::IStorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItem", L"Path"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IStorageFile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::IStorageFile>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageFile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageFile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageFile[] = {
        { "copy_and_replace_async", reinterpret_cast<PyCFunction>(IStorageFile_CopyAndReplaceAsync), METH_VARARGS, nullptr },
        { "copy_async", reinterpret_cast<PyCFunction>(IStorageFile_CopyAsync), METH_VARARGS, nullptr },
        { "delete_async", reinterpret_cast<PyCFunction>(IStorageFile_DeleteAsync), METH_VARARGS, nullptr },
        { "get_basic_properties_async", reinterpret_cast<PyCFunction>(IStorageFile_GetBasicPropertiesAsync), METH_VARARGS, nullptr },
        { "is_of_type", reinterpret_cast<PyCFunction>(IStorageFile_IsOfType), METH_VARARGS, nullptr },
        { "move_and_replace_async", reinterpret_cast<PyCFunction>(IStorageFile_MoveAndReplaceAsync), METH_VARARGS, nullptr },
        { "move_async", reinterpret_cast<PyCFunction>(IStorageFile_MoveAsync), METH_VARARGS, nullptr },
        { "open_async", reinterpret_cast<PyCFunction>(IStorageFile_OpenAsync), METH_VARARGS, nullptr },
        { "open_read_async", reinterpret_cast<PyCFunction>(IStorageFile_OpenReadAsync), METH_VARARGS, nullptr },
        { "open_sequential_read_async", reinterpret_cast<PyCFunction>(IStorageFile_OpenSequentialReadAsync), METH_VARARGS, nullptr },
        { "open_transacted_write_async", reinterpret_cast<PyCFunction>(IStorageFile_OpenTransactedWriteAsync), METH_VARARGS, nullptr },
        { "rename_async", reinterpret_cast<PyCFunction>(IStorageFile_RenameAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IStorageFile, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageFile), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageFile[] = {
        { "content_type", reinterpret_cast<getter>(IStorageFile_get_ContentType), nullptr, nullptr, nullptr },
        { "file_type", reinterpret_cast<getter>(IStorageFile_get_FileType), nullptr, nullptr, nullptr },
        { "attributes", reinterpret_cast<getter>(IStorageFile_get_Attributes), nullptr, nullptr, nullptr },
        { "date_created", reinterpret_cast<getter>(IStorageFile_get_DateCreated), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(IStorageFile_get_Name), nullptr, nullptr, nullptr },
        { "path", reinterpret_cast<getter>(IStorageFile_get_Path), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IStorageFile[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageFile) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageFile) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageFile) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageFile) },
        { },
    };

    static PyType_Spec type_spec_IStorageFile =
    {
        "winrt._winrt_windows_storage.IStorageFile",
        sizeof(py::wrapper::Windows::Storage::IStorageFile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageFile
    };

    // ----- IStorageFile2 interface --------------------

    static PyObject* _new_IStorageFile2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::IStorageFile2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::IStorageFile2>::type_name);
        return nullptr;
    }

    static void _dealloc_IStorageFile2(py::wrapper::Windows::Storage::IStorageFile2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageFile2_OpenAsync(py::wrapper::Windows::Storage::IStorageFile2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFile2", L"OpenAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 1);

                return py::convert(self->obj.OpenAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile2_OpenTransactedWriteAsync(py::wrapper::Windows::Storage::IStorageFile2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFile2", L"OpenTransactedWriteAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 0);

                return py::convert(self->obj.OpenTransactedWriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IStorageFile2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::IStorageFile2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageFile2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageFile2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageFile2[] = {
        { "open_async", reinterpret_cast<PyCFunction>(IStorageFile2_OpenAsync), METH_VARARGS, nullptr },
        { "open_transacted_write_async", reinterpret_cast<PyCFunction>(IStorageFile2_OpenTransactedWriteAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IStorageFile2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageFile2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageFile2[] = {
        { }
    };

    static PyType_Slot _type_slots_IStorageFile2[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageFile2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageFile2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageFile2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageFile2) },
        { },
    };

    static PyType_Spec type_spec_IStorageFile2 =
    {
        "winrt._winrt_windows_storage.IStorageFile2",
        sizeof(py::wrapper::Windows::Storage::IStorageFile2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageFile2
    };

    // ----- IStorageFilePropertiesWithAvailability interface --------------------

    static PyObject* _new_IStorageFilePropertiesWithAvailability(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::IStorageFilePropertiesWithAvailability>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::IStorageFilePropertiesWithAvailability>::type_name);
        return nullptr;
    }

    static void _dealloc_IStorageFilePropertiesWithAvailability(py::wrapper::Windows::Storage::IStorageFilePropertiesWithAvailability* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageFilePropertiesWithAvailability_get_IsAvailable(py::wrapper::Windows::Storage::IStorageFilePropertiesWithAvailability* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageFilePropertiesWithAvailability", L"IsAvailable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IStorageFilePropertiesWithAvailability(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::IStorageFilePropertiesWithAvailability>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageFilePropertiesWithAvailability(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageFilePropertiesWithAvailability>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageFilePropertiesWithAvailability[] = {
        { "_assign_array_", _assign_array_IStorageFilePropertiesWithAvailability, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageFilePropertiesWithAvailability), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageFilePropertiesWithAvailability[] = {
        { "is_available", reinterpret_cast<getter>(IStorageFilePropertiesWithAvailability_get_IsAvailable), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IStorageFilePropertiesWithAvailability[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageFilePropertiesWithAvailability) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageFilePropertiesWithAvailability) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageFilePropertiesWithAvailability) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageFilePropertiesWithAvailability) },
        { },
    };

    static PyType_Spec type_spec_IStorageFilePropertiesWithAvailability =
    {
        "winrt._winrt_windows_storage.IStorageFilePropertiesWithAvailability",
        sizeof(py::wrapper::Windows::Storage::IStorageFilePropertiesWithAvailability),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageFilePropertiesWithAvailability
    };

    // ----- IStorageFolder interface --------------------

    static PyObject* _new_IStorageFolder(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::IStorageFolder>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::IStorageFolder>::type_name);
        return nullptr;
    }

    static void _dealloc_IStorageFolder(py::wrapper::Windows::Storage::IStorageFolder* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageFolder_CreateFileAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFolder", L"CreateFileAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFolder", L"CreateFileAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);

                return py::convert(self->obj.CreateFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_CreateFolderAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFolder", L"CreateFolderAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFolder", L"CreateFolderAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);

                return py::convert(self->obj.CreateFolderAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_DeleteAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"DeleteAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"DeleteAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);

                return py::convert(self->obj.DeleteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_GetBasicPropertiesAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"GetBasicPropertiesAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetBasicPropertiesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_GetFileAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFolder", L"GetFileAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_GetFilesAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFolder", L"GetFilesAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetFilesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_GetFolderAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFolder", L"GetFolderAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_GetFoldersAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFolder", L"GetFoldersAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetFoldersAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_GetItemAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFolder", L"GetItemAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetItemAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_GetItemsAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFolder", L"GetItemsAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetItemsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_IsOfType(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"IsOfType", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

                return py::convert(self->obj.IsOfType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_RenameAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"RenameAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RenameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"RenameAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);

                return py::convert(self->obj.RenameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_get_Attributes(py::wrapper::Windows::Storage::IStorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItem", L"Attributes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Attributes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_get_DateCreated(py::wrapper::Windows::Storage::IStorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItem", L"DateCreated"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DateCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_get_Name(py::wrapper::Windows::Storage::IStorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItem", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_get_Path(py::wrapper::Windows::Storage::IStorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItem", L"Path"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IStorageFolder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::IStorageFolder>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageFolder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageFolder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageFolder[] = {
        { "create_file_async", reinterpret_cast<PyCFunction>(IStorageFolder_CreateFileAsync), METH_VARARGS, nullptr },
        { "create_folder_async", reinterpret_cast<PyCFunction>(IStorageFolder_CreateFolderAsync), METH_VARARGS, nullptr },
        { "delete_async", reinterpret_cast<PyCFunction>(IStorageFolder_DeleteAsync), METH_VARARGS, nullptr },
        { "get_basic_properties_async", reinterpret_cast<PyCFunction>(IStorageFolder_GetBasicPropertiesAsync), METH_VARARGS, nullptr },
        { "get_file_async", reinterpret_cast<PyCFunction>(IStorageFolder_GetFileAsync), METH_VARARGS, nullptr },
        { "get_files_async", reinterpret_cast<PyCFunction>(IStorageFolder_GetFilesAsync), METH_VARARGS, nullptr },
        { "get_folder_async", reinterpret_cast<PyCFunction>(IStorageFolder_GetFolderAsync), METH_VARARGS, nullptr },
        { "get_folders_async", reinterpret_cast<PyCFunction>(IStorageFolder_GetFoldersAsync), METH_VARARGS, nullptr },
        { "get_item_async", reinterpret_cast<PyCFunction>(IStorageFolder_GetItemAsync), METH_VARARGS, nullptr },
        { "get_items_async", reinterpret_cast<PyCFunction>(IStorageFolder_GetItemsAsync), METH_VARARGS, nullptr },
        { "is_of_type", reinterpret_cast<PyCFunction>(IStorageFolder_IsOfType), METH_VARARGS, nullptr },
        { "rename_async", reinterpret_cast<PyCFunction>(IStorageFolder_RenameAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IStorageFolder, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageFolder), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageFolder[] = {
        { "attributes", reinterpret_cast<getter>(IStorageFolder_get_Attributes), nullptr, nullptr, nullptr },
        { "date_created", reinterpret_cast<getter>(IStorageFolder_get_DateCreated), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(IStorageFolder_get_Name), nullptr, nullptr, nullptr },
        { "path", reinterpret_cast<getter>(IStorageFolder_get_Path), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IStorageFolder[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageFolder) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageFolder) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageFolder) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageFolder) },
        { },
    };

    static PyType_Spec type_spec_IStorageFolder =
    {
        "winrt._winrt_windows_storage.IStorageFolder",
        sizeof(py::wrapper::Windows::Storage::IStorageFolder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageFolder
    };

    // ----- IStorageFolder2 interface --------------------

    static PyObject* _new_IStorageFolder2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::IStorageFolder2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::IStorageFolder2>::type_name);
        return nullptr;
    }

    static void _dealloc_IStorageFolder2(py::wrapper::Windows::Storage::IStorageFolder2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageFolder2_TryGetItemAsync(py::wrapper::Windows::Storage::IStorageFolder2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFolder2", L"TryGetItemAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryGetItemAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IStorageFolder2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::IStorageFolder2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageFolder2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageFolder2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageFolder2[] = {
        { "try_get_item_async", reinterpret_cast<PyCFunction>(IStorageFolder2_TryGetItemAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IStorageFolder2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageFolder2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageFolder2[] = {
        { }
    };

    static PyType_Slot _type_slots_IStorageFolder2[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageFolder2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageFolder2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageFolder2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageFolder2) },
        { },
    };

    static PyType_Spec type_spec_IStorageFolder2 =
    {
        "winrt._winrt_windows_storage.IStorageFolder2",
        sizeof(py::wrapper::Windows::Storage::IStorageFolder2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageFolder2
    };

    // ----- IStorageItem interface --------------------

    static PyObject* _new_IStorageItem(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::IStorageItem>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::IStorageItem>::type_name);
        return nullptr;
    }

    static void _dealloc_IStorageItem(py::wrapper::Windows::Storage::IStorageItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageItem_DeleteAsync(py::wrapper::Windows::Storage::IStorageItem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"DeleteAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"DeleteAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);

                return py::convert(self->obj.DeleteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem_GetBasicPropertiesAsync(py::wrapper::Windows::Storage::IStorageItem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"GetBasicPropertiesAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetBasicPropertiesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem_IsOfType(py::wrapper::Windows::Storage::IStorageItem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"IsOfType", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

                return py::convert(self->obj.IsOfType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem_RenameAsync(py::wrapper::Windows::Storage::IStorageItem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"RenameAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RenameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"RenameAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);

                return py::convert(self->obj.RenameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem_get_Attributes(py::wrapper::Windows::Storage::IStorageItem* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItem", L"Attributes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Attributes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItem_get_DateCreated(py::wrapper::Windows::Storage::IStorageItem* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItem", L"DateCreated"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DateCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItem_get_Name(py::wrapper::Windows::Storage::IStorageItem* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItem", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItem_get_Path(py::wrapper::Windows::Storage::IStorageItem* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItem", L"Path"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IStorageItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::IStorageItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageItem[] = {
        { "delete_async", reinterpret_cast<PyCFunction>(IStorageItem_DeleteAsync), METH_VARARGS, nullptr },
        { "get_basic_properties_async", reinterpret_cast<PyCFunction>(IStorageItem_GetBasicPropertiesAsync), METH_VARARGS, nullptr },
        { "is_of_type", reinterpret_cast<PyCFunction>(IStorageItem_IsOfType), METH_VARARGS, nullptr },
        { "rename_async", reinterpret_cast<PyCFunction>(IStorageItem_RenameAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IStorageItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageItem[] = {
        { "attributes", reinterpret_cast<getter>(IStorageItem_get_Attributes), nullptr, nullptr, nullptr },
        { "date_created", reinterpret_cast<getter>(IStorageItem_get_DateCreated), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(IStorageItem_get_Name), nullptr, nullptr, nullptr },
        { "path", reinterpret_cast<getter>(IStorageItem_get_Path), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IStorageItem[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageItem) },
        { },
    };

    static PyType_Spec type_spec_IStorageItem =
    {
        "winrt._winrt_windows_storage.IStorageItem",
        sizeof(py::wrapper::Windows::Storage::IStorageItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageItem
    };

    // ----- IStorageItem2 interface --------------------

    static PyObject* _new_IStorageItem2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::IStorageItem2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::IStorageItem2>::type_name);
        return nullptr;
    }

    static void _dealloc_IStorageItem2(py::wrapper::Windows::Storage::IStorageItem2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageItem2_DeleteAsync(py::wrapper::Windows::Storage::IStorageItem2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"DeleteAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"DeleteAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);

                return py::convert(self->obj.DeleteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_GetBasicPropertiesAsync(py::wrapper::Windows::Storage::IStorageItem2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"GetBasicPropertiesAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetBasicPropertiesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_GetParentAsync(py::wrapper::Windows::Storage::IStorageItem2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem2", L"GetParentAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetParentAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_IsEqual(py::wrapper::Windows::Storage::IStorageItem2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem2", L"IsEqual", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageItem>(args, 0);

                return py::convert(self->obj.IsEqual(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_IsOfType(py::wrapper::Windows::Storage::IStorageItem2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"IsOfType", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

                return py::convert(self->obj.IsOfType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_RenameAsync(py::wrapper::Windows::Storage::IStorageItem2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"RenameAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RenameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"RenameAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);

                return py::convert(self->obj.RenameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_get_Attributes(py::wrapper::Windows::Storage::IStorageItem2* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItem", L"Attributes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Attributes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_get_DateCreated(py::wrapper::Windows::Storage::IStorageItem2* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItem", L"DateCreated"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DateCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_get_Name(py::wrapper::Windows::Storage::IStorageItem2* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItem", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_get_Path(py::wrapper::Windows::Storage::IStorageItem2* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItem", L"Path"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IStorageItem2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::IStorageItem2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageItem2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageItem2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageItem2[] = {
        { "delete_async", reinterpret_cast<PyCFunction>(IStorageItem2_DeleteAsync), METH_VARARGS, nullptr },
        { "get_basic_properties_async", reinterpret_cast<PyCFunction>(IStorageItem2_GetBasicPropertiesAsync), METH_VARARGS, nullptr },
        { "get_parent_async", reinterpret_cast<PyCFunction>(IStorageItem2_GetParentAsync), METH_VARARGS, nullptr },
        { "is_equal", reinterpret_cast<PyCFunction>(IStorageItem2_IsEqual), METH_VARARGS, nullptr },
        { "is_of_type", reinterpret_cast<PyCFunction>(IStorageItem2_IsOfType), METH_VARARGS, nullptr },
        { "rename_async", reinterpret_cast<PyCFunction>(IStorageItem2_RenameAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IStorageItem2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageItem2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageItem2[] = {
        { "attributes", reinterpret_cast<getter>(IStorageItem2_get_Attributes), nullptr, nullptr, nullptr },
        { "date_created", reinterpret_cast<getter>(IStorageItem2_get_DateCreated), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(IStorageItem2_get_Name), nullptr, nullptr, nullptr },
        { "path", reinterpret_cast<getter>(IStorageItem2_get_Path), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IStorageItem2[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageItem2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageItem2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageItem2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageItem2) },
        { },
    };

    static PyType_Spec type_spec_IStorageItem2 =
    {
        "winrt._winrt_windows_storage.IStorageItem2",
        sizeof(py::wrapper::Windows::Storage::IStorageItem2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageItem2
    };

    // ----- IStorageItemProperties interface --------------------

    static PyObject* _new_IStorageItemProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::IStorageItemProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::IStorageItemProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_IStorageItemProperties(py::wrapper::Windows::Storage::IStorageItemProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageItemProperties_GetThumbnailAsync(py::wrapper::Windows::Storage::IStorageItemProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItemProperties", L"GetThumbnailAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

                return py::convert(self->obj.GetThumbnailAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItemProperties", L"GetThumbnailAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetThumbnailAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItemProperties", L"GetThumbnailAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

                return py::convert(self->obj.GetThumbnailAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties_get_DisplayName(py::wrapper::Windows::Storage::IStorageItemProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItemProperties", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties_get_DisplayType(py::wrapper::Windows::Storage::IStorageItemProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItemProperties", L"DisplayType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties_get_FolderRelativeId(py::wrapper::Windows::Storage::IStorageItemProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItemProperties", L"FolderRelativeId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FolderRelativeId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties_get_Properties(py::wrapper::Windows::Storage::IStorageItemProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItemProperties", L"Properties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IStorageItemProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::IStorageItemProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageItemProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageItemProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageItemProperties[] = {
        { "get_thumbnail_async", reinterpret_cast<PyCFunction>(IStorageItemProperties_GetThumbnailAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IStorageItemProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageItemProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageItemProperties[] = {
        { "display_name", reinterpret_cast<getter>(IStorageItemProperties_get_DisplayName), nullptr, nullptr, nullptr },
        { "display_type", reinterpret_cast<getter>(IStorageItemProperties_get_DisplayType), nullptr, nullptr, nullptr },
        { "folder_relative_id", reinterpret_cast<getter>(IStorageItemProperties_get_FolderRelativeId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(IStorageItemProperties_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IStorageItemProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageItemProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageItemProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageItemProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageItemProperties) },
        { },
    };

    static PyType_Spec type_spec_IStorageItemProperties =
    {
        "winrt._winrt_windows_storage.IStorageItemProperties",
        sizeof(py::wrapper::Windows::Storage::IStorageItemProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageItemProperties
    };

    // ----- IStorageItemProperties2 interface --------------------

    static PyObject* _new_IStorageItemProperties2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::IStorageItemProperties2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::IStorageItemProperties2>::type_name);
        return nullptr;
    }

    static void _dealloc_IStorageItemProperties2(py::wrapper::Windows::Storage::IStorageItemProperties2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageItemProperties2_GetScaledImageAsThumbnailAsync(py::wrapper::Windows::Storage::IStorageItemProperties2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItemProperties2", L"GetScaledImageAsThumbnailAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

                return py::convert(self->obj.GetScaledImageAsThumbnailAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItemProperties2", L"GetScaledImageAsThumbnailAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetScaledImageAsThumbnailAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItemProperties2", L"GetScaledImageAsThumbnailAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

                return py::convert(self->obj.GetScaledImageAsThumbnailAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties2_GetThumbnailAsync(py::wrapper::Windows::Storage::IStorageItemProperties2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItemProperties", L"GetThumbnailAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

                return py::convert(self->obj.GetThumbnailAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItemProperties", L"GetThumbnailAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetThumbnailAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItemProperties", L"GetThumbnailAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

                return py::convert(self->obj.GetThumbnailAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties2_get_DisplayName(py::wrapper::Windows::Storage::IStorageItemProperties2* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItemProperties", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties2_get_DisplayType(py::wrapper::Windows::Storage::IStorageItemProperties2* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItemProperties", L"DisplayType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties2_get_FolderRelativeId(py::wrapper::Windows::Storage::IStorageItemProperties2* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItemProperties", L"FolderRelativeId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FolderRelativeId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties2_get_Properties(py::wrapper::Windows::Storage::IStorageItemProperties2* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItemProperties", L"Properties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IStorageItemProperties2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::IStorageItemProperties2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageItemProperties2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageItemProperties2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageItemProperties2[] = {
        { "get_scaled_image_as_thumbnail_async", reinterpret_cast<PyCFunction>(IStorageItemProperties2_GetScaledImageAsThumbnailAsync), METH_VARARGS, nullptr },
        { "get_thumbnail_async", reinterpret_cast<PyCFunction>(IStorageItemProperties2_GetThumbnailAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IStorageItemProperties2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageItemProperties2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageItemProperties2[] = {
        { "display_name", reinterpret_cast<getter>(IStorageItemProperties2_get_DisplayName), nullptr, nullptr, nullptr },
        { "display_type", reinterpret_cast<getter>(IStorageItemProperties2_get_DisplayType), nullptr, nullptr, nullptr },
        { "folder_relative_id", reinterpret_cast<getter>(IStorageItemProperties2_get_FolderRelativeId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(IStorageItemProperties2_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IStorageItemProperties2[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageItemProperties2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageItemProperties2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageItemProperties2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageItemProperties2) },
        { },
    };

    static PyType_Spec type_spec_IStorageItemProperties2 =
    {
        "winrt._winrt_windows_storage.IStorageItemProperties2",
        sizeof(py::wrapper::Windows::Storage::IStorageItemProperties2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageItemProperties2
    };

    // ----- IStorageItemPropertiesWithProvider interface --------------------

    static PyObject* _new_IStorageItemPropertiesWithProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IStorageItemPropertiesWithProvider(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageItemPropertiesWithProvider_GetThumbnailAsync(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItemProperties", L"GetThumbnailAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

                return py::convert(self->obj.GetThumbnailAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItemProperties", L"GetThumbnailAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetThumbnailAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItemProperties", L"GetThumbnailAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

                return py::convert(self->obj.GetThumbnailAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItemPropertiesWithProvider_get_Provider(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItemPropertiesWithProvider", L"Provider"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Provider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemPropertiesWithProvider_get_DisplayName(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItemProperties", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemPropertiesWithProvider_get_DisplayType(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItemProperties", L"DisplayType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemPropertiesWithProvider_get_FolderRelativeId(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItemProperties", L"FolderRelativeId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FolderRelativeId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemPropertiesWithProvider_get_Properties(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItemProperties", L"Properties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IStorageItemPropertiesWithProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageItemPropertiesWithProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageItemPropertiesWithProvider[] = {
        { "get_thumbnail_async", reinterpret_cast<PyCFunction>(IStorageItemPropertiesWithProvider_GetThumbnailAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IStorageItemPropertiesWithProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageItemPropertiesWithProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageItemPropertiesWithProvider[] = {
        { "provider", reinterpret_cast<getter>(IStorageItemPropertiesWithProvider_get_Provider), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(IStorageItemPropertiesWithProvider_get_DisplayName), nullptr, nullptr, nullptr },
        { "display_type", reinterpret_cast<getter>(IStorageItemPropertiesWithProvider_get_DisplayType), nullptr, nullptr, nullptr },
        { "folder_relative_id", reinterpret_cast<getter>(IStorageItemPropertiesWithProvider_get_FolderRelativeId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(IStorageItemPropertiesWithProvider_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IStorageItemPropertiesWithProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageItemPropertiesWithProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageItemPropertiesWithProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageItemPropertiesWithProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageItemPropertiesWithProvider) },
        { },
    };

    static PyType_Spec type_spec_IStorageItemPropertiesWithProvider =
    {
        "winrt._winrt_windows_storage.IStorageItemPropertiesWithProvider",
        sizeof(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageItemPropertiesWithProvider
    };

    // ----- IStreamedFileDataRequest interface --------------------

    static PyObject* _new_IStreamedFileDataRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::IStreamedFileDataRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::IStreamedFileDataRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_IStreamedFileDataRequest(py::wrapper::Windows::Storage::IStreamedFileDataRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStreamedFileDataRequest_FailAndClose(py::wrapper::Windows::Storage::IStreamedFileDataRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStreamedFileDataRequest", L"FailAndClose", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StreamedFileFailureMode>(args, 0);

                self->obj.FailAndClose(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IStreamedFileDataRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::IStreamedFileDataRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStreamedFileDataRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStreamedFileDataRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStreamedFileDataRequest[] = {
        { "fail_and_close", reinterpret_cast<PyCFunction>(IStreamedFileDataRequest_FailAndClose), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IStreamedFileDataRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStreamedFileDataRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStreamedFileDataRequest[] = {
        { }
    };

    static PyType_Slot _type_slots_IStreamedFileDataRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IStreamedFileDataRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStreamedFileDataRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStreamedFileDataRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStreamedFileDataRequest) },
        { },
    };

    static PyType_Spec type_spec_IStreamedFileDataRequest =
    {
        "winrt._winrt_windows_storage.IStreamedFileDataRequest",
        sizeof(py::wrapper::Windows::Storage::IStreamedFileDataRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStreamedFileDataRequest
    };

    // ----- Windows.Storage Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Storage");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_storage",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Storage

PyMODINIT_FUNC PyInit__winrt_windows_storage(void) noexcept
{
    using namespace py::cpp::Windows::Storage;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppDataPaths_Static{PyType_FromSpec(&type_spec_AppDataPaths_Static)};
    if (!type_AppDataPaths_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppDataPaths, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppDataPaths_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ApplicationData_Static{PyType_FromSpec(&type_spec_ApplicationData_Static)};
    if (!type_ApplicationData_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ApplicationData, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ApplicationData_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ApplicationDataCompositeValue, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ApplicationDataContainer, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ApplicationDataContainerSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_CachedFileManager_Static{PyType_FromSpec(&type_spec_CachedFileManager_Static)};
    if (!type_CachedFileManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CachedFileManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CachedFileManager_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_DownloadsFolder_Static{PyType_FromSpec(&type_spec_DownloadsFolder_Static)};
    if (!type_DownloadsFolder_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DownloadsFolder, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DownloadsFolder_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_FileIO_Static{PyType_FromSpec(&type_spec_FileIO_Static)};
    if (!type_FileIO_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_FileIO, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FileIO_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownFolders_Static{PyType_FromSpec(&type_spec_KnownFolders_Static)};
    if (!type_KnownFolders_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_KnownFolders, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KnownFolders_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_PathIO_Static{PyType_FromSpec(&type_spec_PathIO_Static)};
    if (!type_PathIO_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PathIO, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PathIO_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SetVersionDeferral, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SetVersionRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_StorageFile_Static{PyType_FromSpec(&type_spec_StorageFile_Static)};
    if (!type_StorageFile_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorageFile, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_StorageFile_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_StorageFolder_Static{PyType_FromSpec(&type_spec_StorageFolder_Static)};
    if (!type_StorageFolder_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorageFolder, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_StorageFolder_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_StorageLibrary_Static{PyType_FromSpec(&type_spec_StorageLibrary_Static)};
    if (!type_StorageLibrary_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorageLibrary, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_StorageLibrary_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorageLibraryChange, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorageLibraryChangeReader, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorageLibraryChangeTracker, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorageLibraryChangeTrackerOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_StorageLibraryLastChangeId_Static{PyType_FromSpec(&type_spec_StorageLibraryLastChangeId_Static)};
    if (!type_StorageLibraryLastChangeId_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorageLibraryLastChangeId, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_StorageLibraryLastChangeId_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorageProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorageStreamTransaction, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StreamedFileDataRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SystemAudioProperties, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SystemDataPaths_Static{PyType_FromSpec(&type_spec_SystemDataPaths_Static)};
    if (!type_SystemDataPaths_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SystemDataPaths, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SystemDataPaths_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SystemGPSProperties, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SystemImageProperties, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SystemMediaProperties, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SystemMusicProperties, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SystemPhotoProperties, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SystemProperties_Static{PyType_FromSpec(&type_spec_SystemProperties_Static)};
    if (!type_SystemProperties_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SystemProperties, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SystemProperties_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SystemVideoProperties, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_UserDataPaths_Static{PyType_FromSpec(&type_spec_UserDataPaths_Static)};
    if (!type_UserDataPaths_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UserDataPaths, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_UserDataPaths_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IStorageFile, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IStorageFile2, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IStorageFilePropertiesWithAvailability, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IStorageFolder, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IStorageFolder2, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IStorageItem, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IStorageItem2, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IStorageItemProperties, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IStorageItemProperties2, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IStorageItemPropertiesWithProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IStreamedFileDataRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
